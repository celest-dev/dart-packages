// ignore_for_file: type=lint
// ignore_for_file: return_of_invalid_type
// ignore_for_file: unused_element

// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
import 'dart:ffi' as ffi;
import 'package:objective_c/objective_c.dart' as objc;

@ffi.Native<
    ffi.Pointer<objc.ObjCBlockImpl> Function(
        ffi.Pointer<objc.ObjCBlockImpl>)>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
    _AuthenticationServicesIos_wrapListenerBlock_xtuoz7(
  ffi.Pointer<objc.ObjCBlockImpl> block,
);

@ffi.Native<
        ffi.Pointer<objc.ObjCBlockImpl> Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>,
            ffi.Pointer<
                ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>)>(
    isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
    _AuthenticationServicesIos_wrapBlockingBlock_xtuoz7(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
  ffi.Pointer<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>> newWaiter,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>
      awaitWaiter,
);

@ffi.Native<
    ffi.Pointer<objc.ObjCBlockImpl> Function(
        ffi.Pointer<objc.ObjCBlockImpl>)>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
    _AuthenticationServicesIos_wrapListenerBlock_1s56lr9(
  ffi.Pointer<objc.ObjCBlockImpl> block,
);

@ffi.Native<
        ffi.Pointer<objc.ObjCBlockImpl> Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>,
            ffi.Pointer<
                ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>)>(
    isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
    _AuthenticationServicesIos_wrapBlockingBlock_1s56lr9(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
  ffi.Pointer<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>> newWaiter,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>
      awaitWaiter,
);

@ffi.Native<
    ffi.Pointer<objc.ObjCBlockImpl> Function(
        ffi.Pointer<objc.ObjCBlockImpl>)>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
    _AuthenticationServicesIos_wrapListenerBlock_18v1jvf(
  ffi.Pointer<objc.ObjCBlockImpl> block,
);

@ffi.Native<
        ffi.Pointer<objc.ObjCBlockImpl> Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>,
            ffi.Pointer<
                ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>)>(
    isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
    _AuthenticationServicesIos_wrapBlockingBlock_18v1jvf(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
  ffi.Pointer<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>> newWaiter,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>
      awaitWaiter,
);

@ffi.Native<
    ffi.Pointer<objc.ObjCBlockImpl> Function(
        ffi.Pointer<objc.ObjCBlockImpl>)>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
    _AuthenticationServicesIos_wrapListenerBlock_ovsamd(
  ffi.Pointer<objc.ObjCBlockImpl> block,
);

@ffi.Native<
        ffi.Pointer<objc.ObjCBlockImpl> Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>,
            ffi.Pointer<
                ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>)>(
    isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
    _AuthenticationServicesIos_wrapBlockingBlock_ovsamd(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
  ffi.Pointer<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>> newWaiter,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>
      awaitWaiter,
);

@ffi.Native<
    ffi.Pointer<objc.ObjCBlockImpl> Function(
        ffi.Pointer<objc.ObjCBlockImpl>)>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
    _AuthenticationServicesIos_wrapListenerBlock_fjrv01(
  ffi.Pointer<objc.ObjCBlockImpl> block,
);

@ffi.Native<
        ffi.Pointer<objc.ObjCBlockImpl> Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>,
            ffi.Pointer<
                ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>)>(
    isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
    _AuthenticationServicesIos_wrapBlockingBlock_fjrv01(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
  ffi.Pointer<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>> newWaiter,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>
      awaitWaiter,
);

@ffi.Native<
    ffi.Pointer<objc.ObjCBlockImpl> Function(
        ffi.Pointer<objc.ObjCBlockImpl>)>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
    _AuthenticationServicesIos_wrapListenerBlock_pfv6jd(
  ffi.Pointer<objc.ObjCBlockImpl> block,
);

@ffi.Native<
        ffi.Pointer<objc.ObjCBlockImpl> Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>,
            ffi.Pointer<
                ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>)>(
    isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
    _AuthenticationServicesIos_wrapBlockingBlock_pfv6jd(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
  ffi.Pointer<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>> newWaiter,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>
      awaitWaiter,
);

enum UIUserInterfaceIdiom {
  UIUserInterfaceIdiomUnspecified(-1),
  UIUserInterfaceIdiomPhone(0),
  UIUserInterfaceIdiomPad(1),
  UIUserInterfaceIdiomTV(2),
  UIUserInterfaceIdiomCarPlay(3),
  UIUserInterfaceIdiomMac(5),
  UIUserInterfaceIdiomVision(6);

  final int value;
  const UIUserInterfaceIdiom(this.value);

  static UIUserInterfaceIdiom fromValue(int value) => switch (value) {
        -1 => UIUserInterfaceIdiomUnspecified,
        0 => UIUserInterfaceIdiomPhone,
        1 => UIUserInterfaceIdiomPad,
        2 => UIUserInterfaceIdiomTV,
        3 => UIUserInterfaceIdiomCarPlay,
        5 => UIUserInterfaceIdiomMac,
        6 => UIUserInterfaceIdiomVision,
        _ =>
          throw ArgumentError("Unknown value for UIUserInterfaceIdiom: $value"),
      };
}

late final _class_UIDevice = objc.getClass("UIDevice");
late final _sel_isKindOfClass_ = objc.registerName("isKindOfClass:");
final _objc_msgSend_19nvye5 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Bool Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        bool Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<objc.ObjCObject>)>();
late final _sel_currentDevice = objc.registerName("currentDevice");
final _objc_msgSend_151sglz = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_systemVersion = objc.registerName("systemVersion");

/// UIDevice
class UIDevice extends objc.NSObject {
  UIDevice._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release) {
    objc.checkOsVersion('UIDevice', iOS: (false, (2, 0, 0)));
  }

  /// Constructs a [UIDevice] that points to the same underlying object as [other].
  UIDevice.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UIDevice] that wraps the given raw object pointer.
  UIDevice.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [UIDevice].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(
        obj.ref.pointer, _sel_isKindOfClass_, _class_UIDevice);
  }

  /// currentDevice
  static UIDevice getCurrentDevice() {
    objc.checkOsVersion('UIDevice.currentDevice', iOS: (false, (2, 0, 0)));
    final _ret = _objc_msgSend_151sglz(_class_UIDevice, _sel_currentDevice);
    return UIDevice.castFromPointer(_ret, retain: true, release: true);
  }

  /// systemVersion
  objc.NSString get systemVersion {
    objc.checkOsVersion('UIDevice.systemVersion', iOS: (false, (2, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_systemVersion);
    return objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }
}

enum UIStatusBarStyle {
  UIStatusBarStyleDefault(0),
  UIStatusBarStyleLightContent(1),
  UIStatusBarStyleDarkContent(3),
  UIStatusBarStyleBlackOpaque(2);

  static const UIStatusBarStyleBlackTranslucent = UIStatusBarStyleLightContent;

  final int value;
  const UIStatusBarStyle(this.value);

  static UIStatusBarStyle fromValue(int value) => switch (value) {
        0 => UIStatusBarStyleDefault,
        1 => UIStatusBarStyleLightContent,
        3 => UIStatusBarStyleDarkContent,
        2 => UIStatusBarStyleBlackOpaque,
        _ => throw ArgumentError("Unknown value for UIStatusBarStyle: $value"),
      };

  @override
  String toString() {
    if (this == UIStatusBarStyleLightContent)
      return "UIStatusBarStyle.UIStatusBarStyleLightContent, UIStatusBarStyle.UIStatusBarStyleBlackTranslucent";
    return super.toString();
  }
}

enum UIStatusBarAnimation {
  UIStatusBarAnimationNone(0),
  UIStatusBarAnimationFade(1),
  UIStatusBarAnimationSlide(2);

  final int value;
  const UIStatusBarAnimation(this.value);

  static UIStatusBarAnimation fromValue(int value) => switch (value) {
        0 => UIStatusBarAnimationNone,
        1 => UIStatusBarAnimationFade,
        2 => UIStatusBarAnimationSlide,
        _ =>
          throw ArgumentError("Unknown value for UIStatusBarAnimation: $value"),
      };
}

late final _class_UIResponder = objc.getClass("UIResponder");

/// WARNING: UIResponderStandardEditActions is a stub. To generate bindings for this class, include
/// UIResponderStandardEditActions in your config's objc-protocols list.
///
/// UIResponderStandardEditActions
interface class UIResponderStandardEditActions extends objc.ObjCProtocolBase
    implements objc.NSObjectProtocol {
  UIResponderStandardEditActions._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super(pointer, retain: retain, release: release);

  /// Constructs a [UIResponderStandardEditActions] that points to the same underlying object as [other].
  UIResponderStandardEditActions.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UIResponderStandardEditActions] that wraps the given raw object pointer.
  UIResponderStandardEditActions.castFromPointer(
      ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false,
      bool release = false})
      : this._(other, retain: retain, release: release);
}

/// UIResponder
class UIResponder extends objc.NSObject
    implements UIResponderStandardEditActions {
  UIResponder._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release) {
    objc.checkOsVersion('UIResponder', iOS: (false, (2, 0, 0)));
  }

  /// Constructs a [UIResponder] that points to the same underlying object as [other].
  UIResponder.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UIResponder] that wraps the given raw object pointer.
  UIResponder.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [UIResponder].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(
        obj.ref.pointer, _sel_isKindOfClass_, _class_UIResponder);
  }
}

late final _class_UIApplication = objc.getClass("UIApplication");
late final _sel_registerForRemoteNotifications =
    objc.registerName("registerForRemoteNotifications");
final _objc_msgSend_1pl9qdv = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        void Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_unregisterForRemoteNotifications =
    objc.registerName("unregisterForRemoteNotifications");
late final _sel_isRegisteredForRemoteNotifications =
    objc.registerName("isRegisteredForRemoteNotifications");
final _objc_msgSend_91o635 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Bool Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        bool Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();

/// UIRemoteNotifications
extension UIRemoteNotifications on UIApplication {
  /// registerForRemoteNotifications
  void registerForRemoteNotifications() {
    objc.checkOsVersion('UIApplication.registerForRemoteNotifications',
        iOS: (false, (8, 0, 0)));
    _objc_msgSend_1pl9qdv(
        this.ref.pointer, _sel_registerForRemoteNotifications);
  }

  /// unregisterForRemoteNotifications
  void unregisterForRemoteNotifications() {
    objc.checkOsVersion('UIApplication.unregisterForRemoteNotifications',
        iOS: (false, (3, 0, 0)));
    _objc_msgSend_1pl9qdv(
        this.ref.pointer, _sel_unregisterForRemoteNotifications);
  }

  /// isRegisteredForRemoteNotifications
  bool get registeredForRemoteNotifications {
    objc.checkOsVersion('UIApplication.isRegisteredForRemoteNotifications',
        iOS: (false, (8, 0, 0)));
    return _objc_msgSend_91o635(
        this.ref.pointer, _sel_isRegisteredForRemoteNotifications);
  }
}

/// UILocalNotifications
extension UILocalNotifications on UIApplication {}

/// UIUserNotificationSettings
extension UIUserNotificationSettings on UIApplication {}

late final _sel_beginReceivingRemoteControlEvents =
    objc.registerName("beginReceivingRemoteControlEvents");
late final _sel_endReceivingRemoteControlEvents =
    objc.registerName("endReceivingRemoteControlEvents");

/// UIRemoteControlEvents
extension UIRemoteControlEvents on UIApplication {
  /// beginReceivingRemoteControlEvents
  void beginReceivingRemoteControlEvents() {
    objc.checkOsVersion('UIApplication.beginReceivingRemoteControlEvents',
        iOS: (false, (4, 0, 0)));
    _objc_msgSend_1pl9qdv(
        this.ref.pointer, _sel_beginReceivingRemoteControlEvents);
  }

  /// endReceivingRemoteControlEvents
  void endReceivingRemoteControlEvents() {
    objc.checkOsVersion('UIApplication.endReceivingRemoteControlEvents',
        iOS: (false, (4, 0, 0)));
    _objc_msgSend_1pl9qdv(
        this.ref.pointer, _sel_endReceivingRemoteControlEvents);
  }
}

/// UINewsstand
extension UINewsstand on UIApplication {}

late final _sel_shortcutItems = objc.registerName("shortcutItems");
late final _sel_setShortcutItems_ = objc.registerName("setShortcutItems:");
final _objc_msgSend_xtuoz7 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<objc.ObjCObject>)>();

/// UIShortcutItems
extension UIShortcutItems on UIApplication {
  /// shortcutItems
  objc.NSArray? get shortcutItems {
    objc.checkOsVersion('UIApplication.shortcutItems', iOS: (false, (9, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_shortcutItems);
    return _ret.address == 0
        ? null
        : objc.NSArray.castFromPointer(_ret, retain: true, release: true);
  }

  /// setShortcutItems:
  set shortcutItems(objc.NSArray? value) {
    objc.checkOsVersion('UIApplication.setShortcutItems:',
        iOS: (false, (9, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setShortcutItems_,
        value?.ref.pointer ?? ffi.nullptr);
  }
}

late final _sel_supportsAlternateIcons =
    objc.registerName("supportsAlternateIcons");
void _ObjCBlock_ffiVoid_NSError_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<objc.ObjCObject> arg0) =>
    block.ref.target
        .cast<
            ffi.NativeFunction<
                ffi.Void Function(ffi.Pointer<objc.ObjCObject> arg0)>>()
        .asFunction<void Function(ffi.Pointer<objc.ObjCObject>)>()(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_ffiVoid_NSError_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_ffiVoid_NSError_fnPtrTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_NSError_closureTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<objc.ObjCObject> arg0) =>
    (objc.getBlockClosure(block) as void Function(
        ffi.Pointer<objc.ObjCObject>))(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_ffiVoid_NSError_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_ffiVoid_NSError_closureTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_NSError_listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<objc.ObjCObject> arg0) {
  (objc.getBlockClosure(block) as void Function(
      ffi.Pointer<objc.ObjCObject>))(arg0);
  objc.objectRelease(block.cast());
}

ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_NSError_listenerCallable = ffi.NativeCallable<
            ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<objc.ObjCObject>)>.listener(
        _ObjCBlock_ffiVoid_NSError_listenerTrampoline)
      ..keepIsolateAlive = false;
void _ObjCBlock_ffiVoid_NSError_blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<objc.ObjCObject> arg0) {
  try {
    (objc.getBlockClosure(block) as void Function(
        ffi.Pointer<objc.ObjCObject>))(arg0);
  } catch (e) {
  } finally {
    objc.signalWaiter(waiter);
    objc.objectRelease(block.cast());
  }
}

ffi.NativeCallable<
        ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_NSError_blockingCallable = ffi.NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>)>.isolateLocal(
        _ObjCBlock_ffiVoid_NSError_blockingTrampoline)
      ..keepIsolateAlive = false;
ffi.NativeCallable<
        ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_NSError_blockingListenerCallable = ffi.NativeCallable<
            ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>.listener(
        _ObjCBlock_ffiVoid_NSError_blockingTrampoline)
      ..keepIsolateAlive = false;

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(objc.NSError?)>`.
abstract final class ObjCBlock_ffiVoid_NSError {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(objc.NSError?)> castFromPointer(
          ffi.Pointer<objc.ObjCBlockImpl> pointer,
          {bool retain = false,
          bool release = false}) =>
      objc.ObjCBlock<ffi.Void Function(objc.NSError?)>(pointer,
          retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(objc.NSError?)> fromFunctionPointer(
          ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Void Function(ffi.Pointer<objc.ObjCObject> arg0)>>
              ptr) =>
      objc.ObjCBlock<ffi.Void Function(objc.NSError?)>(
          objc.newPointerBlock(
              _ObjCBlock_ffiVoid_NSError_fnPtrCallable, ptr.cast()),
          retain: false,
          release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(objc.NSError?)> fromFunction(
          void Function(objc.NSError?) fn) =>
      objc.ObjCBlock<ffi.Void Function(objc.NSError?)>(
          objc.newClosureBlock(
              _ObjCBlock_ffiVoid_NSError_closureCallable,
              (ffi.Pointer<objc.ObjCObject> arg0) => fn(arg0.address == 0
                  ? null
                  : objc.NSError.castFromPointer(arg0,
                      retain: true, release: true))),
          retain: false,
          release: true);

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// Note that unlike the default behavior of NativeCallable.listener, listener
  /// blocks do not keep the isolate alive.
  static objc.ObjCBlock<ffi.Void Function(objc.NSError?)> listener(
      void Function(objc.NSError?) fn) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_NSError_listenerCallable.nativeFunction.cast(),
        (ffi.Pointer<objc.ObjCObject> arg0) => fn(arg0.address == 0
            ? null
            : objc.NSError.castFromPointer(arg0,
                retain: false, release: true)));
    final wrapper = _AuthenticationServicesIos_wrapListenerBlock_xtuoz7(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<ffi.Void Function(objc.NSError?)>(wrapper,
        retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// This block does not keep the owner isolate alive. If the owner isolate has
  /// shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(objc.NSError?)> blocking(
      void Function(objc.NSError?) fn) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_NSError_blockingCallable.nativeFunction.cast(),
        (ffi.Pointer<objc.ObjCObject> arg0) => fn(arg0.address == 0
            ? null
            : objc.NSError.castFromPointer(arg0,
                retain: false, release: true)));
    final rawListener = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_NSError_blockingListenerCallable.nativeFunction
            .cast(),
        (ffi.Pointer<objc.ObjCObject> arg0) => fn(arg0.address == 0
            ? null
            : objc.NSError.castFromPointer(arg0,
                retain: false, release: true)));
    final wrapper = objc.wrapBlockingBlock(
        _AuthenticationServicesIos_wrapBlockingBlock_xtuoz7, raw, rawListener);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<ffi.Void Function(objc.NSError?)>(wrapper,
        retain: false, release: true);
  }
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(objc.NSError?)>`.
extension ObjCBlock_ffiVoid_NSError_CallExtension
    on objc.ObjCBlock<ffi.Void Function(objc.NSError?)> {
  void call(objc.NSError? arg0) => ref.pointer.ref.invoke
          .cast<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> block,
                      ffi.Pointer<objc.ObjCObject> arg0)>>()
          .asFunction<
              void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                  ffi.Pointer<objc.ObjCObject>)>()(
      ref.pointer, arg0?.ref.pointer ?? ffi.nullptr);
}

late final _sel_setAlternateIconName_completionHandler_ =
    objc.registerName("setAlternateIconName:completionHandler:");
final _objc_msgSend_o762yo = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCBlockImpl>)>>()
    .asFunction<
        void Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCBlockImpl>)>();
late final _sel_alternateIconName = objc.registerName("alternateIconName");

/// UIAlternateApplicationIcons
extension UIAlternateApplicationIcons on UIApplication {
  /// supportsAlternateIcons
  bool get supportsAlternateIcons {
    objc.checkOsVersion('UIApplication.supportsAlternateIcons',
        iOS: (false, (10, 3, 0)));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_supportsAlternateIcons);
  }

  /// setAlternateIconName:completionHandler:
  void setAlternateIconName_completionHandler_(objc.NSString? alternateIconName,
      objc.ObjCBlock<ffi.Void Function(objc.NSError?)>? completionHandler) {
    objc.checkOsVersion('UIApplication.setAlternateIconName:completionHandler:',
        iOS: (false, (10, 3, 0)));
    _objc_msgSend_o762yo(
        this.ref.pointer,
        _sel_setAlternateIconName_completionHandler_,
        alternateIconName?.ref.pointer ?? ffi.nullptr,
        completionHandler?.ref.pointer ?? ffi.nullptr);
  }

  /// alternateIconName
  objc.NSString? get alternateIconName {
    objc.checkOsVersion('UIApplication.alternateIconName',
        iOS: (false, (10, 3, 0)));
    final _ret =
        _objc_msgSend_151sglz(this.ref.pointer, _sel_alternateIconName);
    return _ret.address == 0
        ? null
        : objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }
}

late final _sel_extendStateRestoration =
    objc.registerName("extendStateRestoration");
late final _sel_completeStateRestoration =
    objc.registerName("completeStateRestoration");
late final _sel_ignoreSnapshotOnNextApplicationLaunch =
    objc.registerName("ignoreSnapshotOnNextApplicationLaunch");

/// WARNING: UIStateRestoring is a stub. To generate bindings for this class, include
/// UIStateRestoring in your config's objc-protocols list.
///
/// UIStateRestoring
interface class UIStateRestoring extends objc.ObjCProtocolBase
    implements objc.NSObjectProtocol {
  UIStateRestoring._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super(pointer, retain: retain, release: release);

  /// Constructs a [UIStateRestoring] that points to the same underlying object as [other].
  UIStateRestoring.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UIStateRestoring] that wraps the given raw object pointer.
  UIStateRestoring.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);
}

late final _sel_registerObjectForStateRestoration_restorationIdentifier_ = objc
    .registerName("registerObjectForStateRestoration:restorationIdentifier:");
final _objc_msgSend_pfv6jd = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        void Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>();

/// UIStateRestoration
extension UIStateRestoration on UIApplication {
  /// extendStateRestoration
  void extendStateRestoration() {
    objc.checkOsVersion('UIApplication.extendStateRestoration',
        iOS: (false, (6, 0, 0)));
    _objc_msgSend_1pl9qdv(this.ref.pointer, _sel_extendStateRestoration);
  }

  /// completeStateRestoration
  void completeStateRestoration() {
    objc.checkOsVersion('UIApplication.completeStateRestoration',
        iOS: (false, (6, 0, 0)));
    _objc_msgSend_1pl9qdv(this.ref.pointer, _sel_completeStateRestoration);
  }

  /// ignoreSnapshotOnNextApplicationLaunch
  void ignoreSnapshotOnNextApplicationLaunch() {
    objc.checkOsVersion('UIApplication.ignoreSnapshotOnNextApplicationLaunch',
        iOS: (false, (7, 0, 0)));
    _objc_msgSend_1pl9qdv(
        this.ref.pointer, _sel_ignoreSnapshotOnNextApplicationLaunch);
  }

  /// registerObjectForStateRestoration:restorationIdentifier:
  static void registerObjectForStateRestoration_restorationIdentifier_(
      UIStateRestoring object, objc.NSString restorationIdentifier) {
    objc.checkOsVersion(
        'UIApplication.registerObjectForStateRestoration:restorationIdentifier:',
        iOS: (false, (7, 0, 0)));
    _objc_msgSend_pfv6jd(
        _class_UIApplication,
        _sel_registerObjectForStateRestoration_restorationIdentifier_,
        object.ref.pointer,
        restorationIdentifier.ref.pointer);
  }
}

/// iOS: introduced 18.2.0
enum UIApplicationCategoryDefaultStatus {
  UIApplicationCategoryDefaultStatusUnavailable(0),
  UIApplicationCategoryDefaultStatusIsDefault(1),
  UIApplicationCategoryDefaultStatusNotDefault(2);

  final int value;
  const UIApplicationCategoryDefaultStatus(this.value);

  static UIApplicationCategoryDefaultStatus fromValue(int value) =>
      switch (value) {
        0 => UIApplicationCategoryDefaultStatusUnavailable,
        1 => UIApplicationCategoryDefaultStatusIsDefault,
        2 => UIApplicationCategoryDefaultStatusNotDefault,
        _ => throw ArgumentError(
            "Unknown value for UIApplicationCategoryDefaultStatus: $value"),
      };
}

/// iOS: introduced 18.2.0
enum UIApplicationCategory {
  UIApplicationCategoryWebBrowser(1);

  final int value;
  const UIApplicationCategory(this.value);

  static UIApplicationCategory fromValue(int value) => switch (value) {
        1 => UIApplicationCategoryWebBrowser,
        _ => throw ArgumentError(
            "Unknown value for UIApplicationCategory: $value"),
      };
}

late final _sel_defaultStatusForCategory_error_ =
    objc.registerName("defaultStatusForCategory:error:");
final _objc_msgSend_1yelsrr = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Long Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Long,
                ffi.Pointer<ffi.Pointer<objc.ObjCObject>>)>>()
    .asFunction<
        int Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            int,
            ffi.Pointer<ffi.Pointer<objc.ObjCObject>>)>();

/// DefaultApplication
extension DefaultApplication on UIApplication {
  /// defaultStatusForCategory:error:
  ///
  /// iOS: introduced 18.2.0
  UIApplicationCategoryDefaultStatus defaultStatusForCategory_error_(
      UIApplicationCategory category,
      ffi.Pointer<ffi.Pointer<objc.ObjCObject>> error) {
    objc.checkOsVersion('UIApplication.defaultStatusForCategory:error:',
        iOS: (false, (18, 2, 0)));
    final _ret = _objc_msgSend_1yelsrr(this.ref.pointer,
        _sel_defaultStatusForCategory_error_, category.value, error);
    return UIApplicationCategoryDefaultStatus.fromValue(_ret);
  }
}

/// UIApplicationDeprecated
extension UIApplicationDeprecated on UIApplication {}

late final _sel_sharedApplication = objc.registerName("sharedApplication");
late final _sel_connectedScenes = objc.registerName("connectedScenes");

/// UIApplication
class UIApplication extends UIResponder {
  UIApplication._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release) {
    objc.checkOsVersion('UIApplication', iOS: (false, (2, 0, 0)));
  }

  /// Constructs a [UIApplication] that points to the same underlying object as [other].
  UIApplication.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UIApplication] that wraps the given raw object pointer.
  UIApplication.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [UIApplication].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(
        obj.ref.pointer, _sel_isKindOfClass_, _class_UIApplication);
  }

  /// sharedApplication
  static UIApplication getSharedApplication() {
    final _ret =
        _objc_msgSend_151sglz(_class_UIApplication, _sel_sharedApplication);
    return UIApplication.castFromPointer(_ret, retain: true, release: true);
  }

  /// connectedScenes
  objc.NSSet get connectedScenes {
    objc.checkOsVersion('UIApplication.connectedScenes',
        iOS: (false, (13, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_connectedScenes);
    return objc.NSSet.castFromPointer(_ret, retain: true, release: true);
  }
}

late final _class_UIScene = objc.getClass("UIScene");
typedef instancetype = ffi.Pointer<objc.ObjCObject>;
typedef Dartinstancetype = objc.ObjCObjectBase;

/// WARNING: UISceneSession is a stub. To generate bindings for this class, include
/// UISceneSession in your config's objc-interfaces list.
///
/// UISceneSession
class UISceneSession extends objc.NSObject implements objc.NSSecureCoding {
  UISceneSession._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release) {
    objc.checkOsVersion('UISceneSession', iOS: (false, (13, 0, 0)));
  }

  /// Constructs a [UISceneSession] that points to the same underlying object as [other].
  UISceneSession.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UISceneSession] that wraps the given raw object pointer.
  UISceneSession.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);
}

/// WARNING: UISceneConnectionOptions is a stub. To generate bindings for this class, include
/// UISceneConnectionOptions in your config's objc-interfaces list.
///
/// UISceneConnectionOptions
class UISceneConnectionOptions extends objc.NSObject {
  UISceneConnectionOptions._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release) {
    objc.checkOsVersion('UISceneConnectionOptions', iOS: (false, (13, 0, 0)));
  }

  /// Constructs a [UISceneConnectionOptions] that points to the same underlying object as [other].
  UISceneConnectionOptions.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UISceneConnectionOptions] that wraps the given raw object pointer.
  UISceneConnectionOptions.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);
}

late final _sel_initWithSession_connectionOptions_ =
    objc.registerName("initWithSession:connectionOptions:");
final _objc_msgSend_15qeuct = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>();
late final _sel_session = objc.registerName("session");

/// WARNING: UISceneDelegate is a stub. To generate bindings for this class, include
/// UISceneDelegate in your config's objc-protocols list.
///
/// UISceneDelegate
interface class UISceneDelegate extends objc.ObjCProtocolBase
    implements objc.NSObjectProtocol {
  UISceneDelegate._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super(pointer, retain: retain, release: release);

  /// Constructs a [UISceneDelegate] that points to the same underlying object as [other].
  UISceneDelegate.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UISceneDelegate] that wraps the given raw object pointer.
  UISceneDelegate.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);
}

late final _sel_delegate = objc.registerName("delegate");
late final _sel_setDelegate_ = objc.registerName("setDelegate:");

enum UISceneActivationState {
  UISceneActivationStateUnattached(-1),
  UISceneActivationStateForegroundActive(0),
  UISceneActivationStateForegroundInactive(1),
  UISceneActivationStateBackground(2);

  final int value;
  const UISceneActivationState(this.value);

  static UISceneActivationState fromValue(int value) => switch (value) {
        -1 => UISceneActivationStateUnattached,
        0 => UISceneActivationStateForegroundActive,
        1 => UISceneActivationStateForegroundInactive,
        2 => UISceneActivationStateBackground,
        _ => throw ArgumentError(
            "Unknown value for UISceneActivationState: $value"),
      };
}

late final _sel_activationState = objc.registerName("activationState");
final _objc_msgSend_ma5inq = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Long Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        int Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();

/// WARNING: UISceneOpenExternalURLOptions is a stub. To generate bindings for this class, include
/// UISceneOpenExternalURLOptions in your config's objc-interfaces list.
///
/// UISceneOpenExternalURLOptions
class UISceneOpenExternalURLOptions extends objc.NSObject {
  UISceneOpenExternalURLOptions._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release) {
    objc.checkOsVersion('UISceneOpenExternalURLOptions',
        iOS: (false, (13, 0, 0)));
  }

  /// Constructs a [UISceneOpenExternalURLOptions] that points to the same underlying object as [other].
  UISceneOpenExternalURLOptions.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UISceneOpenExternalURLOptions] that wraps the given raw object pointer.
  UISceneOpenExternalURLOptions.castFromPointer(
      ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false,
      bool release = false})
      : this._(other, retain: retain, release: release);
}

void _ObjCBlock_ffiVoid_bool_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block, bool arg0) =>
    block.ref.target
        .cast<ffi.NativeFunction<ffi.Void Function(ffi.Bool arg0)>>()
        .asFunction<void Function(bool)>()(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_ffiVoid_bool_fnPtrCallable =
    ffi.Pointer.fromFunction<
            ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Bool)>(_ObjCBlock_ffiVoid_bool_fnPtrTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_bool_closureTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block, bool arg0) =>
    (objc.getBlockClosure(block) as void Function(bool))(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_ffiVoid_bool_closureCallable =
    ffi.Pointer.fromFunction<
            ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Bool)>(_ObjCBlock_ffiVoid_bool_closureTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_bool_listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block, bool arg0) {
  (objc.getBlockClosure(block) as void Function(bool))(arg0);
  objc.objectRelease(block.cast());
}

ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Bool)>
    _ObjCBlock_ffiVoid_bool_listenerCallable = ffi.NativeCallable<
        ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Bool)>.listener(_ObjCBlock_ffiVoid_bool_listenerTrampoline)
      ..keepIsolateAlive = false;
void _ObjCBlock_ffiVoid_bool_blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    bool arg0) {
  try {
    (objc.getBlockClosure(block) as void Function(bool))(arg0);
  } catch (e) {
  } finally {
    objc.signalWaiter(waiter);
    objc.objectRelease(block.cast());
  }
}

ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Bool)>
    _ObjCBlock_ffiVoid_bool_blockingCallable = ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Bool)>.isolateLocal(_ObjCBlock_ffiVoid_bool_blockingTrampoline)
      ..keepIsolateAlive = false;
ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Bool)>
    _ObjCBlock_ffiVoid_bool_blockingListenerCallable = ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Bool)>.listener(_ObjCBlock_ffiVoid_bool_blockingTrampoline)
      ..keepIsolateAlive = false;

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Bool)>`.
abstract final class ObjCBlock_ffiVoid_bool {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(ffi.Bool)> castFromPointer(
          ffi.Pointer<objc.ObjCBlockImpl> pointer,
          {bool retain = false,
          bool release = false}) =>
      objc.ObjCBlock<ffi.Void Function(ffi.Bool)>(pointer,
          retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(ffi.Bool)> fromFunctionPointer(
          ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Bool arg0)>>
              ptr) =>
      objc.ObjCBlock<ffi.Void Function(ffi.Bool)>(
          objc.newPointerBlock(
              _ObjCBlock_ffiVoid_bool_fnPtrCallable, ptr.cast()),
          retain: false,
          release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(ffi.Bool)> fromFunction(
          void Function(bool) fn) =>
      objc.ObjCBlock<ffi.Void Function(ffi.Bool)>(
          objc.newClosureBlock(
              _ObjCBlock_ffiVoid_bool_closureCallable, (bool arg0) => fn(arg0)),
          retain: false,
          release: true);

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// Note that unlike the default behavior of NativeCallable.listener, listener
  /// blocks do not keep the isolate alive.
  static objc.ObjCBlock<ffi.Void Function(ffi.Bool)> listener(
      void Function(bool) fn) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_bool_listenerCallable.nativeFunction.cast(),
        (bool arg0) => fn(arg0));
    final wrapper = _AuthenticationServicesIos_wrapListenerBlock_1s56lr9(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Bool)>(wrapper,
        retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// This block does not keep the owner isolate alive. If the owner isolate has
  /// shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(ffi.Bool)> blocking(
      void Function(bool) fn) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_bool_blockingCallable.nativeFunction.cast(),
        (bool arg0) => fn(arg0));
    final rawListener = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_bool_blockingListenerCallable.nativeFunction.cast(),
        (bool arg0) => fn(arg0));
    final wrapper = objc.wrapBlockingBlock(
        _AuthenticationServicesIos_wrapBlockingBlock_1s56lr9, raw, rawListener);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Bool)>(wrapper,
        retain: false, release: true);
  }
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Bool)>`.
extension ObjCBlock_ffiVoid_bool_CallExtension
    on objc.ObjCBlock<ffi.Void Function(ffi.Bool)> {
  void call(bool arg0) => ref.pointer.ref.invoke
          .cast<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Bool arg0)>>()
          .asFunction<void Function(ffi.Pointer<objc.ObjCBlockImpl>, bool)>()(
      ref.pointer, arg0);
}

late final _sel_openURL_options_completionHandler_ =
    objc.registerName("openURL:options:completionHandler:");
final _objc_msgSend_18qun1e = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCBlockImpl>)>>()
    .asFunction<
        void Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCBlockImpl>)>();
late final _sel_title = objc.registerName("title");
late final _sel_setTitle_ = objc.registerName("setTitle:");
late final _sel_subtitle = objc.registerName("subtitle");
late final _sel_setSubtitle_ = objc.registerName("setSubtitle:");

/// WARNING: UISceneActivationConditions is a stub. To generate bindings for this class, include
/// UISceneActivationConditions in your config's objc-interfaces list.
///
/// UISceneActivationConditions
class UISceneActivationConditions extends objc.NSObject
    implements objc.NSSecureCoding {
  UISceneActivationConditions._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release) {
    objc.checkOsVersion('UISceneActivationConditions',
        iOS: (false, (13, 0, 0)));
  }

  /// Constructs a [UISceneActivationConditions] that points to the same underlying object as [other].
  UISceneActivationConditions.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UISceneActivationConditions] that wraps the given raw object pointer.
  UISceneActivationConditions.castFromPointer(
      ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false,
      bool release = false})
      : this._(other, retain: retain, release: release);
}

late final _sel_activationConditions =
    objc.registerName("activationConditions");
late final _sel_setActivationConditions_ =
    objc.registerName("setActivationConditions:");

/// UIScene
class UIScene extends UIResponder {
  UIScene._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release) {
    objc.checkOsVersion('UIScene', iOS: (false, (13, 0, 0)));
  }

  /// Constructs a [UIScene] that points to the same underlying object as [other].
  UIScene.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UIScene] that wraps the given raw object pointer.
  UIScene.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [UIScene].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(
        obj.ref.pointer, _sel_isKindOfClass_, _class_UIScene);
  }

  /// initWithSession:connectionOptions:
  UIScene initWithSession_connectionOptions_(
      UISceneSession session, UISceneConnectionOptions connectionOptions) {
    objc.checkOsVersion('UIScene.initWithSession:connectionOptions:',
        iOS: (false, (13, 0, 0)));
    final _ret = _objc_msgSend_15qeuct(
        this.ref.retainAndReturnPointer(),
        _sel_initWithSession_connectionOptions_,
        session.ref.pointer,
        connectionOptions.ref.pointer);
    return UIScene.castFromPointer(_ret, retain: false, release: true);
  }

  /// session
  UISceneSession get session {
    objc.checkOsVersion('UIScene.session', iOS: (false, (13, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_session);
    return UISceneSession.castFromPointer(_ret, retain: true, release: true);
  }

  /// delegate
  UISceneDelegate? get delegate {
    objc.checkOsVersion('UIScene.delegate', iOS: (false, (13, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_delegate);
    return _ret.address == 0
        ? null
        : UISceneDelegate.castFromPointer(_ret, retain: true, release: true);
  }

  /// setDelegate:
  set delegate(UISceneDelegate? value) {
    objc.checkOsVersion('UIScene.setDelegate:', iOS: (false, (13, 0, 0)));
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setDelegate_, value?.ref.pointer ?? ffi.nullptr);
  }

  /// activationState
  UISceneActivationState get activationState {
    objc.checkOsVersion('UIScene.activationState', iOS: (false, (13, 0, 0)));
    final _ret = _objc_msgSend_ma5inq(this.ref.pointer, _sel_activationState);
    return UISceneActivationState.fromValue(_ret);
  }

  /// openURL:options:completionHandler:
  void openURL_options_completionHandler_(
      objc.NSURL url,
      UISceneOpenExternalURLOptions? options,
      objc.ObjCBlock<ffi.Void Function(ffi.Bool)>? completion) {
    objc.checkOsVersion('UIScene.openURL:options:completionHandler:',
        iOS: (false, (13, 0, 0)));
    _objc_msgSend_18qun1e(
        this.ref.pointer,
        _sel_openURL_options_completionHandler_,
        url.ref.pointer,
        options?.ref.pointer ?? ffi.nullptr,
        completion?.ref.pointer ?? ffi.nullptr);
  }

  /// title
  objc.NSString get title {
    objc.checkOsVersion('UIScene.title', iOS: (false, (13, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_title);
    return objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// setTitle:
  set title(objc.NSString value) {
    objc.checkOsVersion('UIScene.setTitle:', iOS: (false, (13, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setTitle_, value.ref.pointer);
  }

  /// subtitle
  objc.NSString get subtitle {
    objc.checkOsVersion('UIScene.subtitle', iOS: (false, (15, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_subtitle);
    return objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// setSubtitle:
  set subtitle(objc.NSString value) {
    objc.checkOsVersion('UIScene.setSubtitle:', iOS: (false, (15, 0, 0)));
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setSubtitle_, value.ref.pointer);
  }

  /// activationConditions
  UISceneActivationConditions get activationConditions {
    objc.checkOsVersion('UIScene.activationConditions',
        iOS: (false, (13, 0, 0)));
    final _ret =
        _objc_msgSend_151sglz(this.ref.pointer, _sel_activationConditions);
    return UISceneActivationConditions.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// setActivationConditions:
  set activationConditions(UISceneActivationConditions value) {
    objc.checkOsVersion('UIScene.setActivationConditions:',
        iOS: (false, (13, 0, 0)));
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setActivationConditions_, value.ref.pointer);
  }
}

late final _class_UIWindowScene = objc.getClass("UIWindowScene");

/// WARNING: UITraitEnvironment is a stub. To generate bindings for this class, include
/// UITraitEnvironment in your config's objc-protocols list.
///
/// UITraitEnvironment
interface class UITraitEnvironment extends objc.ObjCProtocolBase
    implements objc.NSObjectProtocol {
  UITraitEnvironment._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super(pointer, retain: retain, release: release);

  /// Constructs a [UITraitEnvironment] that points to the same underlying object as [other].
  UITraitEnvironment.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UITraitEnvironment] that wraps the given raw object pointer.
  UITraitEnvironment.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);
}

/// WARNING: UITraitChangeObservable is a stub. To generate bindings for this class, include
/// UITraitChangeObservable in your config's objc-protocols list.
///
/// UITraitChangeObservable
interface class UITraitChangeObservable extends objc.ObjCProtocolBase {
  UITraitChangeObservable._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super(pointer, retain: retain, release: release);

  /// Constructs a [UITraitChangeObservable] that points to the same underlying object as [other].
  UITraitChangeObservable.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UITraitChangeObservable] that wraps the given raw object pointer.
  UITraitChangeObservable.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);
}

///
extension on UIWindowScene {}

late final _sel_windows = objc.registerName("windows");

/// UIWindowScene
class UIWindowScene extends UIScene {
  UIWindowScene._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release) {
    objc.checkOsVersion('UIWindowScene', iOS: (false, (13, 0, 0)));
  }

  /// Constructs a [UIWindowScene] that points to the same underlying object as [other].
  UIWindowScene.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UIWindowScene] that wraps the given raw object pointer.
  UIWindowScene.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [UIWindowScene].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(
        obj.ref.pointer, _sel_isKindOfClass_, _class_UIWindowScene);
  }

  /// windows
  objc.NSArray get windows {
    objc.checkOsVersion('UIWindowScene.windows', iOS: (false, (13, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_windows);
    return objc.NSArray.castFromPointer(_ret, retain: true, release: true);
  }
}

late final _class_UIView = objc.getClass("UIView");

/// WARNING: UIAppearance is a stub. To generate bindings for this class, include
/// UIAppearance in your config's objc-protocols list.
///
/// UIAppearance
interface class UIAppearance extends objc.ObjCProtocolBase
    implements objc.NSObjectProtocol {
  UIAppearance._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super(pointer, retain: retain, release: release);

  /// Constructs a [UIAppearance] that points to the same underlying object as [other].
  UIAppearance.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UIAppearance] that wraps the given raw object pointer.
  UIAppearance.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);
}

/// WARNING: UIAppearanceContainer is a stub. To generate bindings for this class, include
/// UIAppearanceContainer in your config's objc-protocols list.
///
/// UIAppearanceContainer
interface class UIAppearanceContainer extends objc.ObjCProtocolBase
    implements objc.NSObjectProtocol {
  UIAppearanceContainer._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super(pointer, retain: retain, release: release);

  /// Constructs a [UIAppearanceContainer] that points to the same underlying object as [other].
  UIAppearanceContainer.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UIAppearanceContainer] that wraps the given raw object pointer.
  UIAppearanceContainer.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);
}

/// WARNING: UIDynamicItem is a stub. To generate bindings for this class, include
/// UIDynamicItem in your config's objc-protocols list.
///
/// UIDynamicItem
interface class UIDynamicItem extends objc.ObjCProtocolBase
    implements objc.NSObjectProtocol {
  UIDynamicItem._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super(pointer, retain: retain, release: release);

  /// Constructs a [UIDynamicItem] that points to the same underlying object as [other].
  UIDynamicItem.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UIDynamicItem] that wraps the given raw object pointer.
  UIDynamicItem.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);
}

/// WARNING: UICoordinateSpace is a stub. To generate bindings for this class, include
/// UICoordinateSpace in your config's objc-protocols list.
///
/// UICoordinateSpace
interface class UICoordinateSpace extends objc.ObjCProtocolBase
    implements objc.NSObjectProtocol {
  UICoordinateSpace._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super(pointer, retain: retain, release: release);

  /// Constructs a [UICoordinateSpace] that points to the same underlying object as [other].
  UICoordinateSpace.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UICoordinateSpace] that wraps the given raw object pointer.
  UICoordinateSpace.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);
}

late final _protocol_UIFocusItem = objc.getProtocol("UIFocusItem");

/// WARNING: UIFocusEnvironment is a stub. To generate bindings for this class, include
/// UIFocusEnvironment in your config's objc-protocols list.
///
/// UIFocusEnvironment
interface class UIFocusEnvironment extends objc.ObjCProtocolBase
    implements objc.NSObjectProtocol {
  UIFocusEnvironment._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super(pointer, retain: retain, release: release);

  /// Constructs a [UIFocusEnvironment] that points to the same underlying object as [other].
  UIFocusEnvironment.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UIFocusEnvironment] that wraps the given raw object pointer.
  UIFocusEnvironment.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);
}

late final _sel_conformsToProtocol_ = objc.registerName("conformsToProtocol:");
final _objc_msgSend_e3qsqz = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Bool Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCProtocol>)>>()
    .asFunction<
        bool Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<objc.ObjCProtocol>)>();
late final _sel_canBecomeFocused = objc.registerName("canBecomeFocused");
bool _ObjCBlock_bool_ffiVoid_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0) =>
    block.ref.target
        .cast<
            ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<ffi.Void> arg0)>>()
        .asFunction<bool Function(ffi.Pointer<ffi.Void>)>()(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_bool_ffiVoid_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Bool Function(
                    ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>(
            _ObjCBlock_bool_ffiVoid_fnPtrTrampoline, false)
        .cast();
bool _ObjCBlock_bool_ffiVoid_closureTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0) =>
    (objc.getBlockClosure(block) as bool Function(ffi.Pointer<ffi.Void>))(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_bool_ffiVoid_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Bool Function(
                    ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>(
            _ObjCBlock_bool_ffiVoid_closureTrampoline, false)
        .cast();

/// Construction methods for `objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>)>`.
abstract final class ObjCBlock_bool_ffiVoid {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>)>(pointer,
              retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>)>
      fromFunctionPointer(
              ffi.Pointer<
                      ffi.NativeFunction<
                          ffi.Bool Function(ffi.Pointer<ffi.Void> arg0)>>
                  ptr) =>
          objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>)>(
              objc.newPointerBlock(_ObjCBlock_bool_ffiVoid_fnPtrCallable, ptr.cast()),
              retain: false,
              release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>)> fromFunction(
          bool Function(ffi.Pointer<ffi.Void>) fn) =>
      objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>)>(
          objc.newClosureBlock(_ObjCBlock_bool_ffiVoid_closureCallable,
              (ffi.Pointer<ffi.Void> arg0) => fn(arg0)),
          retain: false,
          release: true);
}

/// Call operator for `objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>)>`.
extension ObjCBlock_bool_ffiVoid_CallExtension
    on objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>)> {
  bool call(ffi.Pointer<ffi.Void> arg0) => ref.pointer.ref.invoke
      .cast<
          ffi.NativeFunction<
              ffi.Bool Function(ffi.Pointer<objc.ObjCBlockImpl> block,
                  ffi.Pointer<ffi.Void> arg0)>>()
      .asFunction<
          bool Function(ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>)>()(ref.pointer, arg0);
}

final class CGPoint extends ffi.Struct {
  @ffi.Double()
  external double x;

  @ffi.Double()
  external double y;
}

final class CGSize extends ffi.Struct {
  @ffi.Double()
  external double width;

  @ffi.Double()
  external double height;
}

final class CGRect extends ffi.Struct {
  external CGPoint origin;

  external CGSize size;
}

late final _sel_frame = objc.registerName("frame");
final _objc_msgSend_bu1hbw = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            CGRect Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        CGRect Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
final _objc_msgSend_bu1hbwStret = objc.msgSendStretPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(ffi.Pointer<CGRect>, ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        void Function(ffi.Pointer<CGRect>, ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>)>();
CGRect _ObjCBlock_CGRect_ffiVoid_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0) =>
    block.ref.target
        .cast<ffi.NativeFunction<CGRect Function(ffi.Pointer<ffi.Void> arg0)>>()
        .asFunction<CGRect Function(ffi.Pointer<ffi.Void>)>()(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_CGRect_ffiVoid_fnPtrCallable =
    ffi.Pointer.fromFunction<
                CGRect Function(
                    ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>(
            _ObjCBlock_CGRect_ffiVoid_fnPtrTrampoline)
        .cast();
CGRect _ObjCBlock_CGRect_ffiVoid_closureTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0) =>
    (objc.getBlockClosure(block) as CGRect Function(
        ffi.Pointer<ffi.Void>))(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_CGRect_ffiVoid_closureCallable =
    ffi.Pointer.fromFunction<
                CGRect Function(
                    ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>(
            _ObjCBlock_CGRect_ffiVoid_closureTrampoline)
        .cast();

/// Construction methods for `objc.ObjCBlock<CGRect Function(ffi.Pointer<ffi.Void>)>`.
abstract final class ObjCBlock_CGRect_ffiVoid {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<CGRect Function(ffi.Pointer<ffi.Void>)> castFromPointer(
          ffi.Pointer<objc.ObjCBlockImpl> pointer,
          {bool retain = false,
          bool release = false}) =>
      objc.ObjCBlock<CGRect Function(ffi.Pointer<ffi.Void>)>(pointer,
          retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<CGRect Function(ffi.Pointer<ffi.Void>)> fromFunctionPointer(
          ffi.Pointer<
                  ffi
                  .NativeFunction<CGRect Function(ffi.Pointer<ffi.Void> arg0)>>
              ptr) =>
      objc.ObjCBlock<CGRect Function(ffi.Pointer<ffi.Void>)>(
          objc.newPointerBlock(
              _ObjCBlock_CGRect_ffiVoid_fnPtrCallable, ptr.cast()),
          retain: false,
          release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<CGRect Function(ffi.Pointer<ffi.Void>)> fromFunction(
          CGRect Function(ffi.Pointer<ffi.Void>) fn) =>
      objc.ObjCBlock<CGRect Function(ffi.Pointer<ffi.Void>)>(
          objc.newClosureBlock(_ObjCBlock_CGRect_ffiVoid_closureCallable,
              (ffi.Pointer<ffi.Void> arg0) => fn(arg0)),
          retain: false,
          release: true);
}

/// Call operator for `objc.ObjCBlock<CGRect Function(ffi.Pointer<ffi.Void>)>`.
extension ObjCBlock_CGRect_ffiVoid_CallExtension
    on objc.ObjCBlock<CGRect Function(ffi.Pointer<ffi.Void>)> {
  CGRect call(ffi.Pointer<ffi.Void> arg0) => ref.pointer.ref.invoke
      .cast<
          ffi.NativeFunction<
              CGRect Function(ffi.Pointer<objc.ObjCBlockImpl> block,
                  ffi.Pointer<ffi.Void> arg0)>>()
      .asFunction<
          CGRect Function(ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>)>()(ref.pointer, arg0);
}

/// WARNING: UIFocusEffect is a stub. To generate bindings for this class, include
/// UIFocusEffect in your config's objc-interfaces list.
///
/// UIFocusEffect
class UIFocusEffect extends objc.NSObject implements objc.NSCopying {
  UIFocusEffect._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release) {
    objc.checkOsVersion('UIFocusEffect', iOS: (false, (15, 0, 0)));
  }

  /// Constructs a [UIFocusEffect] that points to the same underlying object as [other].
  UIFocusEffect.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UIFocusEffect] that wraps the given raw object pointer.
  UIFocusEffect.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);
}

late final _sel_focusEffect = objc.registerName("focusEffect");
ffi.Pointer<objc.ObjCObject> _ObjCBlock_UIFocusEffect_ffiVoid_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0) =>
    block.ref.target
        .cast<
            ffi.NativeFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<ffi.Void> arg0)>>()
        .asFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<ffi.Void>)>()(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_UIFocusEffect_ffiVoid_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>(
            _ObjCBlock_UIFocusEffect_ffiVoid_fnPtrTrampoline)
        .cast();
ffi.Pointer<objc.ObjCObject> _ObjCBlock_UIFocusEffect_ffiVoid_closureTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0) =>
    (objc.getBlockClosure(block) as ffi.Pointer<objc.ObjCObject> Function(
        ffi.Pointer<ffi.Void>))(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_UIFocusEffect_ffiVoid_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>(
            _ObjCBlock_UIFocusEffect_ffiVoid_closureTrampoline)
        .cast();

/// Construction methods for `objc.ObjCBlock<UIFocusEffect? Function(ffi.Pointer<ffi.Void>)>`.
abstract final class ObjCBlock_UIFocusEffect_ffiVoid {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<UIFocusEffect? Function(ffi.Pointer<ffi.Void>)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<UIFocusEffect? Function(ffi.Pointer<ffi.Void>)>(
              pointer,
              retain: retain,
              release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<UIFocusEffect? Function(ffi.Pointer<ffi.Void>)> fromFunctionPointer(
          ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Pointer<objc.ObjCObject> Function(
                          ffi.Pointer<ffi.Void> arg0)>>
              ptr) =>
      objc.ObjCBlock<UIFocusEffect? Function(ffi.Pointer<ffi.Void>)>(
          objc.newPointerBlock(
              _ObjCBlock_UIFocusEffect_ffiVoid_fnPtrCallable, ptr.cast()),
          retain: false,
          release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<UIFocusEffect? Function(ffi.Pointer<ffi.Void>)>
      fromFunction(UIFocusEffect? Function(ffi.Pointer<ffi.Void>) fn) =>
          objc.ObjCBlock<UIFocusEffect? Function(ffi.Pointer<ffi.Void>)>(
              objc.newClosureBlock(
                  _ObjCBlock_UIFocusEffect_ffiVoid_closureCallable,
                  (ffi.Pointer<ffi.Void> arg0) =>
                      fn(arg0)?.ref.retainAndAutorelease() ?? ffi.nullptr),
              retain: false,
              release: true);
}

/// Call operator for `objc.ObjCBlock<UIFocusEffect? Function(ffi.Pointer<ffi.Void>)>`.
extension ObjCBlock_UIFocusEffect_ffiVoid_CallExtension
    on objc.ObjCBlock<UIFocusEffect? Function(ffi.Pointer<ffi.Void>)> {
  UIFocusEffect? call(ffi.Pointer<ffi.Void> arg0) => ref.pointer.ref.invoke
              .cast<
                  ffi.NativeFunction<
                      ffi.Pointer<objc.ObjCObject> Function(
                          ffi.Pointer<objc.ObjCBlockImpl> block,
                          ffi.Pointer<ffi.Void> arg0)>>()
              .asFunction<
                  ffi.Pointer<objc.ObjCObject> Function(
                      ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>()
              (ref.pointer, arg0)
              .address ==
          0
      ? null
      : UIFocusEffect.castFromPointer(
          ref.pointer.ref.invoke
              .cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0)>>()
              .asFunction<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>()(ref.pointer, arg0),
          retain: true,
          release: true);
}

late final _sel_focusGroupPriority = objc.registerName("focusGroupPriority");
int _ObjCBlock_UIFocusGroupPriority_ffiVoid_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0) =>
    block.ref.target
        .cast<
            ffi.NativeFunction<ffi.Long Function(ffi.Pointer<ffi.Void> arg0)>>()
        .asFunction<int Function(ffi.Pointer<ffi.Void>)>()(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_UIFocusGroupPriority_ffiVoid_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Long Function(
                    ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>(
            _ObjCBlock_UIFocusGroupPriority_ffiVoid_fnPtrTrampoline, 0)
        .cast();
int _ObjCBlock_UIFocusGroupPriority_ffiVoid_closureTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0) =>
    (objc.getBlockClosure(block) as int Function(ffi.Pointer<ffi.Void>))(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_UIFocusGroupPriority_ffiVoid_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Long Function(
                    ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>(
            _ObjCBlock_UIFocusGroupPriority_ffiVoid_closureTrampoline, 0)
        .cast();

/// Construction methods for `objc.ObjCBlock<ffi.Long Function(ffi.Pointer<ffi.Void>)>`.
abstract final class ObjCBlock_UIFocusGroupPriority_ffiVoid {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Long Function(ffi.Pointer<ffi.Void>)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<ffi.Long Function(ffi.Pointer<ffi.Void>)>(pointer,
              retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Long Function(ffi.Pointer<ffi.Void>)> fromFunctionPointer(
          ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Long Function(ffi.Pointer<ffi.Void> arg0)>>
              ptr) =>
      objc.ObjCBlock<ffi.Long Function(ffi.Pointer<ffi.Void>)>(
          objc.newPointerBlock(
              _ObjCBlock_UIFocusGroupPriority_ffiVoid_fnPtrCallable, ptr.cast()),
          retain: false,
          release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Long Function(ffi.Pointer<ffi.Void>)> fromFunction(
          int Function(ffi.Pointer<ffi.Void>) fn) =>
      objc.ObjCBlock<ffi.Long Function(ffi.Pointer<ffi.Void>)>(
          objc.newClosureBlock(
              _ObjCBlock_UIFocusGroupPriority_ffiVoid_closureCallable,
              (ffi.Pointer<ffi.Void> arg0) => fn(arg0)),
          retain: false,
          release: true);
}

/// Call operator for `objc.ObjCBlock<ffi.Long Function(ffi.Pointer<ffi.Void>)>`.
extension ObjCBlock_UIFocusGroupPriority_ffiVoid_CallExtension
    on objc.ObjCBlock<ffi.Long Function(ffi.Pointer<ffi.Void>)> {
  int call(ffi.Pointer<ffi.Void> arg0) => ref.pointer.ref.invoke
      .cast<
          ffi.NativeFunction<
              ffi.Long Function(ffi.Pointer<objc.ObjCBlockImpl> block,
                  ffi.Pointer<ffi.Void> arg0)>>()
      .asFunction<
          int Function(ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>)>()(ref.pointer, arg0);
}

/// iOS: introduced 18.0.0
enum UIFocusItemDeferralMode {
  UIFocusItemDeferralModeAutomatic(0),
  UIFocusItemDeferralModeAlways(1),
  UIFocusItemDeferralModeNever(2);

  final int value;
  const UIFocusItemDeferralMode(this.value);

  static UIFocusItemDeferralMode fromValue(int value) => switch (value) {
        0 => UIFocusItemDeferralModeAutomatic,
        1 => UIFocusItemDeferralModeAlways,
        2 => UIFocusItemDeferralModeNever,
        _ => throw ArgumentError(
            "Unknown value for UIFocusItemDeferralMode: $value"),
      };
}

late final _sel_focusItemDeferralMode =
    objc.registerName("focusItemDeferralMode");
final _objc_msgSend_1lv2zxu = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Long Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        int Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
int _ObjCBlock_UIFocusItemDeferralMode_ffiVoid_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0) =>
    block.ref.target
        .cast<
            ffi.NativeFunction<ffi.Long Function(ffi.Pointer<ffi.Void> arg0)>>()
        .asFunction<int Function(ffi.Pointer<ffi.Void>)>()(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_UIFocusItemDeferralMode_ffiVoid_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Long Function(
                    ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>(
            _ObjCBlock_UIFocusItemDeferralMode_ffiVoid_fnPtrTrampoline, 0)
        .cast();
int _ObjCBlock_UIFocusItemDeferralMode_ffiVoid_closureTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0) =>
    (objc.getBlockClosure(block) as int Function(ffi.Pointer<ffi.Void>))(arg0);
ffi.Pointer<ffi.Void>
    _ObjCBlock_UIFocusItemDeferralMode_ffiVoid_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Long Function(
                    ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>(
            _ObjCBlock_UIFocusItemDeferralMode_ffiVoid_closureTrampoline, 0)
        .cast();

/// Construction methods for `objc.ObjCBlock<ffi.Long Function(ffi.Pointer<ffi.Void>)>`.
abstract final class ObjCBlock_UIFocusItemDeferralMode_ffiVoid {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Long Function(ffi.Pointer<ffi.Void>)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<ffi.Long Function(ffi.Pointer<ffi.Void>)>(pointer,
              retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
      ffi.Long Function(ffi.Pointer<ffi.Void>)> fromFunctionPointer(
          ffi.Pointer<ffi.NativeFunction<ffi.Long Function(ffi.Pointer<ffi.Void> arg0)>>
              ptr) =>
      objc.ObjCBlock<ffi.Long Function(ffi.Pointer<ffi.Void>)>(
          objc.newPointerBlock(
              _ObjCBlock_UIFocusItemDeferralMode_ffiVoid_fnPtrCallable,
              ptr.cast()),
          retain: false,
          release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Long Function(ffi.Pointer<ffi.Void>)> fromFunction(
          UIFocusItemDeferralMode Function(ffi.Pointer<ffi.Void>) fn) =>
      objc.ObjCBlock<ffi.Long Function(ffi.Pointer<ffi.Void>)>(
          objc.newClosureBlock(
              _ObjCBlock_UIFocusItemDeferralMode_ffiVoid_closureCallable,
              (ffi.Pointer<ffi.Void> arg0) => fn(arg0).value),
          retain: false,
          release: true);
}

/// Call operator for `objc.ObjCBlock<ffi.Long Function(ffi.Pointer<ffi.Void>)>`.
extension ObjCBlock_UIFocusItemDeferralMode_ffiVoid_CallExtension
    on objc.ObjCBlock<ffi.Long Function(ffi.Pointer<ffi.Void>)> {
  UIFocusItemDeferralMode call(ffi.Pointer<ffi.Void> arg0) =>
      UIFocusItemDeferralMode.fromValue(ref.pointer.ref.invoke
          .cast<
              ffi.NativeFunction<
                  ffi.Long Function(ffi.Pointer<objc.ObjCBlockImpl> block,
                      ffi.Pointer<ffi.Void> arg0)>>()
          .asFunction<
              int Function(ffi.Pointer<objc.ObjCBlockImpl>,
                  ffi.Pointer<ffi.Void>)>()(ref.pointer, arg0));
}

late final _sel_isTransparentFocusItem =
    objc.registerName("isTransparentFocusItem");

/// WARNING: UIFocusMovementHint is a stub. To generate bindings for this class, include
/// UIFocusMovementHint in your config's objc-interfaces list.
///
/// UIFocusMovementHint
class UIFocusMovementHint extends objc.NSObject implements objc.NSCopying {
  UIFocusMovementHint._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release) {
    objc.checkOsVersion('UIFocusMovementHint', iOS: (false, (12, 0, 0)));
  }

  /// Constructs a [UIFocusMovementHint] that points to the same underlying object as [other].
  UIFocusMovementHint.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UIFocusMovementHint] that wraps the given raw object pointer.
  UIFocusMovementHint.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);
}

late final _sel_didHintFocusMovement_ =
    objc.registerName("didHintFocusMovement:");
void _ObjCBlock_ffiVoid_ffiVoid_UIFocusMovementHint_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1) =>
    block.ref.target
        .cast<
            ffi.NativeFunction<
                ffi.Void Function(ffi.Pointer<ffi.Void> arg0,
                    ffi.Pointer<objc.ObjCObject> arg1)>>()
        .asFunction<
            void Function(ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>)>()(arg0, arg1);
ffi.Pointer<ffi.Void>
    _ObjCBlock_ffiVoid_ffiVoid_UIFocusMovementHint_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_ffiVoid_ffiVoid_UIFocusMovementHint_fnPtrTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_ffiVoid_UIFocusMovementHint_closureTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1) =>
    (objc.getBlockClosure(block) as void Function(
        ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>))(arg0, arg1);
ffi.Pointer<ffi.Void>
    _ObjCBlock_ffiVoid_ffiVoid_UIFocusMovementHint_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_ffiVoid_ffiVoid_UIFocusMovementHint_closureTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_ffiVoid_UIFocusMovementHint_listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObject> arg1) {
  (objc.getBlockClosure(block) as void Function(
      ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>))(arg0, arg1);
  objc.objectRelease(block.cast());
}

ffi.NativeCallable<
        ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_ffiVoid_UIFocusMovementHint_listenerCallable = ffi
        .NativeCallable<
            ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>.listener(
        _ObjCBlock_ffiVoid_ffiVoid_UIFocusMovementHint_listenerTrampoline)
      ..keepIsolateAlive = false;
void _ObjCBlock_ffiVoid_ffiVoid_UIFocusMovementHint_blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObject> arg1) {
  try {
    (objc.getBlockClosure(block) as void Function(
        ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>))(arg0, arg1);
  } catch (e) {
  } finally {
    objc.signalWaiter(waiter);
    objc.objectRelease(block.cast());
  }
}

ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_ffiVoid_UIFocusMovementHint_blockingCallable = ffi
        .NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>)>.isolateLocal(
        _ObjCBlock_ffiVoid_ffiVoid_UIFocusMovementHint_blockingTrampoline)
      ..keepIsolateAlive = false;
ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_ffiVoid_UIFocusMovementHint_blockingListenerCallable =
    ffi.NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>)>.listener(
        _ObjCBlock_ffiVoid_ffiVoid_UIFocusMovementHint_blockingTrampoline)
      ..keepIsolateAlive = false;

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UIFocusMovementHint)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_UIFocusMovementHint {
  /// Returns a block that wraps the given raw block pointer.
  static objc
      .ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UIFocusMovementHint)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, UIFocusMovementHint)>(pointer,
              retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UIFocusMovementHint)>
      fromFunctionPointer(
              ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1)>>
                  ptr) =>
          objc.ObjCBlock<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, UIFocusMovementHint)>(
              objc.newPointerBlock(
                  _ObjCBlock_ffiVoid_ffiVoid_UIFocusMovementHint_fnPtrCallable,
                  ptr.cast()),
              retain: false,
              release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UIFocusMovementHint)> fromFunction(
          void Function(ffi.Pointer<ffi.Void>, UIFocusMovementHint) fn) =>
      objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UIFocusMovementHint)>(
          objc.newClosureBlock(
              _ObjCBlock_ffiVoid_ffiVoid_UIFocusMovementHint_closureCallable,
              (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1) =>
                  fn(
                      arg0,
                      UIFocusMovementHint.castFromPointer(arg1,
                          retain: true, release: true))),
          retain: false,
          release: true);

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// Note that unlike the default behavior of NativeCallable.listener, listener
  /// blocks do not keep the isolate alive.
  static objc
      .ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UIFocusMovementHint)>
      listener(void Function(ffi.Pointer<ffi.Void>, UIFocusMovementHint) fn) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_UIFocusMovementHint_listenerCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1) => fn(
            arg0,
            UIFocusMovementHint.castFromPointer(arg1,
                retain: false, release: true)));
    final wrapper = _AuthenticationServicesIos_wrapListenerBlock_18v1jvf(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
        ffi.Void Function(ffi.Pointer<ffi.Void>,
            UIFocusMovementHint)>(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// This block does not keep the owner isolate alive. If the owner isolate has
  /// shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc
      .ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UIFocusMovementHint)>
      blocking(void Function(ffi.Pointer<ffi.Void>, UIFocusMovementHint) fn) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_UIFocusMovementHint_blockingCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1) => fn(
            arg0,
            UIFocusMovementHint.castFromPointer(arg1,
                retain: false, release: true)));
    final rawListener = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_UIFocusMovementHint_blockingListenerCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1) => fn(
            arg0,
            UIFocusMovementHint.castFromPointer(arg1,
                retain: false, release: true)));
    final wrapper = objc.wrapBlockingBlock(
        _AuthenticationServicesIos_wrapBlockingBlock_18v1jvf, raw, rawListener);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
        ffi.Void Function(ffi.Pointer<ffi.Void>,
            UIFocusMovementHint)>(wrapper, retain: false, release: true);
  }
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UIFocusMovementHint)>`.
extension ObjCBlock_ffiVoid_ffiVoid_UIFocusMovementHint_CallExtension on objc
    .ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UIFocusMovementHint)> {
  void call(ffi.Pointer<ffi.Void> arg0, UIFocusMovementHint arg1) =>
      ref.pointer.ref.invoke
              .cast<
                  ffi.NativeFunction<
                      ffi.Void Function(
                          ffi.Pointer<objc.ObjCBlockImpl> block,
                          ffi.Pointer<ffi.Void> arg0,
                          ffi.Pointer<objc.ObjCObject> arg1)>>()
              .asFunction<
                  void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>()(
          ref.pointer, arg0, arg1.ref.pointer);
}

late final _sel_preferredFocusEnvironments =
    objc.registerName("preferredFocusEnvironments");
ffi.Pointer<objc.ObjCObject> _ObjCBlock_objcObjCObject_ffiVoid_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0) =>
    block.ref.target
        .cast<
            ffi.NativeFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<ffi.Void> arg0)>>()
        .asFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<ffi.Void>)>()(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_objcObjCObject_ffiVoid_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>(
            _ObjCBlock_objcObjCObject_ffiVoid_fnPtrTrampoline)
        .cast();
ffi.Pointer<objc.ObjCObject>
    _ObjCBlock_objcObjCObject_ffiVoid_closureTrampoline(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0) =>
        (objc.getBlockClosure(block) as ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<ffi.Void>))(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_objcObjCObject_ffiVoid_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>(
            _ObjCBlock_objcObjCObject_ffiVoid_closureTrampoline)
        .cast();

/// Construction methods for `objc.ObjCBlock<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>)>`.
abstract final class ObjCBlock_objcObjCObject_ffiVoid {
  /// Returns a block that wraps the given raw block pointer.
  static objc
      .ObjCBlock<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<
                  ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>)>(
              pointer,
              retain: retain,
              release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>)>
      fromFunctionPointer(
              ffi.Pointer<
                      ffi.NativeFunction<
                          ffi.Pointer<objc.ObjCObject> Function(
                              ffi.Pointer<ffi.Void> arg0)>>
                  ptr) =>
          objc.ObjCBlock<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>)>(
              objc.newPointerBlock(_ObjCBlock_objcObjCObject_ffiVoid_fnPtrCallable, ptr.cast()),
              retain: false,
              release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc
      .ObjCBlock<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>)>
      fromFunction(objc.ObjCObjectBase Function(ffi.Pointer<ffi.Void>) fn) =>
          objc.ObjCBlock<
                  ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>)>(
              objc.newClosureBlock(
                  _ObjCBlock_objcObjCObject_ffiVoid_closureCallable,
                  (ffi.Pointer<ffi.Void> arg0) =>
                      fn(arg0).ref.retainAndAutorelease()),
              retain: false,
              release: true);
}

/// Call operator for `objc.ObjCBlock<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>)>`.
extension ObjCBlock_objcObjCObject_ffiVoid_CallExtension on objc
    .ObjCBlock<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>)> {
  objc.ObjCObjectBase call(ffi.Pointer<ffi.Void> arg0) => objc.ObjCObjectBase(
      ref.pointer.ref.invoke
          .cast<
              ffi.NativeFunction<
                  ffi.Pointer<objc.ObjCObject> Function(
                      ffi.Pointer<objc.ObjCBlockImpl> block,
                      ffi.Pointer<ffi.Void> arg0)>>()
          .asFunction<
              ffi.Pointer<objc.ObjCObject> Function(
                  ffi.Pointer<objc.ObjCBlockImpl>,
                  ffi.Pointer<ffi.Void>)>()(ref.pointer, arg0),
      retain: true,
      release: true);
}

late final _sel_parentFocusEnvironment =
    objc.registerName("parentFocusEnvironment");
ffi.Pointer<objc.ObjCObject>
    _ObjCBlock_idUIFocusEnvironment_ffiVoid_fnPtrTrampoline(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0) =>
        block.ref.target
            .cast<
                ffi.NativeFunction<
                    ffi.Pointer<objc.ObjCObject> Function(
                        ffi.Pointer<ffi.Void> arg0)>>()
            .asFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<ffi.Void>)>()(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_idUIFocusEnvironment_ffiVoid_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>(
            _ObjCBlock_idUIFocusEnvironment_ffiVoid_fnPtrTrampoline)
        .cast();
ffi.Pointer<objc.ObjCObject>
    _ObjCBlock_idUIFocusEnvironment_ffiVoid_closureTrampoline(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0) =>
        (objc.getBlockClosure(block) as ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<ffi.Void>))(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_idUIFocusEnvironment_ffiVoid_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>(
            _ObjCBlock_idUIFocusEnvironment_ffiVoid_closureTrampoline)
        .cast();

/// Construction methods for `objc.ObjCBlock<ffi.Pointer<objc.ObjCObject>? Function(ffi.Pointer<ffi.Void>)>`.
abstract final class ObjCBlock_idUIFocusEnvironment_ffiVoid {
  /// Returns a block that wraps the given raw block pointer.
  static objc
      .ObjCBlock<ffi.Pointer<objc.ObjCObject>? Function(ffi.Pointer<ffi.Void>)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<
                  ffi.Pointer<objc.ObjCObject>? Function(
                      ffi.Pointer<ffi.Void>)>(pointer,
              retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Pointer<objc.ObjCObject>? Function(ffi.Pointer<ffi.Void>)>
      fromFunctionPointer(
              ffi.Pointer<
                      ffi.NativeFunction<
                          ffi.Pointer<objc.ObjCObject> Function(
                              ffi.Pointer<ffi.Void> arg0)>>
                  ptr) =>
          objc.ObjCBlock<ffi.Pointer<objc.ObjCObject>? Function(ffi.Pointer<ffi.Void>)>(
              objc.newPointerBlock(_ObjCBlock_idUIFocusEnvironment_ffiVoid_fnPtrCallable, ptr.cast()),
              retain: false,
              release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc
      .ObjCBlock<ffi.Pointer<objc.ObjCObject>? Function(ffi.Pointer<ffi.Void>)>
      fromFunction(UIFocusEnvironment? Function(ffi.Pointer<ffi.Void>) fn) =>
          objc.ObjCBlock<
                  ffi.Pointer<objc.ObjCObject>? Function(
                      ffi.Pointer<ffi.Void>)>(
              objc.newClosureBlock(
                  _ObjCBlock_idUIFocusEnvironment_ffiVoid_closureCallable,
                  (ffi.Pointer<ffi.Void> arg0) =>
                      fn(arg0)?.ref.retainAndAutorelease() ?? ffi.nullptr),
              retain: false,
              release: true);
}

/// Call operator for `objc.ObjCBlock<ffi.Pointer<objc.ObjCObject>? Function(ffi.Pointer<ffi.Void>)>`.
extension ObjCBlock_idUIFocusEnvironment_ffiVoid_CallExtension on objc
    .ObjCBlock<ffi.Pointer<objc.ObjCObject>? Function(ffi.Pointer<ffi.Void>)> {
  UIFocusEnvironment? call(ffi.Pointer<ffi.Void> arg0) => ref.pointer.ref.invoke
              .cast<
                  ffi.NativeFunction<
                      ffi.Pointer<objc.ObjCObject> Function(
                          ffi.Pointer<objc.ObjCBlockImpl> block,
                          ffi.Pointer<ffi.Void> arg0)>>()
              .asFunction<
                  ffi.Pointer<objc.ObjCObject> Function(
                      ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>()
              (ref.pointer, arg0)
              .address ==
          0
      ? null
      : UIFocusEnvironment.castFromPointer(
          ref.pointer.ref.invoke
              .cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0)>>()
              .asFunction<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>()(ref.pointer, arg0),
          retain: true,
          release: true);
}

/// WARNING: UIFocusItemContainer is a stub. To generate bindings for this class, include
/// UIFocusItemContainer in your config's objc-protocols list.
///
/// UIFocusItemContainer
interface class UIFocusItemContainer extends objc.ObjCProtocolBase
    implements objc.NSObjectProtocol {
  UIFocusItemContainer._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super(pointer, retain: retain, release: release);

  /// Constructs a [UIFocusItemContainer] that points to the same underlying object as [other].
  UIFocusItemContainer.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UIFocusItemContainer] that wraps the given raw object pointer.
  UIFocusItemContainer.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);
}

late final _sel_focusItemContainer = objc.registerName("focusItemContainer");
ffi.Pointer<objc.ObjCObject>
    _ObjCBlock_idUIFocusItemContainer_ffiVoid_fnPtrTrampoline(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0) =>
        block.ref.target
            .cast<
                ffi.NativeFunction<
                    ffi.Pointer<objc.ObjCObject> Function(
                        ffi.Pointer<ffi.Void> arg0)>>()
            .asFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<ffi.Void>)>()(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_idUIFocusItemContainer_ffiVoid_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>(
            _ObjCBlock_idUIFocusItemContainer_ffiVoid_fnPtrTrampoline)
        .cast();
ffi.Pointer<objc.ObjCObject>
    _ObjCBlock_idUIFocusItemContainer_ffiVoid_closureTrampoline(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0) =>
        (objc.getBlockClosure(block) as ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<ffi.Void>))(arg0);
ffi.Pointer<ffi.Void>
    _ObjCBlock_idUIFocusItemContainer_ffiVoid_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>(
            _ObjCBlock_idUIFocusItemContainer_ffiVoid_closureTrampoline)
        .cast();

/// Construction methods for `objc.ObjCBlock<ffi.Pointer<objc.ObjCObject>? Function(ffi.Pointer<ffi.Void>)>`.
abstract final class ObjCBlock_idUIFocusItemContainer_ffiVoid {
  /// Returns a block that wraps the given raw block pointer.
  static objc
      .ObjCBlock<ffi.Pointer<objc.ObjCObject>? Function(ffi.Pointer<ffi.Void>)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<
                  ffi.Pointer<objc.ObjCObject>? Function(
                      ffi.Pointer<ffi.Void>)>(pointer,
              retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Pointer<objc.ObjCObject>? Function(ffi.Pointer<ffi.Void>)>
      fromFunctionPointer(
              ffi.Pointer<
                      ffi.NativeFunction<
                          ffi.Pointer<objc.ObjCObject> Function(
                              ffi.Pointer<ffi.Void> arg0)>>
                  ptr) =>
          objc.ObjCBlock<ffi.Pointer<objc.ObjCObject>? Function(ffi.Pointer<ffi.Void>)>(
              objc.newPointerBlock(_ObjCBlock_idUIFocusItemContainer_ffiVoid_fnPtrCallable, ptr.cast()),
              retain: false,
              release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc
      .ObjCBlock<ffi.Pointer<objc.ObjCObject>? Function(ffi.Pointer<ffi.Void>)>
      fromFunction(UIFocusItemContainer? Function(ffi.Pointer<ffi.Void>) fn) =>
          objc.ObjCBlock<
                  ffi.Pointer<objc.ObjCObject>? Function(
                      ffi.Pointer<ffi.Void>)>(
              objc.newClosureBlock(
                  _ObjCBlock_idUIFocusItemContainer_ffiVoid_closureCallable,
                  (ffi.Pointer<ffi.Void> arg0) =>
                      fn(arg0)?.ref.retainAndAutorelease() ?? ffi.nullptr),
              retain: false,
              release: true);
}

/// Call operator for `objc.ObjCBlock<ffi.Pointer<objc.ObjCObject>? Function(ffi.Pointer<ffi.Void>)>`.
extension ObjCBlock_idUIFocusItemContainer_ffiVoid_CallExtension on objc
    .ObjCBlock<ffi.Pointer<objc.ObjCObject>? Function(ffi.Pointer<ffi.Void>)> {
  UIFocusItemContainer? call(ffi.Pointer<ffi.Void> arg0) => ref.pointer.ref.invoke
              .cast<
                  ffi.NativeFunction<
                      ffi.Pointer<objc.ObjCObject> Function(
                          ffi.Pointer<objc.ObjCBlockImpl> block,
                          ffi.Pointer<ffi.Void> arg0)>>()
              .asFunction<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>()
              (ref.pointer, arg0)
              .address ==
          0
      ? null
      : UIFocusItemContainer.castFromPointer(
          ref.pointer.ref.invoke.cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0)>>().asFunction<
              ffi.Pointer<objc.ObjCObject> Function(
                  ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>()(ref.pointer, arg0),
          retain: true,
          release: true);
}

late final _sel_setNeedsFocusUpdate = objc.registerName("setNeedsFocusUpdate");
void _ObjCBlock_ffiVoid_ffiVoid_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0) =>
    block.ref.target
        .cast<
            ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void> arg0)>>()
        .asFunction<void Function(ffi.Pointer<ffi.Void>)>()(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_ffiVoid_ffiVoid_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(
                    ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>(
            _ObjCBlock_ffiVoid_ffiVoid_fnPtrTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_ffiVoid_closureTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0) =>
    (objc.getBlockClosure(block) as void Function(ffi.Pointer<ffi.Void>))(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_ffiVoid_ffiVoid_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(
                    ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>(
            _ObjCBlock_ffiVoid_ffiVoid_closureTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_ffiVoid_listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0) {
  (objc.getBlockClosure(block) as void Function(ffi.Pointer<ffi.Void>))(arg0);
  objc.objectRelease(block.cast());
}

ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>
    _ObjCBlock_ffiVoid_ffiVoid_listenerCallable = ffi.NativeCallable<
            ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>)>.listener(
        _ObjCBlock_ffiVoid_ffiVoid_listenerTrampoline)
      ..keepIsolateAlive = false;
void _ObjCBlock_ffiVoid_ffiVoid_blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<ffi.Void> arg0) {
  try {
    (objc.getBlockClosure(block) as void Function(ffi.Pointer<ffi.Void>))(arg0);
  } catch (e) {
  } finally {
    objc.signalWaiter(waiter);
    objc.objectRelease(block.cast());
  }
}

ffi.NativeCallable<
        ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>
    _ObjCBlock_ffiVoid_ffiVoid_blockingCallable = ffi.NativeCallable<
            ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>.isolateLocal(
        _ObjCBlock_ffiVoid_ffiVoid_blockingTrampoline)
      ..keepIsolateAlive = false;
ffi.NativeCallable<
        ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>
    _ObjCBlock_ffiVoid_ffiVoid_blockingListenerCallable = ffi.NativeCallable<
            ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>.listener(
        _ObjCBlock_ffiVoid_ffiVoid_blockingTrampoline)
      ..keepIsolateAlive = false;

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>)>(pointer,
              retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>)> fromFunctionPointer(
          ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Void Function(ffi.Pointer<ffi.Void> arg0)>>
              ptr) =>
      objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>)>(
          objc.newPointerBlock(
              _ObjCBlock_ffiVoid_ffiVoid_fnPtrCallable, ptr.cast()),
          retain: false,
          release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>)> fromFunction(
          void Function(ffi.Pointer<ffi.Void>) fn) =>
      objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>)>(
          objc.newClosureBlock(_ObjCBlock_ffiVoid_ffiVoid_closureCallable,
              (ffi.Pointer<ffi.Void> arg0) => fn(arg0)),
          retain: false,
          release: true);

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// Note that unlike the default behavior of NativeCallable.listener, listener
  /// blocks do not keep the isolate alive.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>)> listener(
      void Function(ffi.Pointer<ffi.Void>) fn) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_listenerCallable.nativeFunction.cast(),
        (ffi.Pointer<ffi.Void> arg0) => fn(arg0));
    final wrapper = _AuthenticationServicesIos_wrapListenerBlock_ovsamd(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>)>(wrapper,
        retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// This block does not keep the owner isolate alive. If the owner isolate has
  /// shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>)> blocking(
      void Function(ffi.Pointer<ffi.Void>) fn) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_blockingCallable.nativeFunction.cast(),
        (ffi.Pointer<ffi.Void> arg0) => fn(arg0));
    final rawListener = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_blockingListenerCallable.nativeFunction
            .cast(),
        (ffi.Pointer<ffi.Void> arg0) => fn(arg0));
    final wrapper = objc.wrapBlockingBlock(
        _AuthenticationServicesIos_wrapBlockingBlock_ovsamd, raw, rawListener);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>)>(wrapper,
        retain: false, release: true);
  }
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>)>`.
extension ObjCBlock_ffiVoid_ffiVoid_CallExtension
    on objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>)> {
  void call(ffi.Pointer<ffi.Void> arg0) => ref.pointer.ref.invoke
      .cast<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> block,
                  ffi.Pointer<ffi.Void> arg0)>>()
      .asFunction<
          void Function(ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>)>()(ref.pointer, arg0);
}

late final _sel_updateFocusIfNeeded = objc.registerName("updateFocusIfNeeded");

/// WARNING: UIFocusUpdateContext is a stub. To generate bindings for this class, include
/// UIFocusUpdateContext in your config's objc-interfaces list.
///
/// UIFocusUpdateContext
class UIFocusUpdateContext extends objc.NSObject {
  UIFocusUpdateContext._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release) {
    objc.checkOsVersion('UIFocusUpdateContext', iOS: (false, (9, 0, 0)));
  }

  /// Constructs a [UIFocusUpdateContext] that points to the same underlying object as [other].
  UIFocusUpdateContext.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UIFocusUpdateContext] that wraps the given raw object pointer.
  UIFocusUpdateContext.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);
}

late final _sel_shouldUpdateFocusInContext_ =
    objc.registerName("shouldUpdateFocusInContext:");
bool _ObjCBlock_bool_ffiVoid_UIFocusUpdateContext_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1) =>
    block.ref.target
        .cast<
            ffi.NativeFunction<
                ffi.Bool Function(ffi.Pointer<ffi.Void> arg0,
                    ffi.Pointer<objc.ObjCObject> arg1)>>()
        .asFunction<
            bool Function(ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>)>()(arg0, arg1);
ffi.Pointer<ffi.Void>
    _ObjCBlock_bool_ffiVoid_UIFocusUpdateContext_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Bool Function(ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_bool_ffiVoid_UIFocusUpdateContext_fnPtrTrampoline, false)
        .cast();
bool _ObjCBlock_bool_ffiVoid_UIFocusUpdateContext_closureTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1) =>
    (objc.getBlockClosure(block) as bool Function(
        ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>))(arg0, arg1);
ffi.Pointer<ffi.Void>
    _ObjCBlock_bool_ffiVoid_UIFocusUpdateContext_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Bool Function(ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_bool_ffiVoid_UIFocusUpdateContext_closureTrampoline,
            false)
        .cast();

/// Construction methods for `objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>, UIFocusUpdateContext)>`.
abstract final class ObjCBlock_bool_ffiVoid_UIFocusUpdateContext {
  /// Returns a block that wraps the given raw block pointer.
  static objc
      .ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>, UIFocusUpdateContext)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<
                  ffi.Bool Function(
                      ffi.Pointer<ffi.Void>, UIFocusUpdateContext)>(pointer,
              retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>, UIFocusUpdateContext)>
      fromFunctionPointer(
              ffi.Pointer<
                      ffi.NativeFunction<
                          ffi.Bool Function(ffi.Pointer<ffi.Void> arg0,
                              ffi.Pointer<objc.ObjCObject> arg1)>>
                  ptr) =>
          objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>, UIFocusUpdateContext)>(
              objc.newPointerBlock(_ObjCBlock_bool_ffiVoid_UIFocusUpdateContext_fnPtrCallable, ptr.cast()),
              retain: false,
              release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>, UIFocusUpdateContext)> fromFunction(
          bool Function(ffi.Pointer<ffi.Void>, UIFocusUpdateContext) fn) =>
      objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>, UIFocusUpdateContext)>(
          objc.newClosureBlock(
              _ObjCBlock_bool_ffiVoid_UIFocusUpdateContext_closureCallable,
              (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1) =>
                  fn(
                      arg0,
                      UIFocusUpdateContext.castFromPointer(arg1,
                          retain: true, release: true))),
          retain: false,
          release: true);
}

/// Call operator for `objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>, UIFocusUpdateContext)>`.
extension ObjCBlock_bool_ffiVoid_UIFocusUpdateContext_CallExtension on objc
    .ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>, UIFocusUpdateContext)> {
  bool call(ffi.Pointer<ffi.Void> arg0, UIFocusUpdateContext arg1) =>
      ref.pointer.ref.invoke
              .cast<
                  ffi.NativeFunction<
                      ffi.Bool Function(
                          ffi.Pointer<objc.ObjCBlockImpl> block,
                          ffi.Pointer<ffi.Void> arg0,
                          ffi.Pointer<objc.ObjCObject> arg1)>>()
              .asFunction<
                  bool Function(ffi.Pointer<objc.ObjCBlockImpl>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>()(
          ref.pointer, arg0, arg1.ref.pointer);
}

/// WARNING: UIFocusAnimationCoordinator is a stub. To generate bindings for this class, include
/// UIFocusAnimationCoordinator in your config's objc-interfaces list.
///
/// UIFocusAnimationCoordinator
class UIFocusAnimationCoordinator extends objc.NSObject {
  UIFocusAnimationCoordinator._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release) {
    objc.checkOsVersion('UIFocusAnimationCoordinator', iOS: (false, (9, 0, 0)));
  }

  /// Constructs a [UIFocusAnimationCoordinator] that points to the same underlying object as [other].
  UIFocusAnimationCoordinator.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UIFocusAnimationCoordinator] that wraps the given raw object pointer.
  UIFocusAnimationCoordinator.castFromPointer(
      ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false,
      bool release = false})
      : this._(other, retain: retain, release: release);
}

late final _sel_didUpdateFocusInContext_withAnimationCoordinator_ =
    objc.registerName("didUpdateFocusInContext:withAnimationCoordinator:");
void
    _ObjCBlock_ffiVoid_ffiVoid_UIFocusUpdateContext_UIFocusAnimationCoordinator_fnPtrTrampoline(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObject> arg1,
            ffi.Pointer<objc.ObjCObject> arg2) =>
        block.ref.target
            .cast<
                ffi.NativeFunction<
                    ffi.Void Function(
                        ffi.Pointer<ffi.Void> arg0,
                        ffi.Pointer<objc.ObjCObject> arg1,
                        ffi.Pointer<objc.ObjCObject> arg2)>>()
            .asFunction<
                void Function(
                    ffi.Pointer<ffi.Void>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>)>()(arg0, arg1, arg2);
ffi.Pointer<ffi.Void>
    _ObjCBlock_ffiVoid_ffiVoid_UIFocusUpdateContext_UIFocusAnimationCoordinator_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_ffiVoid_ffiVoid_UIFocusUpdateContext_UIFocusAnimationCoordinator_fnPtrTrampoline)
        .cast();
void
    _ObjCBlock_ffiVoid_ffiVoid_UIFocusUpdateContext_UIFocusAnimationCoordinator_closureTrampoline(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObject> arg1,
            ffi.Pointer<objc.ObjCObject> arg2) =>
        (objc.getBlockClosure(block) as void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>))(arg0, arg1, arg2);
ffi.Pointer<ffi.Void>
    _ObjCBlock_ffiVoid_ffiVoid_UIFocusUpdateContext_UIFocusAnimationCoordinator_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_ffiVoid_ffiVoid_UIFocusUpdateContext_UIFocusAnimationCoordinator_closureTrampoline)
        .cast();
void
    _ObjCBlock_ffiVoid_ffiVoid_UIFocusUpdateContext_UIFocusAnimationCoordinator_listenerTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1,
        ffi.Pointer<objc.ObjCObject> arg2) {
  (objc.getBlockClosure(block) as void Function(
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObject>,
      ffi.Pointer<objc.ObjCObject>))(arg0, arg1, arg2);
  objc.objectRelease(block.cast());
}

ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_ffiVoid_UIFocusUpdateContext_UIFocusAnimationCoordinator_listenerCallable =
    ffi.NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>.listener(
        _ObjCBlock_ffiVoid_ffiVoid_UIFocusUpdateContext_UIFocusAnimationCoordinator_listenerTrampoline)
      ..keepIsolateAlive = false;
void
    _ObjCBlock_ffiVoid_ffiVoid_UIFocusUpdateContext_UIFocusAnimationCoordinator_blockingTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> waiter,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1,
        ffi.Pointer<objc.ObjCObject> arg2) {
  try {
    (objc.getBlockClosure(block) as void Function(
        ffi.Pointer<ffi.Void>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>))(arg0, arg1, arg2);
  } catch (e) {
  } finally {
    objc.signalWaiter(waiter);
    objc.objectRelease(block.cast());
  }
}

ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_ffiVoid_UIFocusUpdateContext_UIFocusAnimationCoordinator_blockingCallable =
    ffi.NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>.isolateLocal(
        _ObjCBlock_ffiVoid_ffiVoid_UIFocusUpdateContext_UIFocusAnimationCoordinator_blockingTrampoline)
      ..keepIsolateAlive = false;
ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_ffiVoid_UIFocusUpdateContext_UIFocusAnimationCoordinator_blockingListenerCallable =
    ffi.NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>.listener(
        _ObjCBlock_ffiVoid_ffiVoid_UIFocusUpdateContext_UIFocusAnimationCoordinator_blockingTrampoline)
      ..keepIsolateAlive = false;

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UIFocusUpdateContext, UIFocusAnimationCoordinator)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_UIFocusUpdateContext_UIFocusAnimationCoordinator {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
          ffi.Void Function(ffi.Pointer<ffi.Void>, UIFocusUpdateContext,
              UIFocusAnimationCoordinator)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, UIFocusUpdateContext,
                      UIFocusAnimationCoordinator)>(pointer,
              retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UIFocusUpdateContext, UIFocusAnimationCoordinator)> fromFunctionPointer(
          ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Void Function(
                          ffi.Pointer<ffi.Void> arg0,
                          ffi.Pointer<objc.ObjCObject> arg1,
                          ffi.Pointer<objc.ObjCObject> arg2)>>
              ptr) =>
      objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UIFocusUpdateContext, UIFocusAnimationCoordinator)>(
          objc.newPointerBlock(_ObjCBlock_ffiVoid_ffiVoid_UIFocusUpdateContext_UIFocusAnimationCoordinator_fnPtrCallable, ptr.cast()),
          retain: false,
          release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UIFocusUpdateContext, UIFocusAnimationCoordinator)>
      fromFunction(void Function(ffi.Pointer<ffi.Void>, UIFocusUpdateContext, UIFocusAnimationCoordinator) fn) =>
          objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UIFocusUpdateContext, UIFocusAnimationCoordinator)>(
              objc.newClosureBlock(
                  _ObjCBlock_ffiVoid_ffiVoid_UIFocusUpdateContext_UIFocusAnimationCoordinator_closureCallable,
                  (ffi.Pointer<ffi.Void> arg0,
                          ffi.Pointer<objc.ObjCObject> arg1,
                          ffi.Pointer<objc.ObjCObject> arg2) =>
                      fn(
                          arg0,
                          UIFocusUpdateContext.castFromPointer(arg1, retain: true, release: true),
                          UIFocusAnimationCoordinator.castFromPointer(arg2, retain: true, release: true))),
              retain: false,
              release: true);

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// Note that unlike the default behavior of NativeCallable.listener, listener
  /// blocks do not keep the isolate alive.
  static objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<ffi.Void>, UIFocusUpdateContext,
          UIFocusAnimationCoordinator)> listener(
      void Function(ffi.Pointer<ffi.Void>, UIFocusUpdateContext,
              UIFocusAnimationCoordinator)
          fn) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_UIFocusUpdateContext_UIFocusAnimationCoordinator_listenerCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1,
                ffi.Pointer<objc.ObjCObject> arg2) =>
            fn(
                arg0,
                UIFocusUpdateContext.castFromPointer(arg1,
                    retain: false, release: true),
                UIFocusAnimationCoordinator.castFromPointer(arg2,
                    retain: false, release: true)));
    final wrapper = _AuthenticationServicesIos_wrapListenerBlock_fjrv01(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
            ffi.Void Function(ffi.Pointer<ffi.Void>, UIFocusUpdateContext,
                UIFocusAnimationCoordinator)>(wrapper,
        retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// This block does not keep the owner isolate alive. If the owner isolate has
  /// shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<ffi.Void>, UIFocusUpdateContext,
          UIFocusAnimationCoordinator)> blocking(
      void Function(ffi.Pointer<ffi.Void>, UIFocusUpdateContext,
              UIFocusAnimationCoordinator)
          fn) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_UIFocusUpdateContext_UIFocusAnimationCoordinator_blockingCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1,
                ffi.Pointer<objc.ObjCObject> arg2) =>
            fn(
                arg0,
                UIFocusUpdateContext.castFromPointer(arg1,
                    retain: false, release: true),
                UIFocusAnimationCoordinator.castFromPointer(arg2,
                    retain: false, release: true)));
    final rawListener = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_UIFocusUpdateContext_UIFocusAnimationCoordinator_blockingListenerCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1,
                ffi.Pointer<objc.ObjCObject> arg2) =>
            fn(
                arg0,
                UIFocusUpdateContext.castFromPointer(arg1,
                    retain: false, release: true),
                UIFocusAnimationCoordinator.castFromPointer(arg2,
                    retain: false, release: true)));
    final wrapper = objc.wrapBlockingBlock(
        _AuthenticationServicesIos_wrapBlockingBlock_fjrv01, raw, rawListener);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
            ffi.Void Function(ffi.Pointer<ffi.Void>, UIFocusUpdateContext,
                UIFocusAnimationCoordinator)>(wrapper,
        retain: false, release: true);
  }
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UIFocusUpdateContext, UIFocusAnimationCoordinator)>`.
extension ObjCBlock_ffiVoid_ffiVoid_UIFocusUpdateContext_UIFocusAnimationCoordinator_CallExtension
    on objc.ObjCBlock<
        ffi.Void Function(ffi.Pointer<ffi.Void>, UIFocusUpdateContext,
            UIFocusAnimationCoordinator)> {
  void call(ffi.Pointer<ffi.Void> arg0, UIFocusUpdateContext arg1,
          UIFocusAnimationCoordinator arg2) =>
      ref.pointer.ref.invoke
              .cast<
                  ffi.NativeFunction<
                      ffi.Void Function(
                          ffi.Pointer<objc.ObjCBlockImpl> block,
                          ffi.Pointer<ffi.Void> arg0,
                          ffi.Pointer<objc.ObjCObject> arg1,
                          ffi.Pointer<objc.ObjCObject> arg2)>>()
              .asFunction<
                  void Function(
                      ffi.Pointer<objc.ObjCBlockImpl>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<objc.ObjCObject>,
                      ffi.Pointer<objc.ObjCObject>)>()(
          ref.pointer, arg0, arg1.ref.pointer, arg2.ref.pointer);
}

late final _sel_focusGroupIdentifier =
    objc.registerName("focusGroupIdentifier");
ffi.Pointer<objc.ObjCObject> _ObjCBlock_NSString_ffiVoid_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0) =>
    block.ref.target
        .cast<
            ffi.NativeFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<ffi.Void> arg0)>>()
        .asFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<ffi.Void>)>()(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_NSString_ffiVoid_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>(
            _ObjCBlock_NSString_ffiVoid_fnPtrTrampoline)
        .cast();
ffi.Pointer<objc.ObjCObject> _ObjCBlock_NSString_ffiVoid_closureTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0) =>
    (objc.getBlockClosure(block) as ffi.Pointer<objc.ObjCObject> Function(
        ffi.Pointer<ffi.Void>))(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_NSString_ffiVoid_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>(
            _ObjCBlock_NSString_ffiVoid_closureTrampoline)
        .cast();

/// Construction methods for `objc.ObjCBlock<objc.NSString? Function(ffi.Pointer<ffi.Void>)>`.
abstract final class ObjCBlock_NSString_ffiVoid {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<objc.NSString? Function(ffi.Pointer<ffi.Void>)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<objc.NSString? Function(ffi.Pointer<ffi.Void>)>(
              pointer,
              retain: retain,
              release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<objc.NSString? Function(ffi.Pointer<ffi.Void>)>
      fromFunctionPointer(
              ffi.Pointer<
                      ffi.NativeFunction<
                          ffi.Pointer<objc.ObjCObject> Function(
                              ffi.Pointer<ffi.Void> arg0)>>
                  ptr) =>
          objc.ObjCBlock<objc.NSString? Function(ffi.Pointer<ffi.Void>)>(
              objc.newPointerBlock(_ObjCBlock_NSString_ffiVoid_fnPtrCallable, ptr.cast()),
              retain: false,
              release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<objc.NSString? Function(ffi.Pointer<ffi.Void>)>
      fromFunction(objc.NSString? Function(ffi.Pointer<ffi.Void>) fn) =>
          objc.ObjCBlock<objc.NSString? Function(ffi.Pointer<ffi.Void>)>(
              objc.newClosureBlock(
                  _ObjCBlock_NSString_ffiVoid_closureCallable,
                  (ffi.Pointer<ffi.Void> arg0) =>
                      fn(arg0)?.ref.retainAndAutorelease() ?? ffi.nullptr),
              retain: false,
              release: true);
}

/// Call operator for `objc.ObjCBlock<objc.NSString? Function(ffi.Pointer<ffi.Void>)>`.
extension ObjCBlock_NSString_ffiVoid_CallExtension
    on objc.ObjCBlock<objc.NSString? Function(ffi.Pointer<ffi.Void>)> {
  objc.NSString? call(ffi.Pointer<ffi.Void> arg0) => ref.pointer.ref.invoke
              .cast<
                  ffi.NativeFunction<
                      ffi.Pointer<objc.ObjCObject> Function(
                          ffi.Pointer<objc.ObjCBlockImpl> block,
                          ffi.Pointer<ffi.Void> arg0)>>()
              .asFunction<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>()
              (ref.pointer, arg0)
              .address ==
          0
      ? null
      : objc.NSString.castFromPointer(
          ref.pointer.ref.invoke
              .cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0)>>()
              .asFunction<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>()(ref.pointer, arg0),
          retain: true,
          release: true);
}

/// UIFocusItem
interface class UIFocusItem extends objc.ObjCProtocolBase
    implements UIFocusEnvironment {
  UIFocusItem._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super(pointer, retain: retain, release: release);

  /// Constructs a [UIFocusItem] that points to the same underlying object as [other].
  UIFocusItem.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UIFocusItem] that wraps the given raw object pointer.
  UIFocusItem.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [UIFocusItem].
  static bool conformsTo(objc.ObjCObjectBase obj) {
    return _objc_msgSend_e3qsqz(
        obj.ref.pointer, _sel_conformsToProtocol_, _protocol_UIFocusItem);
  }

  /// Builds an object that implements the UIFocusItem protocol. To implement
  /// multiple protocols, use [addToBuilder] or [objc.ObjCProtocolBuilder] directly.
  static UIFocusItem implement(
      {required bool Function() canBecomeFocused,
      required CGRect Function() frame,
      UIFocusEffect? Function()? focusEffect,
      int Function()? focusGroupPriority,
      UIFocusItemDeferralMode Function()? focusItemDeferralMode,
      bool Function()? isTransparentFocusItem,
      void Function(UIFocusMovementHint)? didHintFocusMovement_,
      required objc.ObjCObjectBase Function() preferredFocusEnvironments,
      required UIFocusEnvironment? Function() parentFocusEnvironment,
      required UIFocusItemContainer? Function() focusItemContainer,
      required void Function() setNeedsFocusUpdate,
      required void Function() updateFocusIfNeeded,
      required bool Function(UIFocusUpdateContext) shouldUpdateFocusInContext_,
      required void Function(UIFocusUpdateContext, UIFocusAnimationCoordinator)
          didUpdateFocusInContext_withAnimationCoordinator_,
      objc.NSString? Function()? focusGroupIdentifier}) {
    final builder = objc.ObjCProtocolBuilder();
    UIFocusItem.canBecomeFocused.implement(builder, canBecomeFocused);
    UIFocusItem.frame.implement(builder, frame);
    UIFocusItem.focusEffect.implement(builder, focusEffect);
    UIFocusItem.focusGroupPriority.implement(builder, focusGroupPriority);
    UIFocusItem.focusItemDeferralMode.implement(builder, focusItemDeferralMode);
    UIFocusItem.isTransparentFocusItem
        .implement(builder, isTransparentFocusItem);
    UIFocusItem.didHintFocusMovement_.implement(builder, didHintFocusMovement_);
    UIFocusItem.preferredFocusEnvironments
        .implement(builder, preferredFocusEnvironments);
    UIFocusItem.parentFocusEnvironment
        .implement(builder, parentFocusEnvironment);
    UIFocusItem.focusItemContainer.implement(builder, focusItemContainer);
    UIFocusItem.setNeedsFocusUpdate.implement(builder, setNeedsFocusUpdate);
    UIFocusItem.updateFocusIfNeeded.implement(builder, updateFocusIfNeeded);
    UIFocusItem.shouldUpdateFocusInContext_
        .implement(builder, shouldUpdateFocusInContext_);
    UIFocusItem.didUpdateFocusInContext_withAnimationCoordinator_
        .implement(builder, didUpdateFocusInContext_withAnimationCoordinator_);
    UIFocusItem.focusGroupIdentifier.implement(builder, focusGroupIdentifier);
    return UIFocusItem.castFrom(builder.build());
  }

  /// Adds the implementation of the UIFocusItem protocol to an existing
  /// [objc.ObjCProtocolBuilder].
  static void addToBuilder(objc.ObjCProtocolBuilder builder,
      {required bool Function() canBecomeFocused,
      required CGRect Function() frame,
      UIFocusEffect? Function()? focusEffect,
      int Function()? focusGroupPriority,
      UIFocusItemDeferralMode Function()? focusItemDeferralMode,
      bool Function()? isTransparentFocusItem,
      void Function(UIFocusMovementHint)? didHintFocusMovement_,
      required objc.ObjCObjectBase Function() preferredFocusEnvironments,
      required UIFocusEnvironment? Function() parentFocusEnvironment,
      required UIFocusItemContainer? Function() focusItemContainer,
      required void Function() setNeedsFocusUpdate,
      required void Function() updateFocusIfNeeded,
      required bool Function(UIFocusUpdateContext) shouldUpdateFocusInContext_,
      required void Function(UIFocusUpdateContext, UIFocusAnimationCoordinator)
          didUpdateFocusInContext_withAnimationCoordinator_,
      objc.NSString? Function()? focusGroupIdentifier}) {
    UIFocusItem.canBecomeFocused.implement(builder, canBecomeFocused);
    UIFocusItem.frame.implement(builder, frame);
    UIFocusItem.focusEffect.implement(builder, focusEffect);
    UIFocusItem.focusGroupPriority.implement(builder, focusGroupPriority);
    UIFocusItem.focusItemDeferralMode.implement(builder, focusItemDeferralMode);
    UIFocusItem.isTransparentFocusItem
        .implement(builder, isTransparentFocusItem);
    UIFocusItem.didHintFocusMovement_.implement(builder, didHintFocusMovement_);
    UIFocusItem.preferredFocusEnvironments
        .implement(builder, preferredFocusEnvironments);
    UIFocusItem.parentFocusEnvironment
        .implement(builder, parentFocusEnvironment);
    UIFocusItem.focusItemContainer.implement(builder, focusItemContainer);
    UIFocusItem.setNeedsFocusUpdate.implement(builder, setNeedsFocusUpdate);
    UIFocusItem.updateFocusIfNeeded.implement(builder, updateFocusIfNeeded);
    UIFocusItem.shouldUpdateFocusInContext_
        .implement(builder, shouldUpdateFocusInContext_);
    UIFocusItem.didUpdateFocusInContext_withAnimationCoordinator_
        .implement(builder, didUpdateFocusInContext_withAnimationCoordinator_);
    UIFocusItem.focusGroupIdentifier.implement(builder, focusGroupIdentifier);
  }

  /// Builds an object that implements the UIFocusItem protocol. To implement
  /// multiple protocols, use [addToBuilder] or [objc.ObjCProtocolBuilder] directly. All
  /// methods that can be implemented as listeners will be.
  static UIFocusItem implementAsListener(
      {required bool Function() canBecomeFocused,
      required CGRect Function() frame,
      UIFocusEffect? Function()? focusEffect,
      int Function()? focusGroupPriority,
      UIFocusItemDeferralMode Function()? focusItemDeferralMode,
      bool Function()? isTransparentFocusItem,
      void Function(UIFocusMovementHint)? didHintFocusMovement_,
      required objc.ObjCObjectBase Function() preferredFocusEnvironments,
      required UIFocusEnvironment? Function() parentFocusEnvironment,
      required UIFocusItemContainer? Function() focusItemContainer,
      required void Function() setNeedsFocusUpdate,
      required void Function() updateFocusIfNeeded,
      required bool Function(UIFocusUpdateContext) shouldUpdateFocusInContext_,
      required void Function(UIFocusUpdateContext, UIFocusAnimationCoordinator)
          didUpdateFocusInContext_withAnimationCoordinator_,
      objc.NSString? Function()? focusGroupIdentifier}) {
    final builder = objc.ObjCProtocolBuilder();
    UIFocusItem.canBecomeFocused.implement(builder, canBecomeFocused);
    UIFocusItem.frame.implement(builder, frame);
    UIFocusItem.focusEffect.implement(builder, focusEffect);
    UIFocusItem.focusGroupPriority.implement(builder, focusGroupPriority);
    UIFocusItem.focusItemDeferralMode.implement(builder, focusItemDeferralMode);
    UIFocusItem.isTransparentFocusItem
        .implement(builder, isTransparentFocusItem);
    UIFocusItem.didHintFocusMovement_
        .implementAsListener(builder, didHintFocusMovement_);
    UIFocusItem.preferredFocusEnvironments
        .implement(builder, preferredFocusEnvironments);
    UIFocusItem.parentFocusEnvironment
        .implement(builder, parentFocusEnvironment);
    UIFocusItem.focusItemContainer.implement(builder, focusItemContainer);
    UIFocusItem.setNeedsFocusUpdate
        .implementAsListener(builder, setNeedsFocusUpdate);
    UIFocusItem.updateFocusIfNeeded
        .implementAsListener(builder, updateFocusIfNeeded);
    UIFocusItem.shouldUpdateFocusInContext_
        .implement(builder, shouldUpdateFocusInContext_);
    UIFocusItem.didUpdateFocusInContext_withAnimationCoordinator_
        .implementAsListener(
            builder, didUpdateFocusInContext_withAnimationCoordinator_);
    UIFocusItem.focusGroupIdentifier.implement(builder, focusGroupIdentifier);
    return UIFocusItem.castFrom(builder.build());
  }

  /// Adds the implementation of the UIFocusItem protocol to an existing
  /// [objc.ObjCProtocolBuilder]. All methods that can be implemented as listeners will
  /// be.
  static void addToBuilderAsListener(objc.ObjCProtocolBuilder builder,
      {required bool Function() canBecomeFocused,
      required CGRect Function() frame,
      UIFocusEffect? Function()? focusEffect,
      int Function()? focusGroupPriority,
      UIFocusItemDeferralMode Function()? focusItemDeferralMode,
      bool Function()? isTransparentFocusItem,
      void Function(UIFocusMovementHint)? didHintFocusMovement_,
      required objc.ObjCObjectBase Function() preferredFocusEnvironments,
      required UIFocusEnvironment? Function() parentFocusEnvironment,
      required UIFocusItemContainer? Function() focusItemContainer,
      required void Function() setNeedsFocusUpdate,
      required void Function() updateFocusIfNeeded,
      required bool Function(UIFocusUpdateContext) shouldUpdateFocusInContext_,
      required void Function(UIFocusUpdateContext, UIFocusAnimationCoordinator)
          didUpdateFocusInContext_withAnimationCoordinator_,
      objc.NSString? Function()? focusGroupIdentifier}) {
    UIFocusItem.canBecomeFocused.implement(builder, canBecomeFocused);
    UIFocusItem.frame.implement(builder, frame);
    UIFocusItem.focusEffect.implement(builder, focusEffect);
    UIFocusItem.focusGroupPriority.implement(builder, focusGroupPriority);
    UIFocusItem.focusItemDeferralMode.implement(builder, focusItemDeferralMode);
    UIFocusItem.isTransparentFocusItem
        .implement(builder, isTransparentFocusItem);
    UIFocusItem.didHintFocusMovement_
        .implementAsListener(builder, didHintFocusMovement_);
    UIFocusItem.preferredFocusEnvironments
        .implement(builder, preferredFocusEnvironments);
    UIFocusItem.parentFocusEnvironment
        .implement(builder, parentFocusEnvironment);
    UIFocusItem.focusItemContainer.implement(builder, focusItemContainer);
    UIFocusItem.setNeedsFocusUpdate
        .implementAsListener(builder, setNeedsFocusUpdate);
    UIFocusItem.updateFocusIfNeeded
        .implementAsListener(builder, updateFocusIfNeeded);
    UIFocusItem.shouldUpdateFocusInContext_
        .implement(builder, shouldUpdateFocusInContext_);
    UIFocusItem.didUpdateFocusInContext_withAnimationCoordinator_
        .implementAsListener(
            builder, didUpdateFocusInContext_withAnimationCoordinator_);
    UIFocusItem.focusGroupIdentifier.implement(builder, focusGroupIdentifier);
  }

  /// Builds an object that implements the UIFocusItem protocol. To implement
  /// multiple protocols, use [addToBuilder] or [objc.ObjCProtocolBuilder] directly. All
  /// methods that can be implemented as blocking listeners will be.
  static UIFocusItem implementAsBlocking(
      {required bool Function() canBecomeFocused,
      required CGRect Function() frame,
      UIFocusEffect? Function()? focusEffect,
      int Function()? focusGroupPriority,
      UIFocusItemDeferralMode Function()? focusItemDeferralMode,
      bool Function()? isTransparentFocusItem,
      void Function(UIFocusMovementHint)? didHintFocusMovement_,
      required objc.ObjCObjectBase Function() preferredFocusEnvironments,
      required UIFocusEnvironment? Function() parentFocusEnvironment,
      required UIFocusItemContainer? Function() focusItemContainer,
      required void Function() setNeedsFocusUpdate,
      required void Function() updateFocusIfNeeded,
      required bool Function(UIFocusUpdateContext) shouldUpdateFocusInContext_,
      required void Function(UIFocusUpdateContext, UIFocusAnimationCoordinator)
          didUpdateFocusInContext_withAnimationCoordinator_,
      objc.NSString? Function()? focusGroupIdentifier}) {
    final builder = objc.ObjCProtocolBuilder();
    UIFocusItem.canBecomeFocused.implement(builder, canBecomeFocused);
    UIFocusItem.frame.implement(builder, frame);
    UIFocusItem.focusEffect.implement(builder, focusEffect);
    UIFocusItem.focusGroupPriority.implement(builder, focusGroupPriority);
    UIFocusItem.focusItemDeferralMode.implement(builder, focusItemDeferralMode);
    UIFocusItem.isTransparentFocusItem
        .implement(builder, isTransparentFocusItem);
    UIFocusItem.didHintFocusMovement_
        .implementAsBlocking(builder, didHintFocusMovement_);
    UIFocusItem.preferredFocusEnvironments
        .implement(builder, preferredFocusEnvironments);
    UIFocusItem.parentFocusEnvironment
        .implement(builder, parentFocusEnvironment);
    UIFocusItem.focusItemContainer.implement(builder, focusItemContainer);
    UIFocusItem.setNeedsFocusUpdate
        .implementAsBlocking(builder, setNeedsFocusUpdate);
    UIFocusItem.updateFocusIfNeeded
        .implementAsBlocking(builder, updateFocusIfNeeded);
    UIFocusItem.shouldUpdateFocusInContext_
        .implement(builder, shouldUpdateFocusInContext_);
    UIFocusItem.didUpdateFocusInContext_withAnimationCoordinator_
        .implementAsBlocking(
            builder, didUpdateFocusInContext_withAnimationCoordinator_);
    UIFocusItem.focusGroupIdentifier.implement(builder, focusGroupIdentifier);
    return UIFocusItem.castFrom(builder.build());
  }

  /// Adds the implementation of the UIFocusItem protocol to an existing
  /// [objc.ObjCProtocolBuilder]. All methods that can be implemented as blocking
  /// listeners will be.
  static void addToBuilderAsBlocking(objc.ObjCProtocolBuilder builder,
      {required bool Function() canBecomeFocused,
      required CGRect Function() frame,
      UIFocusEffect? Function()? focusEffect,
      int Function()? focusGroupPriority,
      UIFocusItemDeferralMode Function()? focusItemDeferralMode,
      bool Function()? isTransparentFocusItem,
      void Function(UIFocusMovementHint)? didHintFocusMovement_,
      required objc.ObjCObjectBase Function() preferredFocusEnvironments,
      required UIFocusEnvironment? Function() parentFocusEnvironment,
      required UIFocusItemContainer? Function() focusItemContainer,
      required void Function() setNeedsFocusUpdate,
      required void Function() updateFocusIfNeeded,
      required bool Function(UIFocusUpdateContext) shouldUpdateFocusInContext_,
      required void Function(UIFocusUpdateContext, UIFocusAnimationCoordinator)
          didUpdateFocusInContext_withAnimationCoordinator_,
      objc.NSString? Function()? focusGroupIdentifier}) {
    UIFocusItem.canBecomeFocused.implement(builder, canBecomeFocused);
    UIFocusItem.frame.implement(builder, frame);
    UIFocusItem.focusEffect.implement(builder, focusEffect);
    UIFocusItem.focusGroupPriority.implement(builder, focusGroupPriority);
    UIFocusItem.focusItemDeferralMode.implement(builder, focusItemDeferralMode);
    UIFocusItem.isTransparentFocusItem
        .implement(builder, isTransparentFocusItem);
    UIFocusItem.didHintFocusMovement_
        .implementAsBlocking(builder, didHintFocusMovement_);
    UIFocusItem.preferredFocusEnvironments
        .implement(builder, preferredFocusEnvironments);
    UIFocusItem.parentFocusEnvironment
        .implement(builder, parentFocusEnvironment);
    UIFocusItem.focusItemContainer.implement(builder, focusItemContainer);
    UIFocusItem.setNeedsFocusUpdate
        .implementAsBlocking(builder, setNeedsFocusUpdate);
    UIFocusItem.updateFocusIfNeeded
        .implementAsBlocking(builder, updateFocusIfNeeded);
    UIFocusItem.shouldUpdateFocusInContext_
        .implement(builder, shouldUpdateFocusInContext_);
    UIFocusItem.didUpdateFocusInContext_withAnimationCoordinator_
        .implementAsBlocking(
            builder, didUpdateFocusInContext_withAnimationCoordinator_);
    UIFocusItem.focusGroupIdentifier.implement(builder, focusGroupIdentifier);
  }

  /// canBecomeFocused
  static final canBecomeFocused = objc.ObjCProtocolMethod<bool Function()>(
    _protocol_UIFocusItem,
    _sel_canBecomeFocused,
    objc.getProtocolMethodSignature(
      _protocol_UIFocusItem,
      _sel_canBecomeFocused,
      isRequired: true,
      isInstanceMethod: true,
    ),
    (bool Function() func) => ObjCBlock_bool_ffiVoid.fromFunction((
      ffi.Pointer<ffi.Void> _,
    ) =>
        func()),
  );

  /// frame
  static final frame = objc.ObjCProtocolMethod<CGRect Function()>(
    _protocol_UIFocusItem,
    _sel_frame,
    objc.getProtocolMethodSignature(
      _protocol_UIFocusItem,
      _sel_frame,
      isRequired: true,
      isInstanceMethod: true,
    ),
    (CGRect Function() func) => ObjCBlock_CGRect_ffiVoid.fromFunction((
      ffi.Pointer<ffi.Void> _,
    ) =>
        func()),
  );

  /// focusEffect
  static final focusEffect = objc.ObjCProtocolMethod<UIFocusEffect? Function()>(
    _protocol_UIFocusItem,
    _sel_focusEffect,
    objc.getProtocolMethodSignature(
      _protocol_UIFocusItem,
      _sel_focusEffect,
      isRequired: false,
      isInstanceMethod: true,
    ),
    (UIFocusEffect? Function() func) =>
        ObjCBlock_UIFocusEffect_ffiVoid.fromFunction((
      ffi.Pointer<ffi.Void> _,
    ) =>
            func()),
  );

  /// focusGroupPriority
  static final focusGroupPriority = objc.ObjCProtocolMethod<int Function()>(
    _protocol_UIFocusItem,
    _sel_focusGroupPriority,
    objc.getProtocolMethodSignature(
      _protocol_UIFocusItem,
      _sel_focusGroupPriority,
      isRequired: false,
      isInstanceMethod: true,
    ),
    (int Function() func) =>
        ObjCBlock_UIFocusGroupPriority_ffiVoid.fromFunction((
      ffi.Pointer<ffi.Void> _,
    ) =>
            func()),
  );

  /// focusItemDeferralMode
  static final focusItemDeferralMode =
      objc.ObjCProtocolMethod<UIFocusItemDeferralMode Function()>(
    _protocol_UIFocusItem,
    _sel_focusItemDeferralMode,
    objc.getProtocolMethodSignature(
      _protocol_UIFocusItem,
      _sel_focusItemDeferralMode,
      isRequired: false,
      isInstanceMethod: true,
    ),
    (UIFocusItemDeferralMode Function() func) =>
        ObjCBlock_UIFocusItemDeferralMode_ffiVoid.fromFunction((
      ffi.Pointer<ffi.Void> _,
    ) =>
            func()),
  );

  /// isTransparentFocusItem
  static final isTransparentFocusItem =
      objc.ObjCProtocolMethod<bool Function()>(
    _protocol_UIFocusItem,
    _sel_isTransparentFocusItem,
    objc.getProtocolMethodSignature(
      _protocol_UIFocusItem,
      _sel_isTransparentFocusItem,
      isRequired: false,
      isInstanceMethod: true,
    ),
    (bool Function() func) => ObjCBlock_bool_ffiVoid.fromFunction((
      ffi.Pointer<ffi.Void> _,
    ) =>
        func()),
  );

  /// didHintFocusMovement:
  static final didHintFocusMovement_ =
      objc.ObjCProtocolListenableMethod<void Function(UIFocusMovementHint)>(
    _protocol_UIFocusItem,
    _sel_didHintFocusMovement_,
    objc.getProtocolMethodSignature(
      _protocol_UIFocusItem,
      _sel_didHintFocusMovement_,
      isRequired: false,
      isInstanceMethod: true,
    ),
    (void Function(UIFocusMovementHint) func) =>
        ObjCBlock_ffiVoid_ffiVoid_UIFocusMovementHint.fromFunction(
            (ffi.Pointer<ffi.Void> _, UIFocusMovementHint arg1) => func(arg1)),
    (void Function(UIFocusMovementHint) func) =>
        ObjCBlock_ffiVoid_ffiVoid_UIFocusMovementHint.listener(
            (ffi.Pointer<ffi.Void> _, UIFocusMovementHint arg1) => func(arg1)),
    (void Function(UIFocusMovementHint) func) =>
        ObjCBlock_ffiVoid_ffiVoid_UIFocusMovementHint.blocking(
            (ffi.Pointer<ffi.Void> _, UIFocusMovementHint arg1) => func(arg1)),
  );

  /// preferredFocusEnvironments
  static final preferredFocusEnvironments =
      objc.ObjCProtocolMethod<objc.ObjCObjectBase Function()>(
    _protocol_UIFocusItem,
    _sel_preferredFocusEnvironments,
    objc.getProtocolMethodSignature(
      _protocol_UIFocusItem,
      _sel_preferredFocusEnvironments,
      isRequired: true,
      isInstanceMethod: true,
    ),
    (objc.ObjCObjectBase Function() func) =>
        ObjCBlock_objcObjCObject_ffiVoid.fromFunction((
      ffi.Pointer<ffi.Void> _,
    ) =>
            func()),
  );

  /// parentFocusEnvironment
  static final parentFocusEnvironment =
      objc.ObjCProtocolMethod<UIFocusEnvironment? Function()>(
    _protocol_UIFocusItem,
    _sel_parentFocusEnvironment,
    objc.getProtocolMethodSignature(
      _protocol_UIFocusItem,
      _sel_parentFocusEnvironment,
      isRequired: true,
      isInstanceMethod: true,
    ),
    (UIFocusEnvironment? Function() func) =>
        ObjCBlock_idUIFocusEnvironment_ffiVoid.fromFunction((
      ffi.Pointer<ffi.Void> _,
    ) =>
            func()),
  );

  /// focusItemContainer
  static final focusItemContainer =
      objc.ObjCProtocolMethod<UIFocusItemContainer? Function()>(
    _protocol_UIFocusItem,
    _sel_focusItemContainer,
    objc.getProtocolMethodSignature(
      _protocol_UIFocusItem,
      _sel_focusItemContainer,
      isRequired: true,
      isInstanceMethod: true,
    ),
    (UIFocusItemContainer? Function() func) =>
        ObjCBlock_idUIFocusItemContainer_ffiVoid.fromFunction((
      ffi.Pointer<ffi.Void> _,
    ) =>
            func()),
  );

  /// setNeedsFocusUpdate
  static final setNeedsFocusUpdate =
      objc.ObjCProtocolListenableMethod<void Function()>(
    _protocol_UIFocusItem,
    _sel_setNeedsFocusUpdate,
    objc.getProtocolMethodSignature(
      _protocol_UIFocusItem,
      _sel_setNeedsFocusUpdate,
      isRequired: true,
      isInstanceMethod: true,
    ),
    (void Function() func) => ObjCBlock_ffiVoid_ffiVoid.fromFunction((
      ffi.Pointer<ffi.Void> _,
    ) =>
        func()),
    (void Function() func) => ObjCBlock_ffiVoid_ffiVoid.listener((
      ffi.Pointer<ffi.Void> _,
    ) =>
        func()),
    (void Function() func) => ObjCBlock_ffiVoid_ffiVoid.blocking((
      ffi.Pointer<ffi.Void> _,
    ) =>
        func()),
  );

  /// updateFocusIfNeeded
  static final updateFocusIfNeeded =
      objc.ObjCProtocolListenableMethod<void Function()>(
    _protocol_UIFocusItem,
    _sel_updateFocusIfNeeded,
    objc.getProtocolMethodSignature(
      _protocol_UIFocusItem,
      _sel_updateFocusIfNeeded,
      isRequired: true,
      isInstanceMethod: true,
    ),
    (void Function() func) => ObjCBlock_ffiVoid_ffiVoid.fromFunction((
      ffi.Pointer<ffi.Void> _,
    ) =>
        func()),
    (void Function() func) => ObjCBlock_ffiVoid_ffiVoid.listener((
      ffi.Pointer<ffi.Void> _,
    ) =>
        func()),
    (void Function() func) => ObjCBlock_ffiVoid_ffiVoid.blocking((
      ffi.Pointer<ffi.Void> _,
    ) =>
        func()),
  );

  /// shouldUpdateFocusInContext:
  static final shouldUpdateFocusInContext_ =
      objc.ObjCProtocolMethod<bool Function(UIFocusUpdateContext)>(
    _protocol_UIFocusItem,
    _sel_shouldUpdateFocusInContext_,
    objc.getProtocolMethodSignature(
      _protocol_UIFocusItem,
      _sel_shouldUpdateFocusInContext_,
      isRequired: true,
      isInstanceMethod: true,
    ),
    (bool Function(UIFocusUpdateContext) func) =>
        ObjCBlock_bool_ffiVoid_UIFocusUpdateContext.fromFunction(
            (ffi.Pointer<ffi.Void> _, UIFocusUpdateContext arg1) => func(arg1)),
  );

  /// didUpdateFocusInContext:withAnimationCoordinator:
  static final didUpdateFocusInContext_withAnimationCoordinator_ =
      objc.ObjCProtocolListenableMethod<
          void Function(UIFocusUpdateContext, UIFocusAnimationCoordinator)>(
    _protocol_UIFocusItem,
    _sel_didUpdateFocusInContext_withAnimationCoordinator_,
    objc.getProtocolMethodSignature(
      _protocol_UIFocusItem,
      _sel_didUpdateFocusInContext_withAnimationCoordinator_,
      isRequired: true,
      isInstanceMethod: true,
    ),
    (void Function(UIFocusUpdateContext, UIFocusAnimationCoordinator) func) =>
        ObjCBlock_ffiVoid_ffiVoid_UIFocusUpdateContext_UIFocusAnimationCoordinator
            .fromFunction((ffi.Pointer<ffi.Void> _, UIFocusUpdateContext arg1,
                    UIFocusAnimationCoordinator arg2) =>
                func(arg1, arg2)),
    (void Function(UIFocusUpdateContext, UIFocusAnimationCoordinator) func) =>
        ObjCBlock_ffiVoid_ffiVoid_UIFocusUpdateContext_UIFocusAnimationCoordinator
            .listener((ffi.Pointer<ffi.Void> _, UIFocusUpdateContext arg1,
                    UIFocusAnimationCoordinator arg2) =>
                func(arg1, arg2)),
    (void Function(UIFocusUpdateContext, UIFocusAnimationCoordinator) func) =>
        ObjCBlock_ffiVoid_ffiVoid_UIFocusUpdateContext_UIFocusAnimationCoordinator
            .blocking((ffi.Pointer<ffi.Void> _, UIFocusUpdateContext arg1,
                    UIFocusAnimationCoordinator arg2) =>
                func(arg1, arg2)),
  );

  /// focusGroupIdentifier
  static final focusGroupIdentifier =
      objc.ObjCProtocolMethod<objc.NSString? Function()>(
    _protocol_UIFocusItem,
    _sel_focusGroupIdentifier,
    objc.getProtocolMethodSignature(
      _protocol_UIFocusItem,
      _sel_focusGroupIdentifier,
      isRequired: false,
      isInstanceMethod: true,
    ),
    (objc.NSString? Function() func) =>
        ObjCBlock_NSString_ffiVoid.fromFunction((
      ffi.Pointer<ffi.Void> _,
    ) =>
            func()),
  );
}

/// WARNING: CALayerDelegate is a stub. To generate bindings for this class, include
/// CALayerDelegate in your config's objc-protocols list.
///
/// CALayerDelegate
interface class CALayerDelegate extends objc.ObjCProtocolBase
    implements objc.NSObjectProtocol {
  CALayerDelegate._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super(pointer, retain: retain, release: release);

  /// Constructs a [CALayerDelegate] that points to the same underlying object as [other].
  CALayerDelegate.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [CALayerDelegate] that wraps the given raw object pointer.
  CALayerDelegate.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);
}

/// UIView
class UIView extends UIResponder
    implements
        objc.NSCoding,
        UIAppearance,
        UIAppearanceContainer,
        UIDynamicItem,
        UITraitEnvironment,
        UICoordinateSpace,
        UIFocusItem,
        UIFocusItemContainer,
        CALayerDelegate {
  UIView._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release) {
    objc.checkOsVersion('UIView', iOS: (false, (2, 0, 0)));
  }

  /// Constructs a [UIView] that points to the same underlying object as [other].
  UIView.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UIView] that wraps the given raw object pointer.
  UIView.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [UIView].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(
        obj.ref.pointer, _sel_isKindOfClass_, _class_UIView);
  }
}

late final _class_UIWindow = objc.getClass("UIWindow");
late final _sel_isKeyWindow = objc.registerName("isKeyWindow");

/// UIWindow
class UIWindow extends UIView {
  UIWindow._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release) {
    objc.checkOsVersion('UIWindow', iOS: (false, (2, 0, 0)));
  }

  /// Constructs a [UIWindow] that points to the same underlying object as [other].
  UIWindow.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UIWindow] that wraps the given raw object pointer.
  UIWindow.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [UIWindow].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(
        obj.ref.pointer, _sel_isKindOfClass_, _class_UIWindow);
  }

  /// isKeyWindow
  bool get keyWindow {
    objc.checkOsVersion('UIWindow.isKeyWindow', iOS: (false, (2, 0, 0)));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_isKeyWindow);
  }
}

/// ! @enum ASWebAuthenticationSessionErrorCode
/// @abstract Error code of the NSError object passed in by ASWebAuthenticationSessionCompletionHandler.
/// @constant ASWebAuthenticationSessionErrorCodeCanceledLogin The user has canceled login by cancelling the
/// alert asking for permission to log in to this app, or by dismissing the view controller for loading the
/// authentication webpage.
/// @constant ASWebAuthenticationSessionErrorCodePresentationContextNotProvided A valid presentationContextProvider
/// was not found when -start was called. Ensure this property was not nil when -start was called.
/// @constant ASWebAuthenticationSessionErrorCodePresentationContextInvalid The presentation context returned
/// was not elligible to show the authentication UI. For iOS, validate that the UIWindow is in a foreground scene.
enum ASWebAuthenticationSessionErrorCode {
  ASWebAuthenticationSessionErrorCodeCanceledLogin(1),
  ASWebAuthenticationSessionErrorCodePresentationContextNotProvided(2),
  ASWebAuthenticationSessionErrorCodePresentationContextInvalid(3);

  final int value;
  const ASWebAuthenticationSessionErrorCode(this.value);

  static ASWebAuthenticationSessionErrorCode fromValue(int value) =>
      switch (value) {
        1 => ASWebAuthenticationSessionErrorCodeCanceledLogin,
        2 => ASWebAuthenticationSessionErrorCodePresentationContextNotProvided,
        3 => ASWebAuthenticationSessionErrorCodePresentationContextInvalid,
        _ => throw ArgumentError(
            "Unknown value for ASWebAuthenticationSessionErrorCode: $value"),
      };
}

void _ObjCBlock_ffiVoid_NSURL_NSError_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<objc.ObjCObject> arg0,
        ffi.Pointer<objc.ObjCObject> arg1) =>
    block.ref.target
        .cast<
            ffi.NativeFunction<
                ffi.Void Function(ffi.Pointer<objc.ObjCObject> arg0,
                    ffi.Pointer<objc.ObjCObject> arg1)>>()
        .asFunction<
            void Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>()(arg0, arg1);
ffi.Pointer<ffi.Void> _ObjCBlock_ffiVoid_NSURL_NSError_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_ffiVoid_NSURL_NSError_fnPtrTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_NSURL_NSError_closureTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<objc.ObjCObject> arg0,
        ffi.Pointer<objc.ObjCObject> arg1) =>
    (objc.getBlockClosure(block) as void Function(ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>))(arg0, arg1);
ffi.Pointer<ffi.Void> _ObjCBlock_ffiVoid_NSURL_NSError_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_ffiVoid_NSURL_NSError_closureTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_NSURL_NSError_listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObject> arg0,
    ffi.Pointer<objc.ObjCObject> arg1) {
  (objc.getBlockClosure(block) as void Function(
      ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCObject>))(arg0, arg1);
  objc.objectRelease(block.cast());
}

ffi.NativeCallable<
        ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_NSURL_NSError_listenerCallable = ffi.NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>.listener(
        _ObjCBlock_ffiVoid_NSURL_NSError_listenerTrampoline)
      ..keepIsolateAlive = false;
void _ObjCBlock_ffiVoid_NSURL_NSError_blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<objc.ObjCObject> arg0,
    ffi.Pointer<objc.ObjCObject> arg1) {
  try {
    (objc.getBlockClosure(block) as void Function(ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>))(arg0, arg1);
  } catch (e) {
  } finally {
    objc.signalWaiter(waiter);
    objc.objectRelease(block.cast());
  }
}

ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_NSURL_NSError_blockingCallable = ffi.NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>.isolateLocal(
        _ObjCBlock_ffiVoid_NSURL_NSError_blockingTrampoline)
      ..keepIsolateAlive = false;
ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_NSURL_NSError_blockingListenerCallable = ffi
        .NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>.listener(
        _ObjCBlock_ffiVoid_NSURL_NSError_blockingTrampoline)
      ..keepIsolateAlive = false;

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(objc.NSURL?, objc.NSError?)>`.
abstract final class ObjCBlock_ffiVoid_NSURL_NSError {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(objc.NSURL?, objc.NSError?)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<ffi.Void Function(objc.NSURL?, objc.NSError?)>(pointer,
              retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(objc.NSURL?, objc.NSError?)> fromFunctionPointer(
          ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Void Function(ffi.Pointer<objc.ObjCObject> arg0,
                          ffi.Pointer<objc.ObjCObject> arg1)>>
              ptr) =>
      objc.ObjCBlock<ffi.Void Function(objc.NSURL?, objc.NSError?)>(
          objc.newPointerBlock(_ObjCBlock_ffiVoid_NSURL_NSError_fnPtrCallable, ptr.cast()),
          retain: false,
          release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(objc.NSURL?, objc.NSError?)> fromFunction(
          void Function(objc.NSURL?, objc.NSError?) fn) =>
      objc.ObjCBlock<ffi.Void Function(objc.NSURL?, objc.NSError?)>(
          objc.newClosureBlock(
              _ObjCBlock_ffiVoid_NSURL_NSError_closureCallable,
              (ffi.Pointer<objc.ObjCObject> arg0, ffi.Pointer<objc.ObjCObject> arg1) => fn(
                  arg0.address == 0
                      ? null
                      : objc.NSURL
                          .castFromPointer(arg0, retain: true, release: true),
                  arg1.address == 0 ? null : objc.NSError.castFromPointer(arg1, retain: true, release: true))),
          retain: false,
          release: true);

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// Note that unlike the default behavior of NativeCallable.listener, listener
  /// blocks do not keep the isolate alive.
  static objc.ObjCBlock<ffi.Void Function(objc.NSURL?, objc.NSError?)> listener(
      void Function(objc.NSURL?, objc.NSError?) fn) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_NSURL_NSError_listenerCallable.nativeFunction.cast(),
        (ffi.Pointer<objc.ObjCObject> arg0,
                ffi.Pointer<objc.ObjCObject> arg1) =>
            fn(
                arg0.address == 0
                    ? null
                    : objc.NSURL
                        .castFromPointer(arg0, retain: false, release: true),
                arg1.address == 0
                    ? null
                    : objc.NSError.castFromPointer(arg1,
                        retain: false, release: true)));
    final wrapper = _AuthenticationServicesIos_wrapListenerBlock_pfv6jd(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<ffi.Void Function(objc.NSURL?, objc.NSError?)>(
        wrapper,
        retain: false,
        release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// This block does not keep the owner isolate alive. If the owner isolate has
  /// shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(objc.NSURL?, objc.NSError?)> blocking(
      void Function(objc.NSURL?, objc.NSError?) fn) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_NSURL_NSError_blockingCallable.nativeFunction.cast(),
        (ffi.Pointer<objc.ObjCObject> arg0,
                ffi.Pointer<objc.ObjCObject> arg1) =>
            fn(
                arg0.address == 0
                    ? null
                    : objc.NSURL
                        .castFromPointer(arg0, retain: false, release: true),
                arg1.address == 0
                    ? null
                    : objc.NSError.castFromPointer(arg1,
                        retain: false, release: true)));
    final rawListener = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_NSURL_NSError_blockingListenerCallable.nativeFunction
            .cast(),
        (ffi.Pointer<objc.ObjCObject> arg0,
                ffi.Pointer<objc.ObjCObject> arg1) =>
            fn(
                arg0.address == 0
                    ? null
                    : objc.NSURL
                        .castFromPointer(arg0, retain: false, release: true),
                arg1.address == 0
                    ? null
                    : objc.NSError.castFromPointer(arg1,
                        retain: false, release: true)));
    final wrapper = objc.wrapBlockingBlock(
        _AuthenticationServicesIos_wrapBlockingBlock_pfv6jd, raw, rawListener);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<ffi.Void Function(objc.NSURL?, objc.NSError?)>(
        wrapper,
        retain: false,
        release: true);
  }
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(objc.NSURL?, objc.NSError?)>`.
extension ObjCBlock_ffiVoid_NSURL_NSError_CallExtension
    on objc.ObjCBlock<ffi.Void Function(objc.NSURL?, objc.NSError?)> {
  void call(objc.NSURL? arg0, objc.NSError? arg1) => ref.pointer.ref.invoke
          .cast<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<objc.ObjCBlockImpl> block,
                      ffi.Pointer<objc.ObjCObject> arg0,
                      ffi.Pointer<objc.ObjCObject> arg1)>>()
          .asFunction<
              void Function(
                  ffi.Pointer<objc.ObjCBlockImpl>,
                  ffi.Pointer<objc.ObjCObject>,
                  ffi.Pointer<objc.ObjCObject>)>()(ref.pointer,
      arg0?.ref.pointer ?? ffi.nullptr, arg1?.ref.pointer ?? ffi.nullptr);
}

late final _class_ASWebAuthenticationSession =
    objc.getClass("ASWebAuthenticationSession");
late final _sel_initWithURL_callbackURLScheme_completionHandler_ =
    objc.registerName("initWithURL:callbackURLScheme:completionHandler:");
final _objc_msgSend_2wiv66 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCBlockImpl>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCBlockImpl>)>();
late final _class_ASWebAuthenticationSessionCallback =
    objc.getClass("ASWebAuthenticationSessionCallback");
late final _sel_callbackWithCustomScheme_ =
    objc.registerName("callbackWithCustomScheme:");
final _objc_msgSend_1sotr3r = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<objc.ObjCObject>)>();
late final _sel_callbackWithHTTPSHost_path_ =
    objc.registerName("callbackWithHTTPSHost:path:");
late final _sel_matchesURL_ = objc.registerName("matchesURL:");
late final _sel_init = objc.registerName("init");
late final _sel_new = objc.registerName("new");
late final _sel_allocWithZone_ = objc.registerName("allocWithZone:");
final _objc_msgSend_1cwp428 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<objc.NSZone>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<objc.NSZone>)>();
late final _sel_alloc = objc.registerName("alloc");
late final _sel_self = objc.registerName("self");
late final _sel_retain = objc.registerName("retain");
late final _sel_autorelease = objc.registerName("autorelease");

/// ASWebAuthenticationSessionCallback
class ASWebAuthenticationSessionCallback extends objc.NSObject {
  ASWebAuthenticationSessionCallback._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release);

  /// Constructs a [ASWebAuthenticationSessionCallback] that points to the same underlying object as [other].
  ASWebAuthenticationSessionCallback.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [ASWebAuthenticationSessionCallback] that wraps the given raw object pointer.
  ASWebAuthenticationSessionCallback.castFromPointer(
      ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false,
      bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [ASWebAuthenticationSessionCallback].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(obj.ref.pointer, _sel_isKindOfClass_,
        _class_ASWebAuthenticationSessionCallback);
  }

  /// Creates a callback object that matches against URLs with the given custom scheme.
  /// @param customScheme The custom scheme that the app expects in the callback URL.
  static ASWebAuthenticationSessionCallback callbackWithCustomScheme_(
      objc.NSString customScheme) {
    objc.checkOsVersion(
        'ASWebAuthenticationSessionCallback.callbackWithCustomScheme:',
        iOS: (false, (17, 4, 0)),
        macOS: (false, (14, 4, 0)));
    final _ret = _objc_msgSend_1sotr3r(
        _class_ASWebAuthenticationSessionCallback,
        _sel_callbackWithCustomScheme_,
        customScheme.ref.pointer);
    return ASWebAuthenticationSessionCallback.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// Creates a callback object that matches against HTTPS URLs with the given host and path.
  /// @param host The host that the app expects in the callback URL. The host must be associated with the
  /// app using associated web credentials domains.
  /// @param path The path that the app expects in the callback URL.
  static ASWebAuthenticationSessionCallback callbackWithHTTPSHost_path_(
      objc.NSString host, objc.NSString path) {
    objc.checkOsVersion(
        'ASWebAuthenticationSessionCallback.callbackWithHTTPSHost:path:',
        iOS: (false, (17, 4, 0)),
        macOS: (false, (14, 4, 0)));
    final _ret = _objc_msgSend_15qeuct(
        _class_ASWebAuthenticationSessionCallback,
        _sel_callbackWithHTTPSHost_path_,
        host.ref.pointer,
        path.ref.pointer);
    return ASWebAuthenticationSessionCallback.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// Check whether a given main-frame navigation URL matches the callback expected by the client app. Handles all URL-based callback strategies, including custom schemes and HTTPS navigations.
  /// This is mainly meant for web browsers adopting the ASWebAuthenticationWebBrowser API, but may also be useful for other apps for debugging purposes.
  /// @param url The URL to check.
  bool matchesURL_(objc.NSURL url) {
    objc.checkOsVersion('ASWebAuthenticationSessionCallback.matchesURL:',
        iOS: (false, (17, 4, 0)), macOS: (false, (14, 4, 0)));
    return _objc_msgSend_19nvye5(
        this.ref.pointer, _sel_matchesURL_, url.ref.pointer);
  }

  /// init
  ASWebAuthenticationSessionCallback init() {
    objc.checkOsVersion('ASWebAuthenticationSessionCallback.init',
        iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final _ret =
        _objc_msgSend_151sglz(this.ref.retainAndReturnPointer(), _sel_init);
    return ASWebAuthenticationSessionCallback.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// new
  static ASWebAuthenticationSessionCallback new1() {
    final _ret = _objc_msgSend_151sglz(
        _class_ASWebAuthenticationSessionCallback, _sel_new);
    return ASWebAuthenticationSessionCallback.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// allocWithZone:
  static ASWebAuthenticationSessionCallback allocWithZone_(
      ffi.Pointer<objc.NSZone> zone) {
    final _ret = _objc_msgSend_1cwp428(
        _class_ASWebAuthenticationSessionCallback, _sel_allocWithZone_, zone);
    return ASWebAuthenticationSessionCallback.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// alloc
  static ASWebAuthenticationSessionCallback alloc() {
    final _ret = _objc_msgSend_151sglz(
        _class_ASWebAuthenticationSessionCallback, _sel_alloc);
    return ASWebAuthenticationSessionCallback.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// self
  ASWebAuthenticationSessionCallback self1() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_self);
    return ASWebAuthenticationSessionCallback.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// retain
  ASWebAuthenticationSessionCallback retain() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_retain);
    return ASWebAuthenticationSessionCallback.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// autorelease
  ASWebAuthenticationSessionCallback autorelease() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_autorelease);
    return ASWebAuthenticationSessionCallback.castFromPointer(_ret,
        retain: true, release: true);
  }
}

late final _sel_initWithURL_callback_completionHandler_ =
    objc.registerName("initWithURL:callback:completionHandler:");
late final _protocol_ASWebAuthenticationPresentationContextProviding =
    objc.getProtocol("ASWebAuthenticationPresentationContextProviding");
late final _sel_presentationAnchorForWebAuthenticationSession_ =
    objc.registerName("presentationAnchorForWebAuthenticationSession:");
ffi.Pointer<objc.ObjCObject>
    _ObjCBlock_ASPresentationAnchor_ffiVoid_ASWebAuthenticationSession_fnPtrTrampoline(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObject> arg1) =>
        block.ref.target
            .cast<
                ffi.NativeFunction<
                    ffi.Pointer<objc.ObjCObject> Function(
                        ffi.Pointer<ffi.Void> arg0,
                        ffi.Pointer<objc.ObjCObject> arg1)>>()
            .asFunction<
                ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>,
                    ffi.Pointer<objc.ObjCObject>)>()(arg0, arg1);
ffi.Pointer<ffi.Void>
    _ObjCBlock_ASPresentationAnchor_ffiVoid_ASWebAuthenticationSession_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>,
                    ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_ASPresentationAnchor_ffiVoid_ASWebAuthenticationSession_fnPtrTrampoline)
        .cast();
ffi.Pointer<objc.ObjCObject>
    _ObjCBlock_ASPresentationAnchor_ffiVoid_ASWebAuthenticationSession_closureTrampoline(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObject> arg1) =>
        (objc.getBlockClosure(block) as ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>))(arg0, arg1);
ffi.Pointer<ffi.Void>
    _ObjCBlock_ASPresentationAnchor_ffiVoid_ASWebAuthenticationSession_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>,
                    ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_ASPresentationAnchor_ffiVoid_ASWebAuthenticationSession_closureTrampoline)
        .cast();

/// Construction methods for `objc.ObjCBlock<UIWindow Function(ffi.Pointer<ffi.Void>, ASWebAuthenticationSession)>`.
abstract final class ObjCBlock_ASPresentationAnchor_ffiVoid_ASWebAuthenticationSession {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
          UIWindow Function(ffi.Pointer<ffi.Void>, ASWebAuthenticationSession)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<
                  UIWindow Function(
                      ffi.Pointer<ffi.Void>, ASWebAuthenticationSession)>(
              pointer,
              retain: retain,
              release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<UIWindow Function(ffi.Pointer<ffi.Void>, ASWebAuthenticationSession)>
      fromFunctionPointer(
              ffi.Pointer<
                      ffi.NativeFunction<
                          ffi.Pointer<objc.ObjCObject> Function(
                              ffi.Pointer<ffi.Void> arg0,
                              ffi.Pointer<objc.ObjCObject> arg1)>>
                  ptr) =>
          objc.ObjCBlock<UIWindow Function(ffi.Pointer<ffi.Void>, ASWebAuthenticationSession)>(
              objc.newPointerBlock(_ObjCBlock_ASPresentationAnchor_ffiVoid_ASWebAuthenticationSession_fnPtrCallable, ptr.cast()),
              retain: false,
              release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<UIWindow Function(ffi.Pointer<ffi.Void>, ASWebAuthenticationSession)>
      fromFunction(UIWindow Function(ffi.Pointer<ffi.Void>, ASWebAuthenticationSession) fn) =>
          objc.ObjCBlock<UIWindow Function(ffi.Pointer<ffi.Void>, ASWebAuthenticationSession)>(
              objc.newClosureBlock(
                  _ObjCBlock_ASPresentationAnchor_ffiVoid_ASWebAuthenticationSession_closureCallable,
                  (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1) => fn(
                          arg0,
                          ASWebAuthenticationSession.castFromPointer(arg1,
                              retain: true, release: true))
                      .ref
                      .retainAndAutorelease()),
              retain: false,
              release: true);
}

/// Call operator for `objc.ObjCBlock<UIWindow Function(ffi.Pointer<ffi.Void>, ASWebAuthenticationSession)>`.
extension ObjCBlock_ASPresentationAnchor_ffiVoid_ASWebAuthenticationSession_CallExtension
    on objc.ObjCBlock<
        UIWindow Function(ffi.Pointer<ffi.Void>, ASWebAuthenticationSession)> {
  UIWindow call(ffi.Pointer<ffi.Void> arg0, ASWebAuthenticationSession arg1) =>
      UIWindow.castFromPointer(
          ref.pointer.ref.invoke
                  .cast<
                      ffi.NativeFunction<
                          ffi.Pointer<objc.ObjCObject> Function(
                              ffi.Pointer<objc.ObjCBlockImpl> block,
                              ffi.Pointer<ffi.Void> arg0,
                              ffi.Pointer<objc.ObjCObject> arg1)>>()
                  .asFunction<
                      ffi.Pointer<objc.ObjCObject> Function(
                          ffi.Pointer<objc.ObjCBlockImpl>,
                          ffi.Pointer<ffi.Void>,
                          ffi.Pointer<objc.ObjCObject>)>()(
              ref.pointer, arg0, arg1.ref.pointer),
          retain: true,
          release: true);
}

/// ! @abstract Provides context to target where in an application's UI the authorization view should be shown.
interface class ASWebAuthenticationPresentationContextProviding
    extends objc.ObjCProtocolBase implements objc.NSObjectProtocol {
  ASWebAuthenticationPresentationContextProviding._(
      ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false,
      bool release = false})
      : super(pointer, retain: retain, release: release);

  /// Constructs a [ASWebAuthenticationPresentationContextProviding] that points to the same underlying object as [other].
  ASWebAuthenticationPresentationContextProviding.castFrom(
      objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [ASWebAuthenticationPresentationContextProviding] that wraps the given raw object pointer.
  ASWebAuthenticationPresentationContextProviding.castFromPointer(
      ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false,
      bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [ASWebAuthenticationPresentationContextProviding].
  static bool conformsTo(objc.ObjCObjectBase obj) {
    return _objc_msgSend_e3qsqz(obj.ref.pointer, _sel_conformsToProtocol_,
        _protocol_ASWebAuthenticationPresentationContextProviding);
  }

  /// Builds an object that implements the ASWebAuthenticationPresentationContextProviding protocol. To implement
  /// multiple protocols, use [addToBuilder] or [objc.ObjCProtocolBuilder] directly.
  static ASWebAuthenticationPresentationContextProviding implement(
      {required UIWindow Function(ASWebAuthenticationSession)
          presentationAnchorForWebAuthenticationSession_}) {
    final builder = objc.ObjCProtocolBuilder();
    ASWebAuthenticationPresentationContextProviding
        .presentationAnchorForWebAuthenticationSession_
        .implement(builder, presentationAnchorForWebAuthenticationSession_);
    return ASWebAuthenticationPresentationContextProviding.castFrom(
        builder.build());
  }

  /// Adds the implementation of the ASWebAuthenticationPresentationContextProviding protocol to an existing
  /// [objc.ObjCProtocolBuilder].
  static void addToBuilder(objc.ObjCProtocolBuilder builder,
      {required UIWindow Function(ASWebAuthenticationSession)
          presentationAnchorForWebAuthenticationSession_}) {
    ASWebAuthenticationPresentationContextProviding
        .presentationAnchorForWebAuthenticationSession_
        .implement(builder, presentationAnchorForWebAuthenticationSession_);
  }

  /// ! @abstract Return the ASPresentationAnchor in the closest proximity to where a user interacted with your app to trigger
  /// authentication. If starting an ASWebAuthenticationSession on first launch, use the application's main window.
  /// @param session The session requesting a presentation anchor.
  /// @result The ASPresentationAnchor most closely associated with the UI used to trigger authentication.
  static final presentationAnchorForWebAuthenticationSession_ =
      objc.ObjCProtocolMethod<UIWindow Function(ASWebAuthenticationSession)>(
    _protocol_ASWebAuthenticationPresentationContextProviding,
    _sel_presentationAnchorForWebAuthenticationSession_,
    objc.getProtocolMethodSignature(
      _protocol_ASWebAuthenticationPresentationContextProviding,
      _sel_presentationAnchorForWebAuthenticationSession_,
      isRequired: true,
      isInstanceMethod: true,
    ),
    (UIWindow Function(ASWebAuthenticationSession) func) =>
        ObjCBlock_ASPresentationAnchor_ffiVoid_ASWebAuthenticationSession
            .fromFunction(
                (ffi.Pointer<ffi.Void> _, ASWebAuthenticationSession arg1) =>
                    func(arg1)),
  );
}

late final _sel_presentationContextProvider =
    objc.registerName("presentationContextProvider");
late final _sel_setPresentationContextProvider_ =
    objc.registerName("setPresentationContextProvider:");
late final _sel_prefersEphemeralWebBrowserSession =
    objc.registerName("prefersEphemeralWebBrowserSession");
late final _sel_setPrefersEphemeralWebBrowserSession_ =
    objc.registerName("setPrefersEphemeralWebBrowserSession:");
final _objc_msgSend_1s56lr9 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, ffi.Bool)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, bool)>();
late final _sel_additionalHeaderFields =
    objc.registerName("additionalHeaderFields");
late final _sel_setAdditionalHeaderFields_ =
    objc.registerName("setAdditionalHeaderFields:");
late final _sel_canStart = objc.registerName("canStart");
late final _sel_start = objc.registerName("start");
late final _sel_cancel = objc.registerName("cancel");

/// !
/// @class ASWebAuthenticationSession
/// An ASWebAuthenticationSession object can be used to authenticate a user with a web service, even if the web service is run
/// by a third party. ASWebAuthenticationSession puts the user in control of whether they want to use their existing logged-in
/// session from Safari. The app provides a URL that points to the authentication webpage. The page will be loaded in a secure
/// view controller. From the webpage, the user can authenticate herself and grant access to the app.
/// On completion, the service will send a callback URL with an authentication token, and this URL will be passed to the app by
/// ASWebAuthenticationSessionCompletionHandler.
///
/// The callback URL usually has a custom URL scheme. For the app to receive the callback URL, it needs to either register the
/// custom URL scheme in its Info.plist, or set the scheme to callbackURLScheme argument in the initializer.
///
/// If the user has already logged into the web service in Safari or other apps via ASWebAuthenticationSession, it is possible to
/// share the existing login information. An alert will be presented to get the user's consent for sharing their existing login
/// information. If the user cancels the alert, the session will be canceled, and the completion handler will be called with
/// the error code ASWebAuthenticationSessionErrorCodeCanceledLogin.
///
/// If the user taps Cancel when showing the login webpage for the web service, the session will be canceled, and the completion
/// handler will be called with the error code ASWebAuthenticationSessionErrorCodeCanceledLogin.
///
/// The app can cancel the session by calling -[ASWebAuthenticationSession cancel]. This will also dismiss the view controller that
/// is showing the web service's login page.
class ASWebAuthenticationSession extends objc.NSObject {
  ASWebAuthenticationSession._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release) {
    objc.checkOsVersion('ASWebAuthenticationSession',
        iOS: (false, (12, 0, 0)), macOS: (false, (10, 15, 0)));
  }

  /// Constructs a [ASWebAuthenticationSession] that points to the same underlying object as [other].
  ASWebAuthenticationSession.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [ASWebAuthenticationSession] that wraps the given raw object pointer.
  ASWebAuthenticationSession.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [ASWebAuthenticationSession].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(obj.ref.pointer, _sel_isKindOfClass_,
        _class_ASWebAuthenticationSession);
  }

  /// ! @abstract Returns an ASWebAuthenticationSession object.
  /// @param URL the initial URL pointing to the authentication webpage. Only supports URLs with http:// or https:// schemes.
  /// @param callbackURLScheme the custom URL scheme that the app expects in the callback URL.
  /// @param completionHandler the completion handler which is called when the session is completed successfully or canceled by user.
  ///
  /// iOS: introduced 12.0.0, deprecated 100000.0.0
  /// macOS: introduced 10.15.0, deprecated 100000.0.0
  ASWebAuthenticationSession initWithURL_callbackURLScheme_completionHandler_(
      objc.NSURL URL,
      objc.NSString? callbackURLScheme,
      objc.ObjCBlock<ffi.Void Function(objc.NSURL?, objc.NSError?)>
          completionHandler) {
    objc.checkOsVersion(
        'ASWebAuthenticationSession.initWithURL:callbackURLScheme:completionHandler:',
        iOS: (false, (12, 0, 0)),
        macOS: (false, (10, 15, 0)));
    final _ret = _objc_msgSend_2wiv66(
        this.ref.retainAndReturnPointer(),
        _sel_initWithURL_callbackURLScheme_completionHandler_,
        URL.ref.pointer,
        callbackURLScheme?.ref.pointer ?? ffi.nullptr,
        completionHandler.ref.pointer);
    return ASWebAuthenticationSession.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// initWithURL:callback:completionHandler:
  ASWebAuthenticationSession initWithURL_callback_completionHandler_(
      objc.NSURL URL,
      ASWebAuthenticationSessionCallback callback,
      objc.ObjCBlock<ffi.Void Function(objc.NSURL?, objc.NSError?)>
          completionHandler) {
    objc.checkOsVersion(
        'ASWebAuthenticationSession.initWithURL:callback:completionHandler:',
        iOS: (false, (17, 4, 0)),
        macOS: (false, (14, 4, 0)));
    final _ret = _objc_msgSend_2wiv66(
        this.ref.retainAndReturnPointer(),
        _sel_initWithURL_callback_completionHandler_,
        URL.ref.pointer,
        callback.ref.pointer,
        completionHandler.ref.pointer);
    return ASWebAuthenticationSession.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// ! @abstract Provides context to target where in an application's UI the authorization view should be shown. A provider
  /// must be set prior to calling -start, otherwise the authorization view cannot be displayed. If deploying to iOS prior to
  /// 13.0, the desired window is inferred by the application's key window.
  ASWebAuthenticationPresentationContextProviding?
      get presentationContextProvider {
    objc.checkOsVersion(
        'ASWebAuthenticationSession.presentationContextProvider',
        iOS: (false, (13, 0, 0)),
        macOS: (false, (10, 15, 0)));
    final _ret = _objc_msgSend_151sglz(
        this.ref.pointer, _sel_presentationContextProvider);
    return _ret.address == 0
        ? null
        : ASWebAuthenticationPresentationContextProviding.castFromPointer(_ret,
            retain: true, release: true);
  }

  /// ! @abstract Provides context to target where in an application's UI the authorization view should be shown. A provider
  /// must be set prior to calling -start, otherwise the authorization view cannot be displayed. If deploying to iOS prior to
  /// 13.0, the desired window is inferred by the application's key window.
  set presentationContextProvider(
      ASWebAuthenticationPresentationContextProviding? value) {
    objc.checkOsVersion(
        'ASWebAuthenticationSession.setPresentationContextProvider:',
        iOS: (false, (13, 0, 0)),
        macOS: (false, (10, 15, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setPresentationContextProvider_,
        value?.ref.pointer ?? ffi.nullptr);
  }

  /// ! @abstract Indicates whether this session should ask the browser for an ephemeral session.
  /// @discussion Ephemeral web browser sessions do not not share cookies or other browsing data with a user's normal browser session.
  /// This value is NO by default. Setting this property after calling -[ASWebAuthenticationSession start] has no effect.
  bool get prefersEphemeralWebBrowserSession {
    objc.checkOsVersion(
        'ASWebAuthenticationSession.prefersEphemeralWebBrowserSession',
        iOS: (false, (13, 0, 0)),
        macOS: (false, (10, 15, 0)));
    return _objc_msgSend_91o635(
        this.ref.pointer, _sel_prefersEphemeralWebBrowserSession);
  }

  /// ! @abstract Indicates whether this session should ask the browser for an ephemeral session.
  /// @discussion Ephemeral web browser sessions do not not share cookies or other browsing data with a user's normal browser session.
  /// This value is NO by default. Setting this property after calling -[ASWebAuthenticationSession start] has no effect.
  set prefersEphemeralWebBrowserSession(bool value) {
    objc.checkOsVersion(
        'ASWebAuthenticationSession.setPrefersEphemeralWebBrowserSession:',
        iOS: (false, (13, 0, 0)),
        macOS: (false, (10, 15, 0)));
    _objc_msgSend_1s56lr9(
        this.ref.pointer, _sel_setPrefersEphemeralWebBrowserSession_, value);
  }

  /// Any additional header fields to be set when loading the initial URL.
  /// All header field names must start with the "X-" prefix.
  objc.NSDictionary? get additionalHeaderFields {
    objc.checkOsVersion('ASWebAuthenticationSession.additionalHeaderFields',
        iOS: (false, (17, 4, 0)), macOS: (false, (14, 4, 0)));
    final _ret =
        _objc_msgSend_151sglz(this.ref.pointer, _sel_additionalHeaderFields);
    return _ret.address == 0
        ? null
        : objc.NSDictionary.castFromPointer(_ret, retain: true, release: true);
  }

  /// Any additional header fields to be set when loading the initial URL.
  /// All header field names must start with the "X-" prefix.
  set additionalHeaderFields(objc.NSDictionary? value) {
    objc.checkOsVersion('ASWebAuthenticationSession.setAdditionalHeaderFields:',
        iOS: (false, (17, 4, 0)), macOS: (false, (14, 4, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setAdditionalHeaderFields_,
        value?.ref.pointer ?? ffi.nullptr);
  }

  /// ! @abstract Returns whether the session can be successfully started. This property returns the same value as calling -start,
  /// but without the side effect of actually starting the session.
  bool get canStart {
    objc.checkOsVersion('ASWebAuthenticationSession.canStart',
        iOS: (false, (13, 4, 0)), macOS: (false, (10, 15, 4)));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_canStart);
  }

  /// ! @abstract Starts the ASWebAuthenticationSession instance after it is instantiated.
  /// @discussion start can only be called once for an ASWebAuthenticationSession instance. This also means calling start on a
  /// canceled session will fail.
  /// @result Returns YES if the session starts successfully.
  bool start() {
    objc.checkOsVersion('ASWebAuthenticationSession.start',
        iOS: (false, (12, 0, 0)), macOS: (false, (10, 15, 0)));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_start);
  }

  /// ! @abstract Cancel an ASWebAuthenticationSession. If the view controller is already presented to load the webpage for
  /// authentication, it will be dismissed. Calling cancel on an already canceled session will have no effect.
  void cancel() {
    _objc_msgSend_1pl9qdv(this.ref.pointer, _sel_cancel);
  }

  /// init
  ASWebAuthenticationSession init() {
    objc.checkOsVersion('ASWebAuthenticationSession.init',
        iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final _ret =
        _objc_msgSend_151sglz(this.ref.retainAndReturnPointer(), _sel_init);
    return ASWebAuthenticationSession.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// new
  static ASWebAuthenticationSession new1() {
    final _ret =
        _objc_msgSend_151sglz(_class_ASWebAuthenticationSession, _sel_new);
    return ASWebAuthenticationSession.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// allocWithZone:
  static ASWebAuthenticationSession allocWithZone_(
      ffi.Pointer<objc.NSZone> zone) {
    final _ret = _objc_msgSend_1cwp428(
        _class_ASWebAuthenticationSession, _sel_allocWithZone_, zone);
    return ASWebAuthenticationSession.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// alloc
  static ASWebAuthenticationSession alloc() {
    final _ret =
        _objc_msgSend_151sglz(_class_ASWebAuthenticationSession, _sel_alloc);
    return ASWebAuthenticationSession.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// self
  ASWebAuthenticationSession self1() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_self);
    return ASWebAuthenticationSession.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// retain
  ASWebAuthenticationSession retain() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_retain);
    return ASWebAuthenticationSession.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// autorelease
  ASWebAuthenticationSession autorelease() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_autorelease);
    return ASWebAuthenticationSession.castFromPointer(_ret,
        retain: true, release: true);
  }
}
