// ignore_for_file: type=lint
// ignore_for_file: return_of_invalid_type
// ignore_for_file: unused_element

// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
import 'dart:ffi' as ffi;
import 'package:objective_c/objective_c.dart' as objc;
import 'package:ffi/ffi.dart' as pkg_ffi;

@ffi.Native<
    ffi.Pointer<objc.ObjCBlockImpl> Function(
        ffi.Pointer<objc.ObjCBlockImpl>)>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
    _AuthenticationServicesMacOS_wrapListenerBlock_1pl9qdv(
  ffi.Pointer<objc.ObjCBlockImpl> block,
);

@ffi.Native<
    ffi.Pointer<objc.ObjCBlockImpl> Function(
        ffi.Pointer<objc.ObjCBlockImpl>,
        ffi.Pointer<objc.ObjCBlockImpl>,
        ffi.Pointer<objc.DOBJC_Context>)>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
    _AuthenticationServicesMacOS_wrapBlockingBlock_1pl9qdv(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
  ffi.Pointer<objc.DOBJC_Context> context,
);

@ffi.Native<
    ffi.Pointer<objc.ObjCObject> Function(
        ffi.Pointer<objc.ObjCObject>, ffi.Pointer<ffi.Void>)>()
external ffi.Pointer<objc.ObjCObject>
    _AuthenticationServicesMacOS_protocolTrampoline_1mbt9g9(
  ffi.Pointer<objc.ObjCObject> target,
  ffi.Pointer<ffi.Void> arg0,
);

@ffi.Native<
    ffi.Pointer<objc.ObjCBlockImpl> Function(
        ffi.Pointer<objc.ObjCBlockImpl>)>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
    _AuthenticationServicesMacOS_wrapListenerBlock_18v1jvf(
  ffi.Pointer<objc.ObjCBlockImpl> block,
);

@ffi.Native<
    ffi.Pointer<objc.ObjCBlockImpl> Function(
        ffi.Pointer<objc.ObjCBlockImpl>,
        ffi.Pointer<objc.ObjCBlockImpl>,
        ffi.Pointer<objc.DOBJC_Context>)>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
    _AuthenticationServicesMacOS_wrapBlockingBlock_18v1jvf(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
  ffi.Pointer<objc.DOBJC_Context> context,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<ffi.Void>,
        ffi.Pointer<objc.ObjCObject>)>()
external void _AuthenticationServicesMacOS_protocolTrampoline_18v1jvf(
  ffi.Pointer<objc.ObjCObject> target,
  ffi.Pointer<ffi.Void> arg0,
  ffi.Pointer<objc.ObjCObject> arg1,
);

@ffi.Native<
    ffi.Pointer<objc.ObjCBlockImpl> Function(
        ffi.Pointer<objc.ObjCBlockImpl>)>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
    _AuthenticationServicesMacOS_wrapListenerBlock_t8l8el(
  ffi.Pointer<objc.ObjCBlockImpl> block,
);

@ffi.Native<
    ffi.Pointer<objc.ObjCBlockImpl> Function(
        ffi.Pointer<objc.ObjCBlockImpl>,
        ffi.Pointer<objc.ObjCBlockImpl>,
        ffi.Pointer<objc.DOBJC_Context>)>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
    _AuthenticationServicesMacOS_wrapBlockingBlock_t8l8el(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
  ffi.Pointer<objc.DOBJC_Context> context,
);

@ffi.Native<
    ffi.UnsignedLong Function(ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>()
external int _AuthenticationServicesMacOS_protocolTrampoline_dl2wbd(
  ffi.Pointer<objc.ObjCObject> target,
  ffi.Pointer<ffi.Void> arg0,
  ffi.Pointer<objc.ObjCObject> arg1,
);

@ffi.Native<
    ffi.Pointer<objc.ObjCBlockImpl> Function(
        ffi.Pointer<objc.ObjCBlockImpl>)>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
    _AuthenticationServicesMacOS_wrapListenerBlock_fjrv01(
  ffi.Pointer<objc.ObjCBlockImpl> block,
);

@ffi.Native<
    ffi.Pointer<objc.ObjCBlockImpl> Function(
        ffi.Pointer<objc.ObjCBlockImpl>,
        ffi.Pointer<objc.ObjCBlockImpl>,
        ffi.Pointer<objc.DOBJC_Context>)>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
    _AuthenticationServicesMacOS_wrapBlockingBlock_fjrv01(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
  ffi.Pointer<objc.DOBJC_Context> context,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<ffi.Void>,
        ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCObject>)>()
external void _AuthenticationServicesMacOS_protocolTrampoline_fjrv01(
  ffi.Pointer<objc.ObjCObject> target,
  ffi.Pointer<ffi.Void> arg0,
  ffi.Pointer<objc.ObjCObject> arg1,
  ffi.Pointer<objc.ObjCObject> arg2,
);

@ffi.Native<
    ffi.Bool Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<ffi.Void>,
        ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCObject>)>()
external bool _AuthenticationServicesMacOS_protocolTrampoline_2n06mv(
  ffi.Pointer<objc.ObjCObject> target,
  ffi.Pointer<ffi.Void> arg0,
  ffi.Pointer<objc.ObjCObject> arg1,
  ffi.Pointer<objc.ObjCObject> arg2,
);

@ffi.Native<
    ffi.Bool Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<ffi.Void>,
        ffi.Pointer<objc.ObjCObject>)>()
external bool _AuthenticationServicesMacOS_protocolTrampoline_3su7tt(
  ffi.Pointer<objc.ObjCObject> target,
  ffi.Pointer<ffi.Void> arg0,
  ffi.Pointer<objc.ObjCObject> arg1,
);

@ffi.Native<
    ffi.UnsignedLong Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<ffi.Void>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Bool)>()
external int _AuthenticationServicesMacOS_protocolTrampoline_1ntoid(
  ffi.Pointer<objc.ObjCObject> target,
  ffi.Pointer<ffi.Void> arg0,
  ffi.Pointer<objc.ObjCObject> arg1,
  ffi.Pointer<objc.ObjCObject> arg2,
  ffi.Pointer<objc.ObjCObject> arg3,
  bool arg4,
);

@ffi.Native<
    ffi.Bool Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<ffi.Void>,
        ffi.Pointer<objc.ObjCObject>, ffi.Bool)>()
external bool _AuthenticationServicesMacOS_protocolTrampoline_9k4e9l(
  ffi.Pointer<objc.ObjCObject> target,
  ffi.Pointer<ffi.Void> arg0,
  ffi.Pointer<objc.ObjCObject> arg1,
  bool arg2,
);

@ffi.Native<
    instancetype Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<ffi.Void>,
        ffi.Pointer<objc.ObjCObject>)>()
external instancetype _AuthenticationServicesMacOS_protocolTrampoline_xr62hr(
  ffi.Pointer<objc.ObjCObject> target,
  ffi.Pointer<ffi.Void> arg0,
  ffi.Pointer<objc.ObjCObject> arg1,
);

@ffi.Native<
    ffi.Pointer<objc.ObjCObject> Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<ffi.Void>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>)>()
external ffi.Pointer<objc.ObjCObject>
    _AuthenticationServicesMacOS_protocolTrampoline_zi5eed(
  ffi.Pointer<objc.ObjCObject> target,
  ffi.Pointer<ffi.Void> arg0,
  ffi.Pointer<objc.ObjCObject> arg1,
  ffi.Pointer<objc.ObjCObject> arg2,
);

@ffi.Native<
    ffi.Pointer<objc.ObjCBlockImpl> Function(
        ffi.Pointer<objc.ObjCBlockImpl>)>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
    _AuthenticationServicesMacOS_wrapListenerBlock_xtuoz7(
  ffi.Pointer<objc.ObjCBlockImpl> block,
);

@ffi.Native<
    ffi.Pointer<objc.ObjCBlockImpl> Function(
        ffi.Pointer<objc.ObjCBlockImpl>,
        ffi.Pointer<objc.ObjCBlockImpl>,
        ffi.Pointer<objc.DOBJC_Context>)>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
    _AuthenticationServicesMacOS_wrapBlockingBlock_xtuoz7(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
  ffi.Pointer<objc.DOBJC_Context> context,
);

@ffi.Native<
    ffi.Bool Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<ffi.Void>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCBlockImpl>)>()
external bool _AuthenticationServicesMacOS_protocolTrampoline_rptcvw(
  ffi.Pointer<objc.ObjCObject> target,
  ffi.Pointer<ffi.Void> arg0,
  ffi.Pointer<objc.ObjCObject> arg1,
  ffi.Pointer<objc.ObjCObject> arg2,
  ffi.Pointer<objc.ObjCBlockImpl> arg3,
);

@ffi.Native<
    ffi.Pointer<objc.ObjCBlockImpl> Function(
        ffi.Pointer<objc.ObjCBlockImpl>)>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
    _AuthenticationServicesMacOS_wrapListenerBlock_1tz5yf(
  ffi.Pointer<objc.ObjCBlockImpl> block,
);

@ffi.Native<
    ffi.Pointer<objc.ObjCBlockImpl> Function(
        ffi.Pointer<objc.ObjCBlockImpl>,
        ffi.Pointer<objc.ObjCBlockImpl>,
        ffi.Pointer<objc.DOBJC_Context>)>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
    _AuthenticationServicesMacOS_wrapBlockingBlock_1tz5yf(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
  ffi.Pointer<objc.DOBJC_Context> context,
);

@ffi.Native<
    ffi.Void Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<ffi.Void>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>)>()
external void _AuthenticationServicesMacOS_protocolTrampoline_1tz5yf(
  ffi.Pointer<objc.ObjCObject> target,
  ffi.Pointer<ffi.Void> arg0,
  ffi.Pointer<objc.ObjCObject> arg1,
  ffi.Pointer<objc.ObjCObject> arg2,
  ffi.Pointer<objc.ObjCObject> arg3,
);

@ffi.Native<
    ffi.UnsignedLong Function(ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>()
external int _AuthenticationServicesMacOS_protocolTrampoline_u1rw1h(
  ffi.Pointer<objc.ObjCObject> target,
  ffi.Pointer<ffi.Void> arg0,
  ffi.Pointer<objc.ObjCObject> arg1,
);

@ffi.Native<
    ffi.Bool Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<ffi.Void>)>()
external bool _AuthenticationServicesMacOS_protocolTrampoline_e3qsqz(
  ffi.Pointer<objc.ObjCObject> target,
  ffi.Pointer<ffi.Void> arg0,
);

@ffi.Native<
    ffi.Pointer<objc.ObjCBlockImpl> Function(
        ffi.Pointer<objc.ObjCBlockImpl>)>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
    _AuthenticationServicesMacOS_wrapListenerBlock_pfv6jd(
  ffi.Pointer<objc.ObjCBlockImpl> block,
);

@ffi.Native<
    ffi.Pointer<objc.ObjCBlockImpl> Function(
        ffi.Pointer<objc.ObjCBlockImpl>,
        ffi.Pointer<objc.ObjCBlockImpl>,
        ffi.Pointer<objc.DOBJC_Context>)>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
    _AuthenticationServicesMacOS_wrapBlockingBlock_pfv6jd(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
  ffi.Pointer<objc.DOBJC_Context> context,
);

late final _class_NSProcessInfo = objc.getClass("NSProcessInfo");
late final _sel_isKindOfClass_ = objc.registerName("isKindOfClass:");
final _objc_msgSend_19nvye5 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Bool Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        bool Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<objc.ObjCObject>)>();

/// The system has heuristics to improve battery life, performance, and responsiveness of applications for the benefit of the user. This API can be used to give hints to the system that your application has special requirements. In response to creating one of these activities, the system will disable some or all of the heuristics so your application can finish quickly while still providing responsive behavior if the user needs it.
///
/// These activities can be used when your application is performing a long-running operation. If the activity can take different amounts of time (for example, calculating the next move in a chess game), it should use this API. This will ensure correct behavior when the amount of data or the capabilities of the user's computer varies. You should put your activity into one of two major categories:
///
/// User initiated: These are finite length activities that the user has explicitly started. Examples include exporting or downloading a user specified file.
///
/// Background: These are finite length activities that are part of the normal operation of your application but are not explicitly started by the user. Examples include autosaving, indexing, and automatic downloading of files.
///
/// In addition, if your application requires high priority IO, you can include the 'NSActivityLatencyCritical' flag (using a bitwise or). This should be reserved for activities like audio or video recording.
///
/// If your activity takes place synchronously inside an event callback on the main thread, you do not need to use this API.
///
/// Be aware that failing to end these activities for an extended period of time can have significant negative impacts to the performance of your user's computer, so be sure to use only the minimum amount of time required. User preferences may override your application’s request.
///
/// This API can also be used to control auto termination or sudden termination.
///
/// id activity = [NSProcessInfo.processInfo beginActivityWithOptions:NSActivityAutomaticTerminationDisabled reason:@"Good Reason"];
/// // work
/// [NSProcessInfo.processInfo endActivity:activity];
///
/// is equivalent to:
///
/// [NSProcessInfo.processInfo disableAutomaticTermination:@"Good Reason"];
/// // work
/// [NSProcessInfo.processInfo enableAutomaticTermination:@"Good Reason"]
///
/// Since this API returns an object, it may be easier to pair begins and ends. If the object is deallocated before the -endActivity: call, the activity will be automatically ended.
///
/// This API also provides a mechanism to disable system-wide idle sleep and display idle sleep. These can have a large impact on the user experience, so be sure not to forget to end activities that disable sleep (including NSActivityUserInitiated).
enum NSActivityOptions {
  /// Used for activities that require the screen to stay powered on.
  NSActivityIdleDisplaySleepDisabled(1099511627776),

  /// Used for activities that require the computer to not idle sleep. This is included in NSActivityUserInitiated.
  NSActivityIdleSystemSleepDisabled(1048576),

  /// Prevents sudden termination. This is included in NSActivityUserInitiated.
  NSActivitySuddenTerminationDisabled(16384),

  /// Prevents automatic termination. This is included in NSActivityUserInitiated.
  NSActivityAutomaticTerminationDisabled(32768),

  /// Emits an os_signpost begin and end during the activity lifetime, intended to be used to track animation activity
  NSActivityAnimationTrackingEnabled(35184372088832),

  /// Emits an os_signpost begin and end during the activity lifetime, intended to be used to track general activity
  NSActivityTrackingEnabled(70368744177664),

  /// App is performing a user-requested action.
  NSActivityUserInitiated(16777215),
  NSActivityUserInitiatedAllowingIdleSystemSleep(15728639),

  /// App has initiated some kind of work, but not as the direct result of user request.
  NSActivityBackground(255),

  /// Used for activities that require the highest amount of timer and I/O precision available. Very few applications should need to use this constant.
  NSActivityLatencyCritical(1095216660480),
  NSActivityUserInteractive(1095233437695);

  final int value;
  const NSActivityOptions(this.value);

  static NSActivityOptions fromValue(int value) => switch (value) {
        1099511627776 => NSActivityIdleDisplaySleepDisabled,
        1048576 => NSActivityIdleSystemSleepDisabled,
        16384 => NSActivitySuddenTerminationDisabled,
        32768 => NSActivityAutomaticTerminationDisabled,
        35184372088832 => NSActivityAnimationTrackingEnabled,
        70368744177664 => NSActivityTrackingEnabled,
        16777215 => NSActivityUserInitiated,
        15728639 => NSActivityUserInitiatedAllowingIdleSystemSleep,
        255 => NSActivityBackground,
        1095216660480 => NSActivityLatencyCritical,
        1095233437695 => NSActivityUserInteractive,
        _ => throw ArgumentError('Unknown value for NSActivityOptions: $value'),
      };
}

late final _sel_beginActivityWithOptions_reason_ =
    objc.registerName("beginActivityWithOptions:reason:");
final _objc_msgSend_u2drt1 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Uint64,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            int,
            ffi.Pointer<objc.ObjCObject>)>();
late final _sel_endActivity_ = objc.registerName("endActivity:");
final _objc_msgSend_xtuoz7 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<objc.ObjCObject>)>();
void _ObjCBlock_ffiVoid_fnPtrTrampoline(
  ffi.Pointer<objc.ObjCBlockImpl> block,
) =>
    block.ref.target
        .cast<ffi.NativeFunction<ffi.Void Function()>>()
        .asFunction<void Function()>()();
ffi.Pointer<ffi.Void> _ObjCBlock_ffiVoid_fnPtrCallable = ffi.Pointer
        .fromFunction<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>)>(
            _ObjCBlock_ffiVoid_fnPtrTrampoline)
    .cast();
void _ObjCBlock_ffiVoid_closureTrampoline(
  ffi.Pointer<objc.ObjCBlockImpl> block,
) =>
    (objc.getBlockClosure(block) as void Function())();
ffi.Pointer<ffi.Void> _ObjCBlock_ffiVoid_closureCallable = ffi.Pointer
        .fromFunction<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>)>(
            _ObjCBlock_ffiVoid_closureTrampoline)
    .cast();
void _ObjCBlock_ffiVoid_listenerTrampoline(
  ffi.Pointer<objc.ObjCBlockImpl> block,
) {
  (objc.getBlockClosure(block) as void Function())();
  objc.objectRelease(block.cast());
}

ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>)>
    _ObjCBlock_ffiVoid_listenerCallable = ffi.NativeCallable<
            ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>)>.listener(
        _ObjCBlock_ffiVoid_listenerTrampoline)
      ..keepIsolateAlive = false;
void _ObjCBlock_ffiVoid_blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> waiter) {
  try {
    (objc.getBlockClosure(block) as void Function())();
  } catch (e) {
  } finally {
    objc.signalWaiter(waiter);
    objc.objectRelease(block.cast());
  }
}

ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>
    _ObjCBlock_ffiVoid_blockingCallable = ffi.NativeCallable<
            ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>)>.isolateLocal(
        _ObjCBlock_ffiVoid_blockingTrampoline)
      ..keepIsolateAlive = false;
ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>
    _ObjCBlock_ffiVoid_blockingListenerCallable = ffi.NativeCallable<
            ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>)>.listener(
        _ObjCBlock_ffiVoid_blockingTrampoline)
      ..keepIsolateAlive = false;

/// Construction methods for `objc.ObjCBlock<ffi.Void Function()>`.
abstract final class ObjCBlock_ffiVoid {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function()> castFromPointer(
          ffi.Pointer<objc.ObjCBlockImpl> pointer,
          {bool retain = false,
          bool release = false}) =>
      objc.ObjCBlock<ffi.Void Function()>(pointer,
          retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function()> fromFunctionPointer(
          ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> ptr) =>
      objc.ObjCBlock<ffi.Void Function()>(
          objc.newPointerBlock(_ObjCBlock_ffiVoid_fnPtrCallable, ptr.cast()),
          retain: false,
          release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function()> fromFunction(void Function() fn,
          {bool keepIsolateAlive = true}) =>
      objc.ObjCBlock<ffi.Void Function()>(
          objc.newClosureBlock(
              _ObjCBlock_ffiVoid_closureCallable, () => fn(), keepIsolateAlive),
          retain: false,
          release: true);

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function()> listener(void Function() fn,
      {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_listenerCallable.nativeFunction.cast(),
        () => fn(),
        keepIsolateAlive);
    final wrapper = _AuthenticationServicesMacOS_wrapListenerBlock_1pl9qdv(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<ffi.Void Function()>(wrapper,
        retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function()> blocking(void Function() fn,
      {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_blockingCallable.nativeFunction.cast(),
        () => fn(),
        keepIsolateAlive);
    final rawListener = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_blockingListenerCallable.nativeFunction.cast(),
        () => fn(),
        keepIsolateAlive);
    final wrapper = _AuthenticationServicesMacOS_wrapBlockingBlock_1pl9qdv(
        raw, rawListener, objc.objCContext);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<ffi.Void Function()>(wrapper,
        retain: false, release: true);
  }
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function()>`.
extension ObjCBlock_ffiVoid_CallExtension
    on objc.ObjCBlock<ffi.Void Function()> {
  void call() => ref.pointer.ref.invoke
          .cast<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> block)>>()
          .asFunction<void Function(ffi.Pointer<objc.ObjCBlockImpl>)>()(
        ref.pointer,
      );
}

late final _sel_performActivityWithOptions_reason_usingBlock_ =
    objc.registerName("performActivityWithOptions:reason:usingBlock:");
final _objc_msgSend_1jz97e = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Uint64,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCBlockImpl>)>>()
    .asFunction<
        void Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            int,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCBlockImpl>)>();

/// NSProcessInfoActivity
extension NSProcessInfoActivity on NSProcessInfo {
  /// Pass in an activity to this API, and a non-NULL, non-empty reason string. Indicate completion of the activity by calling the corresponding endActivity: method with the result of the beginActivityWithOptions:reason: method. The reason string is used for debugging.
  objc.NSObjectProtocol beginActivityWithOptions_reason_(
      NSActivityOptions options, objc.NSString reason) {
    objc.checkOsVersionInternal(
        'NSProcessInfo.beginActivityWithOptions:reason:',
        iOS: (false, (7, 0, 0)),
        macOS: (false, (10, 9, 0)));
    final _ret = _objc_msgSend_u2drt1(
        this.ref.pointer,
        _sel_beginActivityWithOptions_reason_,
        options.value,
        reason.ref.pointer);
    return objc.NSObjectProtocol.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// The argument to this method is the result of beginActivityWithOptions:reason:.
  void endActivity_(objc.NSObjectProtocol activity) {
    objc.checkOsVersionInternal('NSProcessInfo.endActivity:',
        iOS: (false, (7, 0, 0)), macOS: (false, (10, 9, 0)));
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_endActivity_, activity.ref.pointer);
  }

  /// Synchronously perform an activity. The activity will be automatically ended after your block argument returns. The reason string is used for debugging.
  void performActivityWithOptions_reason_usingBlock_(NSActivityOptions options,
      objc.NSString reason, objc.ObjCBlock<ffi.Void Function()> block) {
    objc.checkOsVersionInternal(
        'NSProcessInfo.performActivityWithOptions:reason:usingBlock:',
        iOS: (false, (7, 0, 0)),
        macOS: (false, (10, 9, 0)));
    _objc_msgSend_1jz97e(
        this.ref.pointer,
        _sel_performActivityWithOptions_reason_usingBlock_,
        options.value,
        reason.ref.pointer,
        block.ref.pointer);
  }
}

late final _sel_userName = objc.registerName("userName");
final _objc_msgSend_151sglz = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_fullUserName = objc.registerName("fullUserName");

/// NSUserInformation
extension NSUserInformation on NSProcessInfo {
  /// userName
  objc.NSString get userName {
    objc.checkOsVersionInternal('NSProcessInfo.userName',
        iOS: (true, null), macOS: (false, (10, 12, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_userName);
    return objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// fullUserName
  objc.NSString get fullUserName {
    objc.checkOsVersionInternal('NSProcessInfo.fullUserName',
        iOS: (true, null), macOS: (false, (10, 12, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_fullUserName);
    return objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }
}

/// Describes the current thermal state of the system.
enum NSProcessInfoThermalState {
  /// No corrective action is needed.
  NSProcessInfoThermalStateNominal(0),

  /// The system has reached a state where fans may become audible (on systems which have fans). Recommendation: Defer non-user-visible activity.
  NSProcessInfoThermalStateFair(1),

  /// Fans are running at maximum speed (on systems which have fans), system performance may be impacted. Recommendation: reduce application's usage of CPU, GPU and I/O, if possible. Switch to lower quality visual effects, reduce frame rates.
  NSProcessInfoThermalStateSerious(2),

  /// System performance is significantly impacted and the system needs to cool down. Recommendation: reduce application's usage of CPU, GPU, and I/O to the minimum level needed to respond to user actions. Consider stopping use of camera and other peripherals if your application is using them.
  NSProcessInfoThermalStateCritical(3);

  final int value;
  const NSProcessInfoThermalState(this.value);

  static NSProcessInfoThermalState fromValue(int value) => switch (value) {
        0 => NSProcessInfoThermalStateNominal,
        1 => NSProcessInfoThermalStateFair,
        2 => NSProcessInfoThermalStateSerious,
        3 => NSProcessInfoThermalStateCritical,
        _ => throw ArgumentError(
            'Unknown value for NSProcessInfoThermalState: $value'),
      };
}

late final _sel_thermalState = objc.registerName("thermalState");
final _objc_msgSend_1fnsr6j = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Long Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        int Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();

/// NSProcessInfoThermalState
extension NSProcessInfoThermalState$1 on NSProcessInfo {
  /// Retrieve the current thermal state of the system. On systems where thermal state is unknown or unsupported, the value returned from the thermalState property is always NSProcessInfoThermalStateNominal.
  NSProcessInfoThermalState get thermalState {
    objc.checkOsVersionInternal('NSProcessInfo.thermalState',
        iOS: (false, (11, 0, 0)), macOS: (false, (10, 10, 3)));
    final _ret = _objc_msgSend_1fnsr6j(this.ref.pointer, _sel_thermalState);
    return NSProcessInfoThermalState.fromValue(_ret);
  }
}

late final _sel_isLowPowerModeEnabled =
    objc.registerName("isLowPowerModeEnabled");
final _objc_msgSend_91o635 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Bool Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        bool Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();

/// NSProcessInfoPowerState
extension NSProcessInfoPowerState on NSProcessInfo {
  /// Retrieve the current setting of the system for the low power mode setting. On systems where the low power mode is unknown or unsupported, the value returned from the lowPowerModeEnabled property is always NO
  bool get lowPowerModeEnabled {
    objc.checkOsVersionInternal('NSProcessInfo.isLowPowerModeEnabled',
        iOS: (false, (9, 0, 0)), macOS: (false, (12, 0, 0)));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_isLowPowerModeEnabled);
  }
}

late final _sel_isMacCatalystApp = objc.registerName("isMacCatalystApp");
late final _sel_isiOSAppOnMac = objc.registerName("isiOSAppOnMac");

/// NSProcessInfoPlatform
extension NSProcessInfoPlatform on NSProcessInfo {
  /// isMacCatalystApp
  bool get macCatalystApp {
    objc.checkOsVersionInternal('NSProcessInfo.isMacCatalystApp',
        iOS: (false, (13, 0, 0)), macOS: (false, (10, 15, 0)));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_isMacCatalystApp);
  }

  /// isiOSAppOnMac
  bool get iOSAppOnMac {
    objc.checkOsVersionInternal('NSProcessInfo.isiOSAppOnMac',
        iOS: (false, (14, 0, 0)), macOS: (false, (11, 0, 0)));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_isiOSAppOnMac);
  }
}

late final _sel_processInfo = objc.registerName("processInfo");
late final _sel_operatingSystemVersionString =
    objc.registerName("operatingSystemVersionString");

/// NSProcessInfo
class NSProcessInfo extends objc.NSObject {
  NSProcessInfo._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release);

  /// Constructs a [NSProcessInfo] that points to the same underlying object as [other].
  NSProcessInfo.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [NSProcessInfo] that wraps the given raw object pointer.
  NSProcessInfo.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [NSProcessInfo].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(
        obj.ref.pointer, _sel_isKindOfClass_, _class_NSProcessInfo);
  }

  /// processInfo
  static NSProcessInfo getProcessInfo() {
    final _ret = _objc_msgSend_151sglz(_class_NSProcessInfo, _sel_processInfo);
    return NSProcessInfo.castFromPointer(_ret, retain: true, release: true);
  }

  /// Human readable, localized; appropriate for displaying to user or using in bug emails and such; NOT appropriate for parsing
  objc.NSString get operatingSystemVersionString {
    final _ret = _objc_msgSend_151sglz(
        this.ref.pointer, _sel_operatingSystemVersionString);
    return objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }
}

late final _class_NSResponder = objc.getClass("NSResponder");

/// NSResponder
class NSResponder extends objc.NSObject implements objc.NSCoding {
  NSResponder._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release) {
    objc.checkOsVersionInternal('NSResponder', iOS: (true, null));
  }

  /// Constructs a [NSResponder] that points to the same underlying object as [other].
  NSResponder.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [NSResponder] that wraps the given raw object pointer.
  NSResponder.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [NSResponder].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(
        obj.ref.pointer, _sel_isKindOfClass_, _class_NSResponder);
  }
}

late final _class_NSApplication = objc.getClass("NSApplication");

/// WARNING: NSUserInterfaceValidations is a stub. To generate bindings for this class, include
/// NSUserInterfaceValidations in your config's objc-protocols list.
///
/// NSUserInterfaceValidations
interface class NSUserInterfaceValidations extends objc.ObjCProtocolBase {
  NSUserInterfaceValidations._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super(pointer, retain: retain, release: release);

  /// Constructs a [NSUserInterfaceValidations] that points to the same underlying object as [other].
  NSUserInterfaceValidations.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [NSUserInterfaceValidations] that wraps the given raw object pointer.
  NSUserInterfaceValidations.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);
}

/// WARNING: NSMenuItemValidation is a stub. To generate bindings for this class, include
/// NSMenuItemValidation in your config's objc-protocols list.
///
/// NSMenuItemValidation
interface class NSMenuItemValidation extends objc.ObjCProtocolBase
    implements objc.NSObjectProtocol {
  NSMenuItemValidation._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super(pointer, retain: retain, release: release);

  /// Constructs a [NSMenuItemValidation] that points to the same underlying object as [other].
  NSMenuItemValidation.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [NSMenuItemValidation] that wraps the given raw object pointer.
  NSMenuItemValidation.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);
}

/// WARNING: NSAccessibilityElement is a stub. To generate bindings for this class, include
/// NSAccessibilityElement in your config's objc-protocols list.
///
/// NSAccessibilityElement
interface class NSAccessibilityElement extends objc.ObjCProtocolBase
    implements objc.NSObjectProtocol {
  NSAccessibilityElement._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super(pointer, retain: retain, release: release);

  /// Constructs a [NSAccessibilityElement] that points to the same underlying object as [other].
  NSAccessibilityElement.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [NSAccessibilityElement] that wraps the given raw object pointer.
  NSAccessibilityElement.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);
}

/// WARNING: NSAccessibility is a stub. To generate bindings for this class, include
/// NSAccessibility in your config's objc-protocols list.
///
/// NSAccessibility
interface class NSAccessibility extends objc.ObjCProtocolBase
    implements objc.NSObjectProtocol {
  NSAccessibility._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super(pointer, retain: retain, release: release);

  /// Constructs a [NSAccessibility] that points to the same underlying object as [other].
  NSAccessibility.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [NSAccessibility] that wraps the given raw object pointer.
  NSAccessibility.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);
}

/// WARNING: NSAppearanceCustomization is a stub. To generate bindings for this class, include
/// NSAppearanceCustomization in your config's objc-protocols list.
///
/// NSAppearanceCustomization
interface class NSAppearanceCustomization extends objc.ObjCProtocolBase
    implements objc.NSObjectProtocol {
  NSAppearanceCustomization._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super(pointer, retain: retain, release: release);

  /// Constructs a [NSAppearanceCustomization] that points to the same underlying object as [other].
  NSAppearanceCustomization.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [NSAppearanceCustomization] that wraps the given raw object pointer.
  NSAppearanceCustomization.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);
}

/// WARNING: NSAppearance is a stub. To generate bindings for this class, include
/// NSAppearance in your config's objc-interfaces list.
///
/// NSAppearance
class NSAppearance extends objc.NSObject implements objc.NSSecureCoding {
  NSAppearance._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release) {
    objc.checkOsVersionInternal('NSAppearance',
        iOS: (true, null), macOS: (false, (10, 9, 0)));
  }

  /// Constructs a [NSAppearance] that points to the same underlying object as [other].
  NSAppearance.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [NSAppearance] that wraps the given raw object pointer.
  NSAppearance.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);
}

late final _sel_appearance = objc.registerName("appearance");
ffi.Pointer<objc.ObjCObject> _ObjCBlock_NSAppearance_ffiVoid_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0) =>
    block.ref.target
        .cast<
            ffi.NativeFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<ffi.Void> arg0)>>()
        .asFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<ffi.Void>)>()(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_NSAppearance_ffiVoid_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>(
            _ObjCBlock_NSAppearance_ffiVoid_fnPtrTrampoline)
        .cast();
ffi.Pointer<objc.ObjCObject> _ObjCBlock_NSAppearance_ffiVoid_closureTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0) =>
    (objc.getBlockClosure(block) as ffi.Pointer<objc.ObjCObject> Function(
        ffi.Pointer<ffi.Void>))(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_NSAppearance_ffiVoid_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>(
            _ObjCBlock_NSAppearance_ffiVoid_closureTrampoline)
        .cast();

/// Construction methods for `objc.ObjCBlock<NSAppearance? Function(ffi.Pointer<ffi.Void>)>`.
abstract final class ObjCBlock_NSAppearance_ffiVoid {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<NSAppearance? Function(ffi.Pointer<ffi.Void>)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<NSAppearance? Function(ffi.Pointer<ffi.Void>)>(pointer,
              retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<NSAppearance? Function(ffi.Pointer<ffi.Void>)> fromFunctionPointer(
          ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Pointer<objc.ObjCObject> Function(
                          ffi.Pointer<ffi.Void> arg0)>>
              ptr) =>
      objc.ObjCBlock<NSAppearance? Function(ffi.Pointer<ffi.Void>)>(
          objc.newPointerBlock(
              _ObjCBlock_NSAppearance_ffiVoid_fnPtrCallable, ptr.cast()),
          retain: false,
          release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<NSAppearance? Function(ffi.Pointer<ffi.Void>)>
      fromFunction(NSAppearance? Function(ffi.Pointer<ffi.Void>) fn,
              {bool keepIsolateAlive = true}) =>
          objc.ObjCBlock<NSAppearance? Function(ffi.Pointer<ffi.Void>)>(
              objc.newClosureBlock(
                  _ObjCBlock_NSAppearance_ffiVoid_closureCallable,
                  (ffi.Pointer<ffi.Void> arg0) =>
                      fn(arg0)?.ref.retainAndAutorelease() ?? ffi.nullptr,
                  keepIsolateAlive),
              retain: false,
              release: true);
}

/// Call operator for `objc.ObjCBlock<NSAppearance? Function(ffi.Pointer<ffi.Void>)>`.
extension ObjCBlock_NSAppearance_ffiVoid_CallExtension
    on objc.ObjCBlock<NSAppearance? Function(ffi.Pointer<ffi.Void>)> {
  NSAppearance? call(ffi.Pointer<ffi.Void> arg0) => ref.pointer.ref.invoke
              .cast<
                  ffi.NativeFunction<
                      ffi.Pointer<objc.ObjCObject> Function(
                          ffi.Pointer<objc.ObjCBlockImpl> block,
                          ffi.Pointer<ffi.Void> arg0)>>()
              .asFunction<
                  ffi.Pointer<objc.ObjCObject> Function(
                      ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>()
              (ref.pointer, arg0)
              .address ==
          0
      ? null
      : NSAppearance.castFromPointer(
          ref.pointer.ref.invoke
              .cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0)>>()
              .asFunction<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>()(ref.pointer, arg0),
          retain: true,
          release: true);
}

late final _sel_setAppearance_ = objc.registerName("setAppearance:");
void _ObjCBlock_ffiVoid_ffiVoid_NSAppearance_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1) =>
    block.ref.target
        .cast<
            ffi.NativeFunction<
                ffi.Void Function(ffi.Pointer<ffi.Void> arg0,
                    ffi.Pointer<objc.ObjCObject> arg1)>>()
        .asFunction<
            void Function(ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>)>()(arg0, arg1);
ffi.Pointer<ffi.Void> _ObjCBlock_ffiVoid_ffiVoid_NSAppearance_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_ffiVoid_ffiVoid_NSAppearance_fnPtrTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_ffiVoid_NSAppearance_closureTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1) =>
    (objc.getBlockClosure(block) as void Function(
        ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>))(arg0, arg1);
ffi.Pointer<ffi.Void> _ObjCBlock_ffiVoid_ffiVoid_NSAppearance_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_ffiVoid_ffiVoid_NSAppearance_closureTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_ffiVoid_NSAppearance_listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObject> arg1) {
  (objc.getBlockClosure(block) as void Function(
      ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>))(arg0, arg1);
  objc.objectRelease(block.cast());
}

ffi.NativeCallable<
        ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_ffiVoid_NSAppearance_listenerCallable = ffi
        .NativeCallable<
            ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>.listener(
        _ObjCBlock_ffiVoid_ffiVoid_NSAppearance_listenerTrampoline)
      ..keepIsolateAlive = false;
void _ObjCBlock_ffiVoid_ffiVoid_NSAppearance_blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObject> arg1) {
  try {
    (objc.getBlockClosure(block) as void Function(
        ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>))(arg0, arg1);
  } catch (e) {
  } finally {
    objc.signalWaiter(waiter);
    objc.objectRelease(block.cast());
  }
}

ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_ffiVoid_NSAppearance_blockingCallable = ffi
        .NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>)>.isolateLocal(
        _ObjCBlock_ffiVoid_ffiVoid_NSAppearance_blockingTrampoline)
      ..keepIsolateAlive = false;
ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_ffiVoid_NSAppearance_blockingListenerCallable = ffi
        .NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>)>.listener(
        _ObjCBlock_ffiVoid_ffiVoid_NSAppearance_blockingTrampoline)
      ..keepIsolateAlive = false;

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSAppearance?)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_NSAppearance {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSAppearance?)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  NSAppearance?)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSAppearance?)>
      fromFunctionPointer(
              ffi.Pointer<
                      ffi.NativeFunction<
                          ffi.Void Function(ffi.Pointer<ffi.Void> arg0,
                              ffi.Pointer<objc.ObjCObject> arg1)>>
                  ptr) =>
          objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSAppearance?)>(
              objc.newPointerBlock(_ObjCBlock_ffiVoid_ffiVoid_NSAppearance_fnPtrCallable, ptr.cast()),
              retain: false,
              release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSAppearance?)> fromFunction(
          void Function(ffi.Pointer<ffi.Void>, NSAppearance?) fn,
          {bool keepIsolateAlive = true}) =>
      objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSAppearance?)>(
          objc.newClosureBlock(
              _ObjCBlock_ffiVoid_ffiVoid_NSAppearance_closureCallable,
              (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1) => fn(
                  arg0,
                  arg1.address == 0
                      ? null
                      : NSAppearance.castFromPointer(arg1, retain: true, release: true)),
              keepIsolateAlive),
          retain: false,
          release: true);

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSAppearance?)>
      listener(void Function(ffi.Pointer<ffi.Void>, NSAppearance?) fn,
          {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_NSAppearance_listenerCallable.nativeFunction
            .cast(),
        (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1) => fn(
            arg0,
            arg1.address == 0
                ? null
                : NSAppearance.castFromPointer(arg1,
                    retain: false, release: true)),
        keepIsolateAlive);
    final wrapper = _AuthenticationServicesMacOS_wrapListenerBlock_18v1jvf(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
            ffi.Void Function(ffi.Pointer<ffi.Void>, NSAppearance?)>(wrapper,
        retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSAppearance?)>
      blocking(void Function(ffi.Pointer<ffi.Void>, NSAppearance?) fn,
          {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_NSAppearance_blockingCallable.nativeFunction
            .cast(),
        (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1) => fn(
            arg0,
            arg1.address == 0
                ? null
                : NSAppearance.castFromPointer(arg1,
                    retain: false, release: true)),
        keepIsolateAlive);
    final rawListener = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_NSAppearance_blockingListenerCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1) => fn(
            arg0,
            arg1.address == 0
                ? null
                : NSAppearance.castFromPointer(arg1,
                    retain: false, release: true)),
        keepIsolateAlive);
    final wrapper = _AuthenticationServicesMacOS_wrapBlockingBlock_18v1jvf(
        raw, rawListener, objc.objCContext);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
            ffi.Void Function(ffi.Pointer<ffi.Void>, NSAppearance?)>(wrapper,
        retain: false, release: true);
  }
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSAppearance?)>`.
extension ObjCBlock_ffiVoid_ffiVoid_NSAppearance_CallExtension
    on objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSAppearance?)> {
  void call(ffi.Pointer<ffi.Void> arg0, NSAppearance? arg1) =>
      ref.pointer.ref.invoke
              .cast<
                  ffi.NativeFunction<
                      ffi.Void Function(
                          ffi.Pointer<objc.ObjCBlockImpl> block,
                          ffi.Pointer<ffi.Void> arg0,
                          ffi.Pointer<objc.ObjCObject> arg1)>>()
              .asFunction<
                  void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>()(
          ref.pointer, arg0, arg1?.ref.pointer ?? ffi.nullptr);
}

late final _sel_effectiveAppearance = objc.registerName("effectiveAppearance");
ffi.Pointer<objc.ObjCObject> _ObjCBlock_NSAppearance_ffiVoid$1_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0) =>
    block.ref.target
        .cast<
            ffi.NativeFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<ffi.Void> arg0)>>()
        .asFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<ffi.Void>)>()(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_NSAppearance_ffiVoid$1_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>(
            _ObjCBlock_NSAppearance_ffiVoid$1_fnPtrTrampoline)
        .cast();
ffi.Pointer<objc.ObjCObject>
    _ObjCBlock_NSAppearance_ffiVoid$1_closureTrampoline(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0) =>
        (objc.getBlockClosure(block) as ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<ffi.Void>))(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_NSAppearance_ffiVoid$1_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>(
            _ObjCBlock_NSAppearance_ffiVoid$1_closureTrampoline)
        .cast();

/// Construction methods for `objc.ObjCBlock<NSAppearance Function(ffi.Pointer<ffi.Void>)>`.
abstract final class ObjCBlock_NSAppearance_ffiVoid$1 {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<NSAppearance Function(ffi.Pointer<ffi.Void>)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<NSAppearance Function(ffi.Pointer<ffi.Void>)>(pointer,
              retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<NSAppearance Function(ffi.Pointer<ffi.Void>)> fromFunctionPointer(
          ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Pointer<objc.ObjCObject> Function(
                          ffi.Pointer<ffi.Void> arg0)>>
              ptr) =>
      objc.ObjCBlock<NSAppearance Function(ffi.Pointer<ffi.Void>)>(
          objc.newPointerBlock(
              _ObjCBlock_NSAppearance_ffiVoid$1_fnPtrCallable, ptr.cast()),
          retain: false,
          release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<NSAppearance Function(ffi.Pointer<ffi.Void>)>
      fromFunction(NSAppearance Function(ffi.Pointer<ffi.Void>) fn,
              {bool keepIsolateAlive = true}) =>
          objc.ObjCBlock<NSAppearance Function(ffi.Pointer<ffi.Void>)>(
              objc.newClosureBlock(
                  _ObjCBlock_NSAppearance_ffiVoid$1_closureCallable,
                  (ffi.Pointer<ffi.Void> arg0) =>
                      fn(arg0).ref.retainAndAutorelease(),
                  keepIsolateAlive),
              retain: false,
              release: true);
}

/// Call operator for `objc.ObjCBlock<NSAppearance Function(ffi.Pointer<ffi.Void>)>`.
extension ObjCBlock_NSAppearance_ffiVoid$1_CallExtension
    on objc.ObjCBlock<NSAppearance Function(ffi.Pointer<ffi.Void>)> {
  NSAppearance call(ffi.Pointer<ffi.Void> arg0) => NSAppearance.castFromPointer(
      ref.pointer.ref.invoke
          .cast<
              ffi.NativeFunction<
                  ffi.Pointer<objc.ObjCObject> Function(
                      ffi.Pointer<objc.ObjCBlockImpl> block,
                      ffi.Pointer<ffi.Void> arg0)>>()
          .asFunction<
              ffi.Pointer<objc.ObjCObject> Function(
                  ffi.Pointer<objc.ObjCBlockImpl>,
                  ffi.Pointer<ffi.Void>)>()(ref.pointer, arg0),
      retain: true,
      release: true);
}

/// NSAppearanceCustomization
extension NSAppearanceCustomization$1 on NSApplication {
  /// appearance
  NSAppearance? get appearance {
    objc.checkOsVersionInternal('NSApplication.appearance',
        iOS: (true, null), macOS: (false, (10, 9, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_appearance);
    return _ret.address == 0
        ? null
        : NSAppearance.castFromPointer(_ret, retain: true, release: true);
  }

  /// setAppearance:
  set appearance(NSAppearance? value) {
    objc.checkOsVersionInternal('NSApplication.setAppearance:',
        iOS: (true, null), macOS: (false, (10, 9, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setAppearance_,
        value?.ref.pointer ?? ffi.nullptr);
  }

  /// effectiveAppearance
  NSAppearance get effectiveAppearance {
    objc.checkOsVersionInternal('NSApplication.effectiveAppearance',
        iOS: (true, null), macOS: (false, (10, 9, 0)));
    final _ret =
        _objc_msgSend_151sglz(this.ref.pointer, _sel_effectiveAppearance);
    return NSAppearance.castFromPointer(_ret, retain: true, release: true);
  }
}

/// WARNING: NSEvent is a stub. To generate bindings for this class, include
/// NSEvent in your config's objc-interfaces list.
///
/// NSEvent
class NSEvent extends objc.NSObject implements objc.NSCopying, objc.NSCoding {
  NSEvent._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release) {
    objc.checkOsVersionInternal('NSEvent', iOS: (true, null));
  }

  /// Constructs a [NSEvent] that points to the same underlying object as [other].
  NSEvent.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [NSEvent] that wraps the given raw object pointer.
  NSEvent.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);
}

late final _sel_sendEvent_ = objc.registerName("sendEvent:");
late final _sel_postEvent_atStart_ = objc.registerName("postEvent:atStart:");
final _objc_msgSend_6p7ndb = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Bool)>>()
    .asFunction<
        void Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            bool)>();
late final _sel_currentEvent = objc.registerName("currentEvent");

enum NSEventMask {
  NSEventMaskLeftMouseDown(2),
  NSEventMaskLeftMouseUp(4),
  NSEventMaskRightMouseDown(8),
  NSEventMaskRightMouseUp(16),
  NSEventMaskMouseMoved(32),
  NSEventMaskLeftMouseDragged(64),
  NSEventMaskRightMouseDragged(128),
  NSEventMaskMouseEntered(256),
  NSEventMaskMouseExited(512),
  NSEventMaskKeyDown(1024),
  NSEventMaskKeyUp(2048),
  NSEventMaskFlagsChanged(4096),
  NSEventMaskAppKitDefined(8192),
  NSEventMaskSystemDefined(16384),
  NSEventMaskApplicationDefined(32768),
  NSEventMaskPeriodic(65536),
  NSEventMaskCursorUpdate(131072),
  NSEventMaskScrollWheel(4194304),
  NSEventMaskTabletPoint(8388608),
  NSEventMaskTabletProximity(16777216),
  NSEventMaskOtherMouseDown(33554432),
  NSEventMaskOtherMouseUp(67108864),
  NSEventMaskOtherMouseDragged(134217728),
  NSEventMaskGesture(536870912),
  NSEventMaskMagnify(1073741824),
  NSEventMaskSwipe(2147483648),
  NSEventMaskRotate(262144),
  NSEventMaskBeginGesture(524288),
  NSEventMaskEndGesture(1048576),
  NSEventMaskSmartMagnify(4294967296),
  NSEventMaskPressure(17179869184),
  NSEventMaskDirectTouch(137438953472),
  NSEventMaskChangeMode(274877906944),
  NSEventMaskAny(-1);

  final int value;
  const NSEventMask(this.value);

  static NSEventMask fromValue(int value) => switch (value) {
        2 => NSEventMaskLeftMouseDown,
        4 => NSEventMaskLeftMouseUp,
        8 => NSEventMaskRightMouseDown,
        16 => NSEventMaskRightMouseUp,
        32 => NSEventMaskMouseMoved,
        64 => NSEventMaskLeftMouseDragged,
        128 => NSEventMaskRightMouseDragged,
        256 => NSEventMaskMouseEntered,
        512 => NSEventMaskMouseExited,
        1024 => NSEventMaskKeyDown,
        2048 => NSEventMaskKeyUp,
        4096 => NSEventMaskFlagsChanged,
        8192 => NSEventMaskAppKitDefined,
        16384 => NSEventMaskSystemDefined,
        32768 => NSEventMaskApplicationDefined,
        65536 => NSEventMaskPeriodic,
        131072 => NSEventMaskCursorUpdate,
        4194304 => NSEventMaskScrollWheel,
        8388608 => NSEventMaskTabletPoint,
        16777216 => NSEventMaskTabletProximity,
        33554432 => NSEventMaskOtherMouseDown,
        67108864 => NSEventMaskOtherMouseUp,
        134217728 => NSEventMaskOtherMouseDragged,
        536870912 => NSEventMaskGesture,
        1073741824 => NSEventMaskMagnify,
        2147483648 => NSEventMaskSwipe,
        262144 => NSEventMaskRotate,
        524288 => NSEventMaskBeginGesture,
        1048576 => NSEventMaskEndGesture,
        4294967296 => NSEventMaskSmartMagnify,
        17179869184 => NSEventMaskPressure,
        137438953472 => NSEventMaskDirectTouch,
        274877906944 => NSEventMaskChangeMode,
        -1 => NSEventMaskAny,
        _ => throw ArgumentError('Unknown value for NSEventMask: $value'),
      };
}

late final _sel_nextEventMatchingMask_untilDate_inMode_dequeue_ =
    objc.registerName("nextEventMatchingMask:untilDate:inMode:dequeue:");
final _objc_msgSend_qe9d8w = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.LongLong,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Bool)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            int,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            bool)>();
late final _sel_discardEventsMatchingMask_beforeEvent_ =
    objc.registerName("discardEventsMatchingMask:beforeEvent:");
final _objc_msgSend_58potu = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.LongLong,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        void Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            int,
            ffi.Pointer<objc.ObjCObject>)>();

/// NSEvent
extension NSEvent$1 on NSApplication {
  /// sendEvent:
  void sendEvent_(NSEvent event) {
    objc.checkOsVersionInternal('NSApplication.sendEvent:', iOS: (true, null));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_sendEvent_, event.ref.pointer);
  }

  /// postEvent:atStart:
  void postEvent_atStart_(NSEvent event, bool atStart) {
    objc.checkOsVersionInternal('NSApplication.postEvent:atStart:',
        iOS: (true, null));
    _objc_msgSend_6p7ndb(
        this.ref.pointer, _sel_postEvent_atStart_, event.ref.pointer, atStart);
  }

  /// currentEvent
  NSEvent? get currentEvent {
    objc.checkOsVersionInternal('NSApplication.currentEvent',
        iOS: (true, null));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_currentEvent);
    return _ret.address == 0
        ? null
        : NSEvent.castFromPointer(_ret, retain: true, release: true);
  }

  /// nextEventMatchingMask:untilDate:inMode:dequeue:
  NSEvent? nextEventMatchingMask_untilDate_inMode_dequeue_(NSEventMask mask,
      objc.NSDate? expiration, objc.NSString mode, bool deqFlag) {
    objc.checkOsVersionInternal(
        'NSApplication.nextEventMatchingMask:untilDate:inMode:dequeue:',
        iOS: (true, null));
    final _ret = _objc_msgSend_qe9d8w(
        this.ref.pointer,
        _sel_nextEventMatchingMask_untilDate_inMode_dequeue_,
        mask.value,
        expiration?.ref.pointer ?? ffi.nullptr,
        mode.ref.pointer,
        deqFlag);
    return _ret.address == 0
        ? null
        : NSEvent.castFromPointer(_ret, retain: true, release: true);
  }

  /// discardEventsMatchingMask:beforeEvent:
  void discardEventsMatchingMask_beforeEvent_(
      NSEventMask mask, NSEvent? lastEvent) {
    objc.checkOsVersionInternal(
        'NSApplication.discardEventsMatchingMask:beforeEvent:',
        iOS: (true, null));
    _objc_msgSend_58potu(
        this.ref.pointer,
        _sel_discardEventsMatchingMask_beforeEvent_,
        mask.value,
        lastEvent?.ref.pointer ?? ffi.nullptr);
  }
}

late final _sel_sendAction_to_from_ = objc.registerName("sendAction:to:from:");
final _objc_msgSend_iv7uhk = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Bool Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        bool Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>();
late final _sel_targetForAction_ = objc.registerName("targetForAction:");
final _objc_msgSend_3ctkt6 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_targetForAction_to_from_ =
    objc.registerName("targetForAction:to:from:");
final _objc_msgSend_cfx8ce = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>();
late final _sel_tryToPerform_with_ = objc.registerName("tryToPerform:with:");
final _objc_msgSend_1f04296 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Bool Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        bool Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>)>();
late final _sel_validRequestorForSendType_returnType_ =
    objc.registerName("validRequestorForSendType:returnType:");
final _objc_msgSend_15qeuct = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>();

/// NSResponder
extension NSResponder$1 on NSApplication {
  /// sendAction:to:from:
  bool sendAction_to_from_(ffi.Pointer<objc.ObjCSelector> action,
      objc.ObjCObjectBase? target, objc.ObjCObjectBase? sender) {
    objc.checkOsVersionInternal('NSApplication.sendAction:to:from:',
        iOS: (true, null));
    return _objc_msgSend_iv7uhk(
        this.ref.pointer,
        _sel_sendAction_to_from_,
        action,
        target?.ref.pointer ?? ffi.nullptr,
        sender?.ref.pointer ?? ffi.nullptr);
  }

  /// targetForAction:
  objc.ObjCObjectBase? targetForAction_(ffi.Pointer<objc.ObjCSelector> action) {
    objc.checkOsVersionInternal('NSApplication.targetForAction:',
        iOS: (true, null));
    final _ret =
        _objc_msgSend_3ctkt6(this.ref.pointer, _sel_targetForAction_, action);
    return _ret.address == 0
        ? null
        : objc.ObjCObjectBase(_ret, retain: true, release: true);
  }

  /// targetForAction:to:from:
  objc.ObjCObjectBase? targetForAction_to_from_(
      ffi.Pointer<objc.ObjCSelector> action,
      objc.ObjCObjectBase? target,
      objc.ObjCObjectBase? sender) {
    objc.checkOsVersionInternal('NSApplication.targetForAction:to:from:',
        iOS: (true, null));
    final _ret = _objc_msgSend_cfx8ce(
        this.ref.pointer,
        _sel_targetForAction_to_from_,
        action,
        target?.ref.pointer ?? ffi.nullptr,
        sender?.ref.pointer ?? ffi.nullptr);
    return _ret.address == 0
        ? null
        : objc.ObjCObjectBase(_ret, retain: true, release: true);
  }

  /// tryToPerform:with:
  bool tryToPerform_with_(
      ffi.Pointer<objc.ObjCSelector> action, objc.ObjCObjectBase? object) {
    objc.checkOsVersionInternal('NSApplication.tryToPerform:with:',
        iOS: (true, null));
    return _objc_msgSend_1f04296(this.ref.pointer, _sel_tryToPerform_with_,
        action, object?.ref.pointer ?? ffi.nullptr);
  }

  /// validRequestorForSendType:returnType:
  objc.ObjCObjectBase? validRequestorForSendType_returnType_(
      objc.NSString? sendType, objc.NSString? returnType) {
    objc.checkOsVersionInternal(
        'NSApplication.validRequestorForSendType:returnType:',
        iOS: (true, null));
    final _ret = _objc_msgSend_15qeuct(
        this.ref.pointer,
        _sel_validRequestorForSendType_returnType_,
        sendType?.ref.pointer ?? ffi.nullptr,
        returnType?.ref.pointer ?? ffi.nullptr);
    return _ret.address == 0
        ? null
        : objc.ObjCObjectBase(_ret, retain: true, release: true);
  }
}

/// WARNING: NSMenu is a stub. To generate bindings for this class, include
/// NSMenu in your config's objc-interfaces list.
///
/// NSMenu
class NSMenu extends objc.NSObject
    implements
        objc.NSCopying,
        objc.NSCoding,
        NSUserInterfaceItemIdentification,
        NSAppearanceCustomization,
        NSAccessibilityElement,
        NSAccessibility {
  NSMenu._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release) {
    objc.checkOsVersionInternal('NSMenu', iOS: (true, null));
  }

  /// Constructs a [NSMenu] that points to the same underlying object as [other].
  NSMenu.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [NSMenu] that wraps the given raw object pointer.
  NSMenu.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);
}

late final _sel_windowsMenu = objc.registerName("windowsMenu");
late final _sel_setWindowsMenu_ = objc.registerName("setWindowsMenu:");
late final _sel_arrangeInFront_ = objc.registerName("arrangeInFront:");
late final _class_NSWindow = objc.getClass("NSWindow");

/// WARNING: NSAnimatablePropertyContainer is a stub. To generate bindings for this class, include
/// NSAnimatablePropertyContainer in your config's objc-protocols list.
///
/// NSAnimatablePropertyContainer
interface class NSAnimatablePropertyContainer extends objc.ObjCProtocolBase {
  NSAnimatablePropertyContainer._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super(pointer, retain: retain, release: release);

  /// Constructs a [NSAnimatablePropertyContainer] that points to the same underlying object as [other].
  NSAnimatablePropertyContainer.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [NSAnimatablePropertyContainer] that wraps the given raw object pointer.
  NSAnimatablePropertyContainer.castFromPointer(
      ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false,
      bool release = false})
      : this._(other, retain: retain, release: release);
}

/// WARNING: NSUserInterfaceItemIdentification is a stub. To generate bindings for this class, include
/// NSUserInterfaceItemIdentification in your config's objc-protocols list.
///
/// NSUserInterfaceItemIdentification
interface class NSUserInterfaceItemIdentification
    extends objc.ObjCProtocolBase {
  NSUserInterfaceItemIdentification._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super(pointer, retain: retain, release: release);

  /// Constructs a [NSUserInterfaceItemIdentification] that points to the same underlying object as [other].
  NSUserInterfaceItemIdentification.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [NSUserInterfaceItemIdentification] that wraps the given raw object pointer.
  NSUserInterfaceItemIdentification.castFromPointer(
      ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false,
      bool release = false})
      : this._(other, retain: retain, release: release);
}

void _ObjCBlock_ffiVoid_NSEvent_bool_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<objc.ObjCObject> arg0,
        ffi.Pointer<ffi.Bool> arg1) =>
    block.ref.target
        .cast<
            ffi.NativeFunction<
                ffi.Void Function(ffi.Pointer<objc.ObjCObject> arg0,
                    ffi.Pointer<ffi.Bool> arg1)>>()
        .asFunction<
            void Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<ffi.Bool>)>()(arg0, arg1);
ffi.Pointer<ffi.Void> _ObjCBlock_ffiVoid_NSEvent_bool_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<objc.ObjCObject>, ffi.Pointer<ffi.Bool>)>(
            _ObjCBlock_ffiVoid_NSEvent_bool_fnPtrTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_NSEvent_bool_closureTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<objc.ObjCObject> arg0,
        ffi.Pointer<ffi.Bool> arg1) =>
    (objc.getBlockClosure(block) as void Function(
        ffi.Pointer<objc.ObjCObject>, ffi.Pointer<ffi.Bool>))(arg0, arg1);
ffi.Pointer<ffi.Void> _ObjCBlock_ffiVoid_NSEvent_bool_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<objc.ObjCObject>, ffi.Pointer<ffi.Bool>)>(
            _ObjCBlock_ffiVoid_NSEvent_bool_closureTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_NSEvent_bool_listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObject> arg0,
    ffi.Pointer<ffi.Bool> arg1) {
  (objc.getBlockClosure(block) as void Function(
      ffi.Pointer<objc.ObjCObject>, ffi.Pointer<ffi.Bool>))(arg0, arg1);
  objc.objectRelease(block.cast());
}

ffi.NativeCallable<
        ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<ffi.Bool>)>
    _ObjCBlock_ffiVoid_NSEvent_bool_listenerCallable = ffi.NativeCallable<
            ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<objc.ObjCObject>, ffi.Pointer<ffi.Bool>)>.listener(
        _ObjCBlock_ffiVoid_NSEvent_bool_listenerTrampoline)
      ..keepIsolateAlive = false;
void _ObjCBlock_ffiVoid_NSEvent_bool_blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<objc.ObjCObject> arg0,
    ffi.Pointer<ffi.Bool> arg1) {
  try {
    (objc.getBlockClosure(block) as void Function(
        ffi.Pointer<objc.ObjCObject>, ffi.Pointer<ffi.Bool>))(arg0, arg1);
  } catch (e) {
  } finally {
    objc.signalWaiter(waiter);
    objc.objectRelease(block.cast());
  }
}

ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<ffi.Bool>)>
    _ObjCBlock_ffiVoid_NSEvent_bool_blockingCallable = ffi.NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<ffi.Bool>)>.isolateLocal(
        _ObjCBlock_ffiVoid_NSEvent_bool_blockingTrampoline)
      ..keepIsolateAlive = false;
ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<ffi.Bool>)>
    _ObjCBlock_ffiVoid_NSEvent_bool_blockingListenerCallable = ffi
        .NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<ffi.Bool>)>.listener(
        _ObjCBlock_ffiVoid_NSEvent_bool_blockingTrampoline)
      ..keepIsolateAlive = false;

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(NSEvent?, ffi.Pointer<ffi.Bool>)>`.
abstract final class ObjCBlock_ffiVoid_NSEvent_bool {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(NSEvent?, ffi.Pointer<ffi.Bool>)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<ffi.Void Function(NSEvent?, ffi.Pointer<ffi.Bool>)>(
              pointer,
              retain: retain,
              release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(NSEvent?, ffi.Pointer<ffi.Bool>)> fromFunctionPointer(
          ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Void Function(ffi.Pointer<objc.ObjCObject> arg0,
                          ffi.Pointer<ffi.Bool> arg1)>>
              ptr) =>
      objc.ObjCBlock<ffi.Void Function(NSEvent?, ffi.Pointer<ffi.Bool>)>(
          objc.newPointerBlock(_ObjCBlock_ffiVoid_NSEvent_bool_fnPtrCallable, ptr.cast()),
          retain: false,
          release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(NSEvent?, ffi.Pointer<ffi.Bool>)> fromFunction(
          void Function(NSEvent?, ffi.Pointer<ffi.Bool>) fn,
          {bool keepIsolateAlive = true}) =>
      objc.ObjCBlock<ffi.Void Function(NSEvent?, ffi.Pointer<ffi.Bool>)>(
          objc.newClosureBlock(
              _ObjCBlock_ffiVoid_NSEvent_bool_closureCallable,
              (ffi.Pointer<objc.ObjCObject> arg0, ffi.Pointer<ffi.Bool> arg1) => fn(
                  arg0.address == 0
                      ? null
                      : NSEvent.castFromPointer(arg0, retain: true, release: true),
                  arg1),
              keepIsolateAlive),
          retain: false,
          release: true);

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(NSEvent?, ffi.Pointer<ffi.Bool>)>
      listener(void Function(NSEvent?, ffi.Pointer<ffi.Bool>) fn,
          {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_NSEvent_bool_listenerCallable.nativeFunction.cast(),
        (ffi.Pointer<objc.ObjCObject> arg0, ffi.Pointer<ffi.Bool> arg1) => fn(
            arg0.address == 0
                ? null
                : NSEvent.castFromPointer(arg0, retain: false, release: true),
            arg1),
        keepIsolateAlive);
    final wrapper = _AuthenticationServicesMacOS_wrapListenerBlock_t8l8el(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<ffi.Void Function(NSEvent?, ffi.Pointer<ffi.Bool>)>(
        wrapper,
        retain: false,
        release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(NSEvent?, ffi.Pointer<ffi.Bool>)>
      blocking(void Function(NSEvent?, ffi.Pointer<ffi.Bool>) fn,
          {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_NSEvent_bool_blockingCallable.nativeFunction.cast(),
        (ffi.Pointer<objc.ObjCObject> arg0, ffi.Pointer<ffi.Bool> arg1) => fn(
            arg0.address == 0
                ? null
                : NSEvent.castFromPointer(arg0, retain: false, release: true),
            arg1),
        keepIsolateAlive);
    final rawListener = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_NSEvent_bool_blockingListenerCallable.nativeFunction
            .cast(),
        (ffi.Pointer<objc.ObjCObject> arg0, ffi.Pointer<ffi.Bool> arg1) => fn(
            arg0.address == 0
                ? null
                : NSEvent.castFromPointer(arg0, retain: false, release: true),
            arg1),
        keepIsolateAlive);
    final wrapper = _AuthenticationServicesMacOS_wrapBlockingBlock_t8l8el(
        raw, rawListener, objc.objCContext);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<ffi.Void Function(NSEvent?, ffi.Pointer<ffi.Bool>)>(
        wrapper,
        retain: false,
        release: true);
  }
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(NSEvent?, ffi.Pointer<ffi.Bool>)>`.
extension ObjCBlock_ffiVoid_NSEvent_bool_CallExtension
    on objc.ObjCBlock<ffi.Void Function(NSEvent?, ffi.Pointer<ffi.Bool>)> {
  void call(NSEvent? arg0, ffi.Pointer<ffi.Bool> arg1) => ref.pointer.ref.invoke
          .cast<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<objc.ObjCBlockImpl> block,
                      ffi.Pointer<objc.ObjCObject> arg0,
                      ffi.Pointer<ffi.Bool> arg1)>>()
          .asFunction<
              void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                  ffi.Pointer<objc.ObjCObject>, ffi.Pointer<ffi.Bool>)>()(
      ref.pointer, arg0?.ref.pointer ?? ffi.nullptr, arg1);
}

late final _sel_trackEventsMatchingMask_timeout_mode_handler_ =
    objc.registerName("trackEventsMatchingMask:timeout:mode:handler:");
final _objc_msgSend_14k0sem = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.LongLong,
                ffi.Double,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCBlockImpl>)>>()
    .asFunction<
        void Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            int,
            double,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCBlockImpl>)>();
late final _sel_nextEventMatchingMask_ =
    objc.registerName("nextEventMatchingMask:");
final _objc_msgSend_1piiki0 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, ffi.LongLong)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, int)>();
late final _sel_acceptsMouseMovedEvents =
    objc.registerName("acceptsMouseMovedEvents");
late final _sel_setAcceptsMouseMovedEvents_ =
    objc.registerName("setAcceptsMouseMovedEvents:");
final _objc_msgSend_1s56lr9 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, ffi.Bool)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, bool)>();
late final _sel_ignoresMouseEvents = objc.registerName("ignoresMouseEvents");
late final _sel_setIgnoresMouseEvents_ =
    objc.registerName("setIgnoresMouseEvents:");

final class CGPoint extends ffi.Struct {
  @ffi.Double()
  external double x;

  @ffi.Double()
  external double y;
}

late final _sel_mouseLocationOutsideOfEventStream =
    objc.registerName("mouseLocationOutsideOfEventStream");
final _objc_msgSend_1uwdhlk = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            CGPoint Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        CGPoint Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
final _objc_msgSend_1uwdhlkStret = objc.msgSendStretPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<CGPoint>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        void Function(ffi.Pointer<CGPoint>, ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>)>();

/// NSEvent
extension NSEvent$2 on NSWindow {
  /// ! Tracks events matching the supplied mask with the supplied tracking handler until the tracking handler explicitly terminates tracking. Each event is removed from the event queue then passed to the tracking handler. If a matching event does not exist in the event queue, then the main thread blocks in the specified runloop mode until an event of the requested type is received or the timeout expires. If the timeout expires, the tracking handler is called with a nil event. A negative timeout is interpreted as 0. Use \c NSEventDurationForever to never timeout. Tracking continues until `*stop` is set to \c YES. Calls to `-nextEventMatchingMask:…` are allowed inside the trackingHandler block. This method returns once tracking is terminated.
  void trackEventsMatchingMask_timeout_mode_handler_(
      NSEventMask mask,
      double timeout,
      objc.NSString mode,
      objc.ObjCBlock<ffi.Void Function(NSEvent?, ffi.Pointer<ffi.Bool>)>
          trackingHandler) {
    objc.checkOsVersionInternal(
        'NSWindow.trackEventsMatchingMask:timeout:mode:handler:',
        iOS: (true, null),
        macOS: (false, (10, 10, 0)));
    _objc_msgSend_14k0sem(
        this.ref.pointer,
        _sel_trackEventsMatchingMask_timeout_mode_handler_,
        mask.value,
        timeout,
        mode.ref.pointer,
        trackingHandler.ref.pointer);
  }

  /// nextEventMatchingMask:
  NSEvent? nextEventMatchingMask_(NSEventMask mask) {
    objc.checkOsVersionInternal('NSWindow.nextEventMatchingMask:',
        iOS: (true, null));
    final _ret = _objc_msgSend_1piiki0(
        this.ref.pointer, _sel_nextEventMatchingMask_, mask.value);
    return _ret.address == 0
        ? null
        : NSEvent.castFromPointer(_ret, retain: true, release: true);
  }

  /// nextEventMatchingMask:untilDate:inMode:dequeue:
  NSEvent? nextEventMatchingMask_untilDate_inMode_dequeue_(NSEventMask mask,
      objc.NSDate? expiration, objc.NSString mode, bool deqFlag) {
    objc.checkOsVersionInternal(
        'NSWindow.nextEventMatchingMask:untilDate:inMode:dequeue:',
        iOS: (true, null));
    final _ret = _objc_msgSend_qe9d8w(
        this.ref.pointer,
        _sel_nextEventMatchingMask_untilDate_inMode_dequeue_,
        mask.value,
        expiration?.ref.pointer ?? ffi.nullptr,
        mode.ref.pointer,
        deqFlag);
    return _ret.address == 0
        ? null
        : NSEvent.castFromPointer(_ret, retain: true, release: true);
  }

  /// discardEventsMatchingMask:beforeEvent:
  void discardEventsMatchingMask_beforeEvent_(
      NSEventMask mask, NSEvent? lastEvent) {
    objc.checkOsVersionInternal(
        'NSWindow.discardEventsMatchingMask:beforeEvent:',
        iOS: (true, null));
    _objc_msgSend_58potu(
        this.ref.pointer,
        _sel_discardEventsMatchingMask_beforeEvent_,
        mask.value,
        lastEvent?.ref.pointer ?? ffi.nullptr);
  }

  /// postEvent:atStart:
  void postEvent_atStart_(NSEvent event, bool flag) {
    objc.checkOsVersionInternal('NSWindow.postEvent:atStart:',
        iOS: (true, null));
    _objc_msgSend_6p7ndb(
        this.ref.pointer, _sel_postEvent_atStart_, event.ref.pointer, flag);
  }

  /// sendEvent:
  void sendEvent_(NSEvent event) {
    objc.checkOsVersionInternal('NSWindow.sendEvent:', iOS: (true, null));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_sendEvent_, event.ref.pointer);
  }

  /// currentEvent
  NSEvent? get currentEvent {
    objc.checkOsVersionInternal('NSWindow.currentEvent', iOS: (true, null));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_currentEvent);
    return _ret.address == 0
        ? null
        : NSEvent.castFromPointer(_ret, retain: true, release: true);
  }

  /// acceptsMouseMovedEvents
  bool get acceptsMouseMovedEvents {
    objc.checkOsVersionInternal('NSWindow.acceptsMouseMovedEvents',
        iOS: (true, null));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_acceptsMouseMovedEvents);
  }

  /// setAcceptsMouseMovedEvents:
  set acceptsMouseMovedEvents(bool value) {
    objc.checkOsVersionInternal('NSWindow.setAcceptsMouseMovedEvents:',
        iOS: (true, null));
    _objc_msgSend_1s56lr9(
        this.ref.pointer, _sel_setAcceptsMouseMovedEvents_, value);
  }

  /// ignoresMouseEvents
  bool get ignoresMouseEvents {
    objc.checkOsVersionInternal('NSWindow.ignoresMouseEvents',
        iOS: (true, null));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_ignoresMouseEvents);
  }

  /// setIgnoresMouseEvents:
  set ignoresMouseEvents(bool value) {
    objc.checkOsVersionInternal('NSWindow.setIgnoresMouseEvents:',
        iOS: (true, null));
    _objc_msgSend_1s56lr9(this.ref.pointer, _sel_setIgnoresMouseEvents_, value);
  }

  /// mouseLocationOutsideOfEventStream
  CGPoint get mouseLocationOutsideOfEventStream {
    objc.checkOsVersionInternal('NSWindow.mouseLocationOutsideOfEventStream',
        iOS: (true, null));
    final _ptr = pkg_ffi.calloc<CGPoint>();
    objc.useMsgSendVariants
        ? _objc_msgSend_1uwdhlkStret(
            _ptr, this.ref.pointer, _sel_mouseLocationOutsideOfEventStream)
        : _ptr.ref = _objc_msgSend_1uwdhlk(
            this.ref.pointer, _sel_mouseLocationOutsideOfEventStream);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<CGPoint>(),
        finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<CGPoint>(_finalizable);
  }
}

late final _sel_disableCursorRects = objc.registerName("disableCursorRects");
final _objc_msgSend_1pl9qdv = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        void Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_enableCursorRects = objc.registerName("enableCursorRects");
late final _sel_discardCursorRects = objc.registerName("discardCursorRects");
late final _sel_areCursorRectsEnabled =
    objc.registerName("areCursorRectsEnabled");

/// WARNING: NSView is a stub. To generate bindings for this class, include
/// NSView in your config's objc-interfaces list.
///
/// NSView
class NSView extends NSResponder
    implements
        NSAnimatablePropertyContainer,
        NSUserInterfaceItemIdentification,
        NSDraggingDestination,
        NSAppearanceCustomization,
        NSAccessibilityElement,
        NSAccessibility {
  NSView._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release) {
    objc.checkOsVersionInternal('NSView', iOS: (true, null));
  }

  /// Constructs a [NSView] that points to the same underlying object as [other].
  NSView.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [NSView] that wraps the given raw object pointer.
  NSView.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);
}

late final _sel_invalidateCursorRectsForView_ =
    objc.registerName("invalidateCursorRectsForView:");
late final _sel_resetCursorRects = objc.registerName("resetCursorRects");

/// NSCursorRect
extension NSCursorRect on NSWindow {
  /// disableCursorRects
  void disableCursorRects() {
    objc.checkOsVersionInternal('NSWindow.disableCursorRects',
        iOS: (true, null));
    _objc_msgSend_1pl9qdv(this.ref.pointer, _sel_disableCursorRects);
  }

  /// enableCursorRects
  void enableCursorRects() {
    objc.checkOsVersionInternal('NSWindow.enableCursorRects',
        iOS: (true, null));
    _objc_msgSend_1pl9qdv(this.ref.pointer, _sel_enableCursorRects);
  }

  /// discardCursorRects
  void discardCursorRects() {
    objc.checkOsVersionInternal('NSWindow.discardCursorRects',
        iOS: (true, null));
    _objc_msgSend_1pl9qdv(this.ref.pointer, _sel_discardCursorRects);
  }

  /// areCursorRectsEnabled
  bool get areCursorRectsEnabled {
    objc.checkOsVersionInternal('NSWindow.areCursorRectsEnabled',
        iOS: (true, null));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_areCursorRectsEnabled);
  }

  /// invalidateCursorRectsForView:
  void invalidateCursorRectsForView_(NSView view) {
    objc.checkOsVersionInternal('NSWindow.invalidateCursorRectsForView:',
        iOS: (true, null));
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_invalidateCursorRectsForView_, view.ref.pointer);
  }

  /// resetCursorRects
  void resetCursorRects() {
    objc.checkOsVersionInternal('NSWindow.resetCursorRects', iOS: (true, null));
    _objc_msgSend_1pl9qdv(this.ref.pointer, _sel_resetCursorRects);
  }
}

/// WARNING: NSDraggingSession is a stub. To generate bindings for this class, include
/// NSDraggingSession in your config's objc-interfaces list.
///
/// NSDraggingSession
class NSDraggingSession extends objc.ObjCObjectBase {
  NSDraggingSession._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super(pointer, retain: retain, release: release);

  /// Constructs a [NSDraggingSession] that points to the same underlying object as [other].
  NSDraggingSession.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [NSDraggingSession] that wraps the given raw object pointer.
  NSDraggingSession.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);
}

/// WARNING: NSDraggingSource is a stub. To generate bindings for this class, include
/// NSDraggingSource in your config's objc-protocols list.
///
/// NSDraggingSource
interface class NSDraggingSource extends objc.ObjCProtocolBase
    implements objc.NSObjectProtocol {
  NSDraggingSource._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super(pointer, retain: retain, release: release);

  /// Constructs a [NSDraggingSource] that points to the same underlying object as [other].
  NSDraggingSource.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [NSDraggingSource] that wraps the given raw object pointer.
  NSDraggingSource.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);
}

late final _sel_beginDraggingSessionWithItems_event_source_ =
    objc.registerName("beginDraggingSessionWithItems:event:source:");
final _objc_msgSend_11spmsz = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>();

/// WARNING: NSImage is a stub. To generate bindings for this class, include
/// NSImage in your config's objc-interfaces list.
///
/// NSImage
class NSImage extends objc.NSObject {
  NSImage._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release);

  /// Constructs a [NSImage] that points to the same underlying object as [other].
  NSImage.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [NSImage] that wraps the given raw object pointer.
  NSImage.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);
}

final class CGSize extends ffi.Struct {
  @ffi.Double()
  external double width;

  @ffi.Double()
  external double height;
}

/// WARNING: NSPasteboard is a stub. To generate bindings for this class, include
/// NSPasteboard in your config's objc-interfaces list.
///
/// NSPasteboard
class NSPasteboard extends objc.NSObject {
  NSPasteboard._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release) {
    objc.checkOsVersionInternal('NSPasteboard', iOS: (true, null));
  }

  /// Constructs a [NSPasteboard] that points to the same underlying object as [other].
  NSPasteboard.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [NSPasteboard] that wraps the given raw object pointer.
  NSPasteboard.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);
}

late final _sel_dragImage_at_offset_event_pasteboard_source_slideBack_ =
    objc.registerName("dragImage:at:offset:event:pasteboard:source:slideBack:");
final _objc_msgSend_1t2qvli = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                CGPoint,
                CGSize,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Bool)>>()
    .asFunction<
        void Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            CGPoint,
            CGSize,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            bool)>();
late final _sel_registerForDraggedTypes_ =
    objc.registerName("registerForDraggedTypes:");
late final _sel_unregisterDraggedTypes =
    objc.registerName("unregisterDraggedTypes");

/// NSDrag
extension NSDrag on NSWindow {
  /// beginDraggingSessionWithItems:event:source:
  ///
  /// iOS: unavailable
  /// macOS: introduced 15.0.0
  NSDraggingSession beginDraggingSessionWithItems_event_source_(
      objc.NSArray items, NSEvent event, NSDraggingSource source) {
    objc.checkOsVersionInternal(
        'NSWindow.beginDraggingSessionWithItems:event:source:',
        iOS: (true, null),
        macOS: (false, (15, 0, 0)));
    final _ret = _objc_msgSend_11spmsz(
        this.ref.pointer,
        _sel_beginDraggingSessionWithItems_event_source_,
        items.ref.pointer,
        event.ref.pointer,
        source.ref.pointer);
    return NSDraggingSession.castFromPointer(_ret, retain: true, release: true);
  }

  /// dragImage:at:offset:event:pasteboard:source:slideBack:
  ///
  /// iOS: unavailable
  /// macOS: introduced 10.0.0, deprecated 100000.0.0
  void dragImage_at_offset_event_pasteboard_source_slideBack_(
      NSImage image,
      CGPoint baseLocation,
      CGSize initialOffset,
      NSEvent event,
      NSPasteboard pboard,
      objc.ObjCObjectBase sourceObj,
      bool slideFlag) {
    objc.checkOsVersionInternal(
        'NSWindow.dragImage:at:offset:event:pasteboard:source:slideBack:',
        iOS: (true, null),
        macOS: (false, (10, 0, 0)));
    _objc_msgSend_1t2qvli(
        this.ref.pointer,
        _sel_dragImage_at_offset_event_pasteboard_source_slideBack_,
        image.ref.pointer,
        baseLocation,
        initialOffset,
        event.ref.pointer,
        pboard.ref.pointer,
        sourceObj.ref.pointer,
        slideFlag);
  }

  /// registerForDraggedTypes:
  void registerForDraggedTypes_(objc.NSArray newTypes) {
    objc.checkOsVersionInternal('NSWindow.registerForDraggedTypes:',
        iOS: (true, null));
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_registerForDraggedTypes_, newTypes.ref.pointer);
  }

  /// unregisterDraggedTypes
  void unregisterDraggedTypes() {
    objc.checkOsVersionInternal('NSWindow.unregisterDraggedTypes',
        iOS: (true, null));
    _objc_msgSend_1pl9qdv(this.ref.pointer, _sel_unregisterDraggedTypes);
  }
}

/// WARNING: CADisplayLink is a stub. To generate bindings for this class, include
/// CADisplayLink in your config's objc-interfaces list.
///
/// CADisplayLink
class CADisplayLink extends objc.ObjCObjectBase {
  CADisplayLink._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super(pointer, retain: retain, release: release);

  /// Constructs a [CADisplayLink] that points to the same underlying object as [other].
  CADisplayLink.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [CADisplayLink] that wraps the given raw object pointer.
  CADisplayLink.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);
}

late final _sel_displayLinkWithTarget_selector_ =
    objc.registerName("displayLinkWithTarget:selector:");
final _objc_msgSend_836y90 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>)>();

/// NSDisplayLink
extension NSDisplayLink on NSWindow {
  /// Returns a new display link whose callback will be invoked in-sync with the display the window is on. If the window is not on any display the callback will not be invoked.
  CADisplayLink displayLinkWithTarget_selector_(
      objc.ObjCObjectBase target, ffi.Pointer<objc.ObjCSelector> selector) {
    objc.checkOsVersionInternal('NSWindow.displayLinkWithTarget:selector:',
        iOS: (true, null));
    final _ret = _objc_msgSend_836y90(this.ref.pointer,
        _sel_displayLinkWithTarget_selector_, target.ref.pointer, selector);
    return CADisplayLink.castFromPointer(_ret, retain: true, release: true);
  }
}

late final _sel_showsResizeIndicator =
    objc.registerName("showsResizeIndicator");
late final _sel_setShowsResizeIndicator_ =
    objc.registerName("setShowsResizeIndicator:");
late final _sel_initWithWindowRef_ = objc.registerName("initWithWindowRef:");
final _objc_msgSend_1mbt9g9 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<ffi.Void>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<ffi.Void>)>();
late final _sel_windowRef = objc.registerName("windowRef");
final _objc_msgSend_6ex6p5 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<ffi.Void> Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        ffi.Pointer<ffi.Void> Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_disableScreenUpdatesUntilFlush =
    objc.registerName("disableScreenUpdatesUntilFlush");

/// NSDeprecated
extension NSDeprecated on NSWindow {
  /// iOS: unavailable
  /// macOS: introduced 10.0.0, deprecated 15.0.0
  bool get showsResizeIndicator {
    objc.checkOsVersionInternal('NSWindow.showsResizeIndicator',
        iOS: (true, null), macOS: (false, (10, 0, 0)));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_showsResizeIndicator);
  }

  /// iOS: unavailable
  /// macOS: introduced 10.0.0, deprecated 15.0.0
  set showsResizeIndicator(bool value) {
    objc.checkOsVersionInternal('NSWindow.setShowsResizeIndicator:',
        iOS: (true, null), macOS: (false, (10, 0, 0)));
    _objc_msgSend_1s56lr9(
        this.ref.pointer, _sel_setShowsResizeIndicator_, value);
  }

  /// WindowRef
  ///
  /// iOS: unavailable
  /// macOS: introduced 10.0.0, deprecated 15.0.0
  NSWindow? initWithWindowRef_(ffi.Pointer<ffi.Void> windowRef) {
    objc.checkOsVersionInternal('NSWindow.initWithWindowRef:',
        iOS: (true, null), macOS: (false, (10, 0, 0)));
    final _ret = _objc_msgSend_1mbt9g9(
        this.ref.retainAndReturnPointer(), _sel_initWithWindowRef_, windowRef);
    return _ret.address == 0
        ? null
        : NSWindow.castFromPointer(_ret, retain: false, release: true);
  }

  /// WindowRef
  ///
  /// iOS: unavailable
  /// macOS: introduced 10.0.0, deprecated 15.0.0
  ffi.Pointer<ffi.Void> get windowRef {
    objc.checkOsVersionInternal('NSWindow.windowRef',
        iOS: (true, null), macOS: (false, (10, 0, 0)));
    return _objc_msgSend_6ex6p5(this.ref.pointer, _sel_windowRef);
  }

  /// disableScreenUpdatesUntilFlush
  ///
  /// iOS: unavailable
  /// macOS: introduced 10.0.0, deprecated 15.0.0
  void disableScreenUpdatesUntilFlush() {
    objc.checkOsVersionInternal('NSWindow.disableScreenUpdatesUntilFlush',
        iOS: (true, null), macOS: (false, (10, 0, 0)));
    _objc_msgSend_1pl9qdv(
        this.ref.pointer, _sel_disableScreenUpdatesUntilFlush);
  }
}

late final _sel_isKeyWindow = objc.registerName("isKeyWindow");

/// NSWindow
class NSWindow extends NSResponder
    implements
        NSAnimatablePropertyContainer,
        NSMenuItemValidation,
        NSUserInterfaceValidations,
        NSUserInterfaceItemIdentification,
        NSAppearanceCustomization,
        NSAccessibilityElement,
        NSAccessibility {
  NSWindow._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release);

  /// Constructs a [NSWindow] that points to the same underlying object as [other].
  NSWindow.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [NSWindow] that wraps the given raw object pointer.
  NSWindow.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [NSWindow].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(
        obj.ref.pointer, _sel_isKindOfClass_, _class_NSWindow);
  }

  /// isKeyWindow
  bool get keyWindow {
    objc.checkOsVersionInternal('NSWindow.isKeyWindow', iOS: (true, null));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_isKeyWindow);
  }
}

late final _sel_removeWindowsItem_ = objc.registerName("removeWindowsItem:");
late final _sel_addWindowsItem_title_filename_ =
    objc.registerName("addWindowsItem:title:filename:");
final _objc_msgSend_1lhy15d = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Bool)>>()
    .asFunction<
        void Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            bool)>();
late final _sel_changeWindowsItem_title_filename_ =
    objc.registerName("changeWindowsItem:title:filename:");
late final _sel_updateWindowsItem_ = objc.registerName("updateWindowsItem:");
late final _sel_miniaturizeAll_ = objc.registerName("miniaturizeAll:");

/// NSWindowsMenu
extension NSWindowsMenu on NSApplication {
  /// windowsMenu
  NSMenu? get windowsMenu {
    objc.checkOsVersionInternal('NSApplication.windowsMenu', iOS: (true, null));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_windowsMenu);
    return _ret.address == 0
        ? null
        : NSMenu.castFromPointer(_ret, retain: true, release: true);
  }

  /// setWindowsMenu:
  set windowsMenu(NSMenu? value) {
    objc.checkOsVersionInternal('NSApplication.setWindowsMenu:',
        iOS: (true, null));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setWindowsMenu_,
        value?.ref.pointer ?? ffi.nullptr);
  }

  /// arrangeInFront:
  void arrangeInFront_(objc.ObjCObjectBase? sender) {
    objc.checkOsVersionInternal('NSApplication.arrangeInFront:',
        iOS: (true, null));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_arrangeInFront_,
        sender?.ref.pointer ?? ffi.nullptr);
  }

  /// removeWindowsItem:
  void removeWindowsItem_(NSWindow win) {
    objc.checkOsVersionInternal('NSApplication.removeWindowsItem:',
        iOS: (true, null));
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_removeWindowsItem_, win.ref.pointer);
  }

  /// addWindowsItem:title:filename:
  void addWindowsItem_title_filename_(
      NSWindow win, objc.NSString string, bool isFilename) {
    objc.checkOsVersionInternal('NSApplication.addWindowsItem:title:filename:',
        iOS: (true, null));
    _objc_msgSend_1lhy15d(this.ref.pointer, _sel_addWindowsItem_title_filename_,
        win.ref.pointer, string.ref.pointer, isFilename);
  }

  /// changeWindowsItem:title:filename:
  void changeWindowsItem_title_filename_(
      NSWindow win, objc.NSString string, bool isFilename) {
    objc.checkOsVersionInternal(
        'NSApplication.changeWindowsItem:title:filename:',
        iOS: (true, null));
    _objc_msgSend_1lhy15d(
        this.ref.pointer,
        _sel_changeWindowsItem_title_filename_,
        win.ref.pointer,
        string.ref.pointer,
        isFilename);
  }

  /// updateWindowsItem:
  void updateWindowsItem_(NSWindow win) {
    objc.checkOsVersionInternal('NSApplication.updateWindowsItem:',
        iOS: (true, null));
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_updateWindowsItem_, win.ref.pointer);
  }

  /// miniaturizeAll:
  void miniaturizeAll_(objc.ObjCObjectBase? sender) {
    objc.checkOsVersionInternal('NSApplication.miniaturizeAll:',
        iOS: (true, null));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_miniaturizeAll_,
        sender?.ref.pointer ?? ffi.nullptr);
  }
}

late final _sel_isFullKeyboardAccessEnabled =
    objc.registerName("isFullKeyboardAccessEnabled");

/// NSFullKeyboardAccess
extension NSFullKeyboardAccess on NSApplication {
  /// A Boolean value indicating whether keyboard navigation is enabled in System Settings > Keyboard.
  /// - Note: The value of this property is `YES` if keyboard navigation is enabled or `NO` if it’s not. You might use this value to implement your own key loop or to implement in-control tabbing behavior similar to `NSTableView`. Because of the nature of the preference storage, you won’t be notified of changes to this property if you attempt to observe it through key-value observing; however, accessing this property is fairly inexpensive, so you can access it directly rather than caching it.
  /// - Note: This property’s value isn’t necessarily reflective of the separate accessibility setting named “Full Keyboard Access” in System Settings > Accessibility > Keyboard.
  bool get fullKeyboardAccessEnabled {
    objc.checkOsVersionInternal('NSApplication.isFullKeyboardAccessEnabled',
        iOS: (true, null), macOS: (false, (10, 6, 0)));
    return _objc_msgSend_91o635(
        this.ref.pointer, _sel_isFullKeyboardAccessEnabled);
  }
}

late final _sel_servicesMenu = objc.registerName("servicesMenu");
late final _sel_setServicesMenu_ = objc.registerName("setServicesMenu:");
late final _sel_registerServicesMenuSendTypes_returnTypes_ =
    objc.registerName("registerServicesMenuSendTypes:returnTypes:");
final _objc_msgSend_pfv6jd = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        void Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>();

/// NSServicesMenu
extension NSServicesMenu on NSApplication {
  /// servicesMenu
  NSMenu? get servicesMenu {
    objc.checkOsVersionInternal('NSApplication.servicesMenu',
        iOS: (true, null));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_servicesMenu);
    return _ret.address == 0
        ? null
        : NSMenu.castFromPointer(_ret, retain: true, release: true);
  }

  /// setServicesMenu:
  set servicesMenu(NSMenu? value) {
    objc.checkOsVersionInternal('NSApplication.setServicesMenu:',
        iOS: (true, null));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setServicesMenu_,
        value?.ref.pointer ?? ffi.nullptr);
  }

  /// registerServicesMenuSendTypes:returnTypes:
  void registerServicesMenuSendTypes_returnTypes_(
      objc.NSArray sendTypes, objc.NSArray returnTypes) {
    objc.checkOsVersionInternal(
        'NSApplication.registerServicesMenuSendTypes:returnTypes:',
        iOS: (true, null));
    _objc_msgSend_pfv6jd(
        this.ref.pointer,
        _sel_registerServicesMenuSendTypes_returnTypes_,
        sendTypes.ref.pointer,
        returnTypes.ref.pointer);
  }
}

late final _sel_servicesProvider = objc.registerName("servicesProvider");
late final _sel_setServicesProvider_ =
    objc.registerName("setServicesProvider:");

/// NSServicesHandling
extension NSServicesHandling on NSApplication {
  /// servicesProvider
  objc.ObjCObjectBase? get servicesProvider {
    objc.checkOsVersionInternal('NSApplication.servicesProvider',
        iOS: (true, null));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_servicesProvider);
    return _ret.address == 0
        ? null
        : objc.ObjCObjectBase(_ret, retain: true, release: true);
  }

  /// setServicesProvider:
  set servicesProvider(objc.ObjCObjectBase? value) {
    objc.checkOsVersionInternal('NSApplication.setServicesProvider:',
        iOS: (true, null));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setServicesProvider_,
        value?.ref.pointer ?? ffi.nullptr);
  }
}

late final _sel_orderFrontStandardAboutPanel_ =
    objc.registerName("orderFrontStandardAboutPanel:");
late final _sel_orderFrontStandardAboutPanelWithOptions_ =
    objc.registerName("orderFrontStandardAboutPanelWithOptions:");

/// NSStandardAboutPanel
extension NSStandardAboutPanel on NSApplication {
  /// orderFrontStandardAboutPanel:
  void orderFrontStandardAboutPanel_(objc.ObjCObjectBase? sender) {
    objc.checkOsVersionInternal('NSApplication.orderFrontStandardAboutPanel:',
        iOS: (true, null));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_orderFrontStandardAboutPanel_,
        sender?.ref.pointer ?? ffi.nullptr);
  }

  /// orderFrontStandardAboutPanelWithOptions:
  void orderFrontStandardAboutPanelWithOptions_(
      objc.NSDictionary optionsDictionary) {
    objc.checkOsVersionInternal(
        'NSApplication.orderFrontStandardAboutPanelWithOptions:',
        iOS: (true, null));
    _objc_msgSend_xtuoz7(
        this.ref.pointer,
        _sel_orderFrontStandardAboutPanelWithOptions_,
        optionsDictionary.ref.pointer);
  }
}

enum NSUserInterfaceLayoutDirection {
  NSUserInterfaceLayoutDirectionLeftToRight(0),
  NSUserInterfaceLayoutDirectionRightToLeft(1);

  final int value;
  const NSUserInterfaceLayoutDirection(this.value);

  static NSUserInterfaceLayoutDirection fromValue(int value) => switch (value) {
        0 => NSUserInterfaceLayoutDirectionLeftToRight,
        1 => NSUserInterfaceLayoutDirectionRightToLeft,
        _ => throw ArgumentError(
            'Unknown value for NSUserInterfaceLayoutDirection: $value'),
      };
}

late final _sel_userInterfaceLayoutDirection =
    objc.registerName("userInterfaceLayoutDirection");
final _objc_msgSend_1spww5v = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Long Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        int Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();

/// NSApplicationLayoutDirection
extension NSApplicationLayoutDirection on NSApplication {
  /// Returns the application-wide user interface layout direction.
  NSUserInterfaceLayoutDirection get userInterfaceLayoutDirection {
    objc.checkOsVersionInternal('NSApplication.userInterfaceLayoutDirection',
        iOS: (true, null), macOS: (false, (10, 6, 0)));
    final _ret = _objc_msgSend_1spww5v(
        this.ref.pointer, _sel_userInterfaceLayoutDirection);
    return NSUserInterfaceLayoutDirection.fromValue(_ret);
  }
}

late final _sel_disableRelaunchOnLogin =
    objc.registerName("disableRelaunchOnLogin");
late final _sel_enableRelaunchOnLogin =
    objc.registerName("enableRelaunchOnLogin");

/// NSRestorableUserInterface
extension NSRestorableUserInterface on NSApplication {
  /// Disable or reenable relaunching this app on login, if the app was running at the time the user logged out.  These methods increment and decrement a counter respectively; if the counter is 0 at the time the user logs out, then the app may be relaunched when the user logs back in.  The counter is initially zero, so by default apps are relaunched.
  ///
  /// If your app should not be relaunched because it launches via some other mechanism (e.g. launchd), then the recommended usage is to call `-[NSApp disableRelaunchOnLogin]` once, and never pair it with an -enable call.
  ///
  /// If your app should not be relaunched because it triggers a restart (e.g. an installer), then the recommended usage is to call `-[NSApp disableRelaunchOnLogin]` immediately before you attempt to trigger a restart, and `-[NSApp enableRelaunchOnLogin]` immediately after.  This is because the user may cancel restarting; if the user later restarts for another reason, then your app should be brought back.
  ///
  /// These methods are thread safe.
  void disableRelaunchOnLogin() {
    objc.checkOsVersionInternal('NSApplication.disableRelaunchOnLogin',
        iOS: (true, null), macOS: (false, (10, 7, 0)));
    _objc_msgSend_1pl9qdv(this.ref.pointer, _sel_disableRelaunchOnLogin);
  }

  /// enableRelaunchOnLogin
  void enableRelaunchOnLogin() {
    objc.checkOsVersionInternal('NSApplication.enableRelaunchOnLogin',
        iOS: (true, null), macOS: (false, (10, 7, 0)));
    _objc_msgSend_1pl9qdv(this.ref.pointer, _sel_enableRelaunchOnLogin);
  }
}

late final _sel_registerForRemoteNotifications =
    objc.registerName("registerForRemoteNotifications");
late final _sel_unregisterForRemoteNotifications =
    objc.registerName("unregisterForRemoteNotifications");
late final _sel_isRegisteredForRemoteNotifications =
    objc.registerName("isRegisteredForRemoteNotifications");

/// Soft deprecated.
/// Please use `NSApplication`'s `-registerForRemoteNotifications` along with `-requestAuthorizationWithOptions:` from the `UserNotifications.framework` to specify allowable notification types.
enum NSRemoteNotificationType {
  NSRemoteNotificationTypeNone(0),
  NSRemoteNotificationTypeBadge(1),
  NSRemoteNotificationTypeSound(2),
  NSRemoteNotificationTypeAlert(4);

  final int value;
  const NSRemoteNotificationType(this.value);

  static NSRemoteNotificationType fromValue(int value) => switch (value) {
        0 => NSRemoteNotificationTypeNone,
        1 => NSRemoteNotificationTypeBadge,
        2 => NSRemoteNotificationTypeSound,
        4 => NSRemoteNotificationTypeAlert,
        _ => throw ArgumentError(
            'Unknown value for NSRemoteNotificationType: $value'),
      };
}

late final _sel_registerForRemoteNotificationTypes_ =
    objc.registerName("registerForRemoteNotificationTypes:");
final _objc_msgSend_11aws2b = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, ffi.UnsignedLong)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, int)>();
late final _sel_enabledRemoteNotificationTypes =
    objc.registerName("enabledRemoteNotificationTypes");
final _objc_msgSend_16fwlsv = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.UnsignedLong Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        int Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();

/// NSRemoteNotifications
extension NSRemoteNotifications on NSApplication {
  /// registerForRemoteNotifications
  void registerForRemoteNotifications() {
    objc.checkOsVersionInternal('NSApplication.registerForRemoteNotifications',
        iOS: (true, null), macOS: (false, (10, 14, 0)));
    _objc_msgSend_1pl9qdv(
        this.ref.pointer, _sel_registerForRemoteNotifications);
  }

  /// unregisterForRemoteNotifications
  void unregisterForRemoteNotifications() {
    objc.checkOsVersionInternal(
        'NSApplication.unregisterForRemoteNotifications',
        iOS: (true, null),
        macOS: (false, (10, 7, 0)));
    _objc_msgSend_1pl9qdv(
        this.ref.pointer, _sel_unregisterForRemoteNotifications);
  }

  /// @return @c YES if the application is currently registered for remote notifications, taking into account any systemwide settings; doesn't relate to connectivity.
  bool get registeredForRemoteNotifications {
    objc.checkOsVersionInternal(
        'NSApplication.isRegisteredForRemoteNotifications',
        iOS: (true, null),
        macOS: (false, (10, 14, 0)));
    return _objc_msgSend_91o635(
        this.ref.pointer, _sel_isRegisteredForRemoteNotifications);
  }

  /// The following are soft deprecated.
  /// Please use the `-registerForRemoteNotifications` above and `-requestAuthorizationWithOptions:` from `UserNotifications.framework`.
  void registerForRemoteNotificationTypes_(NSRemoteNotificationType types) {
    objc.checkOsVersionInternal(
        'NSApplication.registerForRemoteNotificationTypes:',
        iOS: (true, null),
        macOS: (false, (10, 7, 0)));
    _objc_msgSend_11aws2b(this.ref.pointer,
        _sel_registerForRemoteNotificationTypes_, types.value);
  }

  /// enabledRemoteNotificationTypes
  NSRemoteNotificationType get enabledRemoteNotificationTypes {
    objc.checkOsVersionInternal('NSApplication.enabledRemoteNotificationTypes',
        iOS: (true, null), macOS: (false, (10, 7, 0)));
    final _ret = _objc_msgSend_16fwlsv(
        this.ref.pointer, _sel_enabledRemoteNotificationTypes);
    return NSRemoteNotificationType.fromValue(_ret);
  }
}

/// NSDeprecated
extension NSDeprecated$1 on NSApplication {}

late final _sel_sharedApplication = objc.registerName("sharedApplication");
late final _sel_windows = objc.registerName("windows");

/// NSApplication
class NSApplication extends NSResponder
    implements
        NSUserInterfaceValidations,
        NSMenuItemValidation,
        NSAccessibilityElement,
        NSAccessibility {
  NSApplication._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release) {
    objc.checkOsVersionInternal('NSApplication', iOS: (true, null));
  }

  /// Constructs a [NSApplication] that points to the same underlying object as [other].
  NSApplication.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [NSApplication] that wraps the given raw object pointer.
  NSApplication.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [NSApplication].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(
        obj.ref.pointer, _sel_isKindOfClass_, _class_NSApplication);
  }

  /// sharedApplication
  static NSApplication getSharedApplication() {
    objc.checkOsVersionInternal('NSApplication.sharedApplication',
        iOS: (true, null));
    final _ret =
        _objc_msgSend_151sglz(_class_NSApplication, _sel_sharedApplication);
    return NSApplication.castFromPointer(_ret, retain: true, release: true);
  }

  /// windows
  objc.NSArray get windows {
    objc.checkOsVersionInternal('NSApplication.windows', iOS: (true, null));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_windows);
    return objc.NSArray.castFromPointer(_ret, retain: true, release: true);
  }
}

/// Return values for `-applicationShouldTerminate:`.
enum NSApplicationTerminateReply {
  NSTerminateCancel(0),
  NSTerminateNow(1),
  NSTerminateLater(2);

  final int value;
  const NSApplicationTerminateReply(this.value);

  static NSApplicationTerminateReply fromValue(int value) => switch (value) {
        0 => NSTerminateCancel,
        1 => NSTerminateNow,
        2 => NSTerminateLater,
        _ => throw ArgumentError(
            'Unknown value for NSApplicationTerminateReply: $value'),
      };
}

/// Return values for `-application:printFiles:withSettings:showPrintPanels:`.
enum NSApplicationPrintReply {
  NSPrintingCancelled(0),
  NSPrintingSuccess(1),
  NSPrintingReplyLater(2),
  NSPrintingFailure(3);

  final int value;
  const NSApplicationPrintReply(this.value);

  static NSApplicationPrintReply fromValue(int value) => switch (value) {
        0 => NSPrintingCancelled,
        1 => NSPrintingSuccess,
        2 => NSPrintingReplyLater,
        3 => NSPrintingFailure,
        _ => throw ArgumentError(
            'Unknown value for NSApplicationPrintReply: $value'),
      };
}

late final _protocol_NSApplicationDelegate =
    objc.getProtocol("NSApplicationDelegate");
late final _sel_conformsToProtocol_ = objc.registerName("conformsToProtocol:");
final _objc_msgSend_e3qsqz = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Bool Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCProtocol>)>>()
    .asFunction<
        bool Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<objc.ObjCProtocol>)>();
late final _sel_applicationShouldTerminate_ =
    objc.registerName("applicationShouldTerminate:");
int _ObjCBlock_NSApplicationTerminateReply_ffiVoid_NSApplication_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1) =>
    block.ref.target
        .cast<
            ffi.NativeFunction<
                ffi.UnsignedLong Function(ffi.Pointer<ffi.Void> arg0,
                    ffi.Pointer<objc.ObjCObject> arg1)>>()
        .asFunction<
            int Function(ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>)>()(arg0, arg1);
ffi.Pointer<ffi.Void>
    _ObjCBlock_NSApplicationTerminateReply_ffiVoid_NSApplication_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.UnsignedLong Function(ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_NSApplicationTerminateReply_ffiVoid_NSApplication_fnPtrTrampoline,
            0)
        .cast();
int _ObjCBlock_NSApplicationTerminateReply_ffiVoid_NSApplication_closureTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1) =>
    (objc.getBlockClosure(block) as int Function(
        ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>))(arg0, arg1);
ffi.Pointer<ffi.Void>
    _ObjCBlock_NSApplicationTerminateReply_ffiVoid_NSApplication_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.UnsignedLong Function(ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_NSApplicationTerminateReply_ffiVoid_NSApplication_closureTrampoline,
            0)
        .cast();

/// Construction methods for `objc.ObjCBlock<ffi.UnsignedLong Function(ffi.Pointer<ffi.Void>, NSApplication)>`.
abstract final class ObjCBlock_NSApplicationTerminateReply_ffiVoid_NSApplication {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
          ffi.UnsignedLong Function(ffi.Pointer<ffi.Void>, NSApplication)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<
              ffi.UnsignedLong Function(ffi.Pointer<ffi.Void>,
                  NSApplication)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.UnsignedLong Function(ffi.Pointer<ffi.Void>, NSApplication)> fromFunctionPointer(
          ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.UnsignedLong Function(ffi.Pointer<ffi.Void> arg0,
                          ffi.Pointer<objc.ObjCObject> arg1)>>
              ptr) =>
      objc.ObjCBlock<ffi.UnsignedLong Function(ffi.Pointer<ffi.Void>, NSApplication)>(
          objc.newPointerBlock(_ObjCBlock_NSApplicationTerminateReply_ffiVoid_NSApplication_fnPtrCallable, ptr.cast()),
          retain: false,
          release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.UnsignedLong Function(ffi.Pointer<ffi.Void>, NSApplication)> fromFunction(
          NSApplicationTerminateReply Function(
                  ffi.Pointer<ffi.Void>, NSApplication)
              fn,
          {bool keepIsolateAlive = true}) =>
      objc.ObjCBlock<ffi.UnsignedLong Function(ffi.Pointer<ffi.Void>, NSApplication)>(
          objc.newClosureBlock(
              _ObjCBlock_NSApplicationTerminateReply_ffiVoid_NSApplication_closureCallable,
              (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1) =>
                  fn(arg0, NSApplication.castFromPointer(arg1, retain: true, release: true)).value,
              keepIsolateAlive),
          retain: false,
          release: true);
}

/// Call operator for `objc.ObjCBlock<ffi.UnsignedLong Function(ffi.Pointer<ffi.Void>, NSApplication)>`.
extension ObjCBlock_NSApplicationTerminateReply_ffiVoid_NSApplication_CallExtension
    on objc.ObjCBlock<
        ffi.UnsignedLong Function(ffi.Pointer<ffi.Void>, NSApplication)> {
  NSApplicationTerminateReply call(
          ffi.Pointer<ffi.Void> arg0, NSApplication arg1) =>
      NSApplicationTerminateReply.fromValue(ref.pointer.ref.invoke
              .cast<
                  ffi.NativeFunction<
                      ffi.UnsignedLong Function(
                          ffi.Pointer<objc.ObjCBlockImpl> block,
                          ffi.Pointer<ffi.Void> arg0,
                          ffi.Pointer<objc.ObjCObject> arg1)>>()
              .asFunction<
                  int Function(ffi.Pointer<objc.ObjCBlockImpl>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>()(
          ref.pointer, arg0, arg1.ref.pointer));
}

late final _sel_application_openURLs_ =
    objc.registerName("application:openURLs:");
void _ObjCBlock_ffiVoid_ffiVoid_NSApplication_NSArray_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1,
        ffi.Pointer<objc.ObjCObject> arg2) =>
    block.ref.target
        .cast<
            ffi.NativeFunction<
                ffi.Void Function(
                    ffi.Pointer<ffi.Void> arg0,
                    ffi.Pointer<objc.ObjCObject> arg1,
                    ffi.Pointer<objc.ObjCObject> arg2)>>()
        .asFunction<
            void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>()(arg0, arg1, arg2);
ffi.Pointer<ffi.Void>
    _ObjCBlock_ffiVoid_ffiVoid_NSApplication_NSArray_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_ffiVoid_ffiVoid_NSApplication_NSArray_fnPtrTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_ffiVoid_NSApplication_NSArray_closureTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1,
        ffi.Pointer<objc.ObjCObject> arg2) =>
    (objc.getBlockClosure(block) as void Function(
        ffi.Pointer<ffi.Void>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>))(arg0, arg1, arg2);
ffi.Pointer<ffi.Void>
    _ObjCBlock_ffiVoid_ffiVoid_NSApplication_NSArray_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_ffiVoid_ffiVoid_NSApplication_NSArray_closureTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_ffiVoid_NSApplication_NSArray_listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObject> arg1,
    ffi.Pointer<objc.ObjCObject> arg2) {
  (objc.getBlockClosure(block) as void Function(
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObject>,
      ffi.Pointer<objc.ObjCObject>))(arg0, arg1, arg2);
  objc.objectRelease(block.cast());
}

ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_ffiVoid_NSApplication_NSArray_listenerCallable = ffi
        .NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>.listener(
        _ObjCBlock_ffiVoid_ffiVoid_NSApplication_NSArray_listenerTrampoline)
      ..keepIsolateAlive = false;
void _ObjCBlock_ffiVoid_ffiVoid_NSApplication_NSArray_blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObject> arg1,
    ffi.Pointer<objc.ObjCObject> arg2) {
  try {
    (objc.getBlockClosure(block) as void Function(
        ffi.Pointer<ffi.Void>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>))(arg0, arg1, arg2);
  } catch (e) {
  } finally {
    objc.signalWaiter(waiter);
    objc.objectRelease(block.cast());
  }
}

ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_ffiVoid_NSApplication_NSArray_blockingCallable = ffi
        .NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>.isolateLocal(
        _ObjCBlock_ffiVoid_ffiVoid_NSApplication_NSArray_blockingTrampoline)
      ..keepIsolateAlive = false;
ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_ffiVoid_NSApplication_NSArray_blockingListenerCallable =
    ffi.NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>.listener(
        _ObjCBlock_ffiVoid_ffiVoid_NSApplication_NSArray_blockingTrampoline)
      ..keepIsolateAlive = false;

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSApplication, objc.NSArray)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_NSApplication_NSArray {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
          ffi.Void Function(ffi.Pointer<ffi.Void>, NSApplication, objc.NSArray)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<
              ffi.Void Function(ffi.Pointer<ffi.Void>, NSApplication,
                  objc.NSArray)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc
      .ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSApplication, objc.NSArray)>
      fromFunctionPointer(
              ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1, ffi.Pointer<objc.ObjCObject> arg2)>>
                  ptr) =>
          objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSApplication, objc.NSArray)>(
              objc.newPointerBlock(
                  _ObjCBlock_ffiVoid_ffiVoid_NSApplication_NSArray_fnPtrCallable,
                  ptr.cast()),
              retain: false,
              release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSApplication, objc.NSArray)> fromFunction(
          void Function(ffi.Pointer<ffi.Void>, NSApplication, objc.NSArray) fn,
          {bool keepIsolateAlive = true}) =>
      objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSApplication, objc.NSArray)>(
          objc.newClosureBlock(
              _ObjCBlock_ffiVoid_ffiVoid_NSApplication_NSArray_closureCallable,
              (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1, ffi.Pointer<objc.ObjCObject> arg2) => fn(
                  arg0,
                  NSApplication.castFromPointer(arg1, retain: true, release: true),
                  objc.NSArray.castFromPointer(arg2, retain: true, release: true)),
              keepIsolateAlive),
          retain: false,
          release: true);

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
          ffi.Void Function(ffi.Pointer<ffi.Void>, NSApplication, objc.NSArray)>
      listener(
          void Function(ffi.Pointer<ffi.Void>, NSApplication, objc.NSArray) fn,
          {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_NSApplication_NSArray_listenerCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1,
                ffi.Pointer<objc.ObjCObject> arg2) =>
            fn(
                arg0,
                NSApplication.castFromPointer(arg1,
                    retain: false, release: true),
                objc.NSArray.castFromPointer(arg2,
                    retain: false, release: true)),
        keepIsolateAlive);
    final wrapper = _AuthenticationServicesMacOS_wrapListenerBlock_fjrv01(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
        ffi.Void Function(ffi.Pointer<ffi.Void>, NSApplication,
            objc.NSArray)>(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<
          ffi.Void Function(ffi.Pointer<ffi.Void>, NSApplication, objc.NSArray)>
      blocking(
          void Function(ffi.Pointer<ffi.Void>, NSApplication, objc.NSArray) fn,
          {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_NSApplication_NSArray_blockingCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1,
                ffi.Pointer<objc.ObjCObject> arg2) =>
            fn(
                arg0,
                NSApplication.castFromPointer(arg1,
                    retain: false, release: true),
                objc.NSArray.castFromPointer(arg2,
                    retain: false, release: true)),
        keepIsolateAlive);
    final rawListener = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_NSApplication_NSArray_blockingListenerCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1,
                ffi.Pointer<objc.ObjCObject> arg2) =>
            fn(
                arg0,
                NSApplication.castFromPointer(arg1,
                    retain: false, release: true),
                objc.NSArray.castFromPointer(arg2,
                    retain: false, release: true)),
        keepIsolateAlive);
    final wrapper = _AuthenticationServicesMacOS_wrapBlockingBlock_fjrv01(
        raw, rawListener, objc.objCContext);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
        ffi.Void Function(ffi.Pointer<ffi.Void>, NSApplication,
            objc.NSArray)>(wrapper, retain: false, release: true);
  }
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSApplication, objc.NSArray)>`.
extension ObjCBlock_ffiVoid_ffiVoid_NSApplication_NSArray_CallExtension
    on objc.ObjCBlock<
        ffi.Void Function(ffi.Pointer<ffi.Void>, NSApplication, objc.NSArray)> {
  void call(
          ffi.Pointer<ffi.Void> arg0, NSApplication arg1, objc.NSArray arg2) =>
      ref.pointer.ref.invoke
              .cast<
                  ffi.NativeFunction<
                      ffi.Void Function(
                          ffi.Pointer<objc.ObjCBlockImpl> block,
                          ffi.Pointer<ffi.Void> arg0,
                          ffi.Pointer<objc.ObjCObject> arg1,
                          ffi.Pointer<objc.ObjCObject> arg2)>>()
              .asFunction<
                  void Function(
                      ffi.Pointer<objc.ObjCBlockImpl>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<objc.ObjCObject>,
                      ffi.Pointer<objc.ObjCObject>)>()(
          ref.pointer, arg0, arg1.ref.pointer, arg2.ref.pointer);
}

late final _sel_application_openFile_ =
    objc.registerName("application:openFile:");
bool _ObjCBlock_bool_ffiVoid_NSApplication_NSString_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1,
        ffi.Pointer<objc.ObjCObject> arg2) =>
    block.ref.target
        .cast<
            ffi.NativeFunction<
                ffi.Bool Function(
                    ffi.Pointer<ffi.Void> arg0,
                    ffi.Pointer<objc.ObjCObject> arg1,
                    ffi.Pointer<objc.ObjCObject> arg2)>>()
        .asFunction<
            bool Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>()(arg0, arg1, arg2);
ffi.Pointer<ffi.Void>
    _ObjCBlock_bool_ffiVoid_NSApplication_NSString_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Bool Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_bool_ffiVoid_NSApplication_NSString_fnPtrTrampoline,
            false)
        .cast();
bool _ObjCBlock_bool_ffiVoid_NSApplication_NSString_closureTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1,
        ffi.Pointer<objc.ObjCObject> arg2) =>
    (objc.getBlockClosure(block) as bool Function(
        ffi.Pointer<ffi.Void>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>))(arg0, arg1, arg2);
ffi.Pointer<ffi.Void>
    _ObjCBlock_bool_ffiVoid_NSApplication_NSString_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Bool Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_bool_ffiVoid_NSApplication_NSString_closureTrampoline,
            false)
        .cast();

/// Construction methods for `objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>, NSApplication, objc.NSString)>`.
abstract final class ObjCBlock_bool_ffiVoid_NSApplication_NSString {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
          ffi.Bool Function(
              ffi.Pointer<ffi.Void>, NSApplication, objc.NSString)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<
              ffi.Bool Function(ffi.Pointer<ffi.Void>, NSApplication,
                  objc.NSString)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc
      .ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>, NSApplication, objc.NSString)>
      fromFunctionPointer(
              ffi.Pointer<ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1, ffi.Pointer<objc.ObjCObject> arg2)>>
                  ptr) =>
          objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>, NSApplication, objc.NSString)>(
              objc.newPointerBlock(
                  _ObjCBlock_bool_ffiVoid_NSApplication_NSString_fnPtrCallable,
                  ptr.cast()),
              retain: false,
              release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>, NSApplication, objc.NSString)> fromFunction(
          bool Function(ffi.Pointer<ffi.Void>, NSApplication, objc.NSString) fn,
          {bool keepIsolateAlive = true}) =>
      objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>, NSApplication, objc.NSString)>(
          objc.newClosureBlock(
              _ObjCBlock_bool_ffiVoid_NSApplication_NSString_closureCallable,
              (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1, ffi.Pointer<objc.ObjCObject> arg2) => fn(
                  arg0,
                  NSApplication.castFromPointer(arg1, retain: true, release: true),
                  objc.NSString.castFromPointer(arg2, retain: true, release: true)),
              keepIsolateAlive),
          retain: false,
          release: true);
}

/// Call operator for `objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>, NSApplication, objc.NSString)>`.
extension ObjCBlock_bool_ffiVoid_NSApplication_NSString_CallExtension
    on objc.ObjCBlock<
        ffi.Bool Function(
            ffi.Pointer<ffi.Void>, NSApplication, objc.NSString)> {
  bool call(
          ffi.Pointer<ffi.Void> arg0, NSApplication arg1, objc.NSString arg2) =>
      ref.pointer.ref.invoke
              .cast<
                  ffi.NativeFunction<
                      ffi.Bool Function(
                          ffi.Pointer<objc.ObjCBlockImpl> block,
                          ffi.Pointer<ffi.Void> arg0,
                          ffi.Pointer<objc.ObjCObject> arg1,
                          ffi.Pointer<objc.ObjCObject> arg2)>>()
              .asFunction<
                  bool Function(
                      ffi.Pointer<objc.ObjCBlockImpl>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<objc.ObjCObject>,
                      ffi.Pointer<objc.ObjCObject>)>()(
          ref.pointer, arg0, arg1.ref.pointer, arg2.ref.pointer);
}

late final _sel_application_openFiles_ =
    objc.registerName("application:openFiles:");
late final _sel_application_openTempFile_ =
    objc.registerName("application:openTempFile:");
late final _sel_applicationShouldOpenUntitledFile_ =
    objc.registerName("applicationShouldOpenUntitledFile:");
bool _ObjCBlock_bool_ffiVoid_NSApplication_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1) =>
    block.ref.target
        .cast<
            ffi.NativeFunction<
                ffi.Bool Function(ffi.Pointer<ffi.Void> arg0,
                    ffi.Pointer<objc.ObjCObject> arg1)>>()
        .asFunction<
            bool Function(ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>)>()(arg0, arg1);
ffi.Pointer<ffi.Void> _ObjCBlock_bool_ffiVoid_NSApplication_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Bool Function(ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_bool_ffiVoid_NSApplication_fnPtrTrampoline, false)
        .cast();
bool _ObjCBlock_bool_ffiVoid_NSApplication_closureTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1) =>
    (objc.getBlockClosure(block) as bool Function(
        ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>))(arg0, arg1);
ffi.Pointer<ffi.Void> _ObjCBlock_bool_ffiVoid_NSApplication_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Bool Function(ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_bool_ffiVoid_NSApplication_closureTrampoline, false)
        .cast();

/// Construction methods for `objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>, NSApplication)>`.
abstract final class ObjCBlock_bool_ffiVoid_NSApplication {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>, NSApplication)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<
              ffi.Bool Function(ffi.Pointer<ffi.Void>,
                  NSApplication)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>, NSApplication)>
      fromFunctionPointer(
              ffi.Pointer<
                      ffi.NativeFunction<
                          ffi.Bool Function(ffi.Pointer<ffi.Void> arg0,
                              ffi.Pointer<objc.ObjCObject> arg1)>>
                  ptr) =>
          objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>, NSApplication)>(
              objc.newPointerBlock(_ObjCBlock_bool_ffiVoid_NSApplication_fnPtrCallable, ptr.cast()),
              retain: false,
              release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
      ffi.Bool Function(ffi.Pointer<ffi.Void>, NSApplication)> fromFunction(
          bool Function(ffi.Pointer<ffi.Void>, NSApplication) fn,
          {bool keepIsolateAlive = true}) =>
      objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>, NSApplication)>(
          objc.newClosureBlock(
              _ObjCBlock_bool_ffiVoid_NSApplication_closureCallable,
              (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1) =>
                  fn(arg0, NSApplication.castFromPointer(arg1, retain: true, release: true)),
              keepIsolateAlive),
          retain: false,
          release: true);
}

/// Call operator for `objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>, NSApplication)>`.
extension ObjCBlock_bool_ffiVoid_NSApplication_CallExtension
    on objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>, NSApplication)> {
  bool call(ffi.Pointer<ffi.Void> arg0, NSApplication arg1) =>
      ref.pointer.ref.invoke
              .cast<
                  ffi.NativeFunction<
                      ffi.Bool Function(
                          ffi.Pointer<objc.ObjCBlockImpl> block,
                          ffi.Pointer<ffi.Void> arg0,
                          ffi.Pointer<objc.ObjCObject> arg1)>>()
              .asFunction<
                  bool Function(ffi.Pointer<objc.ObjCBlockImpl>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>()(
          ref.pointer, arg0, arg1.ref.pointer);
}

late final _sel_applicationOpenUntitledFile_ =
    objc.registerName("applicationOpenUntitledFile:");
late final _sel_application_openFileWithoutUI_ =
    objc.registerName("application:openFileWithoutUI:");
bool _ObjCBlock_bool_ffiVoid_objcObjCObject_NSString_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1,
        ffi.Pointer<objc.ObjCObject> arg2) =>
    block.ref.target
        .cast<
            ffi.NativeFunction<
                ffi.Bool Function(
                    ffi.Pointer<ffi.Void> arg0,
                    ffi.Pointer<objc.ObjCObject> arg1,
                    ffi.Pointer<objc.ObjCObject> arg2)>>()
        .asFunction<
            bool Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>()(arg0, arg1, arg2);
ffi.Pointer<ffi.Void>
    _ObjCBlock_bool_ffiVoid_objcObjCObject_NSString_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Bool Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_bool_ffiVoid_objcObjCObject_NSString_fnPtrTrampoline,
            false)
        .cast();
bool _ObjCBlock_bool_ffiVoid_objcObjCObject_NSString_closureTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1,
        ffi.Pointer<objc.ObjCObject> arg2) =>
    (objc.getBlockClosure(block) as bool Function(
        ffi.Pointer<ffi.Void>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>))(arg0, arg1, arg2);
ffi.Pointer<ffi.Void>
    _ObjCBlock_bool_ffiVoid_objcObjCObject_NSString_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Bool Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_bool_ffiVoid_objcObjCObject_NSString_closureTrampoline,
            false)
        .cast();

/// Construction methods for `objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>, objc.NSString)>`.
abstract final class ObjCBlock_bool_ffiVoid_objcObjCObject_NSString {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
          ffi.Bool Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>,
              objc.NSString)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<
              ffi.Bool Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<objc.ObjCObject>,
                  objc.NSString)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc
      .ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>, objc.NSString)>
      fromFunctionPointer(ffi.Pointer<ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1, ffi.Pointer<objc.ObjCObject> arg2)>> ptr) =>
          objc.ObjCBlock<
                  ffi.Bool Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<objc.ObjCObject>, objc.NSString)>(
              objc.newPointerBlock(
                  _ObjCBlock_bool_ffiVoid_objcObjCObject_NSString_fnPtrCallable,
                  ptr.cast()),
              retain: false,
              release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>, objc.NSString)>
      fromFunction(bool Function(ffi.Pointer<ffi.Void>, objc.ObjCObjectBase, objc.NSString) fn,
              {bool keepIsolateAlive = true}) =>
          objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>, objc.NSString)>(
              objc.newClosureBlock(
                  _ObjCBlock_bool_ffiVoid_objcObjCObject_NSString_closureCallable,
                  (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1, ffi.Pointer<objc.ObjCObject> arg2) => fn(
                      arg0,
                      objc.ObjCObjectBase(arg1, retain: true, release: true),
                      objc.NSString.castFromPointer(arg2, retain: true, release: true)),
                  keepIsolateAlive),
              retain: false,
              release: true);
}

/// Call operator for `objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>, objc.NSString)>`.
extension ObjCBlock_bool_ffiVoid_objcObjCObject_NSString_CallExtension
    on objc.ObjCBlock<
        ffi.Bool Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>,
            objc.NSString)> {
  bool call(ffi.Pointer<ffi.Void> arg0, objc.ObjCObjectBase arg1,
          objc.NSString arg2) =>
      ref.pointer.ref.invoke
              .cast<
                  ffi.NativeFunction<
                      ffi.Bool Function(
                          ffi.Pointer<objc.ObjCBlockImpl> block,
                          ffi.Pointer<ffi.Void> arg0,
                          ffi.Pointer<objc.ObjCObject> arg1,
                          ffi.Pointer<objc.ObjCObject> arg2)>>()
              .asFunction<
                  bool Function(
                      ffi.Pointer<objc.ObjCBlockImpl>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<objc.ObjCObject>,
                      ffi.Pointer<objc.ObjCObject>)>()(
          ref.pointer, arg0, arg1.ref.pointer, arg2.ref.pointer);
}

late final _sel_application_printFile_ =
    objc.registerName("application:printFile:");
late final _sel_application_printFiles_withSettings_showPrintPanels_ =
    objc.registerName("application:printFiles:withSettings:showPrintPanels:");
int _ObjCBlock_NSApplicationPrintReply_ffiVoid_NSApplication_NSArray_objcObjCObject_bool_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1,
        ffi.Pointer<objc.ObjCObject> arg2,
        ffi.Pointer<objc.ObjCObject> arg3,
        bool arg4) =>
    block.ref.target
        .cast<
            ffi.NativeFunction<
                ffi.UnsignedLong Function(
                    ffi.Pointer<ffi.Void> arg0,
                    ffi.Pointer<objc.ObjCObject> arg1,
                    ffi.Pointer<objc.ObjCObject> arg2,
                    ffi.Pointer<objc.ObjCObject> arg3,
                    ffi.Bool arg4)>>()
        .asFunction<
            int Function(
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                bool)>()(arg0, arg1, arg2, arg3, arg4);
ffi.Pointer<ffi.Void>
    _ObjCBlock_NSApplicationPrintReply_ffiVoid_NSApplication_NSArray_objcObjCObject_bool_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.UnsignedLong Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Bool)>(
            _ObjCBlock_NSApplicationPrintReply_ffiVoid_NSApplication_NSArray_objcObjCObject_bool_fnPtrTrampoline,
            0)
        .cast();
int _ObjCBlock_NSApplicationPrintReply_ffiVoid_NSApplication_NSArray_objcObjCObject_bool_closureTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1,
        ffi.Pointer<objc.ObjCObject> arg2,
        ffi.Pointer<objc.ObjCObject> arg3,
        bool arg4) =>
    (objc.getBlockClosure(block) as int Function(
        ffi.Pointer<ffi.Void>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>,
        bool))(arg0, arg1, arg2, arg3, arg4);
ffi.Pointer<ffi.Void>
    _ObjCBlock_NSApplicationPrintReply_ffiVoid_NSApplication_NSArray_objcObjCObject_bool_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.UnsignedLong Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Bool)>(
            _ObjCBlock_NSApplicationPrintReply_ffiVoid_NSApplication_NSArray_objcObjCObject_bool_closureTrampoline,
            0)
        .cast();

/// Construction methods for `objc.ObjCBlock<ffi.UnsignedLong Function(ffi.Pointer<ffi.Void>, NSApplication, objc.NSArray, ffi.Pointer<objc.ObjCObject>, ffi.Bool)>`.
abstract final class ObjCBlock_NSApplicationPrintReply_ffiVoid_NSApplication_NSArray_objcObjCObject_bool {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
          ffi.UnsignedLong Function(ffi.Pointer<ffi.Void>, NSApplication,
              objc.NSArray, ffi.Pointer<objc.ObjCObject>, ffi.Bool)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<
              ffi.UnsignedLong Function(
                  ffi.Pointer<ffi.Void>,
                  NSApplication,
                  objc.NSArray,
                  ffi.Pointer<objc.ObjCObject>,
                  ffi.Bool)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
          ffi.UnsignedLong Function(ffi.Pointer<ffi.Void>, NSApplication,
              objc.NSArray, ffi.Pointer<objc.ObjCObject>, ffi.Bool)>
      fromFunctionPointer(ffi.Pointer<ffi.NativeFunction<ffi.UnsignedLong Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1, ffi.Pointer<objc.ObjCObject> arg2, ffi.Pointer<objc.ObjCObject> arg3, ffi.Bool arg4)>> ptr) =>
          objc.ObjCBlock<
                  ffi.UnsignedLong Function(
                      ffi.Pointer<ffi.Void>,
                      NSApplication,
                      objc.NSArray,
                      ffi.Pointer<objc.ObjCObject>,
                      ffi.Bool)>(
              objc.newPointerBlock(_ObjCBlock_NSApplicationPrintReply_ffiVoid_NSApplication_NSArray_objcObjCObject_bool_fnPtrCallable, ptr.cast()),
              retain: false,
              release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc
      .ObjCBlock<ffi.UnsignedLong Function(ffi.Pointer<ffi.Void>, NSApplication, objc.NSArray, ffi.Pointer<objc.ObjCObject>, ffi.Bool)>
      fromFunction(NSApplicationPrintReply Function(ffi.Pointer<ffi.Void>, NSApplication, objc.NSArray, objc.ObjCObjectBase, bool) fn,
              {bool keepIsolateAlive = true}) =>
          objc.ObjCBlock<ffi.UnsignedLong Function(ffi.Pointer<ffi.Void>, NSApplication, objc.NSArray, ffi.Pointer<objc.ObjCObject>, ffi.Bool)>(
              objc.newClosureBlock(
                  _ObjCBlock_NSApplicationPrintReply_ffiVoid_NSApplication_NSArray_objcObjCObject_bool_closureCallable,
                  (ffi.Pointer<ffi.Void> arg0,
                          ffi.Pointer<objc.ObjCObject> arg1,
                          ffi.Pointer<objc.ObjCObject> arg2,
                          ffi.Pointer<objc.ObjCObject> arg3,
                          bool arg4) =>
                      fn(arg0, NSApplication.castFromPointer(arg1, retain: true, release: true), objc.NSArray.castFromPointer(arg2, retain: true, release: true), objc.ObjCObjectBase(arg3, retain: true, release: true), arg4).value,
                  keepIsolateAlive),
              retain: false,
              release: true);
}

/// Call operator for `objc.ObjCBlock<ffi.UnsignedLong Function(ffi.Pointer<ffi.Void>, NSApplication, objc.NSArray, ffi.Pointer<objc.ObjCObject>, ffi.Bool)>`.
extension ObjCBlock_NSApplicationPrintReply_ffiVoid_NSApplication_NSArray_objcObjCObject_bool_CallExtension
    on objc.ObjCBlock<
        ffi.UnsignedLong Function(ffi.Pointer<ffi.Void>, NSApplication,
            objc.NSArray, ffi.Pointer<objc.ObjCObject>, ffi.Bool)> {
  NSApplicationPrintReply call(ffi.Pointer<ffi.Void> arg0, NSApplication arg1,
          objc.NSArray arg2, objc.ObjCObjectBase arg3, bool arg4) =>
      NSApplicationPrintReply.fromValue(ref.pointer.ref.invoke
          .cast<
              ffi.NativeFunction<
                  ffi.UnsignedLong Function(
                      ffi.Pointer<objc.ObjCBlockImpl> block,
                      ffi.Pointer<ffi.Void> arg0,
                      ffi.Pointer<objc.ObjCObject> arg1,
                      ffi.Pointer<objc.ObjCObject> arg2,
                      ffi.Pointer<objc.ObjCObject> arg3,
                      ffi.Bool arg4)>>()
          .asFunction<
              int Function(
                  ffi.Pointer<objc.ObjCBlockImpl>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<objc.ObjCObject>,
                  ffi.Pointer<objc.ObjCObject>,
                  ffi.Pointer<objc.ObjCObject>,
                  bool)>()(ref.pointer, arg0, arg1.ref.pointer, arg2.ref.pointer, arg3.ref.pointer, arg4));
}

late final _sel_applicationShouldTerminateAfterLastWindowClosed_ =
    objc.registerName("applicationShouldTerminateAfterLastWindowClosed:");
late final _sel_applicationShouldHandleReopen_hasVisibleWindows_ =
    objc.registerName("applicationShouldHandleReopen:hasVisibleWindows:");
bool _ObjCBlock_bool_ffiVoid_NSApplication_bool_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1,
        bool arg2) =>
    block.ref.target
        .cast<
            ffi.NativeFunction<
                ffi.Bool Function(ffi.Pointer<ffi.Void> arg0,
                    ffi.Pointer<objc.ObjCObject> arg1, ffi.Bool arg2)>>()
        .asFunction<
            bool Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>,
                bool)>()(arg0, arg1, arg2);
ffi.Pointer<ffi.Void> _ObjCBlock_bool_ffiVoid_NSApplication_bool_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Bool Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Bool)>(
            _ObjCBlock_bool_ffiVoid_NSApplication_bool_fnPtrTrampoline, false)
        .cast();
bool _ObjCBlock_bool_ffiVoid_NSApplication_bool_closureTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1,
        bool arg2) =>
    (objc.getBlockClosure(block) as bool Function(ffi.Pointer<ffi.Void>,
        ffi.Pointer<objc.ObjCObject>, bool))(arg0, arg1, arg2);
ffi.Pointer<ffi.Void>
    _ObjCBlock_bool_ffiVoid_NSApplication_bool_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Bool Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Bool)>(
            _ObjCBlock_bool_ffiVoid_NSApplication_bool_closureTrampoline, false)
        .cast();

/// Construction methods for `objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>, NSApplication, ffi.Bool)>`.
abstract final class ObjCBlock_bool_ffiVoid_NSApplication_bool {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
          ffi.Bool Function(ffi.Pointer<ffi.Void>, NSApplication, ffi.Bool)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<
              ffi.Bool Function(ffi.Pointer<ffi.Void>, NSApplication,
                  ffi.Bool)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc
      .ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>, NSApplication, ffi.Bool)>
      fromFunctionPointer(
              ffi.Pointer<ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1, ffi.Bool arg2)>>
                  ptr) =>
          objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>, NSApplication, ffi.Bool)>(
              objc.newPointerBlock(
                  _ObjCBlock_bool_ffiVoid_NSApplication_bool_fnPtrCallable,
                  ptr.cast()),
              retain: false,
              release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc
      .ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>, NSApplication, ffi.Bool)>
      fromFunction(bool Function(ffi.Pointer<ffi.Void>, NSApplication, bool) fn,
              {bool keepIsolateAlive = true}) =>
          objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>, NSApplication, ffi.Bool)>(
              objc.newClosureBlock(
                  _ObjCBlock_bool_ffiVoid_NSApplication_bool_closureCallable,
                  (ffi.Pointer<ffi.Void> arg0,
                          ffi.Pointer<objc.ObjCObject> arg1, bool arg2) =>
                      fn(arg0, NSApplication.castFromPointer(arg1, retain: true, release: true), arg2),
                  keepIsolateAlive),
              retain: false,
              release: true);
}

/// Call operator for `objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>, NSApplication, ffi.Bool)>`.
extension ObjCBlock_bool_ffiVoid_NSApplication_bool_CallExtension
    on objc.ObjCBlock<
        ffi.Bool Function(ffi.Pointer<ffi.Void>, NSApplication, ffi.Bool)> {
  bool call(ffi.Pointer<ffi.Void> arg0, NSApplication arg1, bool arg2) =>
      ref.pointer.ref.invoke
          .cast<
              ffi.NativeFunction<
                  ffi.Bool Function(
                      ffi.Pointer<objc.ObjCBlockImpl> block,
                      ffi.Pointer<ffi.Void> arg0,
                      ffi.Pointer<objc.ObjCObject> arg1,
                      ffi.Bool arg2)>>()
          .asFunction<
              bool Function(
                  ffi.Pointer<objc.ObjCBlockImpl>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<objc.ObjCObject>,
                  bool)>()(ref.pointer, arg0, arg1.ref.pointer, arg2);
}

late final _sel_applicationDockMenu_ =
    objc.registerName("applicationDockMenu:");
typedef instancetype = ffi.Pointer<objc.ObjCObject>;
typedef Dartinstancetype = objc.ObjCObjectBase;
ffi.Pointer<objc.ObjCObject>
    _ObjCBlock_NSMenu_ffiVoid_NSApplication_fnPtrTrampoline(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObject> arg1) =>
        block.ref.target
            .cast<
                ffi.NativeFunction<
                    ffi.Pointer<objc.ObjCObject> Function(
                        ffi.Pointer<ffi.Void> arg0,
                        ffi.Pointer<objc.ObjCObject> arg1)>>()
            .asFunction<
                ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>,
                    ffi.Pointer<objc.ObjCObject>)>()(arg0, arg1);
ffi.Pointer<ffi.Void> _ObjCBlock_NSMenu_ffiVoid_NSApplication_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>,
                    ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_NSMenu_ffiVoid_NSApplication_fnPtrTrampoline)
        .cast();
ffi.Pointer<objc.ObjCObject>
    _ObjCBlock_NSMenu_ffiVoid_NSApplication_closureTrampoline(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObject> arg1) =>
        (objc.getBlockClosure(block) as ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>))(arg0, arg1);
ffi.Pointer<ffi.Void> _ObjCBlock_NSMenu_ffiVoid_NSApplication_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>,
                    ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_NSMenu_ffiVoid_NSApplication_closureTrampoline)
        .cast();

/// Construction methods for `objc.ObjCBlock<NSMenu? Function(ffi.Pointer<ffi.Void>, NSApplication)>`.
abstract final class ObjCBlock_NSMenu_ffiVoid_NSApplication {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<NSMenu? Function(ffi.Pointer<ffi.Void>, NSApplication)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<
              NSMenu? Function(ffi.Pointer<ffi.Void>,
                  NSApplication)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<NSMenu? Function(ffi.Pointer<ffi.Void>, NSApplication)> fromFunctionPointer(
          ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Pointer<objc.ObjCObject> Function(
                          ffi.Pointer<ffi.Void> arg0,
                          ffi.Pointer<objc.ObjCObject> arg1)>>
              ptr) =>
      objc.ObjCBlock<NSMenu? Function(ffi.Pointer<ffi.Void>, NSApplication)>(
          objc.newPointerBlock(
              _ObjCBlock_NSMenu_ffiVoid_NSApplication_fnPtrCallable, ptr.cast()),
          retain: false,
          release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<NSMenu? Function(ffi.Pointer<ffi.Void>, NSApplication)>
      fromFunction(NSMenu? Function(ffi.Pointer<ffi.Void>, NSApplication) fn,
              {bool keepIsolateAlive = true}) =>
          objc.ObjCBlock<NSMenu? Function(ffi.Pointer<ffi.Void>, NSApplication)>(
              objc.newClosureBlock(
                  _ObjCBlock_NSMenu_ffiVoid_NSApplication_closureCallable,
                  (ffi.Pointer<ffi.Void> arg0,
                          ffi.Pointer<objc.ObjCObject> arg1) =>
                      fn(arg0, NSApplication.castFromPointer(arg1, retain: true, release: true))
                          ?.ref
                          .retainAndAutorelease() ??
                      ffi.nullptr,
                  keepIsolateAlive),
              retain: false,
              release: true);
}

/// Call operator for `objc.ObjCBlock<NSMenu? Function(ffi.Pointer<ffi.Void>, NSApplication)>`.
extension ObjCBlock_NSMenu_ffiVoid_NSApplication_CallExtension
    on objc.ObjCBlock<NSMenu? Function(ffi.Pointer<ffi.Void>, NSApplication)> {
  NSMenu? call(ffi.Pointer<ffi.Void> arg0, NSApplication arg1) => ref
              .pointer.ref.invoke
              .cast<
                  ffi.NativeFunction<
                      ffi.Pointer<objc.ObjCObject> Function(
                          ffi.Pointer<objc.ObjCBlockImpl> block,
                          ffi.Pointer<ffi.Void> arg0,
                          ffi.Pointer<objc.ObjCObject> arg1)>>()
              .asFunction<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>()
              (ref.pointer, arg0, arg1.ref.pointer)
              .address ==
          0
      ? null
      : NSMenu.castFromPointer(
          ref.pointer.ref.invoke
              .cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1)>>()
              .asFunction<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>()(ref.pointer, arg0, arg1.ref.pointer),
          retain: true,
          release: true);
}

late final _sel_application_willPresentError_ =
    objc.registerName("application:willPresentError:");
ffi.Pointer<objc.ObjCObject>
    _ObjCBlock_NSError_ffiVoid_NSApplication_NSError_fnPtrTrampoline(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObject> arg1,
            ffi.Pointer<objc.ObjCObject> arg2) =>
        block.ref.target
            .cast<
                ffi.NativeFunction<
                    ffi.Pointer<objc.ObjCObject> Function(
                        ffi.Pointer<ffi.Void> arg0,
                        ffi.Pointer<objc.ObjCObject> arg1,
                        ffi.Pointer<objc.ObjCObject> arg2)>>()
            .asFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<ffi.Void>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>)>()(arg0, arg1, arg2);
ffi.Pointer<ffi.Void>
    _ObjCBlock_NSError_ffiVoid_NSApplication_NSError_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_NSError_ffiVoid_NSApplication_NSError_fnPtrTrampoline)
        .cast();
ffi.Pointer<objc.ObjCObject>
    _ObjCBlock_NSError_ffiVoid_NSApplication_NSError_closureTrampoline(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObject> arg1,
            ffi.Pointer<objc.ObjCObject> arg2) =>
        (objc.getBlockClosure(block) as ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>))(arg0, arg1, arg2);
ffi.Pointer<ffi.Void>
    _ObjCBlock_NSError_ffiVoid_NSApplication_NSError_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_NSError_ffiVoid_NSApplication_NSError_closureTrampoline)
        .cast();

/// Construction methods for `objc.ObjCBlock<objc.NSError Function(ffi.Pointer<ffi.Void>, NSApplication, objc.NSError)>`.
abstract final class ObjCBlock_NSError_ffiVoid_NSApplication_NSError {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
          objc.NSError Function(
              ffi.Pointer<ffi.Void>, NSApplication, objc.NSError)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<
              objc.NSError Function(ffi.Pointer<ffi.Void>, NSApplication,
                  objc.NSError)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc
      .ObjCBlock<objc.NSError Function(ffi.Pointer<ffi.Void>, NSApplication, objc.NSError)>
      fromFunctionPointer(ffi.Pointer<ffi.NativeFunction<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1, ffi.Pointer<objc.ObjCObject> arg2)>> ptr) =>
          objc.ObjCBlock<
                  objc.NSError Function(
                      ffi.Pointer<ffi.Void>, NSApplication, objc.NSError)>(
              objc.newPointerBlock(
                  _ObjCBlock_NSError_ffiVoid_NSApplication_NSError_fnPtrCallable,
                  ptr.cast()),
              retain: false,
              release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<objc.NSError Function(ffi.Pointer<ffi.Void>, NSApplication, objc.NSError)>
      fromFunction(objc.NSError Function(ffi.Pointer<ffi.Void>, NSApplication, objc.NSError) fn,
              {bool keepIsolateAlive = true}) =>
          objc.ObjCBlock<objc.NSError Function(ffi.Pointer<ffi.Void>, NSApplication, objc.NSError)>(
              objc.newClosureBlock(
                  _ObjCBlock_NSError_ffiVoid_NSApplication_NSError_closureCallable,
                  (ffi.Pointer<ffi.Void> arg0,
                          ffi.Pointer<objc.ObjCObject> arg1,
                          ffi.Pointer<objc.ObjCObject> arg2) =>
                      fn(arg0, NSApplication.castFromPointer(arg1, retain: true, release: true), objc.NSError.castFromPointer(arg2, retain: true, release: true))
                          .ref
                          .retainAndAutorelease(),
                  keepIsolateAlive),
              retain: false,
              release: true);
}

/// Call operator for `objc.ObjCBlock<objc.NSError Function(ffi.Pointer<ffi.Void>, NSApplication, objc.NSError)>`.
extension ObjCBlock_NSError_ffiVoid_NSApplication_NSError_CallExtension
    on objc.ObjCBlock<
        objc.NSError Function(
            ffi.Pointer<ffi.Void>, NSApplication, objc.NSError)> {
  objc.NSError call(
          ffi.Pointer<ffi.Void> arg0, NSApplication arg1, objc.NSError arg2) =>
      objc.NSError.castFromPointer(
          ref.pointer.ref.invoke
              .cast<
                  ffi.NativeFunction<
                      ffi.Pointer<objc.ObjCObject> Function(
                          ffi.Pointer<objc.ObjCBlockImpl> block,
                          ffi.Pointer<ffi.Void> arg0,
                          ffi.Pointer<objc.ObjCObject> arg1,
                          ffi.Pointer<objc.ObjCObject> arg2)>>()
              .asFunction<
                  ffi.Pointer<objc.ObjCObject> Function(
                      ffi.Pointer<objc.ObjCBlockImpl>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<objc.ObjCObject>,
                      ffi.Pointer<objc.ObjCObject>)>()(ref.pointer, arg0, arg1.ref.pointer, arg2.ref.pointer),
          retain: true,
          release: true);
}

late final _sel_application_didRegisterForRemoteNotificationsWithDeviceToken_ =
    objc.registerName(
        "application:didRegisterForRemoteNotificationsWithDeviceToken:");
void _ObjCBlock_ffiVoid_ffiVoid_NSApplication_NSData_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1,
        ffi.Pointer<objc.ObjCObject> arg2) =>
    block.ref.target
        .cast<
            ffi.NativeFunction<
                ffi.Void Function(
                    ffi.Pointer<ffi.Void> arg0,
                    ffi.Pointer<objc.ObjCObject> arg1,
                    ffi.Pointer<objc.ObjCObject> arg2)>>()
        .asFunction<
            void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>()(arg0, arg1, arg2);
ffi.Pointer<ffi.Void>
    _ObjCBlock_ffiVoid_ffiVoid_NSApplication_NSData_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_ffiVoid_ffiVoid_NSApplication_NSData_fnPtrTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_ffiVoid_NSApplication_NSData_closureTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1,
        ffi.Pointer<objc.ObjCObject> arg2) =>
    (objc.getBlockClosure(block) as void Function(
        ffi.Pointer<ffi.Void>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>))(arg0, arg1, arg2);
ffi.Pointer<ffi.Void>
    _ObjCBlock_ffiVoid_ffiVoid_NSApplication_NSData_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_ffiVoid_ffiVoid_NSApplication_NSData_closureTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_ffiVoid_NSApplication_NSData_listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObject> arg1,
    ffi.Pointer<objc.ObjCObject> arg2) {
  (objc.getBlockClosure(block) as void Function(
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObject>,
      ffi.Pointer<objc.ObjCObject>))(arg0, arg1, arg2);
  objc.objectRelease(block.cast());
}

ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_ffiVoid_NSApplication_NSData_listenerCallable = ffi
        .NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>.listener(
        _ObjCBlock_ffiVoid_ffiVoid_NSApplication_NSData_listenerTrampoline)
      ..keepIsolateAlive = false;
void _ObjCBlock_ffiVoid_ffiVoid_NSApplication_NSData_blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObject> arg1,
    ffi.Pointer<objc.ObjCObject> arg2) {
  try {
    (objc.getBlockClosure(block) as void Function(
        ffi.Pointer<ffi.Void>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>))(arg0, arg1, arg2);
  } catch (e) {
  } finally {
    objc.signalWaiter(waiter);
    objc.objectRelease(block.cast());
  }
}

ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_ffiVoid_NSApplication_NSData_blockingCallable = ffi
        .NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>.isolateLocal(
        _ObjCBlock_ffiVoid_ffiVoid_NSApplication_NSData_blockingTrampoline)
      ..keepIsolateAlive = false;
ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_ffiVoid_NSApplication_NSData_blockingListenerCallable =
    ffi.NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>.listener(
        _ObjCBlock_ffiVoid_ffiVoid_NSApplication_NSData_blockingTrampoline)
      ..keepIsolateAlive = false;

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSApplication, objc.NSData)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_NSApplication_NSData {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
          ffi.Void Function(ffi.Pointer<ffi.Void>, NSApplication, objc.NSData)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<
              ffi.Void Function(ffi.Pointer<ffi.Void>, NSApplication,
                  objc.NSData)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc
      .ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSApplication, objc.NSData)>
      fromFunctionPointer(
              ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1, ffi.Pointer<objc.ObjCObject> arg2)>>
                  ptr) =>
          objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSApplication, objc.NSData)>(
              objc.newPointerBlock(
                  _ObjCBlock_ffiVoid_ffiVoid_NSApplication_NSData_fnPtrCallable,
                  ptr.cast()),
              retain: false,
              release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSApplication, objc.NSData)> fromFunction(
          void Function(ffi.Pointer<ffi.Void>, NSApplication, objc.NSData) fn,
          {bool keepIsolateAlive = true}) =>
      objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSApplication, objc.NSData)>(
          objc.newClosureBlock(
              _ObjCBlock_ffiVoid_ffiVoid_NSApplication_NSData_closureCallable,
              (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1, ffi.Pointer<objc.ObjCObject> arg2) => fn(
                  arg0,
                  NSApplication.castFromPointer(arg1, retain: true, release: true),
                  objc.NSData.castFromPointer(arg2, retain: true, release: true)),
              keepIsolateAlive),
          retain: false,
          release: true);

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
          ffi.Void Function(ffi.Pointer<ffi.Void>, NSApplication, objc.NSData)>
      listener(
          void Function(ffi.Pointer<ffi.Void>, NSApplication, objc.NSData) fn,
          {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_NSApplication_NSData_listenerCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1,
                ffi.Pointer<objc.ObjCObject> arg2) =>
            fn(
                arg0,
                NSApplication.castFromPointer(arg1,
                    retain: false, release: true),
                objc.NSData.castFromPointer(arg2,
                    retain: false, release: true)),
        keepIsolateAlive);
    final wrapper = _AuthenticationServicesMacOS_wrapListenerBlock_fjrv01(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
        ffi.Void Function(ffi.Pointer<ffi.Void>, NSApplication,
            objc.NSData)>(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<
          ffi.Void Function(ffi.Pointer<ffi.Void>, NSApplication, objc.NSData)>
      blocking(
          void Function(ffi.Pointer<ffi.Void>, NSApplication, objc.NSData) fn,
          {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_NSApplication_NSData_blockingCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1,
                ffi.Pointer<objc.ObjCObject> arg2) =>
            fn(
                arg0,
                NSApplication.castFromPointer(arg1,
                    retain: false, release: true),
                objc.NSData.castFromPointer(arg2,
                    retain: false, release: true)),
        keepIsolateAlive);
    final rawListener = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_NSApplication_NSData_blockingListenerCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1,
                ffi.Pointer<objc.ObjCObject> arg2) =>
            fn(
                arg0,
                NSApplication.castFromPointer(arg1,
                    retain: false, release: true),
                objc.NSData.castFromPointer(arg2,
                    retain: false, release: true)),
        keepIsolateAlive);
    final wrapper = _AuthenticationServicesMacOS_wrapBlockingBlock_fjrv01(
        raw, rawListener, objc.objCContext);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
        ffi.Void Function(ffi.Pointer<ffi.Void>, NSApplication,
            objc.NSData)>(wrapper, retain: false, release: true);
  }
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSApplication, objc.NSData)>`.
extension ObjCBlock_ffiVoid_ffiVoid_NSApplication_NSData_CallExtension
    on objc.ObjCBlock<
        ffi.Void Function(ffi.Pointer<ffi.Void>, NSApplication, objc.NSData)> {
  void call(ffi.Pointer<ffi.Void> arg0, NSApplication arg1, objc.NSData arg2) =>
      ref.pointer.ref.invoke
              .cast<
                  ffi.NativeFunction<
                      ffi.Void Function(
                          ffi.Pointer<objc.ObjCBlockImpl> block,
                          ffi.Pointer<ffi.Void> arg0,
                          ffi.Pointer<objc.ObjCObject> arg1,
                          ffi.Pointer<objc.ObjCObject> arg2)>>()
              .asFunction<
                  void Function(
                      ffi.Pointer<objc.ObjCBlockImpl>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<objc.ObjCObject>,
                      ffi.Pointer<objc.ObjCObject>)>()(
          ref.pointer, arg0, arg1.ref.pointer, arg2.ref.pointer);
}

late final _sel_application_didFailToRegisterForRemoteNotificationsWithError_ =
    objc.registerName(
        "application:didFailToRegisterForRemoteNotificationsWithError:");
void _ObjCBlock_ffiVoid_ffiVoid_NSApplication_NSError_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1,
        ffi.Pointer<objc.ObjCObject> arg2) =>
    block.ref.target
        .cast<
            ffi.NativeFunction<
                ffi.Void Function(
                    ffi.Pointer<ffi.Void> arg0,
                    ffi.Pointer<objc.ObjCObject> arg1,
                    ffi.Pointer<objc.ObjCObject> arg2)>>()
        .asFunction<
            void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>()(arg0, arg1, arg2);
ffi.Pointer<ffi.Void>
    _ObjCBlock_ffiVoid_ffiVoid_NSApplication_NSError_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_ffiVoid_ffiVoid_NSApplication_NSError_fnPtrTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_ffiVoid_NSApplication_NSError_closureTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1,
        ffi.Pointer<objc.ObjCObject> arg2) =>
    (objc.getBlockClosure(block) as void Function(
        ffi.Pointer<ffi.Void>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>))(arg0, arg1, arg2);
ffi.Pointer<ffi.Void>
    _ObjCBlock_ffiVoid_ffiVoid_NSApplication_NSError_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_ffiVoid_ffiVoid_NSApplication_NSError_closureTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_ffiVoid_NSApplication_NSError_listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObject> arg1,
    ffi.Pointer<objc.ObjCObject> arg2) {
  (objc.getBlockClosure(block) as void Function(
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObject>,
      ffi.Pointer<objc.ObjCObject>))(arg0, arg1, arg2);
  objc.objectRelease(block.cast());
}

ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_ffiVoid_NSApplication_NSError_listenerCallable = ffi
        .NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>.listener(
        _ObjCBlock_ffiVoid_ffiVoid_NSApplication_NSError_listenerTrampoline)
      ..keepIsolateAlive = false;
void _ObjCBlock_ffiVoid_ffiVoid_NSApplication_NSError_blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObject> arg1,
    ffi.Pointer<objc.ObjCObject> arg2) {
  try {
    (objc.getBlockClosure(block) as void Function(
        ffi.Pointer<ffi.Void>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>))(arg0, arg1, arg2);
  } catch (e) {
  } finally {
    objc.signalWaiter(waiter);
    objc.objectRelease(block.cast());
  }
}

ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_ffiVoid_NSApplication_NSError_blockingCallable = ffi
        .NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>.isolateLocal(
        _ObjCBlock_ffiVoid_ffiVoid_NSApplication_NSError_blockingTrampoline)
      ..keepIsolateAlive = false;
ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_ffiVoid_NSApplication_NSError_blockingListenerCallable =
    ffi.NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>.listener(
        _ObjCBlock_ffiVoid_ffiVoid_NSApplication_NSError_blockingTrampoline)
      ..keepIsolateAlive = false;

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSApplication, objc.NSError)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_NSApplication_NSError {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
          ffi.Void Function(ffi.Pointer<ffi.Void>, NSApplication, objc.NSError)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<
              ffi.Void Function(ffi.Pointer<ffi.Void>, NSApplication,
                  objc.NSError)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc
      .ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSApplication, objc.NSError)>
      fromFunctionPointer(
              ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1, ffi.Pointer<objc.ObjCObject> arg2)>>
                  ptr) =>
          objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSApplication, objc.NSError)>(
              objc.newPointerBlock(
                  _ObjCBlock_ffiVoid_ffiVoid_NSApplication_NSError_fnPtrCallable,
                  ptr.cast()),
              retain: false,
              release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSApplication, objc.NSError)> fromFunction(
          void Function(ffi.Pointer<ffi.Void>, NSApplication, objc.NSError) fn,
          {bool keepIsolateAlive = true}) =>
      objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSApplication, objc.NSError)>(
          objc.newClosureBlock(
              _ObjCBlock_ffiVoid_ffiVoid_NSApplication_NSError_closureCallable,
              (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1, ffi.Pointer<objc.ObjCObject> arg2) => fn(
                  arg0,
                  NSApplication.castFromPointer(arg1, retain: true, release: true),
                  objc.NSError.castFromPointer(arg2, retain: true, release: true)),
              keepIsolateAlive),
          retain: false,
          release: true);

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
          ffi.Void Function(ffi.Pointer<ffi.Void>, NSApplication, objc.NSError)>
      listener(
          void Function(ffi.Pointer<ffi.Void>, NSApplication, objc.NSError) fn,
          {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_NSApplication_NSError_listenerCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1,
                ffi.Pointer<objc.ObjCObject> arg2) =>
            fn(
                arg0,
                NSApplication.castFromPointer(arg1,
                    retain: false, release: true),
                objc.NSError.castFromPointer(arg2,
                    retain: false, release: true)),
        keepIsolateAlive);
    final wrapper = _AuthenticationServicesMacOS_wrapListenerBlock_fjrv01(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
        ffi.Void Function(ffi.Pointer<ffi.Void>, NSApplication,
            objc.NSError)>(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<
          ffi.Void Function(ffi.Pointer<ffi.Void>, NSApplication, objc.NSError)>
      blocking(
          void Function(ffi.Pointer<ffi.Void>, NSApplication, objc.NSError) fn,
          {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_NSApplication_NSError_blockingCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1,
                ffi.Pointer<objc.ObjCObject> arg2) =>
            fn(
                arg0,
                NSApplication.castFromPointer(arg1,
                    retain: false, release: true),
                objc.NSError.castFromPointer(arg2,
                    retain: false, release: true)),
        keepIsolateAlive);
    final rawListener = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_NSApplication_NSError_blockingListenerCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1,
                ffi.Pointer<objc.ObjCObject> arg2) =>
            fn(
                arg0,
                NSApplication.castFromPointer(arg1,
                    retain: false, release: true),
                objc.NSError.castFromPointer(arg2,
                    retain: false, release: true)),
        keepIsolateAlive);
    final wrapper = _AuthenticationServicesMacOS_wrapBlockingBlock_fjrv01(
        raw, rawListener, objc.objCContext);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
        ffi.Void Function(ffi.Pointer<ffi.Void>, NSApplication,
            objc.NSError)>(wrapper, retain: false, release: true);
  }
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSApplication, objc.NSError)>`.
extension ObjCBlock_ffiVoid_ffiVoid_NSApplication_NSError_CallExtension
    on objc.ObjCBlock<
        ffi.Void Function(ffi.Pointer<ffi.Void>, NSApplication, objc.NSError)> {
  void call(
          ffi.Pointer<ffi.Void> arg0, NSApplication arg1, objc.NSError arg2) =>
      ref.pointer.ref.invoke
              .cast<
                  ffi.NativeFunction<
                      ffi.Void Function(
                          ffi.Pointer<objc.ObjCBlockImpl> block,
                          ffi.Pointer<ffi.Void> arg0,
                          ffi.Pointer<objc.ObjCObject> arg1,
                          ffi.Pointer<objc.ObjCObject> arg2)>>()
              .asFunction<
                  void Function(
                      ffi.Pointer<objc.ObjCBlockImpl>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<objc.ObjCObject>,
                      ffi.Pointer<objc.ObjCObject>)>()(
          ref.pointer, arg0, arg1.ref.pointer, arg2.ref.pointer);
}

late final _sel_application_didReceiveRemoteNotification_ =
    objc.registerName("application:didReceiveRemoteNotification:");
void _ObjCBlock_ffiVoid_ffiVoid_NSApplication_objcObjCObject_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1,
        ffi.Pointer<objc.ObjCObject> arg2) =>
    block.ref.target
        .cast<
            ffi.NativeFunction<
                ffi.Void Function(
                    ffi.Pointer<ffi.Void> arg0,
                    ffi.Pointer<objc.ObjCObject> arg1,
                    ffi.Pointer<objc.ObjCObject> arg2)>>()
        .asFunction<
            void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>()(arg0, arg1, arg2);
ffi.Pointer<ffi.Void>
    _ObjCBlock_ffiVoid_ffiVoid_NSApplication_objcObjCObject_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_ffiVoid_ffiVoid_NSApplication_objcObjCObject_fnPtrTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_ffiVoid_NSApplication_objcObjCObject_closureTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1,
        ffi.Pointer<objc.ObjCObject> arg2) =>
    (objc.getBlockClosure(block) as void Function(
        ffi.Pointer<ffi.Void>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>))(arg0, arg1, arg2);
ffi.Pointer<ffi.Void>
    _ObjCBlock_ffiVoid_ffiVoid_NSApplication_objcObjCObject_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_ffiVoid_ffiVoid_NSApplication_objcObjCObject_closureTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_ffiVoid_NSApplication_objcObjCObject_listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObject> arg1,
    ffi.Pointer<objc.ObjCObject> arg2) {
  (objc.getBlockClosure(block) as void Function(
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObject>,
      ffi.Pointer<objc.ObjCObject>))(arg0, arg1, arg2);
  objc.objectRelease(block.cast());
}

ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_ffiVoid_NSApplication_objcObjCObject_listenerCallable =
    ffi.NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>.listener(
        _ObjCBlock_ffiVoid_ffiVoid_NSApplication_objcObjCObject_listenerTrampoline)
      ..keepIsolateAlive = false;
void _ObjCBlock_ffiVoid_ffiVoid_NSApplication_objcObjCObject_blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObject> arg1,
    ffi.Pointer<objc.ObjCObject> arg2) {
  try {
    (objc.getBlockClosure(block) as void Function(
        ffi.Pointer<ffi.Void>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>))(arg0, arg1, arg2);
  } catch (e) {
  } finally {
    objc.signalWaiter(waiter);
    objc.objectRelease(block.cast());
  }
}

ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_ffiVoid_NSApplication_objcObjCObject_blockingCallable =
    ffi.NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>.isolateLocal(
        _ObjCBlock_ffiVoid_ffiVoid_NSApplication_objcObjCObject_blockingTrampoline)
      ..keepIsolateAlive = false;
ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_ffiVoid_NSApplication_objcObjCObject_blockingListenerCallable =
    ffi.NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>.listener(
        _ObjCBlock_ffiVoid_ffiVoid_NSApplication_objcObjCObject_blockingTrampoline)
      ..keepIsolateAlive = false;

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSApplication, ffi.Pointer<objc.ObjCObject>)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_NSApplication_objcObjCObject {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
          ffi.Void Function(ffi.Pointer<ffi.Void>, NSApplication,
              ffi.Pointer<objc.ObjCObject>)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, NSApplication,
                      ffi.Pointer<objc.ObjCObject>)>(pointer,
              retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc
      .ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSApplication, ffi.Pointer<objc.ObjCObject>)>
      fromFunctionPointer(ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1, ffi.Pointer<objc.ObjCObject> arg2)>> ptr) =>
          objc.ObjCBlock<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, NSApplication,
                      ffi.Pointer<objc.ObjCObject>)>(
              objc.newPointerBlock(
                  _ObjCBlock_ffiVoid_ffiVoid_NSApplication_objcObjCObject_fnPtrCallable,
                  ptr.cast()),
              retain: false,
              release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSApplication, ffi.Pointer<objc.ObjCObject>)>
      fromFunction(void Function(ffi.Pointer<ffi.Void>, NSApplication, objc.ObjCObjectBase) fn,
              {bool keepIsolateAlive = true}) =>
          objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSApplication, ffi.Pointer<objc.ObjCObject>)>(
              objc.newClosureBlock(
                  _ObjCBlock_ffiVoid_ffiVoid_NSApplication_objcObjCObject_closureCallable,
                  (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1, ffi.Pointer<objc.ObjCObject> arg2) => fn(
                      arg0,
                      NSApplication.castFromPointer(arg1, retain: true, release: true),
                      objc.ObjCObjectBase(arg2, retain: true, release: true)),
                  keepIsolateAlive),
              retain: false,
              release: true);

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<ffi.Void>, NSApplication,
          ffi.Pointer<objc.ObjCObject>)> listener(
      void Function(ffi.Pointer<ffi.Void>, NSApplication, objc.ObjCObjectBase)
          fn,
      {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_NSApplication_objcObjCObject_listenerCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1,
                ffi.Pointer<objc.ObjCObject> arg2) =>
            fn(
                arg0,
                NSApplication.castFromPointer(arg1,
                    retain: false, release: true),
                objc.ObjCObjectBase(arg2, retain: false, release: true)),
        keepIsolateAlive);
    final wrapper = _AuthenticationServicesMacOS_wrapListenerBlock_fjrv01(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
            ffi.Void Function(ffi.Pointer<ffi.Void>, NSApplication,
                ffi.Pointer<objc.ObjCObject>)>(wrapper,
        retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<ffi.Void>, NSApplication,
          ffi.Pointer<objc.ObjCObject>)> blocking(
      void Function(ffi.Pointer<ffi.Void>, NSApplication, objc.ObjCObjectBase)
          fn,
      {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_NSApplication_objcObjCObject_blockingCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1,
                ffi.Pointer<objc.ObjCObject> arg2) =>
            fn(
                arg0,
                NSApplication.castFromPointer(arg1,
                    retain: false, release: true),
                objc.ObjCObjectBase(arg2, retain: false, release: true)),
        keepIsolateAlive);
    final rawListener = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_NSApplication_objcObjCObject_blockingListenerCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1,
                ffi.Pointer<objc.ObjCObject> arg2) =>
            fn(
                arg0,
                NSApplication.castFromPointer(arg1,
                    retain: false, release: true),
                objc.ObjCObjectBase(arg2, retain: false, release: true)),
        keepIsolateAlive);
    final wrapper = _AuthenticationServicesMacOS_wrapBlockingBlock_fjrv01(
        raw, rawListener, objc.objCContext);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
            ffi.Void Function(ffi.Pointer<ffi.Void>, NSApplication,
                ffi.Pointer<objc.ObjCObject>)>(wrapper,
        retain: false, release: true);
  }
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSApplication, ffi.Pointer<objc.ObjCObject>)>`.
extension ObjCBlock_ffiVoid_ffiVoid_NSApplication_objcObjCObject_CallExtension
    on objc.ObjCBlock<
        ffi.Void Function(ffi.Pointer<ffi.Void>, NSApplication,
            ffi.Pointer<objc.ObjCObject>)> {
  void call(ffi.Pointer<ffi.Void> arg0, NSApplication arg1,
          objc.ObjCObjectBase arg2) =>
      ref.pointer.ref.invoke
              .cast<
                  ffi.NativeFunction<
                      ffi.Void Function(
                          ffi.Pointer<objc.ObjCBlockImpl> block,
                          ffi.Pointer<ffi.Void> arg0,
                          ffi.Pointer<objc.ObjCObject> arg1,
                          ffi.Pointer<objc.ObjCObject> arg2)>>()
              .asFunction<
                  void Function(
                      ffi.Pointer<objc.ObjCBlockImpl>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<objc.ObjCObject>,
                      ffi.Pointer<objc.ObjCObject>)>()(
          ref.pointer, arg0, arg1.ref.pointer, arg2.ref.pointer);
}

late final _sel_applicationSupportsSecureRestorableState_ =
    objc.registerName("applicationSupportsSecureRestorableState:");

/// WARNING: INIntent is a stub. To generate bindings for this class, include
/// INIntent in your config's objc-interfaces list.
///
/// INIntent
class INIntent extends objc.ObjCObjectBase {
  INIntent._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super(pointer, retain: retain, release: release);

  /// Constructs a [INIntent] that points to the same underlying object as [other].
  INIntent.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [INIntent] that wraps the given raw object pointer.
  INIntent.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);
}

late final _sel_application_handlerForIntent_ =
    objc.registerName("application:handlerForIntent:");
ffi.Pointer<objc.ObjCObject>
    _ObjCBlock_objcObjCObject_ffiVoid_NSApplication_INIntent_fnPtrTrampoline(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObject> arg1,
            ffi.Pointer<objc.ObjCObject> arg2) =>
        block.ref.target
            .cast<
                ffi.NativeFunction<
                    ffi.Pointer<objc.ObjCObject> Function(
                        ffi.Pointer<ffi.Void> arg0,
                        ffi.Pointer<objc.ObjCObject> arg1,
                        ffi.Pointer<objc.ObjCObject> arg2)>>()
            .asFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<ffi.Void>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>)>()(arg0, arg1, arg2);
ffi.Pointer<ffi.Void>
    _ObjCBlock_objcObjCObject_ffiVoid_NSApplication_INIntent_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_objcObjCObject_ffiVoid_NSApplication_INIntent_fnPtrTrampoline)
        .cast();
ffi.Pointer<objc.ObjCObject>
    _ObjCBlock_objcObjCObject_ffiVoid_NSApplication_INIntent_closureTrampoline(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObject> arg1,
            ffi.Pointer<objc.ObjCObject> arg2) =>
        (objc.getBlockClosure(block) as ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>))(arg0, arg1, arg2);
ffi.Pointer<ffi.Void>
    _ObjCBlock_objcObjCObject_ffiVoid_NSApplication_INIntent_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_objcObjCObject_ffiVoid_NSApplication_INIntent_closureTrampoline)
        .cast();

/// Construction methods for `objc.ObjCBlock<ffi.Pointer<objc.ObjCObject>? Function(ffi.Pointer<ffi.Void>, NSApplication, INIntent)>`.
abstract final class ObjCBlock_objcObjCObject_ffiVoid_NSApplication_INIntent {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
          ffi.Pointer<objc.ObjCObject>? Function(
              ffi.Pointer<ffi.Void>, NSApplication, INIntent)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<
              ffi.Pointer<objc.ObjCObject>? Function(
                  ffi.Pointer<ffi.Void>,
                  NSApplication,
                  INIntent)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc
      .ObjCBlock<ffi.Pointer<objc.ObjCObject>? Function(ffi.Pointer<ffi.Void>, NSApplication, INIntent)>
      fromFunctionPointer(ffi.Pointer<ffi.NativeFunction<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1, ffi.Pointer<objc.ObjCObject> arg2)>> ptr) =>
          objc.ObjCBlock<
                  ffi.Pointer<objc.ObjCObject>? Function(
                      ffi.Pointer<ffi.Void>, NSApplication, INIntent)>(
              objc.newPointerBlock(
                  _ObjCBlock_objcObjCObject_ffiVoid_NSApplication_INIntent_fnPtrCallable,
                  ptr.cast()),
              retain: false,
              release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Pointer<objc.ObjCObject>? Function(ffi.Pointer<ffi.Void>, NSApplication, INIntent)>
      fromFunction(objc.ObjCObjectBase? Function(ffi.Pointer<ffi.Void>, NSApplication, INIntent) fn,
              {bool keepIsolateAlive = true}) =>
          objc.ObjCBlock<ffi.Pointer<objc.ObjCObject>? Function(ffi.Pointer<ffi.Void>, NSApplication, INIntent)>(
              objc.newClosureBlock(
                  _ObjCBlock_objcObjCObject_ffiVoid_NSApplication_INIntent_closureCallable,
                  (ffi.Pointer<ffi.Void> arg0,
                          ffi.Pointer<objc.ObjCObject> arg1,
                          ffi.Pointer<objc.ObjCObject> arg2) =>
                      fn(arg0, NSApplication.castFromPointer(arg1, retain: true, release: true), INIntent.castFromPointer(arg2, retain: true, release: true))?.ref.retainAndAutorelease() ??
                      ffi.nullptr,
                  keepIsolateAlive),
              retain: false,
              release: true);
}

/// Call operator for `objc.ObjCBlock<ffi.Pointer<objc.ObjCObject>? Function(ffi.Pointer<ffi.Void>, NSApplication, INIntent)>`.
extension ObjCBlock_objcObjCObject_ffiVoid_NSApplication_INIntent_CallExtension
    on objc.ObjCBlock<
        ffi.Pointer<objc.ObjCObject>? Function(
            ffi.Pointer<ffi.Void>, NSApplication, INIntent)> {
  objc.ObjCObjectBase? call(
          ffi.Pointer<ffi.Void> arg0, NSApplication arg1, INIntent arg2) =>
      ref.pointer.ref.invoke
                  .cast<
                      ffi.NativeFunction<
                          ffi.Pointer<objc.ObjCObject> Function(
                              ffi.Pointer<objc.ObjCBlockImpl> block,
                              ffi.Pointer<ffi.Void> arg0,
                              ffi.Pointer<objc.ObjCObject> arg1,
                              ffi.Pointer<objc.ObjCObject> arg2)>>()
                  .asFunction<
                      ffi.Pointer<objc.ObjCObject> Function(
                          ffi.Pointer<objc.ObjCBlockImpl>,
                          ffi.Pointer<ffi.Void>,
                          ffi.Pointer<objc.ObjCObject>,
                          ffi.Pointer<objc.ObjCObject>)>()
                  (ref.pointer, arg0, arg1.ref.pointer, arg2.ref.pointer)
                  .address ==
              0
          ? null
          : objc.ObjCObjectBase(ref.pointer.ref.invoke.cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1, ffi.Pointer<objc.ObjCObject> arg2)>>().asFunction<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCObject>)>()(ref.pointer, arg0, arg1.ref.pointer, arg2.ref.pointer), retain: true, release: true);
}

late final _sel_application_willEncodeRestorableState_ =
    objc.registerName("application:willEncodeRestorableState:");
void _ObjCBlock_ffiVoid_ffiVoid_NSApplication_NSCoder_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1,
        ffi.Pointer<objc.ObjCObject> arg2) =>
    block.ref.target
        .cast<
            ffi.NativeFunction<
                ffi.Void Function(
                    ffi.Pointer<ffi.Void> arg0,
                    ffi.Pointer<objc.ObjCObject> arg1,
                    ffi.Pointer<objc.ObjCObject> arg2)>>()
        .asFunction<
            void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>()(arg0, arg1, arg2);
ffi.Pointer<ffi.Void>
    _ObjCBlock_ffiVoid_ffiVoid_NSApplication_NSCoder_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_ffiVoid_ffiVoid_NSApplication_NSCoder_fnPtrTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_ffiVoid_NSApplication_NSCoder_closureTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1,
        ffi.Pointer<objc.ObjCObject> arg2) =>
    (objc.getBlockClosure(block) as void Function(
        ffi.Pointer<ffi.Void>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>))(arg0, arg1, arg2);
ffi.Pointer<ffi.Void>
    _ObjCBlock_ffiVoid_ffiVoid_NSApplication_NSCoder_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_ffiVoid_ffiVoid_NSApplication_NSCoder_closureTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_ffiVoid_NSApplication_NSCoder_listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObject> arg1,
    ffi.Pointer<objc.ObjCObject> arg2) {
  (objc.getBlockClosure(block) as void Function(
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObject>,
      ffi.Pointer<objc.ObjCObject>))(arg0, arg1, arg2);
  objc.objectRelease(block.cast());
}

ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_ffiVoid_NSApplication_NSCoder_listenerCallable = ffi
        .NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>.listener(
        _ObjCBlock_ffiVoid_ffiVoid_NSApplication_NSCoder_listenerTrampoline)
      ..keepIsolateAlive = false;
void _ObjCBlock_ffiVoid_ffiVoid_NSApplication_NSCoder_blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObject> arg1,
    ffi.Pointer<objc.ObjCObject> arg2) {
  try {
    (objc.getBlockClosure(block) as void Function(
        ffi.Pointer<ffi.Void>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>))(arg0, arg1, arg2);
  } catch (e) {
  } finally {
    objc.signalWaiter(waiter);
    objc.objectRelease(block.cast());
  }
}

ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_ffiVoid_NSApplication_NSCoder_blockingCallable = ffi
        .NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>.isolateLocal(
        _ObjCBlock_ffiVoid_ffiVoid_NSApplication_NSCoder_blockingTrampoline)
      ..keepIsolateAlive = false;
ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_ffiVoid_NSApplication_NSCoder_blockingListenerCallable =
    ffi.NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>.listener(
        _ObjCBlock_ffiVoid_ffiVoid_NSApplication_NSCoder_blockingTrampoline)
      ..keepIsolateAlive = false;

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSApplication, objc.NSCoder)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_NSApplication_NSCoder {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
          ffi.Void Function(ffi.Pointer<ffi.Void>, NSApplication, objc.NSCoder)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<
              ffi.Void Function(ffi.Pointer<ffi.Void>, NSApplication,
                  objc.NSCoder)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc
      .ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSApplication, objc.NSCoder)>
      fromFunctionPointer(
              ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1, ffi.Pointer<objc.ObjCObject> arg2)>>
                  ptr) =>
          objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSApplication, objc.NSCoder)>(
              objc.newPointerBlock(
                  _ObjCBlock_ffiVoid_ffiVoid_NSApplication_NSCoder_fnPtrCallable,
                  ptr.cast()),
              retain: false,
              release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSApplication, objc.NSCoder)> fromFunction(
          void Function(ffi.Pointer<ffi.Void>, NSApplication, objc.NSCoder) fn,
          {bool keepIsolateAlive = true}) =>
      objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSApplication, objc.NSCoder)>(
          objc.newClosureBlock(
              _ObjCBlock_ffiVoid_ffiVoid_NSApplication_NSCoder_closureCallable,
              (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1, ffi.Pointer<objc.ObjCObject> arg2) => fn(
                  arg0,
                  NSApplication.castFromPointer(arg1, retain: true, release: true),
                  objc.NSCoder.castFromPointer(arg2, retain: true, release: true)),
              keepIsolateAlive),
          retain: false,
          release: true);

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
          ffi.Void Function(ffi.Pointer<ffi.Void>, NSApplication, objc.NSCoder)>
      listener(
          void Function(ffi.Pointer<ffi.Void>, NSApplication, objc.NSCoder) fn,
          {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_NSApplication_NSCoder_listenerCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1,
                ffi.Pointer<objc.ObjCObject> arg2) =>
            fn(
                arg0,
                NSApplication.castFromPointer(arg1,
                    retain: false, release: true),
                objc.NSCoder.castFromPointer(arg2,
                    retain: false, release: true)),
        keepIsolateAlive);
    final wrapper = _AuthenticationServicesMacOS_wrapListenerBlock_fjrv01(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
        ffi.Void Function(ffi.Pointer<ffi.Void>, NSApplication,
            objc.NSCoder)>(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<
          ffi.Void Function(ffi.Pointer<ffi.Void>, NSApplication, objc.NSCoder)>
      blocking(
          void Function(ffi.Pointer<ffi.Void>, NSApplication, objc.NSCoder) fn,
          {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_NSApplication_NSCoder_blockingCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1,
                ffi.Pointer<objc.ObjCObject> arg2) =>
            fn(
                arg0,
                NSApplication.castFromPointer(arg1,
                    retain: false, release: true),
                objc.NSCoder.castFromPointer(arg2,
                    retain: false, release: true)),
        keepIsolateAlive);
    final rawListener = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_NSApplication_NSCoder_blockingListenerCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1,
                ffi.Pointer<objc.ObjCObject> arg2) =>
            fn(
                arg0,
                NSApplication.castFromPointer(arg1,
                    retain: false, release: true),
                objc.NSCoder.castFromPointer(arg2,
                    retain: false, release: true)),
        keepIsolateAlive);
    final wrapper = _AuthenticationServicesMacOS_wrapBlockingBlock_fjrv01(
        raw, rawListener, objc.objCContext);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
        ffi.Void Function(ffi.Pointer<ffi.Void>, NSApplication,
            objc.NSCoder)>(wrapper, retain: false, release: true);
  }
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSApplication, objc.NSCoder)>`.
extension ObjCBlock_ffiVoid_ffiVoid_NSApplication_NSCoder_CallExtension
    on objc.ObjCBlock<
        ffi.Void Function(ffi.Pointer<ffi.Void>, NSApplication, objc.NSCoder)> {
  void call(
          ffi.Pointer<ffi.Void> arg0, NSApplication arg1, objc.NSCoder arg2) =>
      ref.pointer.ref.invoke
              .cast<
                  ffi.NativeFunction<
                      ffi.Void Function(
                          ffi.Pointer<objc.ObjCBlockImpl> block,
                          ffi.Pointer<ffi.Void> arg0,
                          ffi.Pointer<objc.ObjCObject> arg1,
                          ffi.Pointer<objc.ObjCObject> arg2)>>()
              .asFunction<
                  void Function(
                      ffi.Pointer<objc.ObjCBlockImpl>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<objc.ObjCObject>,
                      ffi.Pointer<objc.ObjCObject>)>()(
          ref.pointer, arg0, arg1.ref.pointer, arg2.ref.pointer);
}

late final _sel_application_didDecodeRestorableState_ =
    objc.registerName("application:didDecodeRestorableState:");
late final _sel_application_willContinueUserActivityWithType_ =
    objc.registerName("application:willContinueUserActivityWithType:");

/// WARNING: NSUserActivity is a stub. To generate bindings for this class, include
/// NSUserActivity in your config's objc-interfaces list.
///
/// NSUserActivity
class NSUserActivity extends objc.NSObject {
  NSUserActivity._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release) {
    objc.checkOsVersionInternal('NSUserActivity',
        iOS: (false, (8, 0, 0)), macOS: (false, (10, 10, 0)));
  }

  /// Constructs a [NSUserActivity] that points to the same underlying object as [other].
  NSUserActivity.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [NSUserActivity] that wraps the given raw object pointer.
  NSUserActivity.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);
}

void _ObjCBlock_ffiVoid_NSArray_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<objc.ObjCObject> arg0) =>
    block.ref.target
        .cast<
            ffi.NativeFunction<
                ffi.Void Function(ffi.Pointer<objc.ObjCObject> arg0)>>()
        .asFunction<void Function(ffi.Pointer<objc.ObjCObject>)>()(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_ffiVoid_NSArray_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_ffiVoid_NSArray_fnPtrTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_NSArray_closureTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<objc.ObjCObject> arg0) =>
    (objc.getBlockClosure(block) as void Function(
        ffi.Pointer<objc.ObjCObject>))(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_ffiVoid_NSArray_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_ffiVoid_NSArray_closureTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_NSArray_listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<objc.ObjCObject> arg0) {
  (objc.getBlockClosure(block) as void Function(
      ffi.Pointer<objc.ObjCObject>))(arg0);
  objc.objectRelease(block.cast());
}

ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_NSArray_listenerCallable = ffi.NativeCallable<
            ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<objc.ObjCObject>)>.listener(
        _ObjCBlock_ffiVoid_NSArray_listenerTrampoline)
      ..keepIsolateAlive = false;
void _ObjCBlock_ffiVoid_NSArray_blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<objc.ObjCObject> arg0) {
  try {
    (objc.getBlockClosure(block) as void Function(
        ffi.Pointer<objc.ObjCObject>))(arg0);
  } catch (e) {
  } finally {
    objc.signalWaiter(waiter);
    objc.objectRelease(block.cast());
  }
}

ffi.NativeCallable<
        ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_NSArray_blockingCallable = ffi.NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>)>.isolateLocal(
        _ObjCBlock_ffiVoid_NSArray_blockingTrampoline)
      ..keepIsolateAlive = false;
ffi.NativeCallable<
        ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_NSArray_blockingListenerCallable = ffi.NativeCallable<
            ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>.listener(
        _ObjCBlock_ffiVoid_NSArray_blockingTrampoline)
      ..keepIsolateAlive = false;

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(objc.NSArray)>`.
abstract final class ObjCBlock_ffiVoid_NSArray {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(objc.NSArray)> castFromPointer(
          ffi.Pointer<objc.ObjCBlockImpl> pointer,
          {bool retain = false,
          bool release = false}) =>
      objc.ObjCBlock<ffi.Void Function(objc.NSArray)>(pointer,
          retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(objc.NSArray)> fromFunctionPointer(
          ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Void Function(ffi.Pointer<objc.ObjCObject> arg0)>>
              ptr) =>
      objc.ObjCBlock<ffi.Void Function(objc.NSArray)>(
          objc.newPointerBlock(
              _ObjCBlock_ffiVoid_NSArray_fnPtrCallable, ptr.cast()),
          retain: false,
          release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(objc.NSArray)> fromFunction(
          void Function(objc.NSArray) fn,
          {bool keepIsolateAlive = true}) =>
      objc.ObjCBlock<ffi.Void Function(objc.NSArray)>(
          objc.newClosureBlock(
              _ObjCBlock_ffiVoid_NSArray_closureCallable,
              (ffi.Pointer<objc.ObjCObject> arg0) => fn(
                  objc.NSArray.castFromPointer(arg0,
                      retain: true, release: true)),
              keepIsolateAlive),
          retain: false,
          release: true);

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(objc.NSArray)> listener(
      void Function(objc.NSArray) fn,
      {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_NSArray_listenerCallable.nativeFunction.cast(),
        (ffi.Pointer<objc.ObjCObject> arg0) => fn(
            objc.NSArray.castFromPointer(arg0, retain: false, release: true)),
        keepIsolateAlive);
    final wrapper = _AuthenticationServicesMacOS_wrapListenerBlock_xtuoz7(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<ffi.Void Function(objc.NSArray)>(wrapper,
        retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(objc.NSArray)> blocking(
      void Function(objc.NSArray) fn,
      {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_NSArray_blockingCallable.nativeFunction.cast(),
        (ffi.Pointer<objc.ObjCObject> arg0) => fn(
            objc.NSArray.castFromPointer(arg0, retain: false, release: true)),
        keepIsolateAlive);
    final rawListener = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_NSArray_blockingListenerCallable.nativeFunction
            .cast(),
        (ffi.Pointer<objc.ObjCObject> arg0) => fn(
            objc.NSArray.castFromPointer(arg0, retain: false, release: true)),
        keepIsolateAlive);
    final wrapper = _AuthenticationServicesMacOS_wrapBlockingBlock_xtuoz7(
        raw, rawListener, objc.objCContext);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<ffi.Void Function(objc.NSArray)>(wrapper,
        retain: false, release: true);
  }
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(objc.NSArray)>`.
extension ObjCBlock_ffiVoid_NSArray_CallExtension
    on objc.ObjCBlock<ffi.Void Function(objc.NSArray)> {
  void call(objc.NSArray arg0) => ref.pointer.ref.invoke
      .cast<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> block,
                  ffi.Pointer<objc.ObjCObject> arg0)>>()
      .asFunction<
          void Function(ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<objc.ObjCObject>)>()(ref.pointer, arg0.ref.pointer);
}

late final _sel_application_continueUserActivity_restorationHandler_ =
    objc.registerName("application:continueUserActivity:restorationHandler:");
bool
    _ObjCBlock_bool_ffiVoid_NSApplication_NSUserActivity_ffiVoidNSArray_fnPtrTrampoline(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObject> arg1,
            ffi.Pointer<objc.ObjCObject> arg2,
            ffi.Pointer<objc.ObjCBlockImpl> arg3) =>
        block.ref.target
            .cast<
                ffi.NativeFunction<
                    ffi.Bool Function(
                        ffi.Pointer<ffi.Void> arg0,
                        ffi.Pointer<objc.ObjCObject> arg1,
                        ffi.Pointer<objc.ObjCObject> arg2,
                        ffi.Pointer<objc.ObjCBlockImpl> arg3)>>()
            .asFunction<
                bool Function(
                    ffi.Pointer<ffi.Void>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCBlockImpl>)>()(arg0, arg1, arg2, arg3);
ffi.Pointer<ffi.Void>
    _ObjCBlock_bool_ffiVoid_NSApplication_NSUserActivity_ffiVoidNSArray_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Bool Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCBlockImpl>)>(
            _ObjCBlock_bool_ffiVoid_NSApplication_NSUserActivity_ffiVoidNSArray_fnPtrTrampoline,
            false)
        .cast();
bool
    _ObjCBlock_bool_ffiVoid_NSApplication_NSUserActivity_ffiVoidNSArray_closureTrampoline(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObject> arg1,
            ffi.Pointer<objc.ObjCObject> arg2,
            ffi.Pointer<objc.ObjCBlockImpl> arg3) =>
        (objc.getBlockClosure(block) as bool Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCBlockImpl>))(arg0, arg1, arg2, arg3);
ffi.Pointer<ffi.Void>
    _ObjCBlock_bool_ffiVoid_NSApplication_NSUserActivity_ffiVoidNSArray_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Bool Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCBlockImpl>)>(
            _ObjCBlock_bool_ffiVoid_NSApplication_NSUserActivity_ffiVoidNSArray_closureTrampoline,
            false)
        .cast();

/// Construction methods for `objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>, NSApplication, NSUserActivity, objc.ObjCBlock<ffi.Void Function(objc.NSArray)>)>`.
abstract final class ObjCBlock_bool_ffiVoid_NSApplication_NSUserActivity_ffiVoidNSArray {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
          ffi.Bool Function(ffi.Pointer<ffi.Void>, NSApplication,
              NSUserActivity, objc.ObjCBlock<ffi.Void Function(objc.NSArray)>)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer, {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<
                  ffi.Bool Function(
                      ffi.Pointer<ffi.Void>,
                      NSApplication,
                      NSUserActivity,
                      objc.ObjCBlock<ffi.Void Function(objc.NSArray)>)>(pointer,
              retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>, NSApplication, NSUserActivity, objc.ObjCBlock<ffi.Void Function(objc.NSArray)>)>
      fromFunctionPointer(ffi.Pointer<ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1, ffi.Pointer<objc.ObjCObject> arg2, ffi.Pointer<objc.ObjCBlockImpl> arg3)>> ptr) =>
          objc.ObjCBlock<
                  ffi.Bool Function(
                      ffi.Pointer<ffi.Void>,
                      NSApplication,
                      NSUserActivity,
                      objc.ObjCBlock<ffi.Void Function(objc.NSArray)>)>(
              objc.newPointerBlock(
                  _ObjCBlock_bool_ffiVoid_NSApplication_NSUserActivity_ffiVoidNSArray_fnPtrCallable,
                  ptr.cast()),
              retain: false,
              release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>, NSApplication, NSUserActivity, objc.ObjCBlock<ffi.Void Function(objc.NSArray)>)>
      fromFunction(bool Function(ffi.Pointer<ffi.Void>, NSApplication, NSUserActivity, objc.ObjCBlock<ffi.Void Function(objc.NSArray)>) fn, {bool keepIsolateAlive = true}) =>
          objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>, NSApplication, NSUserActivity, objc.ObjCBlock<ffi.Void Function(objc.NSArray)>)>(
              objc.newClosureBlock(
                  _ObjCBlock_bool_ffiVoid_NSApplication_NSUserActivity_ffiVoidNSArray_closureCallable,
                  (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1, ffi.Pointer<objc.ObjCObject> arg2, ffi.Pointer<objc.ObjCBlockImpl> arg3) => fn(
                      arg0,
                      NSApplication.castFromPointer(arg1, retain: true, release: true),
                      NSUserActivity.castFromPointer(arg2, retain: true, release: true),
                      ObjCBlock_ffiVoid_NSArray.castFromPointer(arg3, retain: true, release: true)),
                  keepIsolateAlive),
              retain: false,
              release: true);
}

/// Call operator for `objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>, NSApplication, NSUserActivity, objc.ObjCBlock<ffi.Void Function(objc.NSArray)>)>`.
extension ObjCBlock_bool_ffiVoid_NSApplication_NSUserActivity_ffiVoidNSArray_CallExtension
    on objc.ObjCBlock<
        ffi.Bool Function(ffi.Pointer<ffi.Void>, NSApplication, NSUserActivity,
            objc.ObjCBlock<ffi.Void Function(objc.NSArray)>)> {
  bool call(ffi.Pointer<ffi.Void> arg0, NSApplication arg1, NSUserActivity arg2,
          objc.ObjCBlock<ffi.Void Function(objc.NSArray)> arg3) =>
      ref.pointer.ref.invoke
              .cast<
                  ffi.NativeFunction<
                      ffi.Bool Function(
                          ffi.Pointer<objc.ObjCBlockImpl> block,
                          ffi.Pointer<ffi.Void> arg0,
                          ffi.Pointer<objc.ObjCObject> arg1,
                          ffi.Pointer<objc.ObjCObject> arg2,
                          ffi.Pointer<objc.ObjCBlockImpl> arg3)>>()
              .asFunction<
                  bool Function(
                      ffi.Pointer<objc.ObjCBlockImpl>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<objc.ObjCObject>,
                      ffi.Pointer<objc.ObjCObject>,
                      ffi.Pointer<objc.ObjCBlockImpl>)>()(ref.pointer, arg0,
          arg1.ref.pointer, arg2.ref.pointer, arg3.ref.pointer);
}

late final _sel_application_didFailToContinueUserActivityWithType_error_ = objc
    .registerName("application:didFailToContinueUserActivityWithType:error:");
void _ObjCBlock_ffiVoid_ffiVoid_NSApplication_NSString_NSError_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1,
        ffi.Pointer<objc.ObjCObject> arg2,
        ffi.Pointer<objc.ObjCObject> arg3) =>
    block.ref.target
        .cast<
            ffi.NativeFunction<
                ffi.Void Function(
                    ffi.Pointer<ffi.Void> arg0,
                    ffi.Pointer<objc.ObjCObject> arg1,
                    ffi.Pointer<objc.ObjCObject> arg2,
                    ffi.Pointer<objc.ObjCObject> arg3)>>()
        .asFunction<
            void Function(
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>()(arg0, arg1, arg2, arg3);
ffi.Pointer<ffi.Void>
    _ObjCBlock_ffiVoid_ffiVoid_NSApplication_NSString_NSError_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_ffiVoid_ffiVoid_NSApplication_NSString_NSError_fnPtrTrampoline)
        .cast();
void
    _ObjCBlock_ffiVoid_ffiVoid_NSApplication_NSString_NSError_closureTrampoline(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObject> arg1,
            ffi.Pointer<objc.ObjCObject> arg2,
            ffi.Pointer<objc.ObjCObject> arg3) =>
        (objc.getBlockClosure(block) as void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>))(arg0, arg1, arg2, arg3);
ffi.Pointer<ffi.Void>
    _ObjCBlock_ffiVoid_ffiVoid_NSApplication_NSString_NSError_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_ffiVoid_ffiVoid_NSApplication_NSString_NSError_closureTrampoline)
        .cast();
void
    _ObjCBlock_ffiVoid_ffiVoid_NSApplication_NSString_NSError_listenerTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1,
        ffi.Pointer<objc.ObjCObject> arg2,
        ffi.Pointer<objc.ObjCObject> arg3) {
  (objc.getBlockClosure(block) as void Function(
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObject>,
      ffi.Pointer<objc.ObjCObject>,
      ffi.Pointer<objc.ObjCObject>))(arg0, arg1, arg2, arg3);
  objc.objectRelease(block.cast());
}

ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_ffiVoid_NSApplication_NSString_NSError_listenerCallable =
    ffi.NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>.listener(
        _ObjCBlock_ffiVoid_ffiVoid_NSApplication_NSString_NSError_listenerTrampoline)
      ..keepIsolateAlive = false;
void
    _ObjCBlock_ffiVoid_ffiVoid_NSApplication_NSString_NSError_blockingTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> waiter,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1,
        ffi.Pointer<objc.ObjCObject> arg2,
        ffi.Pointer<objc.ObjCObject> arg3) {
  try {
    (objc.getBlockClosure(block) as void Function(
        ffi.Pointer<ffi.Void>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>))(arg0, arg1, arg2, arg3);
  } catch (e) {
  } finally {
    objc.signalWaiter(waiter);
    objc.objectRelease(block.cast());
  }
}

ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_ffiVoid_NSApplication_NSString_NSError_blockingCallable =
    ffi.NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>.isolateLocal(
        _ObjCBlock_ffiVoid_ffiVoid_NSApplication_NSString_NSError_blockingTrampoline)
      ..keepIsolateAlive = false;
ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_ffiVoid_NSApplication_NSString_NSError_blockingListenerCallable =
    ffi.NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>.listener(
        _ObjCBlock_ffiVoid_ffiVoid_NSApplication_NSString_NSError_blockingTrampoline)
      ..keepIsolateAlive = false;

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSApplication, objc.NSString, objc.NSError)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_NSApplication_NSString_NSError {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
          ffi.Void Function(ffi.Pointer<ffi.Void>, NSApplication, objc.NSString,
              objc.NSError)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<
              ffi.Void Function(
                  ffi.Pointer<ffi.Void>,
                  NSApplication,
                  objc.NSString,
                  objc.NSError)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSApplication, objc.NSString, objc.NSError)>
      fromFunctionPointer(ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1, ffi.Pointer<objc.ObjCObject> arg2, ffi.Pointer<objc.ObjCObject> arg3)>> ptr) =>
          objc.ObjCBlock<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, NSApplication,
                      objc.NSString, objc.NSError)>(
              objc.newPointerBlock(
                  _ObjCBlock_ffiVoid_ffiVoid_NSApplication_NSString_NSError_fnPtrCallable,
                  ptr.cast()),
              retain: false,
              release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSApplication, objc.NSString, objc.NSError)>
      fromFunction(void Function(ffi.Pointer<ffi.Void>, NSApplication, objc.NSString, objc.NSError) fn, {bool keepIsolateAlive = true}) =>
          objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSApplication, objc.NSString, objc.NSError)>(
              objc.newClosureBlock(
                  _ObjCBlock_ffiVoid_ffiVoid_NSApplication_NSString_NSError_closureCallable,
                  (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1, ffi.Pointer<objc.ObjCObject> arg2, ffi.Pointer<objc.ObjCObject> arg3) => fn(
                      arg0,
                      NSApplication.castFromPointer(arg1, retain: true, release: true),
                      objc.NSString.castFromPointer(arg2, retain: true, release: true),
                      objc.NSError.castFromPointer(arg3, retain: true, release: true)),
                  keepIsolateAlive),
              retain: false,
              release: true);

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<ffi.Void>, NSApplication, objc.NSString,
          objc.NSError)> listener(
      void Function(
              ffi.Pointer<ffi.Void>, NSApplication, objc.NSString, objc.NSError)
          fn,
      {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_NSApplication_NSString_NSError_listenerCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<ffi.Void> arg0,
                ffi.Pointer<objc.ObjCObject> arg1,
                ffi.Pointer<objc.ObjCObject> arg2,
                ffi.Pointer<objc.ObjCObject> arg3) =>
            fn(
                arg0,
                NSApplication.castFromPointer(arg1,
                    retain: false, release: true),
                objc.NSString.castFromPointer(arg2,
                    retain: false, release: true),
                objc.NSError.castFromPointer(arg3,
                    retain: false, release: true)),
        keepIsolateAlive);
    final wrapper = _AuthenticationServicesMacOS_wrapListenerBlock_1tz5yf(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
        ffi.Void Function(ffi.Pointer<ffi.Void>, NSApplication, objc.NSString,
            objc.NSError)>(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<ffi.Void>, NSApplication, objc.NSString,
          objc.NSError)> blocking(
      void Function(
              ffi.Pointer<ffi.Void>, NSApplication, objc.NSString, objc.NSError)
          fn,
      {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_NSApplication_NSString_NSError_blockingCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<ffi.Void> arg0,
                ffi.Pointer<objc.ObjCObject> arg1,
                ffi.Pointer<objc.ObjCObject> arg2,
                ffi.Pointer<objc.ObjCObject> arg3) =>
            fn(
                arg0,
                NSApplication.castFromPointer(arg1,
                    retain: false, release: true),
                objc.NSString.castFromPointer(arg2,
                    retain: false, release: true),
                objc.NSError.castFromPointer(arg3,
                    retain: false, release: true)),
        keepIsolateAlive);
    final rawListener = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_NSApplication_NSString_NSError_blockingListenerCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<ffi.Void> arg0,
                ffi.Pointer<objc.ObjCObject> arg1,
                ffi.Pointer<objc.ObjCObject> arg2,
                ffi.Pointer<objc.ObjCObject> arg3) =>
            fn(
                arg0,
                NSApplication.castFromPointer(arg1,
                    retain: false, release: true),
                objc.NSString.castFromPointer(arg2,
                    retain: false, release: true),
                objc.NSError.castFromPointer(arg3,
                    retain: false, release: true)),
        keepIsolateAlive);
    final wrapper = _AuthenticationServicesMacOS_wrapBlockingBlock_1tz5yf(
        raw, rawListener, objc.objCContext);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
        ffi.Void Function(ffi.Pointer<ffi.Void>, NSApplication, objc.NSString,
            objc.NSError)>(wrapper, retain: false, release: true);
  }
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSApplication, objc.NSString, objc.NSError)>`.
extension ObjCBlock_ffiVoid_ffiVoid_NSApplication_NSString_NSError_CallExtension
    on objc.ObjCBlock<
        ffi.Void Function(ffi.Pointer<ffi.Void>, NSApplication, objc.NSString,
            objc.NSError)> {
  void call(ffi.Pointer<ffi.Void> arg0, NSApplication arg1, objc.NSString arg2,
          objc.NSError arg3) =>
      ref.pointer.ref.invoke
              .cast<
                  ffi.NativeFunction<
                      ffi.Void Function(
                          ffi.Pointer<objc.ObjCBlockImpl> block,
                          ffi.Pointer<ffi.Void> arg0,
                          ffi.Pointer<objc.ObjCObject> arg1,
                          ffi.Pointer<objc.ObjCObject> arg2,
                          ffi.Pointer<objc.ObjCObject> arg3)>>()
              .asFunction<
                  void Function(
                      ffi.Pointer<objc.ObjCBlockImpl>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<objc.ObjCObject>,
                      ffi.Pointer<objc.ObjCObject>,
                      ffi.Pointer<objc.ObjCObject>)>()(ref.pointer, arg0,
          arg1.ref.pointer, arg2.ref.pointer, arg3.ref.pointer);
}

late final _sel_application_didUpdateUserActivity_ =
    objc.registerName("application:didUpdateUserActivity:");
void _ObjCBlock_ffiVoid_ffiVoid_NSApplication_NSUserActivity_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1,
        ffi.Pointer<objc.ObjCObject> arg2) =>
    block.ref.target
        .cast<
            ffi.NativeFunction<
                ffi.Void Function(
                    ffi.Pointer<ffi.Void> arg0,
                    ffi.Pointer<objc.ObjCObject> arg1,
                    ffi.Pointer<objc.ObjCObject> arg2)>>()
        .asFunction<
            void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>()(arg0, arg1, arg2);
ffi.Pointer<ffi.Void>
    _ObjCBlock_ffiVoid_ffiVoid_NSApplication_NSUserActivity_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_ffiVoid_ffiVoid_NSApplication_NSUserActivity_fnPtrTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_ffiVoid_NSApplication_NSUserActivity_closureTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1,
        ffi.Pointer<objc.ObjCObject> arg2) =>
    (objc.getBlockClosure(block) as void Function(
        ffi.Pointer<ffi.Void>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>))(arg0, arg1, arg2);
ffi.Pointer<ffi.Void>
    _ObjCBlock_ffiVoid_ffiVoid_NSApplication_NSUserActivity_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_ffiVoid_ffiVoid_NSApplication_NSUserActivity_closureTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_ffiVoid_NSApplication_NSUserActivity_listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObject> arg1,
    ffi.Pointer<objc.ObjCObject> arg2) {
  (objc.getBlockClosure(block) as void Function(
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObject>,
      ffi.Pointer<objc.ObjCObject>))(arg0, arg1, arg2);
  objc.objectRelease(block.cast());
}

ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_ffiVoid_NSApplication_NSUserActivity_listenerCallable =
    ffi.NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>.listener(
        _ObjCBlock_ffiVoid_ffiVoid_NSApplication_NSUserActivity_listenerTrampoline)
      ..keepIsolateAlive = false;
void _ObjCBlock_ffiVoid_ffiVoid_NSApplication_NSUserActivity_blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObject> arg1,
    ffi.Pointer<objc.ObjCObject> arg2) {
  try {
    (objc.getBlockClosure(block) as void Function(
        ffi.Pointer<ffi.Void>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>))(arg0, arg1, arg2);
  } catch (e) {
  } finally {
    objc.signalWaiter(waiter);
    objc.objectRelease(block.cast());
  }
}

ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_ffiVoid_NSApplication_NSUserActivity_blockingCallable =
    ffi.NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>.isolateLocal(
        _ObjCBlock_ffiVoid_ffiVoid_NSApplication_NSUserActivity_blockingTrampoline)
      ..keepIsolateAlive = false;
ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_ffiVoid_NSApplication_NSUserActivity_blockingListenerCallable =
    ffi.NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>.listener(
        _ObjCBlock_ffiVoid_ffiVoid_NSApplication_NSUserActivity_blockingTrampoline)
      ..keepIsolateAlive = false;

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSApplication, NSUserActivity)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_NSApplication_NSUserActivity {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
          ffi.Void Function(
              ffi.Pointer<ffi.Void>, NSApplication, NSUserActivity)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<
              ffi.Void Function(ffi.Pointer<ffi.Void>, NSApplication,
                  NSUserActivity)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSApplication, NSUserActivity)> fromFunctionPointer(
          ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Void Function(
                          ffi.Pointer<ffi.Void> arg0,
                          ffi.Pointer<objc.ObjCObject> arg1,
                          ffi.Pointer<objc.ObjCObject> arg2)>>
              ptr) =>
      objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSApplication, NSUserActivity)>(
          objc.newPointerBlock(_ObjCBlock_ffiVoid_ffiVoid_NSApplication_NSUserActivity_fnPtrCallable, ptr.cast()),
          retain: false,
          release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSApplication, NSUserActivity)>
      fromFunction(void Function(ffi.Pointer<ffi.Void>, NSApplication, NSUserActivity) fn,
              {bool keepIsolateAlive = true}) =>
          objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSApplication, NSUserActivity)>(
              objc.newClosureBlock(
                  _ObjCBlock_ffiVoid_ffiVoid_NSApplication_NSUserActivity_closureCallable,
                  (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1, ffi.Pointer<objc.ObjCObject> arg2) => fn(
                      arg0,
                      NSApplication.castFromPointer(arg1, retain: true, release: true),
                      NSUserActivity.castFromPointer(arg2, retain: true, release: true)),
                  keepIsolateAlive),
              retain: false,
              release: true);

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
      ffi.Void Function(
          ffi.Pointer<ffi.Void>, NSApplication, NSUserActivity)> listener(
      void Function(ffi.Pointer<ffi.Void>, NSApplication, NSUserActivity) fn,
      {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_NSApplication_NSUserActivity_listenerCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1,
                ffi.Pointer<objc.ObjCObject> arg2) =>
            fn(
                arg0,
                NSApplication.castFromPointer(arg1,
                    retain: false, release: true),
                NSUserActivity.castFromPointer(arg2,
                    retain: false, release: true)),
        keepIsolateAlive);
    final wrapper = _AuthenticationServicesMacOS_wrapListenerBlock_fjrv01(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
        ffi.Void Function(ffi.Pointer<ffi.Void>, NSApplication,
            NSUserActivity)>(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<
      ffi.Void Function(
          ffi.Pointer<ffi.Void>, NSApplication, NSUserActivity)> blocking(
      void Function(ffi.Pointer<ffi.Void>, NSApplication, NSUserActivity) fn,
      {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_NSApplication_NSUserActivity_blockingCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1,
                ffi.Pointer<objc.ObjCObject> arg2) =>
            fn(
                arg0,
                NSApplication.castFromPointer(arg1,
                    retain: false, release: true),
                NSUserActivity.castFromPointer(arg2,
                    retain: false, release: true)),
        keepIsolateAlive);
    final rawListener = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_NSApplication_NSUserActivity_blockingListenerCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1,
                ffi.Pointer<objc.ObjCObject> arg2) =>
            fn(
                arg0,
                NSApplication.castFromPointer(arg1,
                    retain: false, release: true),
                NSUserActivity.castFromPointer(arg2,
                    retain: false, release: true)),
        keepIsolateAlive);
    final wrapper = _AuthenticationServicesMacOS_wrapBlockingBlock_fjrv01(
        raw, rawListener, objc.objCContext);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
        ffi.Void Function(ffi.Pointer<ffi.Void>, NSApplication,
            NSUserActivity)>(wrapper, retain: false, release: true);
  }
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSApplication, NSUserActivity)>`.
extension ObjCBlock_ffiVoid_ffiVoid_NSApplication_NSUserActivity_CallExtension
    on objc.ObjCBlock<
        ffi.Void Function(
            ffi.Pointer<ffi.Void>, NSApplication, NSUserActivity)> {
  void call(ffi.Pointer<ffi.Void> arg0, NSApplication arg1,
          NSUserActivity arg2) =>
      ref.pointer.ref.invoke
              .cast<
                  ffi.NativeFunction<
                      ffi.Void Function(
                          ffi.Pointer<objc.ObjCBlockImpl> block,
                          ffi.Pointer<ffi.Void> arg0,
                          ffi.Pointer<objc.ObjCObject> arg1,
                          ffi.Pointer<objc.ObjCObject> arg2)>>()
              .asFunction<
                  void Function(
                      ffi.Pointer<objc.ObjCBlockImpl>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<objc.ObjCObject>,
                      ffi.Pointer<objc.ObjCObject>)>()(
          ref.pointer, arg0, arg1.ref.pointer, arg2.ref.pointer);
}

/// WARNING: CKShareMetadata is a stub. To generate bindings for this class, include
/// CKShareMetadata in your config's objc-interfaces list.
///
/// CKShareMetadata
class CKShareMetadata extends objc.ObjCObjectBase {
  CKShareMetadata._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super(pointer, retain: retain, release: release);

  /// Constructs a [CKShareMetadata] that points to the same underlying object as [other].
  CKShareMetadata.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [CKShareMetadata] that wraps the given raw object pointer.
  CKShareMetadata.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);
}

late final _sel_application_userDidAcceptCloudKitShareWithMetadata_ =
    objc.registerName("application:userDidAcceptCloudKitShareWithMetadata:");
void _ObjCBlock_ffiVoid_ffiVoid_NSApplication_CKShareMetadata_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1,
        ffi.Pointer<objc.ObjCObject> arg2) =>
    block.ref.target
        .cast<
            ffi.NativeFunction<
                ffi.Void Function(
                    ffi.Pointer<ffi.Void> arg0,
                    ffi.Pointer<objc.ObjCObject> arg1,
                    ffi.Pointer<objc.ObjCObject> arg2)>>()
        .asFunction<
            void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>()(arg0, arg1, arg2);
ffi.Pointer<ffi.Void>
    _ObjCBlock_ffiVoid_ffiVoid_NSApplication_CKShareMetadata_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_ffiVoid_ffiVoid_NSApplication_CKShareMetadata_fnPtrTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_ffiVoid_NSApplication_CKShareMetadata_closureTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1,
        ffi.Pointer<objc.ObjCObject> arg2) =>
    (objc.getBlockClosure(block) as void Function(
        ffi.Pointer<ffi.Void>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>))(arg0, arg1, arg2);
ffi.Pointer<ffi.Void>
    _ObjCBlock_ffiVoid_ffiVoid_NSApplication_CKShareMetadata_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_ffiVoid_ffiVoid_NSApplication_CKShareMetadata_closureTrampoline)
        .cast();
void
    _ObjCBlock_ffiVoid_ffiVoid_NSApplication_CKShareMetadata_listenerTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1,
        ffi.Pointer<objc.ObjCObject> arg2) {
  (objc.getBlockClosure(block) as void Function(
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObject>,
      ffi.Pointer<objc.ObjCObject>))(arg0, arg1, arg2);
  objc.objectRelease(block.cast());
}

ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_ffiVoid_NSApplication_CKShareMetadata_listenerCallable =
    ffi.NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>.listener(
        _ObjCBlock_ffiVoid_ffiVoid_NSApplication_CKShareMetadata_listenerTrampoline)
      ..keepIsolateAlive = false;
void
    _ObjCBlock_ffiVoid_ffiVoid_NSApplication_CKShareMetadata_blockingTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> waiter,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1,
        ffi.Pointer<objc.ObjCObject> arg2) {
  try {
    (objc.getBlockClosure(block) as void Function(
        ffi.Pointer<ffi.Void>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>))(arg0, arg1, arg2);
  } catch (e) {
  } finally {
    objc.signalWaiter(waiter);
    objc.objectRelease(block.cast());
  }
}

ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_ffiVoid_NSApplication_CKShareMetadata_blockingCallable =
    ffi.NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>.isolateLocal(
        _ObjCBlock_ffiVoid_ffiVoid_NSApplication_CKShareMetadata_blockingTrampoline)
      ..keepIsolateAlive = false;
ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_ffiVoid_NSApplication_CKShareMetadata_blockingListenerCallable =
    ffi.NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>.listener(
        _ObjCBlock_ffiVoid_ffiVoid_NSApplication_CKShareMetadata_blockingTrampoline)
      ..keepIsolateAlive = false;

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSApplication, CKShareMetadata)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_NSApplication_CKShareMetadata {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
          ffi.Void Function(
              ffi.Pointer<ffi.Void>, NSApplication, CKShareMetadata)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<
              ffi.Void Function(ffi.Pointer<ffi.Void>, NSApplication,
                  CKShareMetadata)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSApplication, CKShareMetadata)> fromFunctionPointer(
          ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Void Function(
                          ffi.Pointer<ffi.Void> arg0,
                          ffi.Pointer<objc.ObjCObject> arg1,
                          ffi.Pointer<objc.ObjCObject> arg2)>>
              ptr) =>
      objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSApplication, CKShareMetadata)>(
          objc.newPointerBlock(_ObjCBlock_ffiVoid_ffiVoid_NSApplication_CKShareMetadata_fnPtrCallable, ptr.cast()),
          retain: false,
          release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSApplication, CKShareMetadata)>
      fromFunction(void Function(ffi.Pointer<ffi.Void>, NSApplication, CKShareMetadata) fn,
              {bool keepIsolateAlive = true}) =>
          objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSApplication, CKShareMetadata)>(
              objc.newClosureBlock(
                  _ObjCBlock_ffiVoid_ffiVoid_NSApplication_CKShareMetadata_closureCallable,
                  (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1, ffi.Pointer<objc.ObjCObject> arg2) => fn(
                      arg0,
                      NSApplication.castFromPointer(arg1, retain: true, release: true),
                      CKShareMetadata.castFromPointer(arg2, retain: true, release: true)),
                  keepIsolateAlive),
              retain: false,
              release: true);

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
      ffi.Void Function(
          ffi.Pointer<ffi.Void>, NSApplication, CKShareMetadata)> listener(
      void Function(ffi.Pointer<ffi.Void>, NSApplication, CKShareMetadata) fn,
      {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_NSApplication_CKShareMetadata_listenerCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1,
                ffi.Pointer<objc.ObjCObject> arg2) =>
            fn(
                arg0,
                NSApplication.castFromPointer(arg1,
                    retain: false, release: true),
                CKShareMetadata.castFromPointer(arg2,
                    retain: false, release: true)),
        keepIsolateAlive);
    final wrapper = _AuthenticationServicesMacOS_wrapListenerBlock_fjrv01(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
        ffi.Void Function(ffi.Pointer<ffi.Void>, NSApplication,
            CKShareMetadata)>(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<
      ffi.Void Function(
          ffi.Pointer<ffi.Void>, NSApplication, CKShareMetadata)> blocking(
      void Function(ffi.Pointer<ffi.Void>, NSApplication, CKShareMetadata) fn,
      {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_NSApplication_CKShareMetadata_blockingCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1,
                ffi.Pointer<objc.ObjCObject> arg2) =>
            fn(
                arg0,
                NSApplication.castFromPointer(arg1,
                    retain: false, release: true),
                CKShareMetadata.castFromPointer(arg2,
                    retain: false, release: true)),
        keepIsolateAlive);
    final rawListener = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_NSApplication_CKShareMetadata_blockingListenerCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1,
                ffi.Pointer<objc.ObjCObject> arg2) =>
            fn(
                arg0,
                NSApplication.castFromPointer(arg1,
                    retain: false, release: true),
                CKShareMetadata.castFromPointer(arg2,
                    retain: false, release: true)),
        keepIsolateAlive);
    final wrapper = _AuthenticationServicesMacOS_wrapBlockingBlock_fjrv01(
        raw, rawListener, objc.objCContext);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
        ffi.Void Function(ffi.Pointer<ffi.Void>, NSApplication,
            CKShareMetadata)>(wrapper, retain: false, release: true);
  }
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSApplication, CKShareMetadata)>`.
extension ObjCBlock_ffiVoid_ffiVoid_NSApplication_CKShareMetadata_CallExtension
    on objc.ObjCBlock<
        ffi.Void Function(
            ffi.Pointer<ffi.Void>, NSApplication, CKShareMetadata)> {
  void call(ffi.Pointer<ffi.Void> arg0, NSApplication arg1,
          CKShareMetadata arg2) =>
      ref.pointer.ref.invoke
              .cast<
                  ffi.NativeFunction<
                      ffi.Void Function(
                          ffi.Pointer<objc.ObjCBlockImpl> block,
                          ffi.Pointer<ffi.Void> arg0,
                          ffi.Pointer<objc.ObjCObject> arg1,
                          ffi.Pointer<objc.ObjCObject> arg2)>>()
              .asFunction<
                  void Function(
                      ffi.Pointer<objc.ObjCBlockImpl>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<objc.ObjCObject>,
                      ffi.Pointer<objc.ObjCObject>)>()(
          ref.pointer, arg0, arg1.ref.pointer, arg2.ref.pointer);
}

late final _sel_application_delegateHandlesKey_ =
    objc.registerName("application:delegateHandlesKey:");
late final _sel_applicationShouldAutomaticallyLocalizeKeyEquivalents_ =
    objc.registerName("applicationShouldAutomaticallyLocalizeKeyEquivalents:");
late final _sel_applicationWillFinishLaunching_ =
    objc.registerName("applicationWillFinishLaunching:");
void _ObjCBlock_ffiVoid_ffiVoid_NSNotification_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1) =>
    block.ref.target
        .cast<
            ffi.NativeFunction<
                ffi.Void Function(ffi.Pointer<ffi.Void> arg0,
                    ffi.Pointer<objc.ObjCObject> arg1)>>()
        .asFunction<
            void Function(ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>)>()(arg0, arg1);
ffi.Pointer<ffi.Void> _ObjCBlock_ffiVoid_ffiVoid_NSNotification_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_ffiVoid_ffiVoid_NSNotification_fnPtrTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_ffiVoid_NSNotification_closureTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1) =>
    (objc.getBlockClosure(block) as void Function(
        ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>))(arg0, arg1);
ffi.Pointer<ffi.Void>
    _ObjCBlock_ffiVoid_ffiVoid_NSNotification_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_ffiVoid_ffiVoid_NSNotification_closureTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_ffiVoid_NSNotification_listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObject> arg1) {
  (objc.getBlockClosure(block) as void Function(
      ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>))(arg0, arg1);
  objc.objectRelease(block.cast());
}

ffi.NativeCallable<
        ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_ffiVoid_NSNotification_listenerCallable = ffi
        .NativeCallable<
            ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>.listener(
        _ObjCBlock_ffiVoid_ffiVoid_NSNotification_listenerTrampoline)
      ..keepIsolateAlive = false;
void _ObjCBlock_ffiVoid_ffiVoid_NSNotification_blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObject> arg1) {
  try {
    (objc.getBlockClosure(block) as void Function(
        ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>))(arg0, arg1);
  } catch (e) {
  } finally {
    objc.signalWaiter(waiter);
    objc.objectRelease(block.cast());
  }
}

ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_ffiVoid_NSNotification_blockingCallable = ffi
        .NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>)>.isolateLocal(
        _ObjCBlock_ffiVoid_ffiVoid_NSNotification_blockingTrampoline)
      ..keepIsolateAlive = false;
ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_ffiVoid_NSNotification_blockingListenerCallable = ffi
        .NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>)>.listener(
        _ObjCBlock_ffiVoid_ffiVoid_NSNotification_blockingTrampoline)
      ..keepIsolateAlive = false;

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSNotification)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_NSNotification {
  /// Returns a block that wraps the given raw block pointer.
  static objc
      .ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSNotification)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, objc.NSNotification)>(pointer,
              retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSNotification)> fromFunctionPointer(
          ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Void Function(ffi.Pointer<ffi.Void> arg0,
                          ffi.Pointer<objc.ObjCObject> arg1)>>
              ptr) =>
      objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSNotification)>(
          objc.newPointerBlock(_ObjCBlock_ffiVoid_ffiVoid_NSNotification_fnPtrCallable, ptr.cast()),
          retain: false,
          release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSNotification)> fromFunction(
          void Function(ffi.Pointer<ffi.Void>, objc.NSNotification) fn,
          {bool keepIsolateAlive = true}) =>
      objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSNotification)>(
          objc.newClosureBlock(
              _ObjCBlock_ffiVoid_ffiVoid_NSNotification_closureCallable,
              (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1) =>
                  fn(arg0, objc.NSNotification.castFromPointer(arg1, retain: true, release: true)),
              keepIsolateAlive),
          retain: false,
          release: true);

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc
      .ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSNotification)>
      listener(void Function(ffi.Pointer<ffi.Void>, objc.NSNotification) fn,
          {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_NSNotification_listenerCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1) => fn(
            arg0,
            objc.NSNotification.castFromPointer(arg1,
                retain: false, release: true)),
        keepIsolateAlive);
    final wrapper = _AuthenticationServicesMacOS_wrapListenerBlock_18v1jvf(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
        ffi.Void Function(ffi.Pointer<ffi.Void>,
            objc.NSNotification)>(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc
      .ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSNotification)>
      blocking(void Function(ffi.Pointer<ffi.Void>, objc.NSNotification) fn,
          {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_NSNotification_blockingCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1) => fn(
            arg0,
            objc.NSNotification.castFromPointer(arg1,
                retain: false, release: true)),
        keepIsolateAlive);
    final rawListener = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_NSNotification_blockingListenerCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1) => fn(
            arg0,
            objc.NSNotification.castFromPointer(arg1,
                retain: false, release: true)),
        keepIsolateAlive);
    final wrapper = _AuthenticationServicesMacOS_wrapBlockingBlock_18v1jvf(
        raw, rawListener, objc.objCContext);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
        ffi.Void Function(ffi.Pointer<ffi.Void>,
            objc.NSNotification)>(wrapper, retain: false, release: true);
  }
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSNotification)>`.
extension ObjCBlock_ffiVoid_ffiVoid_NSNotification_CallExtension on objc
    .ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSNotification)> {
  void call(ffi.Pointer<ffi.Void> arg0, objc.NSNotification arg1) =>
      ref.pointer.ref.invoke
              .cast<
                  ffi.NativeFunction<
                      ffi.Void Function(
                          ffi.Pointer<objc.ObjCBlockImpl> block,
                          ffi.Pointer<ffi.Void> arg0,
                          ffi.Pointer<objc.ObjCObject> arg1)>>()
              .asFunction<
                  void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>()(
          ref.pointer, arg0, arg1.ref.pointer);
}

late final _sel_applicationDidFinishLaunching_ =
    objc.registerName("applicationDidFinishLaunching:");
late final _sel_applicationWillHide_ =
    objc.registerName("applicationWillHide:");
late final _sel_applicationDidHide_ = objc.registerName("applicationDidHide:");
late final _sel_applicationWillUnhide_ =
    objc.registerName("applicationWillUnhide:");
late final _sel_applicationDidUnhide_ =
    objc.registerName("applicationDidUnhide:");
late final _sel_applicationWillBecomeActive_ =
    objc.registerName("applicationWillBecomeActive:");
late final _sel_applicationDidBecomeActive_ =
    objc.registerName("applicationDidBecomeActive:");
late final _sel_applicationWillResignActive_ =
    objc.registerName("applicationWillResignActive:");
late final _sel_applicationDidResignActive_ =
    objc.registerName("applicationDidResignActive:");
late final _sel_applicationWillUpdate_ =
    objc.registerName("applicationWillUpdate:");
late final _sel_applicationDidUpdate_ =
    objc.registerName("applicationDidUpdate:");
late final _sel_applicationWillTerminate_ =
    objc.registerName("applicationWillTerminate:");
late final _sel_applicationDidChangeScreenParameters_ =
    objc.registerName("applicationDidChangeScreenParameters:");
late final _sel_applicationDidChangeOcclusionState_ =
    objc.registerName("applicationDidChangeOcclusionState:");
late final _sel_applicationProtectedDataWillBecomeUnavailable_ =
    objc.registerName("applicationProtectedDataWillBecomeUnavailable:");
late final _sel_applicationProtectedDataDidBecomeAvailable_ =
    objc.registerName("applicationProtectedDataDidBecomeAvailable:");

/// NSApplicationDelegate
interface class NSApplicationDelegate extends objc.ObjCProtocolBase
    implements objc.NSObjectProtocol {
  NSApplicationDelegate._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super(pointer, retain: retain, release: release);

  /// Constructs a [NSApplicationDelegate] that points to the same underlying object as [other].
  NSApplicationDelegate.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [NSApplicationDelegate] that wraps the given raw object pointer.
  NSApplicationDelegate.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [NSApplicationDelegate].
  static bool conformsTo(objc.ObjCObjectBase obj) {
    return _objc_msgSend_e3qsqz(obj.ref.pointer, _sel_conformsToProtocol_,
        _protocol_NSApplicationDelegate);
  }

  /// Returns the [objc.Protocol] object for this protocol.
  static objc.Protocol get $protocol =>
      objc.Protocol.castFromPointer(_protocol_NSApplicationDelegate.cast());

  /// Builds an object that implements the NSApplicationDelegate protocol. To implement
  /// multiple protocols, use [addToBuilder] or [objc.ObjCProtocolBuilder] directly.
  ///
  /// If `$keepIsolateAlive` is true, this protocol will keep this isolate
  /// alive until it is garbage collected by both Dart and ObjC.
  static NSApplicationDelegate implement(
      {NSApplicationTerminateReply Function(NSApplication)?
          applicationShouldTerminate_,
      void Function(NSApplication, objc.NSArray)? application_openURLs_,
      bool Function(NSApplication, objc.NSString)? application_openFile_,
      void Function(NSApplication, objc.NSArray)? application_openFiles_,
      bool Function(NSApplication, objc.NSString)? application_openTempFile_,
      bool Function(NSApplication)? applicationShouldOpenUntitledFile_,
      bool Function(NSApplication)? applicationOpenUntitledFile_,
      bool Function(objc.ObjCObjectBase, objc.NSString)?
          application_openFileWithoutUI_,
      bool Function(NSApplication, objc.NSString)? application_printFile_,
      NSApplicationPrintReply Function(
              NSApplication, objc.NSArray, objc.ObjCObjectBase, bool)?
          application_printFiles_withSettings_showPrintPanels_,
      bool Function(NSApplication)?
          applicationShouldTerminateAfterLastWindowClosed_,
      bool Function(NSApplication, bool)?
          applicationShouldHandleReopen_hasVisibleWindows_,
      NSMenu? Function(NSApplication)? applicationDockMenu_,
      objc.NSError Function(NSApplication, objc.NSError)?
          application_willPresentError_,
      void Function(NSApplication, objc.NSData)?
          application_didRegisterForRemoteNotificationsWithDeviceToken_,
      void Function(NSApplication, objc.NSError)?
          application_didFailToRegisterForRemoteNotificationsWithError_,
      void Function(NSApplication, objc.ObjCObjectBase)?
          application_didReceiveRemoteNotification_,
      bool Function(NSApplication)? applicationSupportsSecureRestorableState_,
      objc.ObjCObjectBase? Function(NSApplication, INIntent)?
          application_handlerForIntent_,
      void Function(NSApplication, objc.NSCoder)?
          application_willEncodeRestorableState_,
      void Function(NSApplication, objc.NSCoder)?
          application_didDecodeRestorableState_,
      bool Function(NSApplication, objc.NSString)?
          application_willContinueUserActivityWithType_,
      bool Function(NSApplication, NSUserActivity,
              objc.ObjCBlock<ffi.Void Function(objc.NSArray)>)?
          application_continueUserActivity_restorationHandler_,
      void Function(NSApplication, objc.NSString, objc.NSError)?
          application_didFailToContinueUserActivityWithType_error_,
      void Function(NSApplication, NSUserActivity)?
          application_didUpdateUserActivity_,
      void Function(NSApplication, CKShareMetadata)?
          application_userDidAcceptCloudKitShareWithMetadata_,
      bool Function(NSApplication, objc.NSString)?
          application_delegateHandlesKey_,
      bool Function(NSApplication)? applicationShouldAutomaticallyLocalizeKeyEquivalents_,
      void Function(objc.NSNotification)? applicationWillFinishLaunching_,
      void Function(objc.NSNotification)? applicationDidFinishLaunching_,
      void Function(objc.NSNotification)? applicationWillHide_,
      void Function(objc.NSNotification)? applicationDidHide_,
      void Function(objc.NSNotification)? applicationWillUnhide_,
      void Function(objc.NSNotification)? applicationDidUnhide_,
      void Function(objc.NSNotification)? applicationWillBecomeActive_,
      void Function(objc.NSNotification)? applicationDidBecomeActive_,
      void Function(objc.NSNotification)? applicationWillResignActive_,
      void Function(objc.NSNotification)? applicationDidResignActive_,
      void Function(objc.NSNotification)? applicationWillUpdate_,
      void Function(objc.NSNotification)? applicationDidUpdate_,
      void Function(objc.NSNotification)? applicationWillTerminate_,
      void Function(objc.NSNotification)? applicationDidChangeScreenParameters_,
      void Function(objc.NSNotification)? applicationDidChangeOcclusionState_,
      void Function(objc.NSNotification)? applicationProtectedDataWillBecomeUnavailable_,
      void Function(objc.NSNotification)? applicationProtectedDataDidBecomeAvailable_,
      bool $keepIsolateAlive = true}) {
    final builder =
        objc.ObjCProtocolBuilder(debugName: 'NSApplicationDelegate');
    NSApplicationDelegate.applicationShouldTerminate_
        .implement(builder, applicationShouldTerminate_);
    NSApplicationDelegate.application_openURLs_
        .implement(builder, application_openURLs_);
    NSApplicationDelegate.application_openFile_
        .implement(builder, application_openFile_);
    NSApplicationDelegate.application_openFiles_
        .implement(builder, application_openFiles_);
    NSApplicationDelegate.application_openTempFile_
        .implement(builder, application_openTempFile_);
    NSApplicationDelegate.applicationShouldOpenUntitledFile_
        .implement(builder, applicationShouldOpenUntitledFile_);
    NSApplicationDelegate.applicationOpenUntitledFile_
        .implement(builder, applicationOpenUntitledFile_);
    NSApplicationDelegate.application_openFileWithoutUI_
        .implement(builder, application_openFileWithoutUI_);
    NSApplicationDelegate.application_printFile_
        .implement(builder, application_printFile_);
    NSApplicationDelegate.application_printFiles_withSettings_showPrintPanels_
        .implement(
            builder, application_printFiles_withSettings_showPrintPanels_);
    NSApplicationDelegate.applicationShouldTerminateAfterLastWindowClosed_
        .implement(builder, applicationShouldTerminateAfterLastWindowClosed_);
    NSApplicationDelegate.applicationShouldHandleReopen_hasVisibleWindows_
        .implement(builder, applicationShouldHandleReopen_hasVisibleWindows_);
    NSApplicationDelegate.applicationDockMenu_
        .implement(builder, applicationDockMenu_);
    NSApplicationDelegate.application_willPresentError_
        .implement(builder, application_willPresentError_);
    NSApplicationDelegate
        .application_didRegisterForRemoteNotificationsWithDeviceToken_
        .implement(builder,
            application_didRegisterForRemoteNotificationsWithDeviceToken_);
    NSApplicationDelegate
        .application_didFailToRegisterForRemoteNotificationsWithError_
        .implement(builder,
            application_didFailToRegisterForRemoteNotificationsWithError_);
    NSApplicationDelegate.application_didReceiveRemoteNotification_
        .implement(builder, application_didReceiveRemoteNotification_);
    NSApplicationDelegate.applicationSupportsSecureRestorableState_
        .implement(builder, applicationSupportsSecureRestorableState_);
    NSApplicationDelegate.application_handlerForIntent_
        .implement(builder, application_handlerForIntent_);
    NSApplicationDelegate.application_willEncodeRestorableState_
        .implement(builder, application_willEncodeRestorableState_);
    NSApplicationDelegate.application_didDecodeRestorableState_
        .implement(builder, application_didDecodeRestorableState_);
    NSApplicationDelegate.application_willContinueUserActivityWithType_
        .implement(builder, application_willContinueUserActivityWithType_);
    NSApplicationDelegate.application_continueUserActivity_restorationHandler_
        .implement(
            builder, application_continueUserActivity_restorationHandler_);
    NSApplicationDelegate
        .application_didFailToContinueUserActivityWithType_error_
        .implement(
            builder, application_didFailToContinueUserActivityWithType_error_);
    NSApplicationDelegate.application_didUpdateUserActivity_
        .implement(builder, application_didUpdateUserActivity_);
    NSApplicationDelegate.application_userDidAcceptCloudKitShareWithMetadata_
        .implement(
            builder, application_userDidAcceptCloudKitShareWithMetadata_);
    NSApplicationDelegate.application_delegateHandlesKey_
        .implement(builder, application_delegateHandlesKey_);
    NSApplicationDelegate.applicationShouldAutomaticallyLocalizeKeyEquivalents_
        .implement(
            builder, applicationShouldAutomaticallyLocalizeKeyEquivalents_);
    NSApplicationDelegate.applicationWillFinishLaunching_
        .implement(builder, applicationWillFinishLaunching_);
    NSApplicationDelegate.applicationDidFinishLaunching_
        .implement(builder, applicationDidFinishLaunching_);
    NSApplicationDelegate.applicationWillHide_
        .implement(builder, applicationWillHide_);
    NSApplicationDelegate.applicationDidHide_
        .implement(builder, applicationDidHide_);
    NSApplicationDelegate.applicationWillUnhide_
        .implement(builder, applicationWillUnhide_);
    NSApplicationDelegate.applicationDidUnhide_
        .implement(builder, applicationDidUnhide_);
    NSApplicationDelegate.applicationWillBecomeActive_
        .implement(builder, applicationWillBecomeActive_);
    NSApplicationDelegate.applicationDidBecomeActive_
        .implement(builder, applicationDidBecomeActive_);
    NSApplicationDelegate.applicationWillResignActive_
        .implement(builder, applicationWillResignActive_);
    NSApplicationDelegate.applicationDidResignActive_
        .implement(builder, applicationDidResignActive_);
    NSApplicationDelegate.applicationWillUpdate_
        .implement(builder, applicationWillUpdate_);
    NSApplicationDelegate.applicationDidUpdate_
        .implement(builder, applicationDidUpdate_);
    NSApplicationDelegate.applicationWillTerminate_
        .implement(builder, applicationWillTerminate_);
    NSApplicationDelegate.applicationDidChangeScreenParameters_
        .implement(builder, applicationDidChangeScreenParameters_);
    NSApplicationDelegate.applicationDidChangeOcclusionState_
        .implement(builder, applicationDidChangeOcclusionState_);
    NSApplicationDelegate.applicationProtectedDataWillBecomeUnavailable_
        .implement(builder, applicationProtectedDataWillBecomeUnavailable_);
    NSApplicationDelegate.applicationProtectedDataDidBecomeAvailable_
        .implement(builder, applicationProtectedDataDidBecomeAvailable_);
    builder.addProtocol($protocol);
    return NSApplicationDelegate.castFrom(
        builder.build(keepIsolateAlive: $keepIsolateAlive));
  }

  /// Adds the implementation of the NSApplicationDelegate protocol to an existing
  /// [objc.ObjCProtocolBuilder].
  ///
  /// Note: You cannot call this method after you have called `builder.build`.
  static void addToBuilder(objc.ObjCProtocolBuilder builder,
      {NSApplicationTerminateReply Function(NSApplication)?
          applicationShouldTerminate_,
      void Function(NSApplication, objc.NSArray)? application_openURLs_,
      bool Function(NSApplication, objc.NSString)? application_openFile_,
      void Function(NSApplication, objc.NSArray)? application_openFiles_,
      bool Function(NSApplication, objc.NSString)? application_openTempFile_,
      bool Function(NSApplication)? applicationShouldOpenUntitledFile_,
      bool Function(NSApplication)? applicationOpenUntitledFile_,
      bool Function(objc.ObjCObjectBase, objc.NSString)?
          application_openFileWithoutUI_,
      bool Function(NSApplication, objc.NSString)? application_printFile_,
      NSApplicationPrintReply Function(
              NSApplication, objc.NSArray, objc.ObjCObjectBase, bool)?
          application_printFiles_withSettings_showPrintPanels_,
      bool Function(NSApplication)?
          applicationShouldTerminateAfterLastWindowClosed_,
      bool Function(NSApplication, bool)?
          applicationShouldHandleReopen_hasVisibleWindows_,
      NSMenu? Function(NSApplication)? applicationDockMenu_,
      objc.NSError Function(NSApplication, objc.NSError)?
          application_willPresentError_,
      void Function(NSApplication, objc.NSData)?
          application_didRegisterForRemoteNotificationsWithDeviceToken_,
      void Function(NSApplication, objc.NSError)?
          application_didFailToRegisterForRemoteNotificationsWithError_,
      void Function(NSApplication, objc.ObjCObjectBase)?
          application_didReceiveRemoteNotification_,
      bool Function(NSApplication)? applicationSupportsSecureRestorableState_,
      objc.ObjCObjectBase? Function(NSApplication, INIntent)?
          application_handlerForIntent_,
      void Function(NSApplication, objc.NSCoder)?
          application_willEncodeRestorableState_,
      void Function(NSApplication, objc.NSCoder)?
          application_didDecodeRestorableState_,
      bool Function(NSApplication, objc.NSString)?
          application_willContinueUserActivityWithType_,
      bool Function(NSApplication, NSUserActivity,
              objc.ObjCBlock<ffi.Void Function(objc.NSArray)>)?
          application_continueUserActivity_restorationHandler_,
      void Function(NSApplication, objc.NSString, objc.NSError)?
          application_didFailToContinueUserActivityWithType_error_,
      void Function(NSApplication, NSUserActivity)?
          application_didUpdateUserActivity_,
      void Function(NSApplication, CKShareMetadata)?
          application_userDidAcceptCloudKitShareWithMetadata_,
      bool Function(NSApplication, objc.NSString)?
          application_delegateHandlesKey_,
      bool Function(NSApplication)? applicationShouldAutomaticallyLocalizeKeyEquivalents_,
      void Function(objc.NSNotification)? applicationWillFinishLaunching_,
      void Function(objc.NSNotification)? applicationDidFinishLaunching_,
      void Function(objc.NSNotification)? applicationWillHide_,
      void Function(objc.NSNotification)? applicationDidHide_,
      void Function(objc.NSNotification)? applicationWillUnhide_,
      void Function(objc.NSNotification)? applicationDidUnhide_,
      void Function(objc.NSNotification)? applicationWillBecomeActive_,
      void Function(objc.NSNotification)? applicationDidBecomeActive_,
      void Function(objc.NSNotification)? applicationWillResignActive_,
      void Function(objc.NSNotification)? applicationDidResignActive_,
      void Function(objc.NSNotification)? applicationWillUpdate_,
      void Function(objc.NSNotification)? applicationDidUpdate_,
      void Function(objc.NSNotification)? applicationWillTerminate_,
      void Function(objc.NSNotification)? applicationDidChangeScreenParameters_,
      void Function(objc.NSNotification)? applicationDidChangeOcclusionState_,
      void Function(objc.NSNotification)? applicationProtectedDataWillBecomeUnavailable_,
      void Function(objc.NSNotification)? applicationProtectedDataDidBecomeAvailable_,
      bool $keepIsolateAlive = true}) {
    NSApplicationDelegate.applicationShouldTerminate_
        .implement(builder, applicationShouldTerminate_);
    NSApplicationDelegate.application_openURLs_
        .implement(builder, application_openURLs_);
    NSApplicationDelegate.application_openFile_
        .implement(builder, application_openFile_);
    NSApplicationDelegate.application_openFiles_
        .implement(builder, application_openFiles_);
    NSApplicationDelegate.application_openTempFile_
        .implement(builder, application_openTempFile_);
    NSApplicationDelegate.applicationShouldOpenUntitledFile_
        .implement(builder, applicationShouldOpenUntitledFile_);
    NSApplicationDelegate.applicationOpenUntitledFile_
        .implement(builder, applicationOpenUntitledFile_);
    NSApplicationDelegate.application_openFileWithoutUI_
        .implement(builder, application_openFileWithoutUI_);
    NSApplicationDelegate.application_printFile_
        .implement(builder, application_printFile_);
    NSApplicationDelegate.application_printFiles_withSettings_showPrintPanels_
        .implement(
            builder, application_printFiles_withSettings_showPrintPanels_);
    NSApplicationDelegate.applicationShouldTerminateAfterLastWindowClosed_
        .implement(builder, applicationShouldTerminateAfterLastWindowClosed_);
    NSApplicationDelegate.applicationShouldHandleReopen_hasVisibleWindows_
        .implement(builder, applicationShouldHandleReopen_hasVisibleWindows_);
    NSApplicationDelegate.applicationDockMenu_
        .implement(builder, applicationDockMenu_);
    NSApplicationDelegate.application_willPresentError_
        .implement(builder, application_willPresentError_);
    NSApplicationDelegate
        .application_didRegisterForRemoteNotificationsWithDeviceToken_
        .implement(builder,
            application_didRegisterForRemoteNotificationsWithDeviceToken_);
    NSApplicationDelegate
        .application_didFailToRegisterForRemoteNotificationsWithError_
        .implement(builder,
            application_didFailToRegisterForRemoteNotificationsWithError_);
    NSApplicationDelegate.application_didReceiveRemoteNotification_
        .implement(builder, application_didReceiveRemoteNotification_);
    NSApplicationDelegate.applicationSupportsSecureRestorableState_
        .implement(builder, applicationSupportsSecureRestorableState_);
    NSApplicationDelegate.application_handlerForIntent_
        .implement(builder, application_handlerForIntent_);
    NSApplicationDelegate.application_willEncodeRestorableState_
        .implement(builder, application_willEncodeRestorableState_);
    NSApplicationDelegate.application_didDecodeRestorableState_
        .implement(builder, application_didDecodeRestorableState_);
    NSApplicationDelegate.application_willContinueUserActivityWithType_
        .implement(builder, application_willContinueUserActivityWithType_);
    NSApplicationDelegate.application_continueUserActivity_restorationHandler_
        .implement(
            builder, application_continueUserActivity_restorationHandler_);
    NSApplicationDelegate
        .application_didFailToContinueUserActivityWithType_error_
        .implement(
            builder, application_didFailToContinueUserActivityWithType_error_);
    NSApplicationDelegate.application_didUpdateUserActivity_
        .implement(builder, application_didUpdateUserActivity_);
    NSApplicationDelegate.application_userDidAcceptCloudKitShareWithMetadata_
        .implement(
            builder, application_userDidAcceptCloudKitShareWithMetadata_);
    NSApplicationDelegate.application_delegateHandlesKey_
        .implement(builder, application_delegateHandlesKey_);
    NSApplicationDelegate.applicationShouldAutomaticallyLocalizeKeyEquivalents_
        .implement(
            builder, applicationShouldAutomaticallyLocalizeKeyEquivalents_);
    NSApplicationDelegate.applicationWillFinishLaunching_
        .implement(builder, applicationWillFinishLaunching_);
    NSApplicationDelegate.applicationDidFinishLaunching_
        .implement(builder, applicationDidFinishLaunching_);
    NSApplicationDelegate.applicationWillHide_
        .implement(builder, applicationWillHide_);
    NSApplicationDelegate.applicationDidHide_
        .implement(builder, applicationDidHide_);
    NSApplicationDelegate.applicationWillUnhide_
        .implement(builder, applicationWillUnhide_);
    NSApplicationDelegate.applicationDidUnhide_
        .implement(builder, applicationDidUnhide_);
    NSApplicationDelegate.applicationWillBecomeActive_
        .implement(builder, applicationWillBecomeActive_);
    NSApplicationDelegate.applicationDidBecomeActive_
        .implement(builder, applicationDidBecomeActive_);
    NSApplicationDelegate.applicationWillResignActive_
        .implement(builder, applicationWillResignActive_);
    NSApplicationDelegate.applicationDidResignActive_
        .implement(builder, applicationDidResignActive_);
    NSApplicationDelegate.applicationWillUpdate_
        .implement(builder, applicationWillUpdate_);
    NSApplicationDelegate.applicationDidUpdate_
        .implement(builder, applicationDidUpdate_);
    NSApplicationDelegate.applicationWillTerminate_
        .implement(builder, applicationWillTerminate_);
    NSApplicationDelegate.applicationDidChangeScreenParameters_
        .implement(builder, applicationDidChangeScreenParameters_);
    NSApplicationDelegate.applicationDidChangeOcclusionState_
        .implement(builder, applicationDidChangeOcclusionState_);
    NSApplicationDelegate.applicationProtectedDataWillBecomeUnavailable_
        .implement(builder, applicationProtectedDataWillBecomeUnavailable_);
    NSApplicationDelegate.applicationProtectedDataDidBecomeAvailable_
        .implement(builder, applicationProtectedDataDidBecomeAvailable_);
    builder.addProtocol($protocol);
  }

  /// Builds an object that implements the NSApplicationDelegate protocol. To implement
  /// multiple protocols, use [addToBuilder] or [objc.ObjCProtocolBuilder] directly. All
  /// methods that can be implemented as listeners will be.
  ///
  /// If `$keepIsolateAlive` is true, this protocol will keep this isolate
  /// alive until it is garbage collected by both Dart and ObjC.
  static NSApplicationDelegate implementAsListener(
      {NSApplicationTerminateReply Function(NSApplication)?
          applicationShouldTerminate_,
      void Function(NSApplication, objc.NSArray)? application_openURLs_,
      bool Function(NSApplication, objc.NSString)? application_openFile_,
      void Function(NSApplication, objc.NSArray)? application_openFiles_,
      bool Function(NSApplication, objc.NSString)? application_openTempFile_,
      bool Function(NSApplication)? applicationShouldOpenUntitledFile_,
      bool Function(NSApplication)? applicationOpenUntitledFile_,
      bool Function(objc.ObjCObjectBase, objc.NSString)?
          application_openFileWithoutUI_,
      bool Function(NSApplication, objc.NSString)? application_printFile_,
      NSApplicationPrintReply Function(
              NSApplication, objc.NSArray, objc.ObjCObjectBase, bool)?
          application_printFiles_withSettings_showPrintPanels_,
      bool Function(NSApplication)?
          applicationShouldTerminateAfterLastWindowClosed_,
      bool Function(NSApplication, bool)?
          applicationShouldHandleReopen_hasVisibleWindows_,
      NSMenu? Function(NSApplication)? applicationDockMenu_,
      objc.NSError Function(NSApplication, objc.NSError)?
          application_willPresentError_,
      void Function(NSApplication, objc.NSData)?
          application_didRegisterForRemoteNotificationsWithDeviceToken_,
      void Function(NSApplication, objc.NSError)?
          application_didFailToRegisterForRemoteNotificationsWithError_,
      void Function(NSApplication, objc.ObjCObjectBase)?
          application_didReceiveRemoteNotification_,
      bool Function(NSApplication)? applicationSupportsSecureRestorableState_,
      objc.ObjCObjectBase? Function(NSApplication, INIntent)?
          application_handlerForIntent_,
      void Function(NSApplication, objc.NSCoder)?
          application_willEncodeRestorableState_,
      void Function(NSApplication, objc.NSCoder)?
          application_didDecodeRestorableState_,
      bool Function(NSApplication, objc.NSString)?
          application_willContinueUserActivityWithType_,
      bool Function(NSApplication, NSUserActivity,
              objc.ObjCBlock<ffi.Void Function(objc.NSArray)>)?
          application_continueUserActivity_restorationHandler_,
      void Function(NSApplication, objc.NSString, objc.NSError)?
          application_didFailToContinueUserActivityWithType_error_,
      void Function(NSApplication, NSUserActivity)?
          application_didUpdateUserActivity_,
      void Function(NSApplication, CKShareMetadata)?
          application_userDidAcceptCloudKitShareWithMetadata_,
      bool Function(NSApplication, objc.NSString)?
          application_delegateHandlesKey_,
      bool Function(NSApplication)? applicationShouldAutomaticallyLocalizeKeyEquivalents_,
      void Function(objc.NSNotification)? applicationWillFinishLaunching_,
      void Function(objc.NSNotification)? applicationDidFinishLaunching_,
      void Function(objc.NSNotification)? applicationWillHide_,
      void Function(objc.NSNotification)? applicationDidHide_,
      void Function(objc.NSNotification)? applicationWillUnhide_,
      void Function(objc.NSNotification)? applicationDidUnhide_,
      void Function(objc.NSNotification)? applicationWillBecomeActive_,
      void Function(objc.NSNotification)? applicationDidBecomeActive_,
      void Function(objc.NSNotification)? applicationWillResignActive_,
      void Function(objc.NSNotification)? applicationDidResignActive_,
      void Function(objc.NSNotification)? applicationWillUpdate_,
      void Function(objc.NSNotification)? applicationDidUpdate_,
      void Function(objc.NSNotification)? applicationWillTerminate_,
      void Function(objc.NSNotification)? applicationDidChangeScreenParameters_,
      void Function(objc.NSNotification)? applicationDidChangeOcclusionState_,
      void Function(objc.NSNotification)? applicationProtectedDataWillBecomeUnavailable_,
      void Function(objc.NSNotification)? applicationProtectedDataDidBecomeAvailable_,
      bool $keepIsolateAlive = true}) {
    final builder =
        objc.ObjCProtocolBuilder(debugName: 'NSApplicationDelegate');
    NSApplicationDelegate.applicationShouldTerminate_
        .implement(builder, applicationShouldTerminate_);
    NSApplicationDelegate.application_openURLs_
        .implementAsListener(builder, application_openURLs_);
    NSApplicationDelegate.application_openFile_
        .implement(builder, application_openFile_);
    NSApplicationDelegate.application_openFiles_
        .implementAsListener(builder, application_openFiles_);
    NSApplicationDelegate.application_openTempFile_
        .implement(builder, application_openTempFile_);
    NSApplicationDelegate.applicationShouldOpenUntitledFile_
        .implement(builder, applicationShouldOpenUntitledFile_);
    NSApplicationDelegate.applicationOpenUntitledFile_
        .implement(builder, applicationOpenUntitledFile_);
    NSApplicationDelegate.application_openFileWithoutUI_
        .implement(builder, application_openFileWithoutUI_);
    NSApplicationDelegate.application_printFile_
        .implement(builder, application_printFile_);
    NSApplicationDelegate.application_printFiles_withSettings_showPrintPanels_
        .implement(
            builder, application_printFiles_withSettings_showPrintPanels_);
    NSApplicationDelegate.applicationShouldTerminateAfterLastWindowClosed_
        .implement(builder, applicationShouldTerminateAfterLastWindowClosed_);
    NSApplicationDelegate.applicationShouldHandleReopen_hasVisibleWindows_
        .implement(builder, applicationShouldHandleReopen_hasVisibleWindows_);
    NSApplicationDelegate.applicationDockMenu_
        .implement(builder, applicationDockMenu_);
    NSApplicationDelegate.application_willPresentError_
        .implement(builder, application_willPresentError_);
    NSApplicationDelegate
        .application_didRegisterForRemoteNotificationsWithDeviceToken_
        .implementAsListener(builder,
            application_didRegisterForRemoteNotificationsWithDeviceToken_);
    NSApplicationDelegate
        .application_didFailToRegisterForRemoteNotificationsWithError_
        .implementAsListener(builder,
            application_didFailToRegisterForRemoteNotificationsWithError_);
    NSApplicationDelegate.application_didReceiveRemoteNotification_
        .implementAsListener(
            builder, application_didReceiveRemoteNotification_);
    NSApplicationDelegate.applicationSupportsSecureRestorableState_
        .implement(builder, applicationSupportsSecureRestorableState_);
    NSApplicationDelegate.application_handlerForIntent_
        .implement(builder, application_handlerForIntent_);
    NSApplicationDelegate.application_willEncodeRestorableState_
        .implementAsListener(builder, application_willEncodeRestorableState_);
    NSApplicationDelegate.application_didDecodeRestorableState_
        .implementAsListener(builder, application_didDecodeRestorableState_);
    NSApplicationDelegate.application_willContinueUserActivityWithType_
        .implement(builder, application_willContinueUserActivityWithType_);
    NSApplicationDelegate.application_continueUserActivity_restorationHandler_
        .implement(
            builder, application_continueUserActivity_restorationHandler_);
    NSApplicationDelegate
        .application_didFailToContinueUserActivityWithType_error_
        .implementAsListener(
            builder, application_didFailToContinueUserActivityWithType_error_);
    NSApplicationDelegate.application_didUpdateUserActivity_
        .implementAsListener(builder, application_didUpdateUserActivity_);
    NSApplicationDelegate.application_userDidAcceptCloudKitShareWithMetadata_
        .implementAsListener(
            builder, application_userDidAcceptCloudKitShareWithMetadata_);
    NSApplicationDelegate.application_delegateHandlesKey_
        .implement(builder, application_delegateHandlesKey_);
    NSApplicationDelegate.applicationShouldAutomaticallyLocalizeKeyEquivalents_
        .implement(
            builder, applicationShouldAutomaticallyLocalizeKeyEquivalents_);
    NSApplicationDelegate.applicationWillFinishLaunching_
        .implementAsListener(builder, applicationWillFinishLaunching_);
    NSApplicationDelegate.applicationDidFinishLaunching_
        .implementAsListener(builder, applicationDidFinishLaunching_);
    NSApplicationDelegate.applicationWillHide_
        .implementAsListener(builder, applicationWillHide_);
    NSApplicationDelegate.applicationDidHide_
        .implementAsListener(builder, applicationDidHide_);
    NSApplicationDelegate.applicationWillUnhide_
        .implementAsListener(builder, applicationWillUnhide_);
    NSApplicationDelegate.applicationDidUnhide_
        .implementAsListener(builder, applicationDidUnhide_);
    NSApplicationDelegate.applicationWillBecomeActive_
        .implementAsListener(builder, applicationWillBecomeActive_);
    NSApplicationDelegate.applicationDidBecomeActive_
        .implementAsListener(builder, applicationDidBecomeActive_);
    NSApplicationDelegate.applicationWillResignActive_
        .implementAsListener(builder, applicationWillResignActive_);
    NSApplicationDelegate.applicationDidResignActive_
        .implementAsListener(builder, applicationDidResignActive_);
    NSApplicationDelegate.applicationWillUpdate_
        .implementAsListener(builder, applicationWillUpdate_);
    NSApplicationDelegate.applicationDidUpdate_
        .implementAsListener(builder, applicationDidUpdate_);
    NSApplicationDelegate.applicationWillTerminate_
        .implementAsListener(builder, applicationWillTerminate_);
    NSApplicationDelegate.applicationDidChangeScreenParameters_
        .implementAsListener(builder, applicationDidChangeScreenParameters_);
    NSApplicationDelegate.applicationDidChangeOcclusionState_
        .implementAsListener(builder, applicationDidChangeOcclusionState_);
    NSApplicationDelegate.applicationProtectedDataWillBecomeUnavailable_
        .implementAsListener(
            builder, applicationProtectedDataWillBecomeUnavailable_);
    NSApplicationDelegate.applicationProtectedDataDidBecomeAvailable_
        .implementAsListener(
            builder, applicationProtectedDataDidBecomeAvailable_);
    builder.addProtocol($protocol);
    return NSApplicationDelegate.castFrom(
        builder.build(keepIsolateAlive: $keepIsolateAlive));
  }

  /// Adds the implementation of the NSApplicationDelegate protocol to an existing
  /// [objc.ObjCProtocolBuilder]. All methods that can be implemented as listeners will
  /// be.
  ///
  /// Note: You cannot call this method after you have called `builder.build`.
  static void addToBuilderAsListener(objc.ObjCProtocolBuilder builder,
      {NSApplicationTerminateReply Function(NSApplication)?
          applicationShouldTerminate_,
      void Function(NSApplication, objc.NSArray)? application_openURLs_,
      bool Function(NSApplication, objc.NSString)? application_openFile_,
      void Function(NSApplication, objc.NSArray)? application_openFiles_,
      bool Function(NSApplication, objc.NSString)? application_openTempFile_,
      bool Function(NSApplication)? applicationShouldOpenUntitledFile_,
      bool Function(NSApplication)? applicationOpenUntitledFile_,
      bool Function(objc.ObjCObjectBase, objc.NSString)?
          application_openFileWithoutUI_,
      bool Function(NSApplication, objc.NSString)? application_printFile_,
      NSApplicationPrintReply Function(
              NSApplication, objc.NSArray, objc.ObjCObjectBase, bool)?
          application_printFiles_withSettings_showPrintPanels_,
      bool Function(NSApplication)?
          applicationShouldTerminateAfterLastWindowClosed_,
      bool Function(NSApplication, bool)?
          applicationShouldHandleReopen_hasVisibleWindows_,
      NSMenu? Function(NSApplication)? applicationDockMenu_,
      objc.NSError Function(NSApplication, objc.NSError)?
          application_willPresentError_,
      void Function(NSApplication, objc.NSData)?
          application_didRegisterForRemoteNotificationsWithDeviceToken_,
      void Function(NSApplication, objc.NSError)?
          application_didFailToRegisterForRemoteNotificationsWithError_,
      void Function(NSApplication, objc.ObjCObjectBase)?
          application_didReceiveRemoteNotification_,
      bool Function(NSApplication)? applicationSupportsSecureRestorableState_,
      objc.ObjCObjectBase? Function(NSApplication, INIntent)?
          application_handlerForIntent_,
      void Function(NSApplication, objc.NSCoder)?
          application_willEncodeRestorableState_,
      void Function(NSApplication, objc.NSCoder)?
          application_didDecodeRestorableState_,
      bool Function(NSApplication, objc.NSString)?
          application_willContinueUserActivityWithType_,
      bool Function(NSApplication, NSUserActivity,
              objc.ObjCBlock<ffi.Void Function(objc.NSArray)>)?
          application_continueUserActivity_restorationHandler_,
      void Function(NSApplication, objc.NSString, objc.NSError)?
          application_didFailToContinueUserActivityWithType_error_,
      void Function(NSApplication, NSUserActivity)?
          application_didUpdateUserActivity_,
      void Function(NSApplication, CKShareMetadata)?
          application_userDidAcceptCloudKitShareWithMetadata_,
      bool Function(NSApplication, objc.NSString)?
          application_delegateHandlesKey_,
      bool Function(NSApplication)? applicationShouldAutomaticallyLocalizeKeyEquivalents_,
      void Function(objc.NSNotification)? applicationWillFinishLaunching_,
      void Function(objc.NSNotification)? applicationDidFinishLaunching_,
      void Function(objc.NSNotification)? applicationWillHide_,
      void Function(objc.NSNotification)? applicationDidHide_,
      void Function(objc.NSNotification)? applicationWillUnhide_,
      void Function(objc.NSNotification)? applicationDidUnhide_,
      void Function(objc.NSNotification)? applicationWillBecomeActive_,
      void Function(objc.NSNotification)? applicationDidBecomeActive_,
      void Function(objc.NSNotification)? applicationWillResignActive_,
      void Function(objc.NSNotification)? applicationDidResignActive_,
      void Function(objc.NSNotification)? applicationWillUpdate_,
      void Function(objc.NSNotification)? applicationDidUpdate_,
      void Function(objc.NSNotification)? applicationWillTerminate_,
      void Function(objc.NSNotification)? applicationDidChangeScreenParameters_,
      void Function(objc.NSNotification)? applicationDidChangeOcclusionState_,
      void Function(objc.NSNotification)? applicationProtectedDataWillBecomeUnavailable_,
      void Function(objc.NSNotification)? applicationProtectedDataDidBecomeAvailable_,
      bool $keepIsolateAlive = true}) {
    NSApplicationDelegate.applicationShouldTerminate_
        .implement(builder, applicationShouldTerminate_);
    NSApplicationDelegate.application_openURLs_
        .implementAsListener(builder, application_openURLs_);
    NSApplicationDelegate.application_openFile_
        .implement(builder, application_openFile_);
    NSApplicationDelegate.application_openFiles_
        .implementAsListener(builder, application_openFiles_);
    NSApplicationDelegate.application_openTempFile_
        .implement(builder, application_openTempFile_);
    NSApplicationDelegate.applicationShouldOpenUntitledFile_
        .implement(builder, applicationShouldOpenUntitledFile_);
    NSApplicationDelegate.applicationOpenUntitledFile_
        .implement(builder, applicationOpenUntitledFile_);
    NSApplicationDelegate.application_openFileWithoutUI_
        .implement(builder, application_openFileWithoutUI_);
    NSApplicationDelegate.application_printFile_
        .implement(builder, application_printFile_);
    NSApplicationDelegate.application_printFiles_withSettings_showPrintPanels_
        .implement(
            builder, application_printFiles_withSettings_showPrintPanels_);
    NSApplicationDelegate.applicationShouldTerminateAfterLastWindowClosed_
        .implement(builder, applicationShouldTerminateAfterLastWindowClosed_);
    NSApplicationDelegate.applicationShouldHandleReopen_hasVisibleWindows_
        .implement(builder, applicationShouldHandleReopen_hasVisibleWindows_);
    NSApplicationDelegate.applicationDockMenu_
        .implement(builder, applicationDockMenu_);
    NSApplicationDelegate.application_willPresentError_
        .implement(builder, application_willPresentError_);
    NSApplicationDelegate
        .application_didRegisterForRemoteNotificationsWithDeviceToken_
        .implementAsListener(builder,
            application_didRegisterForRemoteNotificationsWithDeviceToken_);
    NSApplicationDelegate
        .application_didFailToRegisterForRemoteNotificationsWithError_
        .implementAsListener(builder,
            application_didFailToRegisterForRemoteNotificationsWithError_);
    NSApplicationDelegate.application_didReceiveRemoteNotification_
        .implementAsListener(
            builder, application_didReceiveRemoteNotification_);
    NSApplicationDelegate.applicationSupportsSecureRestorableState_
        .implement(builder, applicationSupportsSecureRestorableState_);
    NSApplicationDelegate.application_handlerForIntent_
        .implement(builder, application_handlerForIntent_);
    NSApplicationDelegate.application_willEncodeRestorableState_
        .implementAsListener(builder, application_willEncodeRestorableState_);
    NSApplicationDelegate.application_didDecodeRestorableState_
        .implementAsListener(builder, application_didDecodeRestorableState_);
    NSApplicationDelegate.application_willContinueUserActivityWithType_
        .implement(builder, application_willContinueUserActivityWithType_);
    NSApplicationDelegate.application_continueUserActivity_restorationHandler_
        .implement(
            builder, application_continueUserActivity_restorationHandler_);
    NSApplicationDelegate
        .application_didFailToContinueUserActivityWithType_error_
        .implementAsListener(
            builder, application_didFailToContinueUserActivityWithType_error_);
    NSApplicationDelegate.application_didUpdateUserActivity_
        .implementAsListener(builder, application_didUpdateUserActivity_);
    NSApplicationDelegate.application_userDidAcceptCloudKitShareWithMetadata_
        .implementAsListener(
            builder, application_userDidAcceptCloudKitShareWithMetadata_);
    NSApplicationDelegate.application_delegateHandlesKey_
        .implement(builder, application_delegateHandlesKey_);
    NSApplicationDelegate.applicationShouldAutomaticallyLocalizeKeyEquivalents_
        .implement(
            builder, applicationShouldAutomaticallyLocalizeKeyEquivalents_);
    NSApplicationDelegate.applicationWillFinishLaunching_
        .implementAsListener(builder, applicationWillFinishLaunching_);
    NSApplicationDelegate.applicationDidFinishLaunching_
        .implementAsListener(builder, applicationDidFinishLaunching_);
    NSApplicationDelegate.applicationWillHide_
        .implementAsListener(builder, applicationWillHide_);
    NSApplicationDelegate.applicationDidHide_
        .implementAsListener(builder, applicationDidHide_);
    NSApplicationDelegate.applicationWillUnhide_
        .implementAsListener(builder, applicationWillUnhide_);
    NSApplicationDelegate.applicationDidUnhide_
        .implementAsListener(builder, applicationDidUnhide_);
    NSApplicationDelegate.applicationWillBecomeActive_
        .implementAsListener(builder, applicationWillBecomeActive_);
    NSApplicationDelegate.applicationDidBecomeActive_
        .implementAsListener(builder, applicationDidBecomeActive_);
    NSApplicationDelegate.applicationWillResignActive_
        .implementAsListener(builder, applicationWillResignActive_);
    NSApplicationDelegate.applicationDidResignActive_
        .implementAsListener(builder, applicationDidResignActive_);
    NSApplicationDelegate.applicationWillUpdate_
        .implementAsListener(builder, applicationWillUpdate_);
    NSApplicationDelegate.applicationDidUpdate_
        .implementAsListener(builder, applicationDidUpdate_);
    NSApplicationDelegate.applicationWillTerminate_
        .implementAsListener(builder, applicationWillTerminate_);
    NSApplicationDelegate.applicationDidChangeScreenParameters_
        .implementAsListener(builder, applicationDidChangeScreenParameters_);
    NSApplicationDelegate.applicationDidChangeOcclusionState_
        .implementAsListener(builder, applicationDidChangeOcclusionState_);
    NSApplicationDelegate.applicationProtectedDataWillBecomeUnavailable_
        .implementAsListener(
            builder, applicationProtectedDataWillBecomeUnavailable_);
    NSApplicationDelegate.applicationProtectedDataDidBecomeAvailable_
        .implementAsListener(
            builder, applicationProtectedDataDidBecomeAvailable_);
    builder.addProtocol($protocol);
  }

  /// Builds an object that implements the NSApplicationDelegate protocol. To implement
  /// multiple protocols, use [addToBuilder] or [objc.ObjCProtocolBuilder] directly. All
  /// methods that can be implemented as blocking listeners will be.
  ///
  /// If `$keepIsolateAlive` is true, this protocol will keep this isolate
  /// alive until it is garbage collected by both Dart and ObjC.
  static NSApplicationDelegate implementAsBlocking(
      {NSApplicationTerminateReply Function(NSApplication)?
          applicationShouldTerminate_,
      void Function(NSApplication, objc.NSArray)? application_openURLs_,
      bool Function(NSApplication, objc.NSString)? application_openFile_,
      void Function(NSApplication, objc.NSArray)? application_openFiles_,
      bool Function(NSApplication, objc.NSString)? application_openTempFile_,
      bool Function(NSApplication)? applicationShouldOpenUntitledFile_,
      bool Function(NSApplication)? applicationOpenUntitledFile_,
      bool Function(objc.ObjCObjectBase, objc.NSString)?
          application_openFileWithoutUI_,
      bool Function(NSApplication, objc.NSString)? application_printFile_,
      NSApplicationPrintReply Function(
              NSApplication, objc.NSArray, objc.ObjCObjectBase, bool)?
          application_printFiles_withSettings_showPrintPanels_,
      bool Function(NSApplication)?
          applicationShouldTerminateAfterLastWindowClosed_,
      bool Function(NSApplication, bool)?
          applicationShouldHandleReopen_hasVisibleWindows_,
      NSMenu? Function(NSApplication)? applicationDockMenu_,
      objc.NSError Function(NSApplication, objc.NSError)?
          application_willPresentError_,
      void Function(NSApplication, objc.NSData)?
          application_didRegisterForRemoteNotificationsWithDeviceToken_,
      void Function(NSApplication, objc.NSError)?
          application_didFailToRegisterForRemoteNotificationsWithError_,
      void Function(NSApplication, objc.ObjCObjectBase)?
          application_didReceiveRemoteNotification_,
      bool Function(NSApplication)? applicationSupportsSecureRestorableState_,
      objc.ObjCObjectBase? Function(NSApplication, INIntent)?
          application_handlerForIntent_,
      void Function(NSApplication, objc.NSCoder)?
          application_willEncodeRestorableState_,
      void Function(NSApplication, objc.NSCoder)?
          application_didDecodeRestorableState_,
      bool Function(NSApplication, objc.NSString)?
          application_willContinueUserActivityWithType_,
      bool Function(NSApplication, NSUserActivity,
              objc.ObjCBlock<ffi.Void Function(objc.NSArray)>)?
          application_continueUserActivity_restorationHandler_,
      void Function(NSApplication, objc.NSString, objc.NSError)?
          application_didFailToContinueUserActivityWithType_error_,
      void Function(NSApplication, NSUserActivity)?
          application_didUpdateUserActivity_,
      void Function(NSApplication, CKShareMetadata)?
          application_userDidAcceptCloudKitShareWithMetadata_,
      bool Function(NSApplication, objc.NSString)?
          application_delegateHandlesKey_,
      bool Function(NSApplication)? applicationShouldAutomaticallyLocalizeKeyEquivalents_,
      void Function(objc.NSNotification)? applicationWillFinishLaunching_,
      void Function(objc.NSNotification)? applicationDidFinishLaunching_,
      void Function(objc.NSNotification)? applicationWillHide_,
      void Function(objc.NSNotification)? applicationDidHide_,
      void Function(objc.NSNotification)? applicationWillUnhide_,
      void Function(objc.NSNotification)? applicationDidUnhide_,
      void Function(objc.NSNotification)? applicationWillBecomeActive_,
      void Function(objc.NSNotification)? applicationDidBecomeActive_,
      void Function(objc.NSNotification)? applicationWillResignActive_,
      void Function(objc.NSNotification)? applicationDidResignActive_,
      void Function(objc.NSNotification)? applicationWillUpdate_,
      void Function(objc.NSNotification)? applicationDidUpdate_,
      void Function(objc.NSNotification)? applicationWillTerminate_,
      void Function(objc.NSNotification)? applicationDidChangeScreenParameters_,
      void Function(objc.NSNotification)? applicationDidChangeOcclusionState_,
      void Function(objc.NSNotification)? applicationProtectedDataWillBecomeUnavailable_,
      void Function(objc.NSNotification)? applicationProtectedDataDidBecomeAvailable_,
      bool $keepIsolateAlive = true}) {
    final builder =
        objc.ObjCProtocolBuilder(debugName: 'NSApplicationDelegate');
    NSApplicationDelegate.applicationShouldTerminate_
        .implement(builder, applicationShouldTerminate_);
    NSApplicationDelegate.application_openURLs_
        .implementAsBlocking(builder, application_openURLs_);
    NSApplicationDelegate.application_openFile_
        .implement(builder, application_openFile_);
    NSApplicationDelegate.application_openFiles_
        .implementAsBlocking(builder, application_openFiles_);
    NSApplicationDelegate.application_openTempFile_
        .implement(builder, application_openTempFile_);
    NSApplicationDelegate.applicationShouldOpenUntitledFile_
        .implement(builder, applicationShouldOpenUntitledFile_);
    NSApplicationDelegate.applicationOpenUntitledFile_
        .implement(builder, applicationOpenUntitledFile_);
    NSApplicationDelegate.application_openFileWithoutUI_
        .implement(builder, application_openFileWithoutUI_);
    NSApplicationDelegate.application_printFile_
        .implement(builder, application_printFile_);
    NSApplicationDelegate.application_printFiles_withSettings_showPrintPanels_
        .implement(
            builder, application_printFiles_withSettings_showPrintPanels_);
    NSApplicationDelegate.applicationShouldTerminateAfterLastWindowClosed_
        .implement(builder, applicationShouldTerminateAfterLastWindowClosed_);
    NSApplicationDelegate.applicationShouldHandleReopen_hasVisibleWindows_
        .implement(builder, applicationShouldHandleReopen_hasVisibleWindows_);
    NSApplicationDelegate.applicationDockMenu_
        .implement(builder, applicationDockMenu_);
    NSApplicationDelegate.application_willPresentError_
        .implement(builder, application_willPresentError_);
    NSApplicationDelegate
        .application_didRegisterForRemoteNotificationsWithDeviceToken_
        .implementAsBlocking(builder,
            application_didRegisterForRemoteNotificationsWithDeviceToken_);
    NSApplicationDelegate
        .application_didFailToRegisterForRemoteNotificationsWithError_
        .implementAsBlocking(builder,
            application_didFailToRegisterForRemoteNotificationsWithError_);
    NSApplicationDelegate.application_didReceiveRemoteNotification_
        .implementAsBlocking(
            builder, application_didReceiveRemoteNotification_);
    NSApplicationDelegate.applicationSupportsSecureRestorableState_
        .implement(builder, applicationSupportsSecureRestorableState_);
    NSApplicationDelegate.application_handlerForIntent_
        .implement(builder, application_handlerForIntent_);
    NSApplicationDelegate.application_willEncodeRestorableState_
        .implementAsBlocking(builder, application_willEncodeRestorableState_);
    NSApplicationDelegate.application_didDecodeRestorableState_
        .implementAsBlocking(builder, application_didDecodeRestorableState_);
    NSApplicationDelegate.application_willContinueUserActivityWithType_
        .implement(builder, application_willContinueUserActivityWithType_);
    NSApplicationDelegate.application_continueUserActivity_restorationHandler_
        .implement(
            builder, application_continueUserActivity_restorationHandler_);
    NSApplicationDelegate
        .application_didFailToContinueUserActivityWithType_error_
        .implementAsBlocking(
            builder, application_didFailToContinueUserActivityWithType_error_);
    NSApplicationDelegate.application_didUpdateUserActivity_
        .implementAsBlocking(builder, application_didUpdateUserActivity_);
    NSApplicationDelegate.application_userDidAcceptCloudKitShareWithMetadata_
        .implementAsBlocking(
            builder, application_userDidAcceptCloudKitShareWithMetadata_);
    NSApplicationDelegate.application_delegateHandlesKey_
        .implement(builder, application_delegateHandlesKey_);
    NSApplicationDelegate.applicationShouldAutomaticallyLocalizeKeyEquivalents_
        .implement(
            builder, applicationShouldAutomaticallyLocalizeKeyEquivalents_);
    NSApplicationDelegate.applicationWillFinishLaunching_
        .implementAsBlocking(builder, applicationWillFinishLaunching_);
    NSApplicationDelegate.applicationDidFinishLaunching_
        .implementAsBlocking(builder, applicationDidFinishLaunching_);
    NSApplicationDelegate.applicationWillHide_
        .implementAsBlocking(builder, applicationWillHide_);
    NSApplicationDelegate.applicationDidHide_
        .implementAsBlocking(builder, applicationDidHide_);
    NSApplicationDelegate.applicationWillUnhide_
        .implementAsBlocking(builder, applicationWillUnhide_);
    NSApplicationDelegate.applicationDidUnhide_
        .implementAsBlocking(builder, applicationDidUnhide_);
    NSApplicationDelegate.applicationWillBecomeActive_
        .implementAsBlocking(builder, applicationWillBecomeActive_);
    NSApplicationDelegate.applicationDidBecomeActive_
        .implementAsBlocking(builder, applicationDidBecomeActive_);
    NSApplicationDelegate.applicationWillResignActive_
        .implementAsBlocking(builder, applicationWillResignActive_);
    NSApplicationDelegate.applicationDidResignActive_
        .implementAsBlocking(builder, applicationDidResignActive_);
    NSApplicationDelegate.applicationWillUpdate_
        .implementAsBlocking(builder, applicationWillUpdate_);
    NSApplicationDelegate.applicationDidUpdate_
        .implementAsBlocking(builder, applicationDidUpdate_);
    NSApplicationDelegate.applicationWillTerminate_
        .implementAsBlocking(builder, applicationWillTerminate_);
    NSApplicationDelegate.applicationDidChangeScreenParameters_
        .implementAsBlocking(builder, applicationDidChangeScreenParameters_);
    NSApplicationDelegate.applicationDidChangeOcclusionState_
        .implementAsBlocking(builder, applicationDidChangeOcclusionState_);
    NSApplicationDelegate.applicationProtectedDataWillBecomeUnavailable_
        .implementAsBlocking(
            builder, applicationProtectedDataWillBecomeUnavailable_);
    NSApplicationDelegate.applicationProtectedDataDidBecomeAvailable_
        .implementAsBlocking(
            builder, applicationProtectedDataDidBecomeAvailable_);
    builder.addProtocol($protocol);
    return NSApplicationDelegate.castFrom(
        builder.build(keepIsolateAlive: $keepIsolateAlive));
  }

  /// Adds the implementation of the NSApplicationDelegate protocol to an existing
  /// [objc.ObjCProtocolBuilder]. All methods that can be implemented as blocking
  /// listeners will be.
  ///
  /// Note: You cannot call this method after you have called `builder.build`.
  static void addToBuilderAsBlocking(objc.ObjCProtocolBuilder builder,
      {NSApplicationTerminateReply Function(NSApplication)?
          applicationShouldTerminate_,
      void Function(NSApplication, objc.NSArray)? application_openURLs_,
      bool Function(NSApplication, objc.NSString)? application_openFile_,
      void Function(NSApplication, objc.NSArray)? application_openFiles_,
      bool Function(NSApplication, objc.NSString)? application_openTempFile_,
      bool Function(NSApplication)? applicationShouldOpenUntitledFile_,
      bool Function(NSApplication)? applicationOpenUntitledFile_,
      bool Function(objc.ObjCObjectBase, objc.NSString)?
          application_openFileWithoutUI_,
      bool Function(NSApplication, objc.NSString)? application_printFile_,
      NSApplicationPrintReply Function(
              NSApplication, objc.NSArray, objc.ObjCObjectBase, bool)?
          application_printFiles_withSettings_showPrintPanels_,
      bool Function(NSApplication)?
          applicationShouldTerminateAfterLastWindowClosed_,
      bool Function(NSApplication, bool)?
          applicationShouldHandleReopen_hasVisibleWindows_,
      NSMenu? Function(NSApplication)? applicationDockMenu_,
      objc.NSError Function(NSApplication, objc.NSError)?
          application_willPresentError_,
      void Function(NSApplication, objc.NSData)?
          application_didRegisterForRemoteNotificationsWithDeviceToken_,
      void Function(NSApplication, objc.NSError)?
          application_didFailToRegisterForRemoteNotificationsWithError_,
      void Function(NSApplication, objc.ObjCObjectBase)?
          application_didReceiveRemoteNotification_,
      bool Function(NSApplication)? applicationSupportsSecureRestorableState_,
      objc.ObjCObjectBase? Function(NSApplication, INIntent)?
          application_handlerForIntent_,
      void Function(NSApplication, objc.NSCoder)?
          application_willEncodeRestorableState_,
      void Function(NSApplication, objc.NSCoder)?
          application_didDecodeRestorableState_,
      bool Function(NSApplication, objc.NSString)?
          application_willContinueUserActivityWithType_,
      bool Function(NSApplication, NSUserActivity,
              objc.ObjCBlock<ffi.Void Function(objc.NSArray)>)?
          application_continueUserActivity_restorationHandler_,
      void Function(NSApplication, objc.NSString, objc.NSError)?
          application_didFailToContinueUserActivityWithType_error_,
      void Function(NSApplication, NSUserActivity)?
          application_didUpdateUserActivity_,
      void Function(NSApplication, CKShareMetadata)?
          application_userDidAcceptCloudKitShareWithMetadata_,
      bool Function(NSApplication, objc.NSString)?
          application_delegateHandlesKey_,
      bool Function(NSApplication)? applicationShouldAutomaticallyLocalizeKeyEquivalents_,
      void Function(objc.NSNotification)? applicationWillFinishLaunching_,
      void Function(objc.NSNotification)? applicationDidFinishLaunching_,
      void Function(objc.NSNotification)? applicationWillHide_,
      void Function(objc.NSNotification)? applicationDidHide_,
      void Function(objc.NSNotification)? applicationWillUnhide_,
      void Function(objc.NSNotification)? applicationDidUnhide_,
      void Function(objc.NSNotification)? applicationWillBecomeActive_,
      void Function(objc.NSNotification)? applicationDidBecomeActive_,
      void Function(objc.NSNotification)? applicationWillResignActive_,
      void Function(objc.NSNotification)? applicationDidResignActive_,
      void Function(objc.NSNotification)? applicationWillUpdate_,
      void Function(objc.NSNotification)? applicationDidUpdate_,
      void Function(objc.NSNotification)? applicationWillTerminate_,
      void Function(objc.NSNotification)? applicationDidChangeScreenParameters_,
      void Function(objc.NSNotification)? applicationDidChangeOcclusionState_,
      void Function(objc.NSNotification)? applicationProtectedDataWillBecomeUnavailable_,
      void Function(objc.NSNotification)? applicationProtectedDataDidBecomeAvailable_,
      bool $keepIsolateAlive = true}) {
    NSApplicationDelegate.applicationShouldTerminate_
        .implement(builder, applicationShouldTerminate_);
    NSApplicationDelegate.application_openURLs_
        .implementAsBlocking(builder, application_openURLs_);
    NSApplicationDelegate.application_openFile_
        .implement(builder, application_openFile_);
    NSApplicationDelegate.application_openFiles_
        .implementAsBlocking(builder, application_openFiles_);
    NSApplicationDelegate.application_openTempFile_
        .implement(builder, application_openTempFile_);
    NSApplicationDelegate.applicationShouldOpenUntitledFile_
        .implement(builder, applicationShouldOpenUntitledFile_);
    NSApplicationDelegate.applicationOpenUntitledFile_
        .implement(builder, applicationOpenUntitledFile_);
    NSApplicationDelegate.application_openFileWithoutUI_
        .implement(builder, application_openFileWithoutUI_);
    NSApplicationDelegate.application_printFile_
        .implement(builder, application_printFile_);
    NSApplicationDelegate.application_printFiles_withSettings_showPrintPanels_
        .implement(
            builder, application_printFiles_withSettings_showPrintPanels_);
    NSApplicationDelegate.applicationShouldTerminateAfterLastWindowClosed_
        .implement(builder, applicationShouldTerminateAfterLastWindowClosed_);
    NSApplicationDelegate.applicationShouldHandleReopen_hasVisibleWindows_
        .implement(builder, applicationShouldHandleReopen_hasVisibleWindows_);
    NSApplicationDelegate.applicationDockMenu_
        .implement(builder, applicationDockMenu_);
    NSApplicationDelegate.application_willPresentError_
        .implement(builder, application_willPresentError_);
    NSApplicationDelegate
        .application_didRegisterForRemoteNotificationsWithDeviceToken_
        .implementAsBlocking(builder,
            application_didRegisterForRemoteNotificationsWithDeviceToken_);
    NSApplicationDelegate
        .application_didFailToRegisterForRemoteNotificationsWithError_
        .implementAsBlocking(builder,
            application_didFailToRegisterForRemoteNotificationsWithError_);
    NSApplicationDelegate.application_didReceiveRemoteNotification_
        .implementAsBlocking(
            builder, application_didReceiveRemoteNotification_);
    NSApplicationDelegate.applicationSupportsSecureRestorableState_
        .implement(builder, applicationSupportsSecureRestorableState_);
    NSApplicationDelegate.application_handlerForIntent_
        .implement(builder, application_handlerForIntent_);
    NSApplicationDelegate.application_willEncodeRestorableState_
        .implementAsBlocking(builder, application_willEncodeRestorableState_);
    NSApplicationDelegate.application_didDecodeRestorableState_
        .implementAsBlocking(builder, application_didDecodeRestorableState_);
    NSApplicationDelegate.application_willContinueUserActivityWithType_
        .implement(builder, application_willContinueUserActivityWithType_);
    NSApplicationDelegate.application_continueUserActivity_restorationHandler_
        .implement(
            builder, application_continueUserActivity_restorationHandler_);
    NSApplicationDelegate
        .application_didFailToContinueUserActivityWithType_error_
        .implementAsBlocking(
            builder, application_didFailToContinueUserActivityWithType_error_);
    NSApplicationDelegate.application_didUpdateUserActivity_
        .implementAsBlocking(builder, application_didUpdateUserActivity_);
    NSApplicationDelegate.application_userDidAcceptCloudKitShareWithMetadata_
        .implementAsBlocking(
            builder, application_userDidAcceptCloudKitShareWithMetadata_);
    NSApplicationDelegate.application_delegateHandlesKey_
        .implement(builder, application_delegateHandlesKey_);
    NSApplicationDelegate.applicationShouldAutomaticallyLocalizeKeyEquivalents_
        .implement(
            builder, applicationShouldAutomaticallyLocalizeKeyEquivalents_);
    NSApplicationDelegate.applicationWillFinishLaunching_
        .implementAsBlocking(builder, applicationWillFinishLaunching_);
    NSApplicationDelegate.applicationDidFinishLaunching_
        .implementAsBlocking(builder, applicationDidFinishLaunching_);
    NSApplicationDelegate.applicationWillHide_
        .implementAsBlocking(builder, applicationWillHide_);
    NSApplicationDelegate.applicationDidHide_
        .implementAsBlocking(builder, applicationDidHide_);
    NSApplicationDelegate.applicationWillUnhide_
        .implementAsBlocking(builder, applicationWillUnhide_);
    NSApplicationDelegate.applicationDidUnhide_
        .implementAsBlocking(builder, applicationDidUnhide_);
    NSApplicationDelegate.applicationWillBecomeActive_
        .implementAsBlocking(builder, applicationWillBecomeActive_);
    NSApplicationDelegate.applicationDidBecomeActive_
        .implementAsBlocking(builder, applicationDidBecomeActive_);
    NSApplicationDelegate.applicationWillResignActive_
        .implementAsBlocking(builder, applicationWillResignActive_);
    NSApplicationDelegate.applicationDidResignActive_
        .implementAsBlocking(builder, applicationDidResignActive_);
    NSApplicationDelegate.applicationWillUpdate_
        .implementAsBlocking(builder, applicationWillUpdate_);
    NSApplicationDelegate.applicationDidUpdate_
        .implementAsBlocking(builder, applicationDidUpdate_);
    NSApplicationDelegate.applicationWillTerminate_
        .implementAsBlocking(builder, applicationWillTerminate_);
    NSApplicationDelegate.applicationDidChangeScreenParameters_
        .implementAsBlocking(builder, applicationDidChangeScreenParameters_);
    NSApplicationDelegate.applicationDidChangeOcclusionState_
        .implementAsBlocking(builder, applicationDidChangeOcclusionState_);
    NSApplicationDelegate.applicationProtectedDataWillBecomeUnavailable_
        .implementAsBlocking(
            builder, applicationProtectedDataWillBecomeUnavailable_);
    NSApplicationDelegate.applicationProtectedDataDidBecomeAvailable_
        .implementAsBlocking(
            builder, applicationProtectedDataDidBecomeAvailable_);
    builder.addProtocol($protocol);
  }

  /// Allowable return values are:
  /// @c NSTerminateNow - it is ok to proceed with termination
  /// @c NSTerminateCancel - the application should not be terminated
  /// @c NSTerminateLater - it may be ok to proceed with termination later.  The application must call `-replyToApplicationShouldTerminate:` with @c YES or @c NO once the answer is known
  /// @note This return value is for delegates who need to provide document modal alerts (sheets) in order to decide whether to quit.
  static final applicationShouldTerminate_ = objc.ObjCProtocolMethod<
      NSApplicationTerminateReply Function(NSApplication)>(
    _protocol_NSApplicationDelegate,
    _sel_applicationShouldTerminate_,
    ffi.Native.addressOf<
                ffi.NativeFunction<
                    ffi.UnsignedLong Function(ffi.Pointer<objc.ObjCObject>,
                        ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>>(
            _AuthenticationServicesMacOS_protocolTrampoline_dl2wbd)
        .cast(),
    objc.getProtocolMethodSignature(
      _protocol_NSApplicationDelegate,
      _sel_applicationShouldTerminate_,
      isRequired: false,
      isInstanceMethod: true,
    ),
    (NSApplicationTerminateReply Function(NSApplication) func) =>
        ObjCBlock_NSApplicationTerminateReply_ffiVoid_NSApplication
            .fromFunction(
                (ffi.Pointer<ffi.Void> _, NSApplication arg1) => func(arg1)),
  );

  /// This will be called for any URLs your application is asked to open. This includes URL types (CFBundleURLTypes) defined in your Info.plist, and Document types (@c CFBundleDocumentTypes) that have no associated @c NSDocument class. Document URLs that have an associated @c NSDocument class will be opened through @c NSDocumentController. If this is implemented, `-application:openFiles:` and `-application:openFile:` will not be called.
  static final application_openURLs_ = objc.ObjCProtocolListenableMethod<
      void Function(NSApplication, objc.NSArray)>(
    _protocol_NSApplicationDelegate,
    _sel_application_openURLs_,
    ffi.Native.addressOf<
                ffi.NativeFunction<
                    ffi.Void Function(
                        ffi.Pointer<objc.ObjCObject>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<objc.ObjCObject>,
                        ffi.Pointer<objc.ObjCObject>)>>(
            _AuthenticationServicesMacOS_protocolTrampoline_fjrv01)
        .cast(),
    objc.getProtocolMethodSignature(
      _protocol_NSApplicationDelegate,
      _sel_application_openURLs_,
      isRequired: false,
      isInstanceMethod: true,
    ),
    (void Function(NSApplication, objc.NSArray) func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSApplication_NSArray.fromFunction(
            (ffi.Pointer<ffi.Void> _, NSApplication arg1, objc.NSArray arg2) =>
                func(arg1, arg2)),
    (void Function(NSApplication, objc.NSArray) func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSApplication_NSArray.listener(
            (ffi.Pointer<ffi.Void> _, NSApplication arg1, objc.NSArray arg2) =>
                func(arg1, arg2)),
    (void Function(NSApplication, objc.NSArray) func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSApplication_NSArray.blocking(
            (ffi.Pointer<ffi.Void> _, NSApplication arg1, objc.NSArray arg2) =>
                func(arg1, arg2)),
  );

  /// application:openFile:
  static final application_openFile_ =
      objc.ObjCProtocolMethod<bool Function(NSApplication, objc.NSString)>(
    _protocol_NSApplicationDelegate,
    _sel_application_openFile_,
    ffi.Native.addressOf<
                ffi.NativeFunction<
                    ffi.Bool Function(
                        ffi.Pointer<objc.ObjCObject>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<objc.ObjCObject>,
                        ffi.Pointer<objc.ObjCObject>)>>(
            _AuthenticationServicesMacOS_protocolTrampoline_2n06mv)
        .cast(),
    objc.getProtocolMethodSignature(
      _protocol_NSApplicationDelegate,
      _sel_application_openFile_,
      isRequired: false,
      isInstanceMethod: true,
    ),
    (bool Function(NSApplication, objc.NSString) func) =>
        ObjCBlock_bool_ffiVoid_NSApplication_NSString.fromFunction(
            (ffi.Pointer<ffi.Void> _, NSApplication arg1, objc.NSString arg2) =>
                func(arg1, arg2)),
  );

  /// application:openFiles:
  static final application_openFiles_ = objc.ObjCProtocolListenableMethod<
      void Function(NSApplication, objc.NSArray)>(
    _protocol_NSApplicationDelegate,
    _sel_application_openFiles_,
    ffi.Native.addressOf<
                ffi.NativeFunction<
                    ffi.Void Function(
                        ffi.Pointer<objc.ObjCObject>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<objc.ObjCObject>,
                        ffi.Pointer<objc.ObjCObject>)>>(
            _AuthenticationServicesMacOS_protocolTrampoline_fjrv01)
        .cast(),
    objc.getProtocolMethodSignature(
      _protocol_NSApplicationDelegate,
      _sel_application_openFiles_,
      isRequired: false,
      isInstanceMethod: true,
    ),
    (void Function(NSApplication, objc.NSArray) func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSApplication_NSArray.fromFunction(
            (ffi.Pointer<ffi.Void> _, NSApplication arg1, objc.NSArray arg2) =>
                func(arg1, arg2)),
    (void Function(NSApplication, objc.NSArray) func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSApplication_NSArray.listener(
            (ffi.Pointer<ffi.Void> _, NSApplication arg1, objc.NSArray arg2) =>
                func(arg1, arg2)),
    (void Function(NSApplication, objc.NSArray) func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSApplication_NSArray.blocking(
            (ffi.Pointer<ffi.Void> _, NSApplication arg1, objc.NSArray arg2) =>
                func(arg1, arg2)),
  );

  /// application:openTempFile:
  static final application_openTempFile_ =
      objc.ObjCProtocolMethod<bool Function(NSApplication, objc.NSString)>(
    _protocol_NSApplicationDelegate,
    _sel_application_openTempFile_,
    ffi.Native.addressOf<
                ffi.NativeFunction<
                    ffi.Bool Function(
                        ffi.Pointer<objc.ObjCObject>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<objc.ObjCObject>,
                        ffi.Pointer<objc.ObjCObject>)>>(
            _AuthenticationServicesMacOS_protocolTrampoline_2n06mv)
        .cast(),
    objc.getProtocolMethodSignature(
      _protocol_NSApplicationDelegate,
      _sel_application_openTempFile_,
      isRequired: false,
      isInstanceMethod: true,
    ),
    (bool Function(NSApplication, objc.NSString) func) =>
        ObjCBlock_bool_ffiVoid_NSApplication_NSString.fromFunction(
            (ffi.Pointer<ffi.Void> _, NSApplication arg1, objc.NSString arg2) =>
                func(arg1, arg2)),
  );

  /// applicationShouldOpenUntitledFile:
  static final applicationShouldOpenUntitledFile_ =
      objc.ObjCProtocolMethod<bool Function(NSApplication)>(
    _protocol_NSApplicationDelegate,
    _sel_applicationShouldOpenUntitledFile_,
    ffi.Native.addressOf<
                ffi.NativeFunction<
                    ffi.Bool Function(ffi.Pointer<objc.ObjCObject>,
                        ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>>(
            _AuthenticationServicesMacOS_protocolTrampoline_3su7tt)
        .cast(),
    objc.getProtocolMethodSignature(
      _protocol_NSApplicationDelegate,
      _sel_applicationShouldOpenUntitledFile_,
      isRequired: false,
      isInstanceMethod: true,
    ),
    (bool Function(NSApplication) func) =>
        ObjCBlock_bool_ffiVoid_NSApplication.fromFunction(
            (ffi.Pointer<ffi.Void> _, NSApplication arg1) => func(arg1)),
  );

  /// applicationOpenUntitledFile:
  static final applicationOpenUntitledFile_ =
      objc.ObjCProtocolMethod<bool Function(NSApplication)>(
    _protocol_NSApplicationDelegate,
    _sel_applicationOpenUntitledFile_,
    ffi.Native.addressOf<
                ffi.NativeFunction<
                    ffi.Bool Function(ffi.Pointer<objc.ObjCObject>,
                        ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>>(
            _AuthenticationServicesMacOS_protocolTrampoline_3su7tt)
        .cast(),
    objc.getProtocolMethodSignature(
      _protocol_NSApplicationDelegate,
      _sel_applicationOpenUntitledFile_,
      isRequired: false,
      isInstanceMethod: true,
    ),
    (bool Function(NSApplication) func) =>
        ObjCBlock_bool_ffiVoid_NSApplication.fromFunction(
            (ffi.Pointer<ffi.Void> _, NSApplication arg1) => func(arg1)),
  );

  /// application:openFileWithoutUI:
  static final application_openFileWithoutUI_ = objc.ObjCProtocolMethod<
      bool Function(objc.ObjCObjectBase, objc.NSString)>(
    _protocol_NSApplicationDelegate,
    _sel_application_openFileWithoutUI_,
    ffi.Native.addressOf<
                ffi.NativeFunction<
                    ffi.Bool Function(
                        ffi.Pointer<objc.ObjCObject>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<objc.ObjCObject>,
                        ffi.Pointer<objc.ObjCObject>)>>(
            _AuthenticationServicesMacOS_protocolTrampoline_2n06mv)
        .cast(),
    objc.getProtocolMethodSignature(
      _protocol_NSApplicationDelegate,
      _sel_application_openFileWithoutUI_,
      isRequired: false,
      isInstanceMethod: true,
    ),
    (bool Function(objc.ObjCObjectBase, objc.NSString) func) =>
        ObjCBlock_bool_ffiVoid_objcObjCObject_NSString.fromFunction(
            (ffi.Pointer<ffi.Void> _, objc.ObjCObjectBase arg1,
                    objc.NSString arg2) =>
                func(arg1, arg2)),
  );

  /// application:printFile:
  static final application_printFile_ =
      objc.ObjCProtocolMethod<bool Function(NSApplication, objc.NSString)>(
    _protocol_NSApplicationDelegate,
    _sel_application_printFile_,
    ffi.Native.addressOf<
                ffi.NativeFunction<
                    ffi.Bool Function(
                        ffi.Pointer<objc.ObjCObject>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<objc.ObjCObject>,
                        ffi.Pointer<objc.ObjCObject>)>>(
            _AuthenticationServicesMacOS_protocolTrampoline_2n06mv)
        .cast(),
    objc.getProtocolMethodSignature(
      _protocol_NSApplicationDelegate,
      _sel_application_printFile_,
      isRequired: false,
      isInstanceMethod: true,
    ),
    (bool Function(NSApplication, objc.NSString) func) =>
        ObjCBlock_bool_ffiVoid_NSApplication_NSString.fromFunction(
            (ffi.Pointer<ffi.Void> _, NSApplication arg1, objc.NSString arg2) =>
                func(arg1, arg2)),
  );

  /// application:printFiles:withSettings:showPrintPanels:
  static final application_printFiles_withSettings_showPrintPanels_ =
      objc.ObjCProtocolMethod<
          NSApplicationPrintReply Function(
              NSApplication, objc.NSArray, objc.ObjCObjectBase, bool)>(
    _protocol_NSApplicationDelegate,
    _sel_application_printFiles_withSettings_showPrintPanels_,
    ffi.Native.addressOf<
                ffi.NativeFunction<
                    ffi.UnsignedLong Function(
                        ffi.Pointer<objc.ObjCObject>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<objc.ObjCObject>,
                        ffi.Pointer<objc.ObjCObject>,
                        ffi.Pointer<objc.ObjCObject>,
                        ffi.Bool)>>(
            _AuthenticationServicesMacOS_protocolTrampoline_1ntoid)
        .cast(),
    objc.getProtocolMethodSignature(
      _protocol_NSApplicationDelegate,
      _sel_application_printFiles_withSettings_showPrintPanels_,
      isRequired: false,
      isInstanceMethod: true,
    ),
    (NSApplicationPrintReply Function(
                NSApplication, objc.NSArray, objc.ObjCObjectBase, bool)
            func) =>
        ObjCBlock_NSApplicationPrintReply_ffiVoid_NSApplication_NSArray_objcObjCObject_bool
            .fromFunction((ffi.Pointer<ffi.Void> _, NSApplication arg1,
                    objc.NSArray arg2, objc.ObjCObjectBase arg3, bool arg4) =>
                func(arg1, arg2, arg3, arg4)),
  );

  /// applicationShouldTerminateAfterLastWindowClosed:
  static final applicationShouldTerminateAfterLastWindowClosed_ =
      objc.ObjCProtocolMethod<bool Function(NSApplication)>(
    _protocol_NSApplicationDelegate,
    _sel_applicationShouldTerminateAfterLastWindowClosed_,
    ffi.Native.addressOf<
                ffi.NativeFunction<
                    ffi.Bool Function(ffi.Pointer<objc.ObjCObject>,
                        ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>>(
            _AuthenticationServicesMacOS_protocolTrampoline_3su7tt)
        .cast(),
    objc.getProtocolMethodSignature(
      _protocol_NSApplicationDelegate,
      _sel_applicationShouldTerminateAfterLastWindowClosed_,
      isRequired: false,
      isInstanceMethod: true,
    ),
    (bool Function(NSApplication) func) =>
        ObjCBlock_bool_ffiVoid_NSApplication.fromFunction(
            (ffi.Pointer<ffi.Void> _, NSApplication arg1) => func(arg1)),
  );

  /// applicationShouldHandleReopen:hasVisibleWindows:
  static final applicationShouldHandleReopen_hasVisibleWindows_ =
      objc.ObjCProtocolMethod<bool Function(NSApplication, bool)>(
    _protocol_NSApplicationDelegate,
    _sel_applicationShouldHandleReopen_hasVisibleWindows_,
    ffi.Native.addressOf<
                ffi.NativeFunction<
                    ffi.Bool Function(
                        ffi.Pointer<objc.ObjCObject>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<objc.ObjCObject>,
                        ffi.Bool)>>(
            _AuthenticationServicesMacOS_protocolTrampoline_9k4e9l)
        .cast(),
    objc.getProtocolMethodSignature(
      _protocol_NSApplicationDelegate,
      _sel_applicationShouldHandleReopen_hasVisibleWindows_,
      isRequired: false,
      isInstanceMethod: true,
    ),
    (bool Function(NSApplication, bool) func) =>
        ObjCBlock_bool_ffiVoid_NSApplication_bool.fromFunction(
            (ffi.Pointer<ffi.Void> _, NSApplication arg1, bool arg2) =>
                func(arg1, arg2)),
  );

  /// applicationDockMenu:
  static final applicationDockMenu_ =
      objc.ObjCProtocolMethod<NSMenu? Function(NSApplication)>(
    _protocol_NSApplicationDelegate,
    _sel_applicationDockMenu_,
    ffi.Native.addressOf<
                ffi.NativeFunction<
                    instancetype Function(ffi.Pointer<objc.ObjCObject>,
                        ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>>(
            _AuthenticationServicesMacOS_protocolTrampoline_xr62hr)
        .cast(),
    objc.getProtocolMethodSignature(
      _protocol_NSApplicationDelegate,
      _sel_applicationDockMenu_,
      isRequired: false,
      isInstanceMethod: true,
    ),
    (NSMenu? Function(NSApplication) func) =>
        ObjCBlock_NSMenu_ffiVoid_NSApplication.fromFunction(
            (ffi.Pointer<ffi.Void> _, NSApplication arg1) => func(arg1)),
  );

  /// application:willPresentError:
  static final application_willPresentError_ = objc.ObjCProtocolMethod<
      objc.NSError Function(NSApplication, objc.NSError)>(
    _protocol_NSApplicationDelegate,
    _sel_application_willPresentError_,
    ffi.Native.addressOf<
                ffi.NativeFunction<
                    ffi.Pointer<objc.ObjCObject> Function(
                        ffi.Pointer<objc.ObjCObject>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<objc.ObjCObject>,
                        ffi.Pointer<objc.ObjCObject>)>>(
            _AuthenticationServicesMacOS_protocolTrampoline_zi5eed)
        .cast(),
    objc.getProtocolMethodSignature(
      _protocol_NSApplicationDelegate,
      _sel_application_willPresentError_,
      isRequired: false,
      isInstanceMethod: true,
    ),
    (objc.NSError Function(NSApplication, objc.NSError) func) =>
        ObjCBlock_NSError_ffiVoid_NSApplication_NSError.fromFunction(
            (ffi.Pointer<ffi.Void> _, NSApplication arg1, objc.NSError arg2) =>
                func(arg1, arg2)),
  );

  /// application:didRegisterForRemoteNotificationsWithDeviceToken:
  static final application_didRegisterForRemoteNotificationsWithDeviceToken_ =
      objc.ObjCProtocolListenableMethod<
          void Function(NSApplication, objc.NSData)>(
    _protocol_NSApplicationDelegate,
    _sel_application_didRegisterForRemoteNotificationsWithDeviceToken_,
    ffi.Native.addressOf<
                ffi.NativeFunction<
                    ffi.Void Function(
                        ffi.Pointer<objc.ObjCObject>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<objc.ObjCObject>,
                        ffi.Pointer<objc.ObjCObject>)>>(
            _AuthenticationServicesMacOS_protocolTrampoline_fjrv01)
        .cast(),
    objc.getProtocolMethodSignature(
      _protocol_NSApplicationDelegate,
      _sel_application_didRegisterForRemoteNotificationsWithDeviceToken_,
      isRequired: false,
      isInstanceMethod: true,
    ),
    (void Function(NSApplication, objc.NSData) func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSApplication_NSData.fromFunction(
            (ffi.Pointer<ffi.Void> _, NSApplication arg1, objc.NSData arg2) =>
                func(arg1, arg2)),
    (void Function(NSApplication, objc.NSData) func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSApplication_NSData.listener(
            (ffi.Pointer<ffi.Void> _, NSApplication arg1, objc.NSData arg2) =>
                func(arg1, arg2)),
    (void Function(NSApplication, objc.NSData) func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSApplication_NSData.blocking(
            (ffi.Pointer<ffi.Void> _, NSApplication arg1, objc.NSData arg2) =>
                func(arg1, arg2)),
  );

  /// application:didFailToRegisterForRemoteNotificationsWithError:
  static final application_didFailToRegisterForRemoteNotificationsWithError_ =
      objc.ObjCProtocolListenableMethod<
          void Function(NSApplication, objc.NSError)>(
    _protocol_NSApplicationDelegate,
    _sel_application_didFailToRegisterForRemoteNotificationsWithError_,
    ffi.Native.addressOf<
                ffi.NativeFunction<
                    ffi.Void Function(
                        ffi.Pointer<objc.ObjCObject>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<objc.ObjCObject>,
                        ffi.Pointer<objc.ObjCObject>)>>(
            _AuthenticationServicesMacOS_protocolTrampoline_fjrv01)
        .cast(),
    objc.getProtocolMethodSignature(
      _protocol_NSApplicationDelegate,
      _sel_application_didFailToRegisterForRemoteNotificationsWithError_,
      isRequired: false,
      isInstanceMethod: true,
    ),
    (void Function(NSApplication, objc.NSError) func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSApplication_NSError.fromFunction(
            (ffi.Pointer<ffi.Void> _, NSApplication arg1, objc.NSError arg2) =>
                func(arg1, arg2)),
    (void Function(NSApplication, objc.NSError) func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSApplication_NSError.listener(
            (ffi.Pointer<ffi.Void> _, NSApplication arg1, objc.NSError arg2) =>
                func(arg1, arg2)),
    (void Function(NSApplication, objc.NSError) func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSApplication_NSError.blocking(
            (ffi.Pointer<ffi.Void> _, NSApplication arg1, objc.NSError arg2) =>
                func(arg1, arg2)),
  );

  /// application:didReceiveRemoteNotification:
  static final application_didReceiveRemoteNotification_ =
      objc.ObjCProtocolListenableMethod<
          void Function(NSApplication, objc.ObjCObjectBase)>(
    _protocol_NSApplicationDelegate,
    _sel_application_didReceiveRemoteNotification_,
    ffi.Native.addressOf<
                ffi.NativeFunction<
                    ffi.Void Function(
                        ffi.Pointer<objc.ObjCObject>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<objc.ObjCObject>,
                        ffi.Pointer<objc.ObjCObject>)>>(
            _AuthenticationServicesMacOS_protocolTrampoline_fjrv01)
        .cast(),
    objc.getProtocolMethodSignature(
      _protocol_NSApplicationDelegate,
      _sel_application_didReceiveRemoteNotification_,
      isRequired: false,
      isInstanceMethod: true,
    ),
    (void Function(NSApplication, objc.ObjCObjectBase) func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSApplication_objcObjCObject.fromFunction(
            (ffi.Pointer<ffi.Void> _, NSApplication arg1,
                    objc.ObjCObjectBase arg2) =>
                func(arg1, arg2)),
    (void Function(NSApplication, objc.ObjCObjectBase) func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSApplication_objcObjCObject.listener(
            (ffi.Pointer<ffi.Void> _, NSApplication arg1,
                    objc.ObjCObjectBase arg2) =>
                func(arg1, arg2)),
    (void Function(NSApplication, objc.ObjCObjectBase) func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSApplication_objcObjCObject.blocking(
            (ffi.Pointer<ffi.Void> _, NSApplication arg1,
                    objc.ObjCObjectBase arg2) =>
                func(arg1, arg2)),
  );

  /// Method to opt-in to secure restorable state.
  ///
  /// When this returns @c YES:
  /// NSCoders that are passed into the various @c NSWindowRestoration methods will @c requiresSecureCoding and have a @c decodingFailurePolicy of @c NSDecodingFailurePolicySetErrorAndReturn.
  /// Any @c restorationClass set on a window must explicitly conform to @c NSWindowRestoration.
  ///
  /// This method will be called prior to any state encoding or restoration.
  static final applicationSupportsSecureRestorableState_ =
      objc.ObjCProtocolMethod<bool Function(NSApplication)>(
    _protocol_NSApplicationDelegate,
    _sel_applicationSupportsSecureRestorableState_,
    ffi.Native.addressOf<
                ffi.NativeFunction<
                    ffi.Bool Function(ffi.Pointer<objc.ObjCObject>,
                        ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>>(
            _AuthenticationServicesMacOS_protocolTrampoline_3su7tt)
        .cast(),
    objc.getProtocolMethodSignature(
      _protocol_NSApplicationDelegate,
      _sel_applicationSupportsSecureRestorableState_,
      isRequired: false,
      isInstanceMethod: true,
    ),
    (bool Function(NSApplication) func) =>
        ObjCBlock_bool_ffiVoid_NSApplication.fromFunction(
            (ffi.Pointer<ffi.Void> _, NSApplication arg1) => func(arg1)),
  );

  /// @return The object capable of handling the specified intent.
  static final application_handlerForIntent_ = objc.ObjCProtocolMethod<
      objc.ObjCObjectBase? Function(NSApplication, INIntent)>(
    _protocol_NSApplicationDelegate,
    _sel_application_handlerForIntent_,
    ffi.Native.addressOf<
                ffi.NativeFunction<
                    ffi.Pointer<objc.ObjCObject> Function(
                        ffi.Pointer<objc.ObjCObject>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<objc.ObjCObject>,
                        ffi.Pointer<objc.ObjCObject>)>>(
            _AuthenticationServicesMacOS_protocolTrampoline_zi5eed)
        .cast(),
    objc.getProtocolMethodSignature(
      _protocol_NSApplicationDelegate,
      _sel_application_handlerForIntent_,
      isRequired: false,
      isInstanceMethod: true,
    ),
    (objc.ObjCObjectBase? Function(NSApplication, INIntent) func) =>
        ObjCBlock_objcObjCObject_ffiVoid_NSApplication_INIntent.fromFunction(
            (ffi.Pointer<ffi.Void> _, NSApplication arg1, INIntent arg2) =>
                func(arg1, arg2)),
  );

  /// Method called by `-[NSApplication encodeRestorableStateWithCoder:]` to give the delegate a chance to encode any additional state into the @c NSCoder. If the restorable state managed by the delegate changes, you must call `-[NSApplication invalidateRestorableState]` so that it will be re-encoded. See the header `NSWindowRestoration.h` for more information.
  static final application_willEncodeRestorableState_ = objc
      .ObjCProtocolListenableMethod<void Function(NSApplication, objc.NSCoder)>(
    _protocol_NSApplicationDelegate,
    _sel_application_willEncodeRestorableState_,
    ffi.Native.addressOf<
                ffi.NativeFunction<
                    ffi.Void Function(
                        ffi.Pointer<objc.ObjCObject>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<objc.ObjCObject>,
                        ffi.Pointer<objc.ObjCObject>)>>(
            _AuthenticationServicesMacOS_protocolTrampoline_fjrv01)
        .cast(),
    objc.getProtocolMethodSignature(
      _protocol_NSApplicationDelegate,
      _sel_application_willEncodeRestorableState_,
      isRequired: false,
      isInstanceMethod: true,
    ),
    (void Function(NSApplication, objc.NSCoder) func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSApplication_NSCoder.fromFunction(
            (ffi.Pointer<ffi.Void> _, NSApplication arg1, objc.NSCoder arg2) =>
                func(arg1, arg2)),
    (void Function(NSApplication, objc.NSCoder) func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSApplication_NSCoder.listener(
            (ffi.Pointer<ffi.Void> _, NSApplication arg1, objc.NSCoder arg2) =>
                func(arg1, arg2)),
    (void Function(NSApplication, objc.NSCoder) func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSApplication_NSCoder.blocking(
            (ffi.Pointer<ffi.Void> _, NSApplication arg1, objc.NSCoder arg2) =>
                func(arg1, arg2)),
  );

  /// Method called by `-[NSApplication restoreStateWithCoder:]` to give the delegate a chance to restore its own state, which it may decode from the @c NSCoder. See the header `NSWindowRestoration.h` for more information.
  static final application_didDecodeRestorableState_ = objc
      .ObjCProtocolListenableMethod<void Function(NSApplication, objc.NSCoder)>(
    _protocol_NSApplicationDelegate,
    _sel_application_didDecodeRestorableState_,
    ffi.Native.addressOf<
                ffi.NativeFunction<
                    ffi.Void Function(
                        ffi.Pointer<objc.ObjCObject>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<objc.ObjCObject>,
                        ffi.Pointer<objc.ObjCObject>)>>(
            _AuthenticationServicesMacOS_protocolTrampoline_fjrv01)
        .cast(),
    objc.getProtocolMethodSignature(
      _protocol_NSApplicationDelegate,
      _sel_application_didDecodeRestorableState_,
      isRequired: false,
      isInstanceMethod: true,
    ),
    (void Function(NSApplication, objc.NSCoder) func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSApplication_NSCoder.fromFunction(
            (ffi.Pointer<ffi.Void> _, NSApplication arg1, objc.NSCoder arg2) =>
                func(arg1, arg2)),
    (void Function(NSApplication, objc.NSCoder) func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSApplication_NSCoder.listener(
            (ffi.Pointer<ffi.Void> _, NSApplication arg1, objc.NSCoder arg2) =>
                func(arg1, arg2)),
    (void Function(NSApplication, objc.NSCoder) func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSApplication_NSCoder.blocking(
            (ffi.Pointer<ffi.Void> _, NSApplication arg1, objc.NSCoder arg2) =>
                func(arg1, arg2)),
  );

  /// This will be called on the main thread as soon as the user indicates they want to continue an activity in your application. The @c NSUserActivity object may not be available instantly, so use this as an opportunity to show the user that an activity will be continued shortly. Return @c YES to indicate that you are doing so. Return @c NO (or leave it unimplemented) and AppKit/UIKit will put up a default UI.
  ///
  /// For each `-application:willContinueUserActivityWithType:` invocation, you are guaranteed to get exactly one invocation of `-application:continueUserActivity:restorationHandler:` on success, or `-application:didFailToContinueUserActivityWithType:error:` if an error was encountered.
  static final application_willContinueUserActivityWithType_ =
      objc.ObjCProtocolMethod<bool Function(NSApplication, objc.NSString)>(
    _protocol_NSApplicationDelegate,
    _sel_application_willContinueUserActivityWithType_,
    ffi.Native.addressOf<
                ffi.NativeFunction<
                    ffi.Bool Function(
                        ffi.Pointer<objc.ObjCObject>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<objc.ObjCObject>,
                        ffi.Pointer<objc.ObjCObject>)>>(
            _AuthenticationServicesMacOS_protocolTrampoline_2n06mv)
        .cast(),
    objc.getProtocolMethodSignature(
      _protocol_NSApplicationDelegate,
      _sel_application_willContinueUserActivityWithType_,
      isRequired: false,
      isInstanceMethod: true,
    ),
    (bool Function(NSApplication, objc.NSString) func) =>
        ObjCBlock_bool_ffiVoid_NSApplication_NSString.fromFunction(
            (ffi.Pointer<ffi.Void> _, NSApplication arg1, objc.NSString arg2) =>
                func(arg1, arg2)),
  );

  /// This will be called on the main thread after the @c NSUserActivity object is available. Use the data you stored in the NSUserActivity object to re-create what the user was doing.
  ///
  /// @return @c YES to indicate that the activity was handled. Return @c NO (or leave it unimplemented) and AppKit will attempt to continue the user activity.
  ///
  /// You should create/fetch any restorable objects associated with the user activity, and pass them to the restorationHandler. They will then get the above `-restoreUserActivityState:` method invoked with the user activity. Invoking the @c restorationHandler is optional. It may be copied and invoked later, but must be invoked on the main thread.
  ///
  /// If this user activity was created automatically by having @c NSUbiquitousDocumentUserActivityType in a @c CFBundleDocumentTypes entry, AppKit can automatically restore the NSUserActivity on OS X if NO is returned, or this method is unimplemented. It will do so by creating a document of the appropriate type using the URL stored in the userInfo under the @c NSUserActivityDocumentURLKey. The document will have `-restoreUserActivity:` called on it.
  static final application_continueUserActivity_restorationHandler_ =
      objc.ObjCProtocolMethod<
          bool Function(NSApplication, NSUserActivity,
              objc.ObjCBlock<ffi.Void Function(objc.NSArray)>)>(
    _protocol_NSApplicationDelegate,
    _sel_application_continueUserActivity_restorationHandler_,
    ffi.Native.addressOf<
                ffi.NativeFunction<
                    ffi.Bool Function(
                        ffi.Pointer<objc.ObjCObject>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<objc.ObjCObject>,
                        ffi.Pointer<objc.ObjCObject>,
                        ffi.Pointer<objc.ObjCBlockImpl>)>>(
            _AuthenticationServicesMacOS_protocolTrampoline_rptcvw)
        .cast(),
    objc.getProtocolMethodSignature(
      _protocol_NSApplicationDelegate,
      _sel_application_continueUserActivity_restorationHandler_,
      isRequired: false,
      isInstanceMethod: true,
    ),
    (bool Function(NSApplication, NSUserActivity,
                objc.ObjCBlock<ffi.Void Function(objc.NSArray)>)
            func) =>
        ObjCBlock_bool_ffiVoid_NSApplication_NSUserActivity_ffiVoidNSArray
            .fromFunction((ffi.Pointer<ffi.Void> _,
                    NSApplication arg1,
                    NSUserActivity arg2,
                    objc.ObjCBlock<ffi.Void Function(objc.NSArray)> arg3) =>
                func(arg1, arg2, arg3)),
  );

  /// There are instances where continuing a @c NSUserActivity may fail. This will get called on the main thread if it does so. If it is unimplemented, AppKit will present the error.
  static final application_didFailToContinueUserActivityWithType_error_ =
      objc.ObjCProtocolListenableMethod<
          void Function(NSApplication, objc.NSString, objc.NSError)>(
    _protocol_NSApplicationDelegate,
    _sel_application_didFailToContinueUserActivityWithType_error_,
    ffi.Native.addressOf<
                ffi.NativeFunction<
                    ffi.Void Function(
                        ffi.Pointer<objc.ObjCObject>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<objc.ObjCObject>,
                        ffi.Pointer<objc.ObjCObject>,
                        ffi.Pointer<objc.ObjCObject>)>>(
            _AuthenticationServicesMacOS_protocolTrampoline_1tz5yf)
        .cast(),
    objc.getProtocolMethodSignature(
      _protocol_NSApplicationDelegate,
      _sel_application_didFailToContinueUserActivityWithType_error_,
      isRequired: false,
      isInstanceMethod: true,
    ),
    (void Function(NSApplication, objc.NSString, objc.NSError) func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSApplication_NSString_NSError.fromFunction(
            (ffi.Pointer<ffi.Void> _, NSApplication arg1, objc.NSString arg2,
                    objc.NSError arg3) =>
                func(arg1, arg2, arg3)),
    (void Function(NSApplication, objc.NSString, objc.NSError) func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSApplication_NSString_NSError.listener(
            (ffi.Pointer<ffi.Void> _, NSApplication arg1, objc.NSString arg2,
                    objc.NSError arg3) =>
                func(arg1, arg2, arg3)),
    (void Function(NSApplication, objc.NSString, objc.NSError) func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSApplication_NSString_NSError.blocking(
            (ffi.Pointer<ffi.Void> _, NSApplication arg1, objc.NSString arg2,
                    objc.NSError arg3) =>
                func(arg1, arg2, arg3)),
  );

  /// This will be called on the main thread when a user activity managed by AppKit/UIKit has been updated. You should use this as a last chance to add additional data to the @c userActivity.
  static final application_didUpdateUserActivity_ =
      objc.ObjCProtocolListenableMethod<
          void Function(NSApplication, NSUserActivity)>(
    _protocol_NSApplicationDelegate,
    _sel_application_didUpdateUserActivity_,
    ffi.Native.addressOf<
                ffi.NativeFunction<
                    ffi.Void Function(
                        ffi.Pointer<objc.ObjCObject>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<objc.ObjCObject>,
                        ffi.Pointer<objc.ObjCObject>)>>(
            _AuthenticationServicesMacOS_protocolTrampoline_fjrv01)
        .cast(),
    objc.getProtocolMethodSignature(
      _protocol_NSApplicationDelegate,
      _sel_application_didUpdateUserActivity_,
      isRequired: false,
      isInstanceMethod: true,
    ),
    (void Function(NSApplication, NSUserActivity) func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSApplication_NSUserActivity.fromFunction(
            (ffi.Pointer<ffi.Void> _, NSApplication arg1,
                    NSUserActivity arg2) =>
                func(arg1, arg2)),
    (void Function(NSApplication, NSUserActivity) func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSApplication_NSUserActivity.listener(
            (ffi.Pointer<ffi.Void> _, NSApplication arg1,
                    NSUserActivity arg2) =>
                func(arg1, arg2)),
    (void Function(NSApplication, NSUserActivity) func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSApplication_NSUserActivity.blocking(
            (ffi.Pointer<ffi.Void> _, NSApplication arg1,
                    NSUserActivity arg2) =>
                func(arg1, arg2)),
  );

  /// This will be called on the main thread after the user indicates they want to accept a CloudKit sharing invitation in your application.
  ///
  /// You should use the @c CKShareMetadata object's @c shareURL and containerIdentifier to schedule a @c CKAcceptSharesOperation, then start using the resulting @c CKShare and its associated record(s), which will appear in the @c CKContainer's shared database in a zone matching that of the record's owner.
  static final application_userDidAcceptCloudKitShareWithMetadata_ =
      objc.ObjCProtocolListenableMethod<
          void Function(NSApplication, CKShareMetadata)>(
    _protocol_NSApplicationDelegate,
    _sel_application_userDidAcceptCloudKitShareWithMetadata_,
    ffi.Native.addressOf<
                ffi.NativeFunction<
                    ffi.Void Function(
                        ffi.Pointer<objc.ObjCObject>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<objc.ObjCObject>,
                        ffi.Pointer<objc.ObjCObject>)>>(
            _AuthenticationServicesMacOS_protocolTrampoline_fjrv01)
        .cast(),
    objc.getProtocolMethodSignature(
      _protocol_NSApplicationDelegate,
      _sel_application_userDidAcceptCloudKitShareWithMetadata_,
      isRequired: false,
      isInstanceMethod: true,
    ),
    (void Function(NSApplication, CKShareMetadata) func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSApplication_CKShareMetadata.fromFunction(
            (ffi.Pointer<ffi.Void> _, NSApplication arg1,
                    CKShareMetadata arg2) =>
                func(arg1, arg2)),
    (void Function(NSApplication, CKShareMetadata) func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSApplication_CKShareMetadata.listener(
            (ffi.Pointer<ffi.Void> _, NSApplication arg1,
                    CKShareMetadata arg2) =>
                func(arg1, arg2)),
    (void Function(NSApplication, CKShareMetadata) func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSApplication_CKShareMetadata.blocking(
            (ffi.Pointer<ffi.Void> _, NSApplication arg1,
                    CKShareMetadata arg2) =>
                func(arg1, arg2)),
  );

  /// @return @c YES if the receiving delegate object can respond to key value coding messages for a specific keyed attribute, to-one relationship, or to-many relationship.  Return @c NO otherwise.
  static final application_delegateHandlesKey_ =
      objc.ObjCProtocolMethod<bool Function(NSApplication, objc.NSString)>(
    _protocol_NSApplicationDelegate,
    _sel_application_delegateHandlesKey_,
    ffi.Native.addressOf<
                ffi.NativeFunction<
                    ffi.Bool Function(
                        ffi.Pointer<objc.ObjCObject>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<objc.ObjCObject>,
                        ffi.Pointer<objc.ObjCObject>)>>(
            _AuthenticationServicesMacOS_protocolTrampoline_2n06mv)
        .cast(),
    objc.getProtocolMethodSignature(
      _protocol_NSApplicationDelegate,
      _sel_application_delegateHandlesKey_,
      isRequired: false,
      isInstanceMethod: true,
    ),
    (bool Function(NSApplication, objc.NSString) func) =>
        ObjCBlock_bool_ffiVoid_NSApplication_NSString.fromFunction(
            (ffi.Pointer<ffi.Void> _, NSApplication arg1, objc.NSString arg2) =>
                func(arg1, arg2)),
  );

  /// This method will be called once during application launch at `-[NSApplication finishLaunching]`.
  ///
  /// @return @c NO if the receiving delegate object wishes to opt-out of system-wide keyboard shortcut localization for all application-supplied menus. Return @c YES by default for apps linked against 12.0 and later SDK.
  static final applicationShouldAutomaticallyLocalizeKeyEquivalents_ =
      objc.ObjCProtocolMethod<bool Function(NSApplication)>(
    _protocol_NSApplicationDelegate,
    _sel_applicationShouldAutomaticallyLocalizeKeyEquivalents_,
    ffi.Native.addressOf<
                ffi.NativeFunction<
                    ffi.Bool Function(ffi.Pointer<objc.ObjCObject>,
                        ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>>(
            _AuthenticationServicesMacOS_protocolTrampoline_3su7tt)
        .cast(),
    objc.getProtocolMethodSignature(
      _protocol_NSApplicationDelegate,
      _sel_applicationShouldAutomaticallyLocalizeKeyEquivalents_,
      isRequired: false,
      isInstanceMethod: true,
    ),
    (bool Function(NSApplication) func) =>
        ObjCBlock_bool_ffiVoid_NSApplication.fromFunction(
            (ffi.Pointer<ffi.Void> _, NSApplication arg1) => func(arg1)),
  );

  /// applicationWillFinishLaunching:
  static final applicationWillFinishLaunching_ =
      objc.ObjCProtocolListenableMethod<void Function(objc.NSNotification)>(
    _protocol_NSApplicationDelegate,
    _sel_applicationWillFinishLaunching_,
    ffi.Native.addressOf<
                ffi.NativeFunction<
                    ffi.Void Function(ffi.Pointer<objc.ObjCObject>,
                        ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>>(
            _AuthenticationServicesMacOS_protocolTrampoline_18v1jvf)
        .cast(),
    objc.getProtocolMethodSignature(
      _protocol_NSApplicationDelegate,
      _sel_applicationWillFinishLaunching_,
      isRequired: false,
      isInstanceMethod: true,
    ),
    (void Function(objc.NSNotification) func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSNotification.fromFunction(
            (ffi.Pointer<ffi.Void> _, objc.NSNotification arg1) => func(arg1)),
    (void Function(objc.NSNotification) func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSNotification.listener(
            (ffi.Pointer<ffi.Void> _, objc.NSNotification arg1) => func(arg1)),
    (void Function(objc.NSNotification) func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSNotification.blocking(
            (ffi.Pointer<ffi.Void> _, objc.NSNotification arg1) => func(arg1)),
  );

  /// applicationDidFinishLaunching:
  static final applicationDidFinishLaunching_ =
      objc.ObjCProtocolListenableMethod<void Function(objc.NSNotification)>(
    _protocol_NSApplicationDelegate,
    _sel_applicationDidFinishLaunching_,
    ffi.Native.addressOf<
                ffi.NativeFunction<
                    ffi.Void Function(ffi.Pointer<objc.ObjCObject>,
                        ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>>(
            _AuthenticationServicesMacOS_protocolTrampoline_18v1jvf)
        .cast(),
    objc.getProtocolMethodSignature(
      _protocol_NSApplicationDelegate,
      _sel_applicationDidFinishLaunching_,
      isRequired: false,
      isInstanceMethod: true,
    ),
    (void Function(objc.NSNotification) func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSNotification.fromFunction(
            (ffi.Pointer<ffi.Void> _, objc.NSNotification arg1) => func(arg1)),
    (void Function(objc.NSNotification) func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSNotification.listener(
            (ffi.Pointer<ffi.Void> _, objc.NSNotification arg1) => func(arg1)),
    (void Function(objc.NSNotification) func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSNotification.blocking(
            (ffi.Pointer<ffi.Void> _, objc.NSNotification arg1) => func(arg1)),
  );

  /// applicationWillHide:
  static final applicationWillHide_ =
      objc.ObjCProtocolListenableMethod<void Function(objc.NSNotification)>(
    _protocol_NSApplicationDelegate,
    _sel_applicationWillHide_,
    ffi.Native.addressOf<
                ffi.NativeFunction<
                    ffi.Void Function(ffi.Pointer<objc.ObjCObject>,
                        ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>>(
            _AuthenticationServicesMacOS_protocolTrampoline_18v1jvf)
        .cast(),
    objc.getProtocolMethodSignature(
      _protocol_NSApplicationDelegate,
      _sel_applicationWillHide_,
      isRequired: false,
      isInstanceMethod: true,
    ),
    (void Function(objc.NSNotification) func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSNotification.fromFunction(
            (ffi.Pointer<ffi.Void> _, objc.NSNotification arg1) => func(arg1)),
    (void Function(objc.NSNotification) func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSNotification.listener(
            (ffi.Pointer<ffi.Void> _, objc.NSNotification arg1) => func(arg1)),
    (void Function(objc.NSNotification) func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSNotification.blocking(
            (ffi.Pointer<ffi.Void> _, objc.NSNotification arg1) => func(arg1)),
  );

  /// applicationDidHide:
  static final applicationDidHide_ =
      objc.ObjCProtocolListenableMethod<void Function(objc.NSNotification)>(
    _protocol_NSApplicationDelegate,
    _sel_applicationDidHide_,
    ffi.Native.addressOf<
                ffi.NativeFunction<
                    ffi.Void Function(ffi.Pointer<objc.ObjCObject>,
                        ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>>(
            _AuthenticationServicesMacOS_protocolTrampoline_18v1jvf)
        .cast(),
    objc.getProtocolMethodSignature(
      _protocol_NSApplicationDelegate,
      _sel_applicationDidHide_,
      isRequired: false,
      isInstanceMethod: true,
    ),
    (void Function(objc.NSNotification) func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSNotification.fromFunction(
            (ffi.Pointer<ffi.Void> _, objc.NSNotification arg1) => func(arg1)),
    (void Function(objc.NSNotification) func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSNotification.listener(
            (ffi.Pointer<ffi.Void> _, objc.NSNotification arg1) => func(arg1)),
    (void Function(objc.NSNotification) func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSNotification.blocking(
            (ffi.Pointer<ffi.Void> _, objc.NSNotification arg1) => func(arg1)),
  );

  /// applicationWillUnhide:
  static final applicationWillUnhide_ =
      objc.ObjCProtocolListenableMethod<void Function(objc.NSNotification)>(
    _protocol_NSApplicationDelegate,
    _sel_applicationWillUnhide_,
    ffi.Native.addressOf<
                ffi.NativeFunction<
                    ffi.Void Function(ffi.Pointer<objc.ObjCObject>,
                        ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>>(
            _AuthenticationServicesMacOS_protocolTrampoline_18v1jvf)
        .cast(),
    objc.getProtocolMethodSignature(
      _protocol_NSApplicationDelegate,
      _sel_applicationWillUnhide_,
      isRequired: false,
      isInstanceMethod: true,
    ),
    (void Function(objc.NSNotification) func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSNotification.fromFunction(
            (ffi.Pointer<ffi.Void> _, objc.NSNotification arg1) => func(arg1)),
    (void Function(objc.NSNotification) func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSNotification.listener(
            (ffi.Pointer<ffi.Void> _, objc.NSNotification arg1) => func(arg1)),
    (void Function(objc.NSNotification) func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSNotification.blocking(
            (ffi.Pointer<ffi.Void> _, objc.NSNotification arg1) => func(arg1)),
  );

  /// applicationDidUnhide:
  static final applicationDidUnhide_ =
      objc.ObjCProtocolListenableMethod<void Function(objc.NSNotification)>(
    _protocol_NSApplicationDelegate,
    _sel_applicationDidUnhide_,
    ffi.Native.addressOf<
                ffi.NativeFunction<
                    ffi.Void Function(ffi.Pointer<objc.ObjCObject>,
                        ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>>(
            _AuthenticationServicesMacOS_protocolTrampoline_18v1jvf)
        .cast(),
    objc.getProtocolMethodSignature(
      _protocol_NSApplicationDelegate,
      _sel_applicationDidUnhide_,
      isRequired: false,
      isInstanceMethod: true,
    ),
    (void Function(objc.NSNotification) func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSNotification.fromFunction(
            (ffi.Pointer<ffi.Void> _, objc.NSNotification arg1) => func(arg1)),
    (void Function(objc.NSNotification) func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSNotification.listener(
            (ffi.Pointer<ffi.Void> _, objc.NSNotification arg1) => func(arg1)),
    (void Function(objc.NSNotification) func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSNotification.blocking(
            (ffi.Pointer<ffi.Void> _, objc.NSNotification arg1) => func(arg1)),
  );

  /// applicationWillBecomeActive:
  static final applicationWillBecomeActive_ =
      objc.ObjCProtocolListenableMethod<void Function(objc.NSNotification)>(
    _protocol_NSApplicationDelegate,
    _sel_applicationWillBecomeActive_,
    ffi.Native.addressOf<
                ffi.NativeFunction<
                    ffi.Void Function(ffi.Pointer<objc.ObjCObject>,
                        ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>>(
            _AuthenticationServicesMacOS_protocolTrampoline_18v1jvf)
        .cast(),
    objc.getProtocolMethodSignature(
      _protocol_NSApplicationDelegate,
      _sel_applicationWillBecomeActive_,
      isRequired: false,
      isInstanceMethod: true,
    ),
    (void Function(objc.NSNotification) func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSNotification.fromFunction(
            (ffi.Pointer<ffi.Void> _, objc.NSNotification arg1) => func(arg1)),
    (void Function(objc.NSNotification) func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSNotification.listener(
            (ffi.Pointer<ffi.Void> _, objc.NSNotification arg1) => func(arg1)),
    (void Function(objc.NSNotification) func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSNotification.blocking(
            (ffi.Pointer<ffi.Void> _, objc.NSNotification arg1) => func(arg1)),
  );

  /// applicationDidBecomeActive:
  static final applicationDidBecomeActive_ =
      objc.ObjCProtocolListenableMethod<void Function(objc.NSNotification)>(
    _protocol_NSApplicationDelegate,
    _sel_applicationDidBecomeActive_,
    ffi.Native.addressOf<
                ffi.NativeFunction<
                    ffi.Void Function(ffi.Pointer<objc.ObjCObject>,
                        ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>>(
            _AuthenticationServicesMacOS_protocolTrampoline_18v1jvf)
        .cast(),
    objc.getProtocolMethodSignature(
      _protocol_NSApplicationDelegate,
      _sel_applicationDidBecomeActive_,
      isRequired: false,
      isInstanceMethod: true,
    ),
    (void Function(objc.NSNotification) func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSNotification.fromFunction(
            (ffi.Pointer<ffi.Void> _, objc.NSNotification arg1) => func(arg1)),
    (void Function(objc.NSNotification) func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSNotification.listener(
            (ffi.Pointer<ffi.Void> _, objc.NSNotification arg1) => func(arg1)),
    (void Function(objc.NSNotification) func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSNotification.blocking(
            (ffi.Pointer<ffi.Void> _, objc.NSNotification arg1) => func(arg1)),
  );

  /// applicationWillResignActive:
  static final applicationWillResignActive_ =
      objc.ObjCProtocolListenableMethod<void Function(objc.NSNotification)>(
    _protocol_NSApplicationDelegate,
    _sel_applicationWillResignActive_,
    ffi.Native.addressOf<
                ffi.NativeFunction<
                    ffi.Void Function(ffi.Pointer<objc.ObjCObject>,
                        ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>>(
            _AuthenticationServicesMacOS_protocolTrampoline_18v1jvf)
        .cast(),
    objc.getProtocolMethodSignature(
      _protocol_NSApplicationDelegate,
      _sel_applicationWillResignActive_,
      isRequired: false,
      isInstanceMethod: true,
    ),
    (void Function(objc.NSNotification) func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSNotification.fromFunction(
            (ffi.Pointer<ffi.Void> _, objc.NSNotification arg1) => func(arg1)),
    (void Function(objc.NSNotification) func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSNotification.listener(
            (ffi.Pointer<ffi.Void> _, objc.NSNotification arg1) => func(arg1)),
    (void Function(objc.NSNotification) func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSNotification.blocking(
            (ffi.Pointer<ffi.Void> _, objc.NSNotification arg1) => func(arg1)),
  );

  /// applicationDidResignActive:
  static final applicationDidResignActive_ =
      objc.ObjCProtocolListenableMethod<void Function(objc.NSNotification)>(
    _protocol_NSApplicationDelegate,
    _sel_applicationDidResignActive_,
    ffi.Native.addressOf<
                ffi.NativeFunction<
                    ffi.Void Function(ffi.Pointer<objc.ObjCObject>,
                        ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>>(
            _AuthenticationServicesMacOS_protocolTrampoline_18v1jvf)
        .cast(),
    objc.getProtocolMethodSignature(
      _protocol_NSApplicationDelegate,
      _sel_applicationDidResignActive_,
      isRequired: false,
      isInstanceMethod: true,
    ),
    (void Function(objc.NSNotification) func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSNotification.fromFunction(
            (ffi.Pointer<ffi.Void> _, objc.NSNotification arg1) => func(arg1)),
    (void Function(objc.NSNotification) func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSNotification.listener(
            (ffi.Pointer<ffi.Void> _, objc.NSNotification arg1) => func(arg1)),
    (void Function(objc.NSNotification) func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSNotification.blocking(
            (ffi.Pointer<ffi.Void> _, objc.NSNotification arg1) => func(arg1)),
  );

  /// applicationWillUpdate:
  static final applicationWillUpdate_ =
      objc.ObjCProtocolListenableMethod<void Function(objc.NSNotification)>(
    _protocol_NSApplicationDelegate,
    _sel_applicationWillUpdate_,
    ffi.Native.addressOf<
                ffi.NativeFunction<
                    ffi.Void Function(ffi.Pointer<objc.ObjCObject>,
                        ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>>(
            _AuthenticationServicesMacOS_protocolTrampoline_18v1jvf)
        .cast(),
    objc.getProtocolMethodSignature(
      _protocol_NSApplicationDelegate,
      _sel_applicationWillUpdate_,
      isRequired: false,
      isInstanceMethod: true,
    ),
    (void Function(objc.NSNotification) func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSNotification.fromFunction(
            (ffi.Pointer<ffi.Void> _, objc.NSNotification arg1) => func(arg1)),
    (void Function(objc.NSNotification) func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSNotification.listener(
            (ffi.Pointer<ffi.Void> _, objc.NSNotification arg1) => func(arg1)),
    (void Function(objc.NSNotification) func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSNotification.blocking(
            (ffi.Pointer<ffi.Void> _, objc.NSNotification arg1) => func(arg1)),
  );

  /// applicationDidUpdate:
  static final applicationDidUpdate_ =
      objc.ObjCProtocolListenableMethod<void Function(objc.NSNotification)>(
    _protocol_NSApplicationDelegate,
    _sel_applicationDidUpdate_,
    ffi.Native.addressOf<
                ffi.NativeFunction<
                    ffi.Void Function(ffi.Pointer<objc.ObjCObject>,
                        ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>>(
            _AuthenticationServicesMacOS_protocolTrampoline_18v1jvf)
        .cast(),
    objc.getProtocolMethodSignature(
      _protocol_NSApplicationDelegate,
      _sel_applicationDidUpdate_,
      isRequired: false,
      isInstanceMethod: true,
    ),
    (void Function(objc.NSNotification) func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSNotification.fromFunction(
            (ffi.Pointer<ffi.Void> _, objc.NSNotification arg1) => func(arg1)),
    (void Function(objc.NSNotification) func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSNotification.listener(
            (ffi.Pointer<ffi.Void> _, objc.NSNotification arg1) => func(arg1)),
    (void Function(objc.NSNotification) func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSNotification.blocking(
            (ffi.Pointer<ffi.Void> _, objc.NSNotification arg1) => func(arg1)),
  );

  /// applicationWillTerminate:
  static final applicationWillTerminate_ =
      objc.ObjCProtocolListenableMethod<void Function(objc.NSNotification)>(
    _protocol_NSApplicationDelegate,
    _sel_applicationWillTerminate_,
    ffi.Native.addressOf<
                ffi.NativeFunction<
                    ffi.Void Function(ffi.Pointer<objc.ObjCObject>,
                        ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>>(
            _AuthenticationServicesMacOS_protocolTrampoline_18v1jvf)
        .cast(),
    objc.getProtocolMethodSignature(
      _protocol_NSApplicationDelegate,
      _sel_applicationWillTerminate_,
      isRequired: false,
      isInstanceMethod: true,
    ),
    (void Function(objc.NSNotification) func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSNotification.fromFunction(
            (ffi.Pointer<ffi.Void> _, objc.NSNotification arg1) => func(arg1)),
    (void Function(objc.NSNotification) func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSNotification.listener(
            (ffi.Pointer<ffi.Void> _, objc.NSNotification arg1) => func(arg1)),
    (void Function(objc.NSNotification) func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSNotification.blocking(
            (ffi.Pointer<ffi.Void> _, objc.NSNotification arg1) => func(arg1)),
  );

  /// applicationDidChangeScreenParameters:
  static final applicationDidChangeScreenParameters_ =
      objc.ObjCProtocolListenableMethod<void Function(objc.NSNotification)>(
    _protocol_NSApplicationDelegate,
    _sel_applicationDidChangeScreenParameters_,
    ffi.Native.addressOf<
                ffi.NativeFunction<
                    ffi.Void Function(ffi.Pointer<objc.ObjCObject>,
                        ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>>(
            _AuthenticationServicesMacOS_protocolTrampoline_18v1jvf)
        .cast(),
    objc.getProtocolMethodSignature(
      _protocol_NSApplicationDelegate,
      _sel_applicationDidChangeScreenParameters_,
      isRequired: false,
      isInstanceMethod: true,
    ),
    (void Function(objc.NSNotification) func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSNotification.fromFunction(
            (ffi.Pointer<ffi.Void> _, objc.NSNotification arg1) => func(arg1)),
    (void Function(objc.NSNotification) func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSNotification.listener(
            (ffi.Pointer<ffi.Void> _, objc.NSNotification arg1) => func(arg1)),
    (void Function(objc.NSNotification) func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSNotification.blocking(
            (ffi.Pointer<ffi.Void> _, objc.NSNotification arg1) => func(arg1)),
  );

  /// applicationDidChangeOcclusionState:
  static final applicationDidChangeOcclusionState_ =
      objc.ObjCProtocolListenableMethod<void Function(objc.NSNotification)>(
    _protocol_NSApplicationDelegate,
    _sel_applicationDidChangeOcclusionState_,
    ffi.Native.addressOf<
                ffi.NativeFunction<
                    ffi.Void Function(ffi.Pointer<objc.ObjCObject>,
                        ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>>(
            _AuthenticationServicesMacOS_protocolTrampoline_18v1jvf)
        .cast(),
    objc.getProtocolMethodSignature(
      _protocol_NSApplicationDelegate,
      _sel_applicationDidChangeOcclusionState_,
      isRequired: false,
      isInstanceMethod: true,
    ),
    (void Function(objc.NSNotification) func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSNotification.fromFunction(
            (ffi.Pointer<ffi.Void> _, objc.NSNotification arg1) => func(arg1)),
    (void Function(objc.NSNotification) func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSNotification.listener(
            (ffi.Pointer<ffi.Void> _, objc.NSNotification arg1) => func(arg1)),
    (void Function(objc.NSNotification) func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSNotification.blocking(
            (ffi.Pointer<ffi.Void> _, objc.NSNotification arg1) => func(arg1)),
  );

  /// applicationProtectedDataWillBecomeUnavailable:
  static final applicationProtectedDataWillBecomeUnavailable_ =
      objc.ObjCProtocolListenableMethod<void Function(objc.NSNotification)>(
    _protocol_NSApplicationDelegate,
    _sel_applicationProtectedDataWillBecomeUnavailable_,
    ffi.Native.addressOf<
                ffi.NativeFunction<
                    ffi.Void Function(ffi.Pointer<objc.ObjCObject>,
                        ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>>(
            _AuthenticationServicesMacOS_protocolTrampoline_18v1jvf)
        .cast(),
    objc.getProtocolMethodSignature(
      _protocol_NSApplicationDelegate,
      _sel_applicationProtectedDataWillBecomeUnavailable_,
      isRequired: false,
      isInstanceMethod: true,
    ),
    (void Function(objc.NSNotification) func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSNotification.fromFunction(
            (ffi.Pointer<ffi.Void> _, objc.NSNotification arg1) => func(arg1)),
    (void Function(objc.NSNotification) func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSNotification.listener(
            (ffi.Pointer<ffi.Void> _, objc.NSNotification arg1) => func(arg1)),
    (void Function(objc.NSNotification) func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSNotification.blocking(
            (ffi.Pointer<ffi.Void> _, objc.NSNotification arg1) => func(arg1)),
  );

  /// applicationProtectedDataDidBecomeAvailable:
  static final applicationProtectedDataDidBecomeAvailable_ =
      objc.ObjCProtocolListenableMethod<void Function(objc.NSNotification)>(
    _protocol_NSApplicationDelegate,
    _sel_applicationProtectedDataDidBecomeAvailable_,
    ffi.Native.addressOf<
                ffi.NativeFunction<
                    ffi.Void Function(ffi.Pointer<objc.ObjCObject>,
                        ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>>(
            _AuthenticationServicesMacOS_protocolTrampoline_18v1jvf)
        .cast(),
    objc.getProtocolMethodSignature(
      _protocol_NSApplicationDelegate,
      _sel_applicationProtectedDataDidBecomeAvailable_,
      isRequired: false,
      isInstanceMethod: true,
    ),
    (void Function(objc.NSNotification) func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSNotification.fromFunction(
            (ffi.Pointer<ffi.Void> _, objc.NSNotification arg1) => func(arg1)),
    (void Function(objc.NSNotification) func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSNotification.listener(
            (ffi.Pointer<ffi.Void> _, objc.NSNotification arg1) => func(arg1)),
    (void Function(objc.NSNotification) func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSNotification.blocking(
            (ffi.Pointer<ffi.Void> _, objc.NSNotification arg1) => func(arg1)),
  );
}

enum NSDragOperation {
  NSDragOperationNone(0),
  NSDragOperationCopy(1),
  NSDragOperationLink(2),
  NSDragOperationGeneric(4),
  NSDragOperationPrivate(8),
  NSDragOperationMove(16),
  NSDragOperationDelete(32),
  NSDragOperationEvery(-1),
  NSDragOperationAll_Obsolete(15);

  static const NSDragOperationAll = NSDragOperationAll_Obsolete;

  final int value;
  const NSDragOperation(this.value);

  static NSDragOperation fromValue(int value) => switch (value) {
        0 => NSDragOperationNone,
        1 => NSDragOperationCopy,
        2 => NSDragOperationLink,
        4 => NSDragOperationGeneric,
        8 => NSDragOperationPrivate,
        16 => NSDragOperationMove,
        32 => NSDragOperationDelete,
        -1 => NSDragOperationEvery,
        15 => NSDragOperationAll_Obsolete,
        _ => throw ArgumentError('Unknown value for NSDragOperation: $value'),
      };

  @override
  String toString() {
    if (this == NSDragOperationAll_Obsolete)
      return "NSDragOperation.NSDragOperationAll_Obsolete, NSDragOperation.NSDragOperationAll";
    return super.toString();
  }
}

enum NSDraggingFormation {
  NSDraggingFormationDefault(0),
  NSDraggingFormationNone(1),
  NSDraggingFormationPile(2),
  NSDraggingFormationList(3),
  NSDraggingFormationStack(4);

  final int value;
  const NSDraggingFormation(this.value);

  static NSDraggingFormation fromValue(int value) => switch (value) {
        0 => NSDraggingFormationDefault,
        1 => NSDraggingFormationNone,
        2 => NSDraggingFormationPile,
        3 => NSDraggingFormationList,
        4 => NSDraggingFormationStack,
        _ =>
          throw ArgumentError('Unknown value for NSDraggingFormation: $value'),
      };
}

enum NSDraggingContext {
  NSDraggingContextOutsideApplication(0),
  NSDraggingContextWithinApplication(1);

  final int value;
  const NSDraggingContext(this.value);

  static NSDraggingContext fromValue(int value) => switch (value) {
        0 => NSDraggingContextOutsideApplication,
        1 => NSDraggingContextWithinApplication,
        _ => throw ArgumentError('Unknown value for NSDraggingContext: $value'),
      };
}

enum NSDraggingItemEnumerationOptions {
  NSDraggingItemEnumerationConcurrent(1),
  NSDraggingItemEnumerationClearNonenumeratedImages(65536);

  final int value;
  const NSDraggingItemEnumerationOptions(this.value);

  static NSDraggingItemEnumerationOptions fromValue(int value) =>
      switch (value) {
        1 => NSDraggingItemEnumerationConcurrent,
        65536 => NSDraggingItemEnumerationClearNonenumeratedImages,
        _ => throw ArgumentError(
            'Unknown value for NSDraggingItemEnumerationOptions: $value'),
      };
}

enum NSSpringLoadingHighlight {
  NSSpringLoadingHighlightNone(0),
  NSSpringLoadingHighlightStandard(1),
  NSSpringLoadingHighlightEmphasized(2);

  final int value;
  const NSSpringLoadingHighlight(this.value);

  static NSSpringLoadingHighlight fromValue(int value) => switch (value) {
        0 => NSSpringLoadingHighlightNone,
        1 => NSSpringLoadingHighlightStandard,
        2 => NSSpringLoadingHighlightEmphasized,
        _ => throw ArgumentError(
            'Unknown value for NSSpringLoadingHighlight: $value'),
      };
}

/// WARNING: NSDraggingInfo is a stub. To generate bindings for this class, include
/// NSDraggingInfo in your config's objc-protocols list.
///
/// NSDraggingInfo
interface class NSDraggingInfo extends objc.ObjCProtocolBase
    implements objc.NSObjectProtocol {
  NSDraggingInfo._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super(pointer, retain: retain, release: release);

  /// Constructs a [NSDraggingInfo] that points to the same underlying object as [other].
  NSDraggingInfo.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [NSDraggingInfo] that wraps the given raw object pointer.
  NSDraggingInfo.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);
}

late final _protocol_NSDraggingDestination =
    objc.getProtocol("NSDraggingDestination");
late final _sel_draggingEntered_ = objc.registerName("draggingEntered:");
final _objc_msgSend_us60nl = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.UnsignedLong Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        int Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<objc.ObjCObject>)>();
int _ObjCBlock_NSDragOperation_ffiVoid_idNSDraggingInfo_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1) =>
    block.ref.target
        .cast<
            ffi.NativeFunction<
                ffi.UnsignedLong Function(ffi.Pointer<ffi.Void> arg0,
                    ffi.Pointer<objc.ObjCObject> arg1)>>()
        .asFunction<
            int Function(ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>)>()(arg0, arg1);
ffi.Pointer<ffi.Void>
    _ObjCBlock_NSDragOperation_ffiVoid_idNSDraggingInfo_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.UnsignedLong Function(ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_NSDragOperation_ffiVoid_idNSDraggingInfo_fnPtrTrampoline,
            0)
        .cast();
int _ObjCBlock_NSDragOperation_ffiVoid_idNSDraggingInfo_closureTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1) =>
    (objc.getBlockClosure(block) as int Function(
        ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>))(arg0, arg1);
ffi.Pointer<ffi.Void>
    _ObjCBlock_NSDragOperation_ffiVoid_idNSDraggingInfo_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.UnsignedLong Function(ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_NSDragOperation_ffiVoid_idNSDraggingInfo_closureTrampoline,
            0)
        .cast();

/// Construction methods for `objc.ObjCBlock<ffi.UnsignedLong Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>`.
abstract final class ObjCBlock_NSDragOperation_ffiVoid_idNSDraggingInfo {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
          ffi.UnsignedLong Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<
                  ffi.UnsignedLong Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>(
              pointer,
              retain: retain,
              release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
          ffi.UnsignedLong Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>
      fromFunctionPointer(ffi.Pointer<ffi.NativeFunction<ffi.UnsignedLong Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1)>> ptr) =>
          objc.ObjCBlock<
                  ffi.UnsignedLong Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>(
              objc.newPointerBlock(
                  _ObjCBlock_NSDragOperation_ffiVoid_idNSDraggingInfo_fnPtrCallable, ptr.cast()),
              retain: false,
              release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.UnsignedLong Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)> fromFunction(
          NSDragOperation Function(ffi.Pointer<ffi.Void>, NSDraggingInfo) fn,
          {bool keepIsolateAlive = true}) =>
      objc.ObjCBlock<
              ffi.UnsignedLong Function(
                  ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>(
          objc.newClosureBlock(
              _ObjCBlock_NSDragOperation_ffiVoid_idNSDraggingInfo_closureCallable,
              (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1) =>
                  fn(arg0, NSDraggingInfo.castFromPointer(arg1, retain: true, release: true)).value,
              keepIsolateAlive),
          retain: false,
          release: true);
}

/// Call operator for `objc.ObjCBlock<ffi.UnsignedLong Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>`.
extension ObjCBlock_NSDragOperation_ffiVoid_idNSDraggingInfo_CallExtension
    on objc.ObjCBlock<
        ffi.UnsignedLong Function(
            ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)> {
  NSDragOperation call(ffi.Pointer<ffi.Void> arg0, NSDraggingInfo arg1) =>
      NSDragOperation.fromValue(ref.pointer.ref.invoke
              .cast<
                  ffi.NativeFunction<
                      ffi.UnsignedLong Function(
                          ffi.Pointer<objc.ObjCBlockImpl> block,
                          ffi.Pointer<ffi.Void> arg0,
                          ffi.Pointer<objc.ObjCObject> arg1)>>()
              .asFunction<
                  int Function(ffi.Pointer<objc.ObjCBlockImpl>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>()(
          ref.pointer, arg0, arg1.ref.pointer));
}

late final _sel_draggingUpdated_ = objc.registerName("draggingUpdated:");
late final _sel_draggingExited_ = objc.registerName("draggingExited:");
void _ObjCBlock_ffiVoid_ffiVoid_idNSDraggingInfo_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1) =>
    block.ref.target
        .cast<
            ffi.NativeFunction<
                ffi.Void Function(ffi.Pointer<ffi.Void> arg0,
                    ffi.Pointer<objc.ObjCObject> arg1)>>()
        .asFunction<
            void Function(ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>)>()(arg0, arg1);
ffi.Pointer<ffi.Void>
    _ObjCBlock_ffiVoid_ffiVoid_idNSDraggingInfo_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_ffiVoid_ffiVoid_idNSDraggingInfo_fnPtrTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_ffiVoid_idNSDraggingInfo_closureTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1) =>
    (objc.getBlockClosure(block) as void Function(
        ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>))(arg0, arg1);
ffi.Pointer<ffi.Void>
    _ObjCBlock_ffiVoid_ffiVoid_idNSDraggingInfo_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_ffiVoid_ffiVoid_idNSDraggingInfo_closureTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_ffiVoid_idNSDraggingInfo_listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObject> arg1) {
  (objc.getBlockClosure(block) as void Function(
      ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>))(arg0, arg1);
  objc.objectRelease(block.cast());
}

ffi.NativeCallable<
        ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_ffiVoid_idNSDraggingInfo_listenerCallable = ffi
        .NativeCallable<
            ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>.listener(
        _ObjCBlock_ffiVoid_ffiVoid_idNSDraggingInfo_listenerTrampoline)
      ..keepIsolateAlive = false;
void _ObjCBlock_ffiVoid_ffiVoid_idNSDraggingInfo_blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObject> arg1) {
  try {
    (objc.getBlockClosure(block) as void Function(
        ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>))(arg0, arg1);
  } catch (e) {
  } finally {
    objc.signalWaiter(waiter);
    objc.objectRelease(block.cast());
  }
}

ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_ffiVoid_idNSDraggingInfo_blockingCallable = ffi
        .NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>)>.isolateLocal(
        _ObjCBlock_ffiVoid_ffiVoid_idNSDraggingInfo_blockingTrampoline)
      ..keepIsolateAlive = false;
ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_ffiVoid_idNSDraggingInfo_blockingListenerCallable = ffi
        .NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>)>.listener(
        _ObjCBlock_ffiVoid_ffiVoid_idNSDraggingInfo_blockingTrampoline)
      ..keepIsolateAlive = false;

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>?)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_idNSDraggingInfo {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
          ffi.Void Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>?)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>?)>(
              pointer,
              retain: retain,
              release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>?)>
      fromFunctionPointer(
              ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1)>>
                  ptr) =>
          objc.ObjCBlock<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>?)>(
              objc.newPointerBlock(
                  _ObjCBlock_ffiVoid_ffiVoid_idNSDraggingInfo_fnPtrCallable, ptr.cast()),
              retain: false,
              release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>?)> fromFunction(
          void Function(ffi.Pointer<ffi.Void>, NSDraggingInfo?) fn,
          {bool keepIsolateAlive = true}) =>
      objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>?)>(
          objc.newClosureBlock(
              _ObjCBlock_ffiVoid_ffiVoid_idNSDraggingInfo_closureCallable,
              (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1) =>
                  fn(arg0, arg1.address == 0 ? null : NSDraggingInfo.castFromPointer(arg1, retain: true, release: true)),
              keepIsolateAlive),
          retain: false,
          release: true);

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
      ffi.Void Function(
          ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>?)> listener(
      void Function(ffi.Pointer<ffi.Void>, NSDraggingInfo?) fn,
      {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_idNSDraggingInfo_listenerCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1) => fn(
            arg0,
            arg1.address == 0
                ? null
                : NSDraggingInfo.castFromPointer(arg1,
                    retain: false, release: true)),
        keepIsolateAlive);
    final wrapper = _AuthenticationServicesMacOS_wrapListenerBlock_18v1jvf(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
            ffi.Void Function(
                ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>?)>(wrapper,
        retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<
      ffi.Void Function(
          ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>?)> blocking(
      void Function(ffi.Pointer<ffi.Void>, NSDraggingInfo?) fn,
      {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_idNSDraggingInfo_blockingCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1) => fn(
            arg0,
            arg1.address == 0
                ? null
                : NSDraggingInfo.castFromPointer(arg1,
                    retain: false, release: true)),
        keepIsolateAlive);
    final rawListener = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_idNSDraggingInfo_blockingListenerCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1) => fn(
            arg0,
            arg1.address == 0
                ? null
                : NSDraggingInfo.castFromPointer(arg1,
                    retain: false, release: true)),
        keepIsolateAlive);
    final wrapper = _AuthenticationServicesMacOS_wrapBlockingBlock_18v1jvf(
        raw, rawListener, objc.objCContext);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
            ffi.Void Function(
                ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>?)>(wrapper,
        retain: false, release: true);
  }
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>?)>`.
extension ObjCBlock_ffiVoid_ffiVoid_idNSDraggingInfo_CallExtension
    on objc.ObjCBlock<
        ffi.Void Function(
            ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>?)> {
  void call(ffi.Pointer<ffi.Void> arg0, NSDraggingInfo? arg1) =>
      ref.pointer.ref.invoke
              .cast<
                  ffi.NativeFunction<
                      ffi.Void Function(
                          ffi.Pointer<objc.ObjCBlockImpl> block,
                          ffi.Pointer<ffi.Void> arg0,
                          ffi.Pointer<objc.ObjCObject> arg1)>>()
              .asFunction<
                  void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>()(
          ref.pointer, arg0, arg1?.ref.pointer ?? ffi.nullptr);
}

late final _sel_prepareForDragOperation_ =
    objc.registerName("prepareForDragOperation:");
bool _ObjCBlock_bool_ffiVoid_idNSDraggingInfo_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1) =>
    block.ref.target
        .cast<
            ffi.NativeFunction<
                ffi.Bool Function(ffi.Pointer<ffi.Void> arg0,
                    ffi.Pointer<objc.ObjCObject> arg1)>>()
        .asFunction<
            bool Function(ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>)>()(arg0, arg1);
ffi.Pointer<ffi.Void> _ObjCBlock_bool_ffiVoid_idNSDraggingInfo_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Bool Function(ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_bool_ffiVoid_idNSDraggingInfo_fnPtrTrampoline, false)
        .cast();
bool _ObjCBlock_bool_ffiVoid_idNSDraggingInfo_closureTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1) =>
    (objc.getBlockClosure(block) as bool Function(
        ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>))(arg0, arg1);
ffi.Pointer<ffi.Void> _ObjCBlock_bool_ffiVoid_idNSDraggingInfo_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Bool Function(ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_bool_ffiVoid_idNSDraggingInfo_closureTrampoline, false)
        .cast();

/// Construction methods for `objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>`.
abstract final class ObjCBlock_bool_ffiVoid_idNSDraggingInfo {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
          ffi.Bool Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<
                  ffi.Bool Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>(
              pointer,
              retain: retain,
              release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)> fromFunctionPointer(
          ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Bool Function(ffi.Pointer<ffi.Void> arg0,
                          ffi.Pointer<objc.ObjCObject> arg1)>>
              ptr) =>
      objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>(
          objc.newPointerBlock(_ObjCBlock_bool_ffiVoid_idNSDraggingInfo_fnPtrCallable, ptr.cast()),
          retain: false,
          release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
      ffi.Bool Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)> fromFunction(
          bool Function(ffi.Pointer<ffi.Void>, NSDraggingInfo) fn,
          {bool keepIsolateAlive = true}) =>
      objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>(
          objc.newClosureBlock(
              _ObjCBlock_bool_ffiVoid_idNSDraggingInfo_closureCallable,
              (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1) =>
                  fn(arg0, NSDraggingInfo.castFromPointer(arg1, retain: true, release: true)),
              keepIsolateAlive),
          retain: false,
          release: true);
}

/// Call operator for `objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>`.
extension ObjCBlock_bool_ffiVoid_idNSDraggingInfo_CallExtension
    on objc.ObjCBlock<
        ffi.Bool Function(
            ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)> {
  bool call(ffi.Pointer<ffi.Void> arg0, NSDraggingInfo arg1) =>
      ref.pointer.ref.invoke
              .cast<
                  ffi.NativeFunction<
                      ffi.Bool Function(
                          ffi.Pointer<objc.ObjCBlockImpl> block,
                          ffi.Pointer<ffi.Void> arg0,
                          ffi.Pointer<objc.ObjCObject> arg1)>>()
              .asFunction<
                  bool Function(ffi.Pointer<objc.ObjCBlockImpl>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>()(
          ref.pointer, arg0, arg1.ref.pointer);
}

late final _sel_performDragOperation_ =
    objc.registerName("performDragOperation:");
late final _sel_concludeDragOperation_ =
    objc.registerName("concludeDragOperation:");
late final _sel_draggingEnded_ = objc.registerName("draggingEnded:");
void _ObjCBlock_ffiVoid_ffiVoid_idNSDraggingInfo$1_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1) =>
    block.ref.target
        .cast<
            ffi.NativeFunction<
                ffi.Void Function(ffi.Pointer<ffi.Void> arg0,
                    ffi.Pointer<objc.ObjCObject> arg1)>>()
        .asFunction<
            void Function(ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>)>()(arg0, arg1);
ffi.Pointer<ffi.Void>
    _ObjCBlock_ffiVoid_ffiVoid_idNSDraggingInfo$1_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_ffiVoid_ffiVoid_idNSDraggingInfo$1_fnPtrTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_ffiVoid_idNSDraggingInfo$1_closureTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1) =>
    (objc.getBlockClosure(block) as void Function(
        ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>))(arg0, arg1);
ffi.Pointer<ffi.Void>
    _ObjCBlock_ffiVoid_ffiVoid_idNSDraggingInfo$1_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_ffiVoid_ffiVoid_idNSDraggingInfo$1_closureTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_ffiVoid_idNSDraggingInfo$1_listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObject> arg1) {
  (objc.getBlockClosure(block) as void Function(
      ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>))(arg0, arg1);
  objc.objectRelease(block.cast());
}

ffi.NativeCallable<
        ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_ffiVoid_idNSDraggingInfo$1_listenerCallable = ffi
        .NativeCallable<
            ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>.listener(
        _ObjCBlock_ffiVoid_ffiVoid_idNSDraggingInfo$1_listenerTrampoline)
      ..keepIsolateAlive = false;
void _ObjCBlock_ffiVoid_ffiVoid_idNSDraggingInfo$1_blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObject> arg1) {
  try {
    (objc.getBlockClosure(block) as void Function(
        ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>))(arg0, arg1);
  } catch (e) {
  } finally {
    objc.signalWaiter(waiter);
    objc.objectRelease(block.cast());
  }
}

ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_ffiVoid_idNSDraggingInfo$1_blockingCallable = ffi
        .NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>)>.isolateLocal(
        _ObjCBlock_ffiVoid_ffiVoid_idNSDraggingInfo$1_blockingTrampoline)
      ..keepIsolateAlive = false;
ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_ffiVoid_idNSDraggingInfo$1_blockingListenerCallable = ffi
        .NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>)>.listener(
        _ObjCBlock_ffiVoid_ffiVoid_idNSDraggingInfo$1_blockingTrampoline)
      ..keepIsolateAlive = false;

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_idNSDraggingInfo$1 {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
          ffi.Void Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>(
              pointer,
              retain: retain,
              release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc
      .ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>
      fromFunctionPointer(
              ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1)>>
                  ptr) =>
          objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>(
              objc.newPointerBlock(
                  _ObjCBlock_ffiVoid_ffiVoid_idNSDraggingInfo$1_fnPtrCallable,
                  ptr.cast()),
              retain: false,
              release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)> fromFunction(
          void Function(ffi.Pointer<ffi.Void>, NSDraggingInfo) fn,
          {bool keepIsolateAlive = true}) =>
      objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>(
          objc.newClosureBlock(
              _ObjCBlock_ffiVoid_ffiVoid_idNSDraggingInfo$1_closureCallable,
              (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1) =>
                  fn(arg0, NSDraggingInfo.castFromPointer(arg1, retain: true, release: true)),
              keepIsolateAlive),
          retain: false,
          release: true);

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
      ffi.Void Function(
          ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)> listener(
      void Function(ffi.Pointer<ffi.Void>, NSDraggingInfo) fn,
      {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_idNSDraggingInfo$1_listenerCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1) => fn(
            arg0,
            NSDraggingInfo.castFromPointer(arg1, retain: false, release: true)),
        keepIsolateAlive);
    final wrapper = _AuthenticationServicesMacOS_wrapListenerBlock_18v1jvf(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
            ffi.Void Function(
                ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>(wrapper,
        retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<
      ffi.Void Function(
          ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)> blocking(
      void Function(ffi.Pointer<ffi.Void>, NSDraggingInfo) fn,
      {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_idNSDraggingInfo$1_blockingCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1) => fn(
            arg0,
            NSDraggingInfo.castFromPointer(arg1, retain: false, release: true)),
        keepIsolateAlive);
    final rawListener = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_idNSDraggingInfo$1_blockingListenerCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1) => fn(
            arg0,
            NSDraggingInfo.castFromPointer(arg1, retain: false, release: true)),
        keepIsolateAlive);
    final wrapper = _AuthenticationServicesMacOS_wrapBlockingBlock_18v1jvf(
        raw, rawListener, objc.objCContext);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
            ffi.Void Function(
                ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>(wrapper,
        retain: false, release: true);
  }
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>`.
extension ObjCBlock_ffiVoid_ffiVoid_idNSDraggingInfo$1_CallExtension
    on objc.ObjCBlock<
        ffi.Void Function(
            ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)> {
  void call(ffi.Pointer<ffi.Void> arg0, NSDraggingInfo arg1) =>
      ref.pointer.ref.invoke
              .cast<
                  ffi.NativeFunction<
                      ffi.Void Function(
                          ffi.Pointer<objc.ObjCBlockImpl> block,
                          ffi.Pointer<ffi.Void> arg0,
                          ffi.Pointer<objc.ObjCObject> arg1)>>()
              .asFunction<
                  void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>()(
          ref.pointer, arg0, arg1.ref.pointer);
}

late final _sel_wantsPeriodicDraggingUpdates =
    objc.registerName("wantsPeriodicDraggingUpdates");
bool _ObjCBlock_bool_ffiVoid_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0) =>
    block.ref.target
        .cast<
            ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<ffi.Void> arg0)>>()
        .asFunction<bool Function(ffi.Pointer<ffi.Void>)>()(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_bool_ffiVoid_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Bool Function(
                    ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>(
            _ObjCBlock_bool_ffiVoid_fnPtrTrampoline, false)
        .cast();
bool _ObjCBlock_bool_ffiVoid_closureTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0) =>
    (objc.getBlockClosure(block) as bool Function(ffi.Pointer<ffi.Void>))(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_bool_ffiVoid_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Bool Function(
                    ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>(
            _ObjCBlock_bool_ffiVoid_closureTrampoline, false)
        .cast();

/// Construction methods for `objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>)>`.
abstract final class ObjCBlock_bool_ffiVoid {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>)>(pointer,
              retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>)>
      fromFunctionPointer(
              ffi.Pointer<
                      ffi.NativeFunction<
                          ffi.Bool Function(ffi.Pointer<ffi.Void> arg0)>>
                  ptr) =>
          objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>)>(
              objc.newPointerBlock(_ObjCBlock_bool_ffiVoid_fnPtrCallable, ptr.cast()),
              retain: false,
              release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>)> fromFunction(
          bool Function(ffi.Pointer<ffi.Void>) fn,
          {bool keepIsolateAlive = true}) =>
      objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>)>(
          objc.newClosureBlock(_ObjCBlock_bool_ffiVoid_closureCallable,
              (ffi.Pointer<ffi.Void> arg0) => fn(arg0), keepIsolateAlive),
          retain: false,
          release: true);
}

/// Call operator for `objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>)>`.
extension ObjCBlock_bool_ffiVoid_CallExtension
    on objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>)> {
  bool call(ffi.Pointer<ffi.Void> arg0) => ref.pointer.ref.invoke
      .cast<
          ffi.NativeFunction<
              ffi.Bool Function(ffi.Pointer<objc.ObjCBlockImpl> block,
                  ffi.Pointer<ffi.Void> arg0)>>()
      .asFunction<
          bool Function(ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>)>()(ref.pointer, arg0);
}

late final _sel_updateDraggingItemsForDrag_ =
    objc.registerName("updateDraggingItemsForDrag:");

/// NSDraggingDestination
interface class NSDraggingDestination extends objc.ObjCProtocolBase
    implements objc.NSObjectProtocol {
  NSDraggingDestination._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super(pointer, retain: retain, release: release);

  /// Constructs a [NSDraggingDestination] that points to the same underlying object as [other].
  NSDraggingDestination.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [NSDraggingDestination] that wraps the given raw object pointer.
  NSDraggingDestination.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [NSDraggingDestination].
  static bool conformsTo(objc.ObjCObjectBase obj) {
    return _objc_msgSend_e3qsqz(obj.ref.pointer, _sel_conformsToProtocol_,
        _protocol_NSDraggingDestination);
  }

  /// Returns the [objc.Protocol] object for this protocol.
  static objc.Protocol get $protocol =>
      objc.Protocol.castFromPointer(_protocol_NSDraggingDestination.cast());

  /// Builds an object that implements the NSDraggingDestination protocol. To implement
  /// multiple protocols, use [addToBuilder] or [objc.ObjCProtocolBuilder] directly.
  ///
  /// If `$keepIsolateAlive` is true, this protocol will keep this isolate
  /// alive until it is garbage collected by both Dart and ObjC.
  static NSDraggingDestination implement(
      {NSDragOperation Function(NSDraggingInfo)? draggingEntered_,
      NSDragOperation Function(NSDraggingInfo)? draggingUpdated_,
      void Function(NSDraggingInfo?)? draggingExited_,
      bool Function(NSDraggingInfo)? prepareForDragOperation_,
      bool Function(NSDraggingInfo)? performDragOperation_,
      void Function(NSDraggingInfo?)? concludeDragOperation_,
      void Function(NSDraggingInfo)? draggingEnded_,
      bool Function()? wantsPeriodicDraggingUpdates,
      void Function(NSDraggingInfo?)? updateDraggingItemsForDrag_,
      bool $keepIsolateAlive = true}) {
    final builder =
        objc.ObjCProtocolBuilder(debugName: 'NSDraggingDestination');
    NSDraggingDestination.draggingEntered_.implement(builder, draggingEntered_);
    NSDraggingDestination.draggingUpdated_.implement(builder, draggingUpdated_);
    NSDraggingDestination.draggingExited_.implement(builder, draggingExited_);
    NSDraggingDestination.prepareForDragOperation_
        .implement(builder, prepareForDragOperation_);
    NSDraggingDestination.performDragOperation_
        .implement(builder, performDragOperation_);
    NSDraggingDestination.concludeDragOperation_
        .implement(builder, concludeDragOperation_);
    NSDraggingDestination.draggingEnded_.implement(builder, draggingEnded_);
    NSDraggingDestination.wantsPeriodicDraggingUpdates
        .implement(builder, wantsPeriodicDraggingUpdates);
    NSDraggingDestination.updateDraggingItemsForDrag_
        .implement(builder, updateDraggingItemsForDrag_);
    builder.addProtocol($protocol);
    return NSDraggingDestination.castFrom(
        builder.build(keepIsolateAlive: $keepIsolateAlive));
  }

  /// Adds the implementation of the NSDraggingDestination protocol to an existing
  /// [objc.ObjCProtocolBuilder].
  ///
  /// Note: You cannot call this method after you have called `builder.build`.
  static void addToBuilder(objc.ObjCProtocolBuilder builder,
      {NSDragOperation Function(NSDraggingInfo)? draggingEntered_,
      NSDragOperation Function(NSDraggingInfo)? draggingUpdated_,
      void Function(NSDraggingInfo?)? draggingExited_,
      bool Function(NSDraggingInfo)? prepareForDragOperation_,
      bool Function(NSDraggingInfo)? performDragOperation_,
      void Function(NSDraggingInfo?)? concludeDragOperation_,
      void Function(NSDraggingInfo)? draggingEnded_,
      bool Function()? wantsPeriodicDraggingUpdates,
      void Function(NSDraggingInfo?)? updateDraggingItemsForDrag_,
      bool $keepIsolateAlive = true}) {
    NSDraggingDestination.draggingEntered_.implement(builder, draggingEntered_);
    NSDraggingDestination.draggingUpdated_.implement(builder, draggingUpdated_);
    NSDraggingDestination.draggingExited_.implement(builder, draggingExited_);
    NSDraggingDestination.prepareForDragOperation_
        .implement(builder, prepareForDragOperation_);
    NSDraggingDestination.performDragOperation_
        .implement(builder, performDragOperation_);
    NSDraggingDestination.concludeDragOperation_
        .implement(builder, concludeDragOperation_);
    NSDraggingDestination.draggingEnded_.implement(builder, draggingEnded_);
    NSDraggingDestination.wantsPeriodicDraggingUpdates
        .implement(builder, wantsPeriodicDraggingUpdates);
    NSDraggingDestination.updateDraggingItemsForDrag_
        .implement(builder, updateDraggingItemsForDrag_);
    builder.addProtocol($protocol);
  }

  /// Builds an object that implements the NSDraggingDestination protocol. To implement
  /// multiple protocols, use [addToBuilder] or [objc.ObjCProtocolBuilder] directly. All
  /// methods that can be implemented as listeners will be.
  ///
  /// If `$keepIsolateAlive` is true, this protocol will keep this isolate
  /// alive until it is garbage collected by both Dart and ObjC.
  static NSDraggingDestination implementAsListener(
      {NSDragOperation Function(NSDraggingInfo)? draggingEntered_,
      NSDragOperation Function(NSDraggingInfo)? draggingUpdated_,
      void Function(NSDraggingInfo?)? draggingExited_,
      bool Function(NSDraggingInfo)? prepareForDragOperation_,
      bool Function(NSDraggingInfo)? performDragOperation_,
      void Function(NSDraggingInfo?)? concludeDragOperation_,
      void Function(NSDraggingInfo)? draggingEnded_,
      bool Function()? wantsPeriodicDraggingUpdates,
      void Function(NSDraggingInfo?)? updateDraggingItemsForDrag_,
      bool $keepIsolateAlive = true}) {
    final builder =
        objc.ObjCProtocolBuilder(debugName: 'NSDraggingDestination');
    NSDraggingDestination.draggingEntered_.implement(builder, draggingEntered_);
    NSDraggingDestination.draggingUpdated_.implement(builder, draggingUpdated_);
    NSDraggingDestination.draggingExited_
        .implementAsListener(builder, draggingExited_);
    NSDraggingDestination.prepareForDragOperation_
        .implement(builder, prepareForDragOperation_);
    NSDraggingDestination.performDragOperation_
        .implement(builder, performDragOperation_);
    NSDraggingDestination.concludeDragOperation_
        .implementAsListener(builder, concludeDragOperation_);
    NSDraggingDestination.draggingEnded_
        .implementAsListener(builder, draggingEnded_);
    NSDraggingDestination.wantsPeriodicDraggingUpdates
        .implement(builder, wantsPeriodicDraggingUpdates);
    NSDraggingDestination.updateDraggingItemsForDrag_
        .implementAsListener(builder, updateDraggingItemsForDrag_);
    builder.addProtocol($protocol);
    return NSDraggingDestination.castFrom(
        builder.build(keepIsolateAlive: $keepIsolateAlive));
  }

  /// Adds the implementation of the NSDraggingDestination protocol to an existing
  /// [objc.ObjCProtocolBuilder]. All methods that can be implemented as listeners will
  /// be.
  ///
  /// Note: You cannot call this method after you have called `builder.build`.
  static void addToBuilderAsListener(objc.ObjCProtocolBuilder builder,
      {NSDragOperation Function(NSDraggingInfo)? draggingEntered_,
      NSDragOperation Function(NSDraggingInfo)? draggingUpdated_,
      void Function(NSDraggingInfo?)? draggingExited_,
      bool Function(NSDraggingInfo)? prepareForDragOperation_,
      bool Function(NSDraggingInfo)? performDragOperation_,
      void Function(NSDraggingInfo?)? concludeDragOperation_,
      void Function(NSDraggingInfo)? draggingEnded_,
      bool Function()? wantsPeriodicDraggingUpdates,
      void Function(NSDraggingInfo?)? updateDraggingItemsForDrag_,
      bool $keepIsolateAlive = true}) {
    NSDraggingDestination.draggingEntered_.implement(builder, draggingEntered_);
    NSDraggingDestination.draggingUpdated_.implement(builder, draggingUpdated_);
    NSDraggingDestination.draggingExited_
        .implementAsListener(builder, draggingExited_);
    NSDraggingDestination.prepareForDragOperation_
        .implement(builder, prepareForDragOperation_);
    NSDraggingDestination.performDragOperation_
        .implement(builder, performDragOperation_);
    NSDraggingDestination.concludeDragOperation_
        .implementAsListener(builder, concludeDragOperation_);
    NSDraggingDestination.draggingEnded_
        .implementAsListener(builder, draggingEnded_);
    NSDraggingDestination.wantsPeriodicDraggingUpdates
        .implement(builder, wantsPeriodicDraggingUpdates);
    NSDraggingDestination.updateDraggingItemsForDrag_
        .implementAsListener(builder, updateDraggingItemsForDrag_);
    builder.addProtocol($protocol);
  }

  /// Builds an object that implements the NSDraggingDestination protocol. To implement
  /// multiple protocols, use [addToBuilder] or [objc.ObjCProtocolBuilder] directly. All
  /// methods that can be implemented as blocking listeners will be.
  ///
  /// If `$keepIsolateAlive` is true, this protocol will keep this isolate
  /// alive until it is garbage collected by both Dart and ObjC.
  static NSDraggingDestination implementAsBlocking(
      {NSDragOperation Function(NSDraggingInfo)? draggingEntered_,
      NSDragOperation Function(NSDraggingInfo)? draggingUpdated_,
      void Function(NSDraggingInfo?)? draggingExited_,
      bool Function(NSDraggingInfo)? prepareForDragOperation_,
      bool Function(NSDraggingInfo)? performDragOperation_,
      void Function(NSDraggingInfo?)? concludeDragOperation_,
      void Function(NSDraggingInfo)? draggingEnded_,
      bool Function()? wantsPeriodicDraggingUpdates,
      void Function(NSDraggingInfo?)? updateDraggingItemsForDrag_,
      bool $keepIsolateAlive = true}) {
    final builder =
        objc.ObjCProtocolBuilder(debugName: 'NSDraggingDestination');
    NSDraggingDestination.draggingEntered_.implement(builder, draggingEntered_);
    NSDraggingDestination.draggingUpdated_.implement(builder, draggingUpdated_);
    NSDraggingDestination.draggingExited_
        .implementAsBlocking(builder, draggingExited_);
    NSDraggingDestination.prepareForDragOperation_
        .implement(builder, prepareForDragOperation_);
    NSDraggingDestination.performDragOperation_
        .implement(builder, performDragOperation_);
    NSDraggingDestination.concludeDragOperation_
        .implementAsBlocking(builder, concludeDragOperation_);
    NSDraggingDestination.draggingEnded_
        .implementAsBlocking(builder, draggingEnded_);
    NSDraggingDestination.wantsPeriodicDraggingUpdates
        .implement(builder, wantsPeriodicDraggingUpdates);
    NSDraggingDestination.updateDraggingItemsForDrag_
        .implementAsBlocking(builder, updateDraggingItemsForDrag_);
    builder.addProtocol($protocol);
    return NSDraggingDestination.castFrom(
        builder.build(keepIsolateAlive: $keepIsolateAlive));
  }

  /// Adds the implementation of the NSDraggingDestination protocol to an existing
  /// [objc.ObjCProtocolBuilder]. All methods that can be implemented as blocking
  /// listeners will be.
  ///
  /// Note: You cannot call this method after you have called `builder.build`.
  static void addToBuilderAsBlocking(objc.ObjCProtocolBuilder builder,
      {NSDragOperation Function(NSDraggingInfo)? draggingEntered_,
      NSDragOperation Function(NSDraggingInfo)? draggingUpdated_,
      void Function(NSDraggingInfo?)? draggingExited_,
      bool Function(NSDraggingInfo)? prepareForDragOperation_,
      bool Function(NSDraggingInfo)? performDragOperation_,
      void Function(NSDraggingInfo?)? concludeDragOperation_,
      void Function(NSDraggingInfo)? draggingEnded_,
      bool Function()? wantsPeriodicDraggingUpdates,
      void Function(NSDraggingInfo?)? updateDraggingItemsForDrag_,
      bool $keepIsolateAlive = true}) {
    NSDraggingDestination.draggingEntered_.implement(builder, draggingEntered_);
    NSDraggingDestination.draggingUpdated_.implement(builder, draggingUpdated_);
    NSDraggingDestination.draggingExited_
        .implementAsBlocking(builder, draggingExited_);
    NSDraggingDestination.prepareForDragOperation_
        .implement(builder, prepareForDragOperation_);
    NSDraggingDestination.performDragOperation_
        .implement(builder, performDragOperation_);
    NSDraggingDestination.concludeDragOperation_
        .implementAsBlocking(builder, concludeDragOperation_);
    NSDraggingDestination.draggingEnded_
        .implementAsBlocking(builder, draggingEnded_);
    NSDraggingDestination.wantsPeriodicDraggingUpdates
        .implement(builder, wantsPeriodicDraggingUpdates);
    NSDraggingDestination.updateDraggingItemsForDrag_
        .implementAsBlocking(builder, updateDraggingItemsForDrag_);
    builder.addProtocol($protocol);
  }

  /// draggingEntered:
  static final draggingEntered_ =
      objc.ObjCProtocolMethod<NSDragOperation Function(NSDraggingInfo)>(
    _protocol_NSDraggingDestination,
    _sel_draggingEntered_,
    ffi.Native.addressOf<
                ffi.NativeFunction<
                    ffi.UnsignedLong Function(ffi.Pointer<objc.ObjCObject>,
                        ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>>(
            _AuthenticationServicesMacOS_protocolTrampoline_u1rw1h)
        .cast(),
    objc.getProtocolMethodSignature(
      _protocol_NSDraggingDestination,
      _sel_draggingEntered_,
      isRequired: false,
      isInstanceMethod: true,
    ),
    (NSDragOperation Function(NSDraggingInfo) func) =>
        ObjCBlock_NSDragOperation_ffiVoid_idNSDraggingInfo.fromFunction(
            (ffi.Pointer<ffi.Void> _, NSDraggingInfo arg1) => func(arg1)),
  );

  /// draggingUpdated:
  static final draggingUpdated_ =
      objc.ObjCProtocolMethod<NSDragOperation Function(NSDraggingInfo)>(
    _protocol_NSDraggingDestination,
    _sel_draggingUpdated_,
    ffi.Native.addressOf<
                ffi.NativeFunction<
                    ffi.UnsignedLong Function(ffi.Pointer<objc.ObjCObject>,
                        ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>>(
            _AuthenticationServicesMacOS_protocolTrampoline_u1rw1h)
        .cast(),
    objc.getProtocolMethodSignature(
      _protocol_NSDraggingDestination,
      _sel_draggingUpdated_,
      isRequired: false,
      isInstanceMethod: true,
    ),
    (NSDragOperation Function(NSDraggingInfo) func) =>
        ObjCBlock_NSDragOperation_ffiVoid_idNSDraggingInfo.fromFunction(
            (ffi.Pointer<ffi.Void> _, NSDraggingInfo arg1) => func(arg1)),
  );

  /// draggingExited:
  static final draggingExited_ =
      objc.ObjCProtocolListenableMethod<void Function(NSDraggingInfo?)>(
    _protocol_NSDraggingDestination,
    _sel_draggingExited_,
    ffi.Native.addressOf<
                ffi.NativeFunction<
                    ffi.Void Function(ffi.Pointer<objc.ObjCObject>,
                        ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>>(
            _AuthenticationServicesMacOS_protocolTrampoline_18v1jvf)
        .cast(),
    objc.getProtocolMethodSignature(
      _protocol_NSDraggingDestination,
      _sel_draggingExited_,
      isRequired: false,
      isInstanceMethod: true,
    ),
    (void Function(NSDraggingInfo?) func) =>
        ObjCBlock_ffiVoid_ffiVoid_idNSDraggingInfo.fromFunction(
            (ffi.Pointer<ffi.Void> _, NSDraggingInfo? arg1) => func(arg1)),
    (void Function(NSDraggingInfo?) func) =>
        ObjCBlock_ffiVoid_ffiVoid_idNSDraggingInfo.listener(
            (ffi.Pointer<ffi.Void> _, NSDraggingInfo? arg1) => func(arg1)),
    (void Function(NSDraggingInfo?) func) =>
        ObjCBlock_ffiVoid_ffiVoid_idNSDraggingInfo.blocking(
            (ffi.Pointer<ffi.Void> _, NSDraggingInfo? arg1) => func(arg1)),
  );

  /// prepareForDragOperation:
  static final prepareForDragOperation_ =
      objc.ObjCProtocolMethod<bool Function(NSDraggingInfo)>(
    _protocol_NSDraggingDestination,
    _sel_prepareForDragOperation_,
    ffi.Native.addressOf<
                ffi.NativeFunction<
                    ffi.Bool Function(ffi.Pointer<objc.ObjCObject>,
                        ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>>(
            _AuthenticationServicesMacOS_protocolTrampoline_3su7tt)
        .cast(),
    objc.getProtocolMethodSignature(
      _protocol_NSDraggingDestination,
      _sel_prepareForDragOperation_,
      isRequired: false,
      isInstanceMethod: true,
    ),
    (bool Function(NSDraggingInfo) func) =>
        ObjCBlock_bool_ffiVoid_idNSDraggingInfo.fromFunction(
            (ffi.Pointer<ffi.Void> _, NSDraggingInfo arg1) => func(arg1)),
  );

  /// performDragOperation:
  static final performDragOperation_ =
      objc.ObjCProtocolMethod<bool Function(NSDraggingInfo)>(
    _protocol_NSDraggingDestination,
    _sel_performDragOperation_,
    ffi.Native.addressOf<
                ffi.NativeFunction<
                    ffi.Bool Function(ffi.Pointer<objc.ObjCObject>,
                        ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>>(
            _AuthenticationServicesMacOS_protocolTrampoline_3su7tt)
        .cast(),
    objc.getProtocolMethodSignature(
      _protocol_NSDraggingDestination,
      _sel_performDragOperation_,
      isRequired: false,
      isInstanceMethod: true,
    ),
    (bool Function(NSDraggingInfo) func) =>
        ObjCBlock_bool_ffiVoid_idNSDraggingInfo.fromFunction(
            (ffi.Pointer<ffi.Void> _, NSDraggingInfo arg1) => func(arg1)),
  );

  /// concludeDragOperation:
  static final concludeDragOperation_ =
      objc.ObjCProtocolListenableMethod<void Function(NSDraggingInfo?)>(
    _protocol_NSDraggingDestination,
    _sel_concludeDragOperation_,
    ffi.Native.addressOf<
                ffi.NativeFunction<
                    ffi.Void Function(ffi.Pointer<objc.ObjCObject>,
                        ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>>(
            _AuthenticationServicesMacOS_protocolTrampoline_18v1jvf)
        .cast(),
    objc.getProtocolMethodSignature(
      _protocol_NSDraggingDestination,
      _sel_concludeDragOperation_,
      isRequired: false,
      isInstanceMethod: true,
    ),
    (void Function(NSDraggingInfo?) func) =>
        ObjCBlock_ffiVoid_ffiVoid_idNSDraggingInfo.fromFunction(
            (ffi.Pointer<ffi.Void> _, NSDraggingInfo? arg1) => func(arg1)),
    (void Function(NSDraggingInfo?) func) =>
        ObjCBlock_ffiVoid_ffiVoid_idNSDraggingInfo.listener(
            (ffi.Pointer<ffi.Void> _, NSDraggingInfo? arg1) => func(arg1)),
    (void Function(NSDraggingInfo?) func) =>
        ObjCBlock_ffiVoid_ffiVoid_idNSDraggingInfo.blocking(
            (ffi.Pointer<ffi.Void> _, NSDraggingInfo? arg1) => func(arg1)),
  );

  /// draggingEnded:
  static final draggingEnded_ =
      objc.ObjCProtocolListenableMethod<void Function(NSDraggingInfo)>(
    _protocol_NSDraggingDestination,
    _sel_draggingEnded_,
    ffi.Native.addressOf<
                ffi.NativeFunction<
                    ffi.Void Function(ffi.Pointer<objc.ObjCObject>,
                        ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>>(
            _AuthenticationServicesMacOS_protocolTrampoline_18v1jvf)
        .cast(),
    objc.getProtocolMethodSignature(
      _protocol_NSDraggingDestination,
      _sel_draggingEnded_,
      isRequired: false,
      isInstanceMethod: true,
    ),
    (void Function(NSDraggingInfo) func) =>
        ObjCBlock_ffiVoid_ffiVoid_idNSDraggingInfo$1.fromFunction(
            (ffi.Pointer<ffi.Void> _, NSDraggingInfo arg1) => func(arg1)),
    (void Function(NSDraggingInfo) func) =>
        ObjCBlock_ffiVoid_ffiVoid_idNSDraggingInfo$1.listener(
            (ffi.Pointer<ffi.Void> _, NSDraggingInfo arg1) => func(arg1)),
    (void Function(NSDraggingInfo) func) =>
        ObjCBlock_ffiVoid_ffiVoid_idNSDraggingInfo$1.blocking(
            (ffi.Pointer<ffi.Void> _, NSDraggingInfo arg1) => func(arg1)),
  );

  /// wantsPeriodicDraggingUpdates
  static final wantsPeriodicDraggingUpdates =
      objc.ObjCProtocolMethod<bool Function()>(
    _protocol_NSDraggingDestination,
    _sel_wantsPeriodicDraggingUpdates,
    ffi.Native.addressOf<
                ffi.NativeFunction<
                    ffi.Bool Function(
                        ffi.Pointer<objc.ObjCObject>, ffi.Pointer<ffi.Void>)>>(
            _AuthenticationServicesMacOS_protocolTrampoline_e3qsqz)
        .cast(),
    objc.getProtocolMethodSignature(
      _protocol_NSDraggingDestination,
      _sel_wantsPeriodicDraggingUpdates,
      isRequired: false,
      isInstanceMethod: true,
    ),
    (bool Function() func) => ObjCBlock_bool_ffiVoid.fromFunction((
      ffi.Pointer<ffi.Void> _,
    ) =>
        func()),
  );

  /// updateDraggingItemsForDrag:
  static final updateDraggingItemsForDrag_ =
      objc.ObjCProtocolListenableMethod<void Function(NSDraggingInfo?)>(
    _protocol_NSDraggingDestination,
    _sel_updateDraggingItemsForDrag_,
    ffi.Native.addressOf<
                ffi.NativeFunction<
                    ffi.Void Function(ffi.Pointer<objc.ObjCObject>,
                        ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>>(
            _AuthenticationServicesMacOS_protocolTrampoline_18v1jvf)
        .cast(),
    objc.getProtocolMethodSignature(
      _protocol_NSDraggingDestination,
      _sel_updateDraggingItemsForDrag_,
      isRequired: false,
      isInstanceMethod: true,
    ),
    (void Function(NSDraggingInfo?) func) =>
        ObjCBlock_ffiVoid_ffiVoid_idNSDraggingInfo.fromFunction(
            (ffi.Pointer<ffi.Void> _, NSDraggingInfo? arg1) => func(arg1)),
    (void Function(NSDraggingInfo?) func) =>
        ObjCBlock_ffiVoid_ffiVoid_idNSDraggingInfo.listener(
            (ffi.Pointer<ffi.Void> _, NSDraggingInfo? arg1) => func(arg1)),
    (void Function(NSDraggingInfo?) func) =>
        ObjCBlock_ffiVoid_ffiVoid_idNSDraggingInfo.blocking(
            (ffi.Pointer<ffi.Void> _, NSDraggingInfo? arg1) => func(arg1)),
  );
}

/// ! @enum ASWebAuthenticationSessionErrorCode
/// @abstract Error code of the NSError object passed in by ASWebAuthenticationSessionCompletionHandler.
/// @constant ASWebAuthenticationSessionErrorCodeCanceledLogin The user has canceled login by cancelling the
/// alert asking for permission to log in to this app, or by dismissing the view controller for loading the
/// authentication webpage.
/// @constant ASWebAuthenticationSessionErrorCodePresentationContextNotProvided A valid presentationContextProvider
/// was not found when -start was called. Ensure this property was not nil when -start was called.
/// @constant ASWebAuthenticationSessionErrorCodePresentationContextInvalid The presentation context returned
/// was not elligible to show the authentication UI. For iOS, validate that the UIWindow is in a foreground scene.
enum ASWebAuthenticationSessionErrorCode {
  ASWebAuthenticationSessionErrorCodeCanceledLogin(1),
  ASWebAuthenticationSessionErrorCodePresentationContextNotProvided(2),
  ASWebAuthenticationSessionErrorCodePresentationContextInvalid(3);

  final int value;
  const ASWebAuthenticationSessionErrorCode(this.value);

  static ASWebAuthenticationSessionErrorCode fromValue(int value) =>
      switch (value) {
        1 => ASWebAuthenticationSessionErrorCodeCanceledLogin,
        2 => ASWebAuthenticationSessionErrorCodePresentationContextNotProvided,
        3 => ASWebAuthenticationSessionErrorCodePresentationContextInvalid,
        _ => throw ArgumentError(
            'Unknown value for ASWebAuthenticationSessionErrorCode: $value'),
      };
}

void _ObjCBlock_ffiVoid_NSURL_NSError_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<objc.ObjCObject> arg0,
        ffi.Pointer<objc.ObjCObject> arg1) =>
    block.ref.target
        .cast<
            ffi.NativeFunction<
                ffi.Void Function(ffi.Pointer<objc.ObjCObject> arg0,
                    ffi.Pointer<objc.ObjCObject> arg1)>>()
        .asFunction<
            void Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>()(arg0, arg1);
ffi.Pointer<ffi.Void> _ObjCBlock_ffiVoid_NSURL_NSError_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_ffiVoid_NSURL_NSError_fnPtrTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_NSURL_NSError_closureTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<objc.ObjCObject> arg0,
        ffi.Pointer<objc.ObjCObject> arg1) =>
    (objc.getBlockClosure(block) as void Function(ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>))(arg0, arg1);
ffi.Pointer<ffi.Void> _ObjCBlock_ffiVoid_NSURL_NSError_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_ffiVoid_NSURL_NSError_closureTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_NSURL_NSError_listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObject> arg0,
    ffi.Pointer<objc.ObjCObject> arg1) {
  (objc.getBlockClosure(block) as void Function(
      ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCObject>))(arg0, arg1);
  objc.objectRelease(block.cast());
}

ffi.NativeCallable<
        ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_NSURL_NSError_listenerCallable = ffi.NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>.listener(
        _ObjCBlock_ffiVoid_NSURL_NSError_listenerTrampoline)
      ..keepIsolateAlive = false;
void _ObjCBlock_ffiVoid_NSURL_NSError_blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<objc.ObjCObject> arg0,
    ffi.Pointer<objc.ObjCObject> arg1) {
  try {
    (objc.getBlockClosure(block) as void Function(ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>))(arg0, arg1);
  } catch (e) {
  } finally {
    objc.signalWaiter(waiter);
    objc.objectRelease(block.cast());
  }
}

ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_NSURL_NSError_blockingCallable = ffi.NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>.isolateLocal(
        _ObjCBlock_ffiVoid_NSURL_NSError_blockingTrampoline)
      ..keepIsolateAlive = false;
ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_NSURL_NSError_blockingListenerCallable = ffi
        .NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>.listener(
        _ObjCBlock_ffiVoid_NSURL_NSError_blockingTrampoline)
      ..keepIsolateAlive = false;

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(objc.NSURL?, objc.NSError?)>`.
abstract final class ObjCBlock_ffiVoid_NSURL_NSError {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(objc.NSURL?, objc.NSError?)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<ffi.Void Function(objc.NSURL?, objc.NSError?)>(pointer,
              retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(objc.NSURL?, objc.NSError?)> fromFunctionPointer(
          ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Void Function(ffi.Pointer<objc.ObjCObject> arg0,
                          ffi.Pointer<objc.ObjCObject> arg1)>>
              ptr) =>
      objc.ObjCBlock<ffi.Void Function(objc.NSURL?, objc.NSError?)>(
          objc.newPointerBlock(_ObjCBlock_ffiVoid_NSURL_NSError_fnPtrCallable, ptr.cast()),
          retain: false,
          release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(objc.NSURL?, objc.NSError?)> fromFunction(
          void Function(objc.NSURL?, objc.NSError?) fn,
          {bool keepIsolateAlive = true}) =>
      objc.ObjCBlock<ffi.Void Function(objc.NSURL?, objc.NSError?)>(
          objc.newClosureBlock(
              _ObjCBlock_ffiVoid_NSURL_NSError_closureCallable,
              (ffi.Pointer<objc.ObjCObject> arg0, ffi.Pointer<objc.ObjCObject> arg1) => fn(
                  arg0.address == 0
                      ? null
                      : objc.NSURL.castFromPointer(arg0, retain: true, release: true),
                  arg1.address == 0 ? null : objc.NSError.castFromPointer(arg1, retain: true, release: true)),
              keepIsolateAlive),
          retain: false,
          release: true);

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(objc.NSURL?, objc.NSError?)> listener(
      void Function(objc.NSURL?, objc.NSError?) fn,
      {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_NSURL_NSError_listenerCallable.nativeFunction.cast(),
        (ffi.Pointer<objc.ObjCObject> arg0,
                ffi.Pointer<objc.ObjCObject> arg1) =>
            fn(
                arg0.address == 0
                    ? null
                    : objc.NSURL
                        .castFromPointer(arg0, retain: false, release: true),
                arg1.address == 0
                    ? null
                    : objc.NSError.castFromPointer(arg1,
                        retain: false, release: true)),
        keepIsolateAlive);
    final wrapper = _AuthenticationServicesMacOS_wrapListenerBlock_pfv6jd(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<ffi.Void Function(objc.NSURL?, objc.NSError?)>(
        wrapper,
        retain: false,
        release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(objc.NSURL?, objc.NSError?)> blocking(
      void Function(objc.NSURL?, objc.NSError?) fn,
      {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_NSURL_NSError_blockingCallable.nativeFunction.cast(),
        (ffi.Pointer<objc.ObjCObject> arg0,
                ffi.Pointer<objc.ObjCObject> arg1) =>
            fn(
                arg0.address == 0
                    ? null
                    : objc.NSURL
                        .castFromPointer(arg0, retain: false, release: true),
                arg1.address == 0
                    ? null
                    : objc.NSError.castFromPointer(arg1,
                        retain: false, release: true)),
        keepIsolateAlive);
    final rawListener = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_NSURL_NSError_blockingListenerCallable.nativeFunction
            .cast(),
        (ffi.Pointer<objc.ObjCObject> arg0,
                ffi.Pointer<objc.ObjCObject> arg1) =>
            fn(
                arg0.address == 0
                    ? null
                    : objc.NSURL
                        .castFromPointer(arg0, retain: false, release: true),
                arg1.address == 0
                    ? null
                    : objc.NSError.castFromPointer(arg1,
                        retain: false, release: true)),
        keepIsolateAlive);
    final wrapper = _AuthenticationServicesMacOS_wrapBlockingBlock_pfv6jd(
        raw, rawListener, objc.objCContext);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<ffi.Void Function(objc.NSURL?, objc.NSError?)>(
        wrapper,
        retain: false,
        release: true);
  }
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(objc.NSURL?, objc.NSError?)>`.
extension ObjCBlock_ffiVoid_NSURL_NSError_CallExtension
    on objc.ObjCBlock<ffi.Void Function(objc.NSURL?, objc.NSError?)> {
  void call(objc.NSURL? arg0, objc.NSError? arg1) => ref.pointer.ref.invoke
          .cast<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<objc.ObjCBlockImpl> block,
                      ffi.Pointer<objc.ObjCObject> arg0,
                      ffi.Pointer<objc.ObjCObject> arg1)>>()
          .asFunction<
              void Function(
                  ffi.Pointer<objc.ObjCBlockImpl>,
                  ffi.Pointer<objc.ObjCObject>,
                  ffi.Pointer<objc.ObjCObject>)>()(ref.pointer,
      arg0?.ref.pointer ?? ffi.nullptr, arg1?.ref.pointer ?? ffi.nullptr);
}

late final _class_ASWebAuthenticationSession =
    objc.getClass("ASWebAuthenticationSession");
late final _sel_initWithURL_callbackURLScheme_completionHandler_ =
    objc.registerName("initWithURL:callbackURLScheme:completionHandler:");
final _objc_msgSend_2wiv66 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCBlockImpl>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCBlockImpl>)>();
late final _class_ASWebAuthenticationSessionCallback =
    objc.getClass("ASWebAuthenticationSessionCallback");
late final _sel_callbackWithCustomScheme_ =
    objc.registerName("callbackWithCustomScheme:");
final _objc_msgSend_1sotr3r = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<objc.ObjCObject>)>();
late final _sel_callbackWithHTTPSHost_path_ =
    objc.registerName("callbackWithHTTPSHost:path:");
late final _sel_matchesURL_ = objc.registerName("matchesURL:");
late final _sel_init = objc.registerName("init");
late final _sel_new = objc.registerName("new");
late final _sel_allocWithZone_ = objc.registerName("allocWithZone:");
final _objc_msgSend_1cwp428 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<objc.NSZone>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<objc.NSZone>)>();
late final _sel_alloc = objc.registerName("alloc");
late final _sel_self = objc.registerName("self");
ffi.Pointer<objc.ObjCObject> _ObjCBlock_objcObjCObject_ffiVoid_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0) =>
    block.ref.target
        .cast<
            ffi.NativeFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<ffi.Void> arg0)>>()
        .asFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<ffi.Void>)>()(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_objcObjCObject_ffiVoid_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>(
            _ObjCBlock_objcObjCObject_ffiVoid_fnPtrTrampoline)
        .cast();
ffi.Pointer<objc.ObjCObject>
    _ObjCBlock_objcObjCObject_ffiVoid_closureTrampoline(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0) =>
        (objc.getBlockClosure(block) as ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<ffi.Void>))(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_objcObjCObject_ffiVoid_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>(
            _ObjCBlock_objcObjCObject_ffiVoid_closureTrampoline)
        .cast();

/// Construction methods for `objc.ObjCBlock<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>)>`.
abstract final class ObjCBlock_objcObjCObject_ffiVoid {
  /// Returns a block that wraps the given raw block pointer.
  static objc
      .ObjCBlock<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<
                  ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>)>(
              pointer,
              retain: retain,
              release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>)>
      fromFunctionPointer(
              ffi.Pointer<
                      ffi.NativeFunction<
                          ffi.Pointer<objc.ObjCObject> Function(
                              ffi.Pointer<ffi.Void> arg0)>>
                  ptr) =>
          objc.ObjCBlock<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>)>(
              objc.newPointerBlock(_ObjCBlock_objcObjCObject_ffiVoid_fnPtrCallable, ptr.cast()),
              retain: false,
              release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc
      .ObjCBlock<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>)>
      fromFunction(objc.ObjCObjectBase Function(ffi.Pointer<ffi.Void>) fn,
              {bool keepIsolateAlive = true}) =>
          objc.ObjCBlock<
                  ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>)>(
              objc.newClosureBlock(
                  _ObjCBlock_objcObjCObject_ffiVoid_closureCallable,
                  (ffi.Pointer<ffi.Void> arg0) =>
                      fn(arg0).ref.retainAndAutorelease(),
                  keepIsolateAlive),
              retain: false,
              release: true);
}

/// Call operator for `objc.ObjCBlock<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>)>`.
extension ObjCBlock_objcObjCObject_ffiVoid_CallExtension on objc
    .ObjCBlock<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>)> {
  objc.ObjCObjectBase call(ffi.Pointer<ffi.Void> arg0) => objc.ObjCObjectBase(
      ref.pointer.ref.invoke
          .cast<
              ffi.NativeFunction<
                  ffi.Pointer<objc.ObjCObject> Function(
                      ffi.Pointer<objc.ObjCBlockImpl> block,
                      ffi.Pointer<ffi.Void> arg0)>>()
          .asFunction<
              ffi.Pointer<objc.ObjCObject> Function(
                  ffi.Pointer<objc.ObjCBlockImpl>,
                  ffi.Pointer<ffi.Void>)>()(ref.pointer, arg0),
      retain: true,
      release: true);
}

late final _sel_retain = objc.registerName("retain");
late final _sel_autorelease = objc.registerName("autorelease");

/// ASWebAuthenticationSessionCallback
class ASWebAuthenticationSessionCallback extends objc.NSObject {
  ASWebAuthenticationSessionCallback._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release);

  /// Constructs a [ASWebAuthenticationSessionCallback] that points to the same underlying object as [other].
  ASWebAuthenticationSessionCallback.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [ASWebAuthenticationSessionCallback] that wraps the given raw object pointer.
  ASWebAuthenticationSessionCallback.castFromPointer(
      ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false,
      bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [ASWebAuthenticationSessionCallback].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(obj.ref.pointer, _sel_isKindOfClass_,
        _class_ASWebAuthenticationSessionCallback);
  }

  /// Creates a callback object that matches against URLs with the given custom scheme.
  /// @param customScheme The custom scheme that the app expects in the callback URL.
  static ASWebAuthenticationSessionCallback callbackWithCustomScheme_(
      objc.NSString customScheme) {
    objc.checkOsVersionInternal(
        'ASWebAuthenticationSessionCallback.callbackWithCustomScheme:',
        iOS: (false, (17, 4, 0)),
        macOS: (false, (14, 4, 0)));
    final _ret = _objc_msgSend_1sotr3r(
        _class_ASWebAuthenticationSessionCallback,
        _sel_callbackWithCustomScheme_,
        customScheme.ref.pointer);
    return ASWebAuthenticationSessionCallback.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// Creates a callback object that matches against HTTPS URLs with the given host and path.
  /// @param host The host that the app expects in the callback URL. The host must be associated with the
  /// app using associated web credentials domains.
  /// @param path The path that the app expects in the callback URL.
  static ASWebAuthenticationSessionCallback callbackWithHTTPSHost_path_(
      objc.NSString host, objc.NSString path) {
    objc.checkOsVersionInternal(
        'ASWebAuthenticationSessionCallback.callbackWithHTTPSHost:path:',
        iOS: (false, (17, 4, 0)),
        macOS: (false, (14, 4, 0)));
    final _ret = _objc_msgSend_15qeuct(
        _class_ASWebAuthenticationSessionCallback,
        _sel_callbackWithHTTPSHost_path_,
        host.ref.pointer,
        path.ref.pointer);
    return ASWebAuthenticationSessionCallback.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// Check whether a given main-frame navigation URL matches the callback expected by the client app. Handles all URL-based callback strategies, including custom schemes and HTTPS navigations.
  /// This is mainly meant for web browsers adopting the ASWebAuthenticationWebBrowser API, but may also be useful for other apps for debugging purposes.
  /// @param url The URL to check.
  bool matchesURL_(objc.NSURL url) {
    objc.checkOsVersionInternal(
        'ASWebAuthenticationSessionCallback.matchesURL:',
        iOS: (false, (17, 4, 0)),
        macOS: (false, (14, 4, 0)));
    return _objc_msgSend_19nvye5(
        this.ref.pointer, _sel_matchesURL_, url.ref.pointer);
  }

  /// init
  ASWebAuthenticationSessionCallback init() {
    objc.checkOsVersionInternal('ASWebAuthenticationSessionCallback.init',
        iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final _ret =
        _objc_msgSend_151sglz(this.ref.retainAndReturnPointer(), _sel_init);
    return ASWebAuthenticationSessionCallback.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// new
  static ASWebAuthenticationSessionCallback new$() {
    final _ret = _objc_msgSend_151sglz(
        _class_ASWebAuthenticationSessionCallback, _sel_new);
    return ASWebAuthenticationSessionCallback.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// allocWithZone:
  static ASWebAuthenticationSessionCallback allocWithZone_(
      ffi.Pointer<objc.NSZone> zone) {
    final _ret = _objc_msgSend_1cwp428(
        _class_ASWebAuthenticationSessionCallback, _sel_allocWithZone_, zone);
    return ASWebAuthenticationSessionCallback.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// alloc
  static ASWebAuthenticationSessionCallback alloc() {
    final _ret = _objc_msgSend_151sglz(
        _class_ASWebAuthenticationSessionCallback, _sel_alloc);
    return ASWebAuthenticationSessionCallback.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// self
  ASWebAuthenticationSessionCallback self$1() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_self);
    return ASWebAuthenticationSessionCallback.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// retain
  ASWebAuthenticationSessionCallback retain() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_retain);
    return ASWebAuthenticationSessionCallback.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// autorelease
  ASWebAuthenticationSessionCallback autorelease() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_autorelease);
    return ASWebAuthenticationSessionCallback.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// Returns a new instance of ASWebAuthenticationSessionCallback constructed with the default `new` method.
  factory ASWebAuthenticationSessionCallback() => new$();
}

late final _sel_initWithURL_callback_completionHandler_ =
    objc.registerName("initWithURL:callback:completionHandler:");
late final _protocol_ASWebAuthenticationPresentationContextProviding =
    objc.getProtocol("ASWebAuthenticationPresentationContextProviding");
late final _sel_presentationAnchorForWebAuthenticationSession_ =
    objc.registerName("presentationAnchorForWebAuthenticationSession:");
ffi.Pointer<objc.ObjCObject>
    _ObjCBlock_ASPresentationAnchor_ffiVoid_ASWebAuthenticationSession_fnPtrTrampoline(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObject> arg1) =>
        block.ref.target
            .cast<
                ffi.NativeFunction<
                    ffi.Pointer<objc.ObjCObject> Function(
                        ffi.Pointer<ffi.Void> arg0,
                        ffi.Pointer<objc.ObjCObject> arg1)>>()
            .asFunction<
                ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>,
                    ffi.Pointer<objc.ObjCObject>)>()(arg0, arg1);
ffi.Pointer<ffi.Void>
    _ObjCBlock_ASPresentationAnchor_ffiVoid_ASWebAuthenticationSession_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>,
                    ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_ASPresentationAnchor_ffiVoid_ASWebAuthenticationSession_fnPtrTrampoline)
        .cast();
ffi.Pointer<objc.ObjCObject>
    _ObjCBlock_ASPresentationAnchor_ffiVoid_ASWebAuthenticationSession_closureTrampoline(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObject> arg1) =>
        (objc.getBlockClosure(block) as ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>))(arg0, arg1);
ffi.Pointer<ffi.Void>
    _ObjCBlock_ASPresentationAnchor_ffiVoid_ASWebAuthenticationSession_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>,
                    ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_ASPresentationAnchor_ffiVoid_ASWebAuthenticationSession_closureTrampoline)
        .cast();

/// Construction methods for `objc.ObjCBlock<NSWindow Function(ffi.Pointer<ffi.Void>, ASWebAuthenticationSession)>`.
abstract final class ObjCBlock_ASPresentationAnchor_ffiVoid_ASWebAuthenticationSession {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
          NSWindow Function(ffi.Pointer<ffi.Void>, ASWebAuthenticationSession)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<
                  NSWindow Function(
                      ffi.Pointer<ffi.Void>, ASWebAuthenticationSession)>(
              pointer,
              retain: retain,
              release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<NSWindow Function(ffi.Pointer<ffi.Void>, ASWebAuthenticationSession)>
      fromFunctionPointer(
              ffi.Pointer<
                      ffi.NativeFunction<
                          ffi.Pointer<objc.ObjCObject> Function(
                              ffi.Pointer<ffi.Void> arg0,
                              ffi.Pointer<objc.ObjCObject> arg1)>>
                  ptr) =>
          objc.ObjCBlock<NSWindow Function(ffi.Pointer<ffi.Void>, ASWebAuthenticationSession)>(
              objc.newPointerBlock(_ObjCBlock_ASPresentationAnchor_ffiVoid_ASWebAuthenticationSession_fnPtrCallable, ptr.cast()),
              retain: false,
              release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<NSWindow Function(ffi.Pointer<ffi.Void>, ASWebAuthenticationSession)> fromFunction(
          NSWindow Function(ffi.Pointer<ffi.Void>, ASWebAuthenticationSession)
              fn,
          {bool keepIsolateAlive = true}) =>
      objc.ObjCBlock<NSWindow Function(ffi.Pointer<ffi.Void>, ASWebAuthenticationSession)>(
          objc.newClosureBlock(
              _ObjCBlock_ASPresentationAnchor_ffiVoid_ASWebAuthenticationSession_closureCallable,
              (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1) =>
                  fn(arg0, ASWebAuthenticationSession.castFromPointer(arg1, retain: true, release: true))
                      .ref
                      .retainAndAutorelease(),
              keepIsolateAlive),
          retain: false,
          release: true);
}

/// Call operator for `objc.ObjCBlock<NSWindow Function(ffi.Pointer<ffi.Void>, ASWebAuthenticationSession)>`.
extension ObjCBlock_ASPresentationAnchor_ffiVoid_ASWebAuthenticationSession_CallExtension
    on objc.ObjCBlock<
        NSWindow Function(ffi.Pointer<ffi.Void>, ASWebAuthenticationSession)> {
  NSWindow call(ffi.Pointer<ffi.Void> arg0, ASWebAuthenticationSession arg1) =>
      NSWindow.castFromPointer(
          ref.pointer.ref.invoke
                  .cast<
                      ffi.NativeFunction<
                          ffi.Pointer<objc.ObjCObject> Function(
                              ffi.Pointer<objc.ObjCBlockImpl> block,
                              ffi.Pointer<ffi.Void> arg0,
                              ffi.Pointer<objc.ObjCObject> arg1)>>()
                  .asFunction<
                      ffi.Pointer<objc.ObjCObject> Function(
                          ffi.Pointer<objc.ObjCBlockImpl>,
                          ffi.Pointer<ffi.Void>,
                          ffi.Pointer<objc.ObjCObject>)>()(
              ref.pointer, arg0, arg1.ref.pointer),
          retain: true,
          release: true);
}

/// ! @abstract Provides context to target where in an application's UI the authorization view should be shown.
interface class ASWebAuthenticationPresentationContextProviding
    extends objc.ObjCProtocolBase implements objc.NSObjectProtocol {
  ASWebAuthenticationPresentationContextProviding._(
      ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false,
      bool release = false})
      : super(pointer, retain: retain, release: release);

  /// Constructs a [ASWebAuthenticationPresentationContextProviding] that points to the same underlying object as [other].
  ASWebAuthenticationPresentationContextProviding.castFrom(
      objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [ASWebAuthenticationPresentationContextProviding] that wraps the given raw object pointer.
  ASWebAuthenticationPresentationContextProviding.castFromPointer(
      ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false,
      bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [ASWebAuthenticationPresentationContextProviding].
  static bool conformsTo(objc.ObjCObjectBase obj) {
    return _objc_msgSend_e3qsqz(obj.ref.pointer, _sel_conformsToProtocol_,
        _protocol_ASWebAuthenticationPresentationContextProviding);
  }

  /// Returns the [objc.Protocol] object for this protocol.
  static objc.Protocol get $protocol => objc.Protocol.castFromPointer(
      _protocol_ASWebAuthenticationPresentationContextProviding.cast());

  /// Builds an object that implements the ASWebAuthenticationPresentationContextProviding protocol. To implement
  /// multiple protocols, use [addToBuilder] or [objc.ObjCProtocolBuilder] directly.
  ///
  /// If `$keepIsolateAlive` is true, this protocol will keep this isolate
  /// alive until it is garbage collected by both Dart and ObjC.
  static ASWebAuthenticationPresentationContextProviding implement(
      {required NSWindow Function(ASWebAuthenticationSession)
          presentationAnchorForWebAuthenticationSession_,
      bool $keepIsolateAlive = true}) {
    final builder = objc.ObjCProtocolBuilder(
        debugName: 'ASWebAuthenticationPresentationContextProviding');
    ASWebAuthenticationPresentationContextProviding
        .presentationAnchorForWebAuthenticationSession_
        .implement(builder, presentationAnchorForWebAuthenticationSession_);
    builder.addProtocol($protocol);
    return ASWebAuthenticationPresentationContextProviding.castFrom(
        builder.build(keepIsolateAlive: $keepIsolateAlive));
  }

  /// Adds the implementation of the ASWebAuthenticationPresentationContextProviding protocol to an existing
  /// [objc.ObjCProtocolBuilder].
  ///
  /// Note: You cannot call this method after you have called `builder.build`.
  static void addToBuilder(objc.ObjCProtocolBuilder builder,
      {required NSWindow Function(ASWebAuthenticationSession)
          presentationAnchorForWebAuthenticationSession_,
      bool $keepIsolateAlive = true}) {
    ASWebAuthenticationPresentationContextProviding
        .presentationAnchorForWebAuthenticationSession_
        .implement(builder, presentationAnchorForWebAuthenticationSession_);
    builder.addProtocol($protocol);
  }

  /// ! @abstract Return the ASPresentationAnchor in the closest proximity to where a user interacted with your app to trigger
  /// authentication. If starting an ASWebAuthenticationSession on first launch, use the application's main window.
  /// @param session The session requesting a presentation anchor.
  /// @result The ASPresentationAnchor most closely associated with the UI used to trigger authentication.
  static final presentationAnchorForWebAuthenticationSession_ =
      objc.ObjCProtocolMethod<NSWindow Function(ASWebAuthenticationSession)>(
    _protocol_ASWebAuthenticationPresentationContextProviding,
    _sel_presentationAnchorForWebAuthenticationSession_,
    ffi.Native.addressOf<
                ffi.NativeFunction<
                    instancetype Function(ffi.Pointer<objc.ObjCObject>,
                        ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>>(
            _AuthenticationServicesMacOS_protocolTrampoline_xr62hr)
        .cast(),
    objc.getProtocolMethodSignature(
      _protocol_ASWebAuthenticationPresentationContextProviding,
      _sel_presentationAnchorForWebAuthenticationSession_,
      isRequired: true,
      isInstanceMethod: true,
    ),
    (NSWindow Function(ASWebAuthenticationSession) func) =>
        ObjCBlock_ASPresentationAnchor_ffiVoid_ASWebAuthenticationSession
            .fromFunction(
                (ffi.Pointer<ffi.Void> _, ASWebAuthenticationSession arg1) =>
                    func(arg1)),
  );
}

late final _sel_presentationContextProvider =
    objc.registerName("presentationContextProvider");
late final _sel_setPresentationContextProvider_ =
    objc.registerName("setPresentationContextProvider:");
late final _sel_prefersEphemeralWebBrowserSession =
    objc.registerName("prefersEphemeralWebBrowserSession");
late final _sel_setPrefersEphemeralWebBrowserSession_ =
    objc.registerName("setPrefersEphemeralWebBrowserSession:");
late final _sel_additionalHeaderFields =
    objc.registerName("additionalHeaderFields");
late final _sel_setAdditionalHeaderFields_ =
    objc.registerName("setAdditionalHeaderFields:");
late final _sel_canStart = objc.registerName("canStart");
late final _sel_start = objc.registerName("start");
late final _sel_cancel = objc.registerName("cancel");

/// !
/// @class ASWebAuthenticationSession
/// An ASWebAuthenticationSession object can be used to authenticate a user with a web service, even if the web service is run
/// by a third party. ASWebAuthenticationSession puts the user in control of whether they want to use their existing logged-in
/// session from Safari. The app provides a URL that points to the authentication webpage. The page will be loaded in a secure
/// view controller. From the webpage, the user can authenticate herself and grant access to the app.
/// On completion, the service will send a callback URL with an authentication token, and this URL will be passed to the app by
/// ASWebAuthenticationSessionCompletionHandler.
///
/// The callback URL usually has a custom URL scheme. For the app to receive the callback URL, it needs to either register the
/// custom URL scheme in its Info.plist, or set the scheme to callbackURLScheme argument in the initializer.
///
/// If the user has already logged into the web service in Safari or other apps via ASWebAuthenticationSession, it is possible to
/// share the existing login information. An alert will be presented to get the user's consent for sharing their existing login
/// information. If the user cancels the alert, the session will be canceled, and the completion handler will be called with
/// the error code ASWebAuthenticationSessionErrorCodeCanceledLogin.
///
/// If the user taps Cancel when showing the login webpage for the web service, the session will be canceled, and the completion
/// handler will be called with the error code ASWebAuthenticationSessionErrorCodeCanceledLogin.
///
/// The app can cancel the session by calling -[ASWebAuthenticationSession cancel]. This will also dismiss the view controller that
/// is showing the web service's login page.
class ASWebAuthenticationSession extends objc.NSObject {
  ASWebAuthenticationSession._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release) {
    objc.checkOsVersionInternal('ASWebAuthenticationSession',
        iOS: (false, (12, 0, 0)), macOS: (false, (10, 15, 0)));
  }

  /// Constructs a [ASWebAuthenticationSession] that points to the same underlying object as [other].
  ASWebAuthenticationSession.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [ASWebAuthenticationSession] that wraps the given raw object pointer.
  ASWebAuthenticationSession.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [ASWebAuthenticationSession].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(obj.ref.pointer, _sel_isKindOfClass_,
        _class_ASWebAuthenticationSession);
  }

  /// ! @abstract Returns an ASWebAuthenticationSession object.
  /// @param URL the initial URL pointing to the authentication webpage. Only supports URLs with http:// or https:// schemes.
  /// @param callbackURLScheme the custom URL scheme that the app expects in the callback URL.
  /// @param completionHandler the completion handler which is called when the session is completed successfully or canceled by user.
  ///
  /// iOS: introduced 12.0.0, deprecated 100000.0.0
  /// macOS: introduced 10.15.0, deprecated 100000.0.0
  ASWebAuthenticationSession initWithURL_callbackURLScheme_completionHandler_(
      objc.NSURL URL,
      objc.NSString? callbackURLScheme,
      objc.ObjCBlock<ffi.Void Function(objc.NSURL?, objc.NSError?)>
          completionHandler) {
    objc.checkOsVersionInternal(
        'ASWebAuthenticationSession.initWithURL:callbackURLScheme:completionHandler:',
        iOS: (false, (12, 0, 0)),
        macOS: (false, (10, 15, 0)));
    final _ret = _objc_msgSend_2wiv66(
        this.ref.retainAndReturnPointer(),
        _sel_initWithURL_callbackURLScheme_completionHandler_,
        URL.ref.pointer,
        callbackURLScheme?.ref.pointer ?? ffi.nullptr,
        completionHandler.ref.pointer);
    return ASWebAuthenticationSession.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// initWithURL:callback:completionHandler:
  ASWebAuthenticationSession initWithURL_callback_completionHandler_(
      objc.NSURL URL,
      ASWebAuthenticationSessionCallback callback,
      objc.ObjCBlock<ffi.Void Function(objc.NSURL?, objc.NSError?)>
          completionHandler) {
    objc.checkOsVersionInternal(
        'ASWebAuthenticationSession.initWithURL:callback:completionHandler:',
        iOS: (false, (17, 4, 0)),
        macOS: (false, (14, 4, 0)));
    final _ret = _objc_msgSend_2wiv66(
        this.ref.retainAndReturnPointer(),
        _sel_initWithURL_callback_completionHandler_,
        URL.ref.pointer,
        callback.ref.pointer,
        completionHandler.ref.pointer);
    return ASWebAuthenticationSession.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// ! @abstract Provides context to target where in an application's UI the authorization view should be shown. A provider
  /// must be set prior to calling -start, otherwise the authorization view cannot be displayed. If deploying to iOS prior to
  /// 13.0, the desired window is inferred by the application's key window.
  ASWebAuthenticationPresentationContextProviding?
      get presentationContextProvider {
    objc.checkOsVersionInternal(
        'ASWebAuthenticationSession.presentationContextProvider',
        iOS: (false, (13, 0, 0)),
        macOS: (false, (10, 15, 0)));
    final _ret = _objc_msgSend_151sglz(
        this.ref.pointer, _sel_presentationContextProvider);
    return _ret.address == 0
        ? null
        : ASWebAuthenticationPresentationContextProviding.castFromPointer(_ret,
            retain: true, release: true);
  }

  /// ! @abstract Provides context to target where in an application's UI the authorization view should be shown. A provider
  /// must be set prior to calling -start, otherwise the authorization view cannot be displayed. If deploying to iOS prior to
  /// 13.0, the desired window is inferred by the application's key window.
  set presentationContextProvider(
      ASWebAuthenticationPresentationContextProviding? value) {
    objc.checkOsVersionInternal(
        'ASWebAuthenticationSession.setPresentationContextProvider:',
        iOS: (false, (13, 0, 0)),
        macOS: (false, (10, 15, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setPresentationContextProvider_,
        value?.ref.pointer ?? ffi.nullptr);
  }

  /// ! @abstract Indicates whether this session should ask the browser for an ephemeral session.
  /// @discussion Ephemeral web browser sessions do not not share cookies or other browsing data with a user's normal browser session.
  /// This value is NO by default. Setting this property after calling -[ASWebAuthenticationSession start] has no effect.
  bool get prefersEphemeralWebBrowserSession {
    objc.checkOsVersionInternal(
        'ASWebAuthenticationSession.prefersEphemeralWebBrowserSession',
        iOS: (false, (13, 0, 0)),
        macOS: (false, (10, 15, 0)));
    return _objc_msgSend_91o635(
        this.ref.pointer, _sel_prefersEphemeralWebBrowserSession);
  }

  /// ! @abstract Indicates whether this session should ask the browser for an ephemeral session.
  /// @discussion Ephemeral web browser sessions do not not share cookies or other browsing data with a user's normal browser session.
  /// This value is NO by default. Setting this property after calling -[ASWebAuthenticationSession start] has no effect.
  set prefersEphemeralWebBrowserSession(bool value) {
    objc.checkOsVersionInternal(
        'ASWebAuthenticationSession.setPrefersEphemeralWebBrowserSession:',
        iOS: (false, (13, 0, 0)),
        macOS: (false, (10, 15, 0)));
    _objc_msgSend_1s56lr9(
        this.ref.pointer, _sel_setPrefersEphemeralWebBrowserSession_, value);
  }

  /// Any additional header fields to be set when loading the initial URL.
  /// All header field names must start with the "X-" prefix.
  objc.NSDictionary? get additionalHeaderFields {
    objc.checkOsVersionInternal(
        'ASWebAuthenticationSession.additionalHeaderFields',
        iOS: (false, (17, 4, 0)),
        macOS: (false, (14, 4, 0)));
    final _ret =
        _objc_msgSend_151sglz(this.ref.pointer, _sel_additionalHeaderFields);
    return _ret.address == 0
        ? null
        : objc.NSDictionary.castFromPointer(_ret, retain: true, release: true);
  }

  /// Any additional header fields to be set when loading the initial URL.
  /// All header field names must start with the "X-" prefix.
  set additionalHeaderFields(objc.NSDictionary? value) {
    objc.checkOsVersionInternal(
        'ASWebAuthenticationSession.setAdditionalHeaderFields:',
        iOS: (false, (17, 4, 0)),
        macOS: (false, (14, 4, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setAdditionalHeaderFields_,
        value?.ref.pointer ?? ffi.nullptr);
  }

  /// ! @abstract Returns whether the session can be successfully started. This property returns the same value as calling -start,
  /// but without the side effect of actually starting the session.
  bool get canStart {
    objc.checkOsVersionInternal('ASWebAuthenticationSession.canStart',
        iOS: (false, (13, 4, 0)), macOS: (false, (10, 15, 4)));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_canStart);
  }

  /// ! @abstract Starts the ASWebAuthenticationSession instance after it is instantiated.
  /// @discussion start can only be called once for an ASWebAuthenticationSession instance. This also means calling start on a
  /// canceled session will fail.
  /// @result Returns YES if the session starts successfully.
  bool start() {
    objc.checkOsVersionInternal('ASWebAuthenticationSession.start',
        iOS: (false, (12, 0, 0)), macOS: (false, (10, 15, 0)));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_start);
  }

  /// ! @abstract Cancel an ASWebAuthenticationSession. If the view controller is already presented to load the webpage for
  /// authentication, it will be dismissed. Calling cancel on an already canceled session will have no effect.
  void cancel() {
    _objc_msgSend_1pl9qdv(this.ref.pointer, _sel_cancel);
  }

  /// init
  ASWebAuthenticationSession init() {
    objc.checkOsVersionInternal('ASWebAuthenticationSession.init',
        iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final _ret =
        _objc_msgSend_151sglz(this.ref.retainAndReturnPointer(), _sel_init);
    return ASWebAuthenticationSession.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// new
  static ASWebAuthenticationSession new$() {
    final _ret =
        _objc_msgSend_151sglz(_class_ASWebAuthenticationSession, _sel_new);
    return ASWebAuthenticationSession.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// allocWithZone:
  static ASWebAuthenticationSession allocWithZone_(
      ffi.Pointer<objc.NSZone> zone) {
    final _ret = _objc_msgSend_1cwp428(
        _class_ASWebAuthenticationSession, _sel_allocWithZone_, zone);
    return ASWebAuthenticationSession.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// alloc
  static ASWebAuthenticationSession alloc() {
    final _ret =
        _objc_msgSend_151sglz(_class_ASWebAuthenticationSession, _sel_alloc);
    return ASWebAuthenticationSession.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// self
  ASWebAuthenticationSession self$1() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_self);
    return ASWebAuthenticationSession.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// retain
  ASWebAuthenticationSession retain() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_retain);
    return ASWebAuthenticationSession.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// autorelease
  ASWebAuthenticationSession autorelease() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_autorelease);
    return ASWebAuthenticationSession.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// Returns a new instance of ASWebAuthenticationSession constructed with the default `new` method.
  factory ASWebAuthenticationSession() => new$();
}
