// ignore_for_file: type=lint
// ignore_for_file: return_of_invalid_type

// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
import 'dart:ffi' as ffi;
import 'package:objective_c/objective_c.dart' as objc;

@ffi.Native<ffi.Pointer<objc.ObjCBlock> Function(ffi.Pointer<objc.ObjCBlock>)>(
    isLeaf: true)
external ffi.Pointer<objc.ObjCBlock>
    wrapListenerBlock_ObjCBlock_ffiVoid_NSEvent(
  ffi.Pointer<objc.ObjCBlock> block,
);

@ffi.Native<ffi.Pointer<objc.ObjCBlock> Function(ffi.Pointer<objc.ObjCBlock>)>(
    isLeaf: true)
external ffi.Pointer<objc.ObjCBlock>
    wrapListenerBlock_ObjCBlock_ffiVoid_NSError(
  ffi.Pointer<objc.ObjCBlock> block,
);

@ffi.Native<ffi.Pointer<objc.ObjCBlock> Function(ffi.Pointer<objc.ObjCBlock>)>(
    isLeaf: true)
external ffi.Pointer<objc.ObjCBlock>
    wrapListenerBlock_ObjCBlock_ffiVoid_NSEvent_bool(
  ffi.Pointer<objc.ObjCBlock> block,
);

@ffi.Native<ffi.Pointer<objc.ObjCBlock> Function(ffi.Pointer<objc.ObjCBlock>)>(
    isLeaf: true)
external ffi.Pointer<objc.ObjCBlock>
    wrapListenerBlock_ObjCBlock_ffiVoid_NSWindow_bool(
  ffi.Pointer<objc.ObjCBlock> block,
);

@ffi.Native<ffi.Pointer<objc.ObjCBlock> Function(ffi.Pointer<objc.ObjCBlock>)>(
    isLeaf: true)
external ffi.Pointer<objc.ObjCBlock>
    wrapListenerBlock_ObjCBlock_ffiVoid_ffiVoid_NSApplication_objcObjCObject(
  ffi.Pointer<objc.ObjCBlock> block,
);

@ffi.Native<ffi.Pointer<objc.ObjCBlock> Function(ffi.Pointer<objc.ObjCBlock>)>(
    isLeaf: true)
external ffi.Pointer<objc.ObjCBlock>
    wrapListenerBlock_ObjCBlock_ffiVoid_ffiVoid_NSApplication_NSData(
  ffi.Pointer<objc.ObjCBlock> block,
);

@ffi.Native<ffi.Pointer<objc.ObjCBlock> Function(ffi.Pointer<objc.ObjCBlock>)>(
    isLeaf: true)
external ffi.Pointer<objc.ObjCBlock>
    wrapListenerBlock_ObjCBlock_ffiVoid_ffiVoid_NSApplication_NSError(
  ffi.Pointer<objc.ObjCBlock> block,
);

@ffi.Native<ffi.Pointer<objc.ObjCBlock> Function(ffi.Pointer<objc.ObjCBlock>)>(
    isLeaf: true)
external ffi.Pointer<objc.ObjCBlock>
    wrapListenerBlock_ObjCBlock_ffiVoid_ffiVoid_NSApplication_NSDictionary(
  ffi.Pointer<objc.ObjCBlock> block,
);

@ffi.Native<ffi.Pointer<objc.ObjCBlock> Function(ffi.Pointer<objc.ObjCBlock>)>(
    isLeaf: true)
external ffi.Pointer<objc.ObjCBlock>
    wrapListenerBlock_ObjCBlock_ffiVoid_ffiVoid_NSApplication_NSCoder(
  ffi.Pointer<objc.ObjCBlock> block,
);

@ffi.Native<ffi.Pointer<objc.ObjCBlock> Function(ffi.Pointer<objc.ObjCBlock>)>(
    isLeaf: true)
external ffi.Pointer<objc.ObjCBlock>
    wrapListenerBlock_ObjCBlock_ffiVoid_NSTimer(
  ffi.Pointer<objc.ObjCBlock> block,
);

@ffi.Native<ffi.Pointer<objc.ObjCBlock> Function(ffi.Pointer<objc.ObjCBlock>)>(
    isLeaf: true)
external ffi.Pointer<objc.ObjCBlock>
    wrapListenerBlock_ObjCBlock_ffiVoid_NSInputStream_NSOutputStream_NSError(
  ffi.Pointer<objc.ObjCBlock> block,
);

@ffi.Native<ffi.Pointer<objc.ObjCBlock> Function(ffi.Pointer<objc.ObjCBlock>)>(
    isLeaf: true)
external ffi.Pointer<objc.ObjCBlock>
    wrapListenerBlock_ObjCBlock_ffiVoid_NSArray(
  ffi.Pointer<objc.ObjCBlock> block,
);

@ffi.Native<ffi.Pointer<objc.ObjCBlock> Function(ffi.Pointer<objc.ObjCBlock>)>(
    isLeaf: true)
external ffi.Pointer<objc.ObjCBlock>
    wrapListenerBlock_ObjCBlock_ffiVoid_ffiVoid_NSApplication_NSString_NSError(
  ffi.Pointer<objc.ObjCBlock> block,
);

@ffi.Native<ffi.Pointer<objc.ObjCBlock> Function(ffi.Pointer<objc.ObjCBlock>)>(
    isLeaf: true)
external ffi.Pointer<objc.ObjCBlock>
    wrapListenerBlock_ObjCBlock_ffiVoid_ffiVoid_NSApplication_NSUserActivity(
  ffi.Pointer<objc.ObjCBlock> block,
);

@ffi.Native<ffi.Pointer<objc.ObjCBlock> Function(ffi.Pointer<objc.ObjCBlock>)>(
    isLeaf: true)
external ffi.Pointer<objc.ObjCBlock>
    wrapListenerBlock_ObjCBlock_ffiVoid_ffiVoid_NSApplication_CKShareMetadata(
  ffi.Pointer<objc.ObjCBlock> block,
);

@ffi.Native<ffi.Pointer<objc.ObjCBlock> Function(ffi.Pointer<objc.ObjCBlock>)>(
    isLeaf: true)
external ffi.Pointer<objc.ObjCBlock>
    wrapListenerBlock_ObjCBlock_ffiVoid_ffiVoid_NSNotification(
  ffi.Pointer<objc.ObjCBlock> block,
);

@ffi.Native<ffi.Pointer<objc.ObjCBlock> Function(ffi.Pointer<objc.ObjCBlock>)>(
    isLeaf: true)
external ffi.Pointer<objc.ObjCBlock>
    wrapListenerBlock_ObjCBlock_ffiVoid_NSURL_NSError(
  ffi.Pointer<objc.ObjCBlock> block,
);

/// NSProcessInfo
class NSProcessInfo extends objc.NSObject {
  NSProcessInfo._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release);

  /// Constructs a [NSProcessInfo] that points to the same underlying object as [other].
  NSProcessInfo.castFrom(objc.ObjCObjectBase other)
      : this._(other.pointer, retain: true, release: true);

  /// Constructs a [NSProcessInfo] that wraps the given raw object pointer.
  NSProcessInfo.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [NSProcessInfo].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_0(
        obj.pointer, _sel_isKindOfClass_, _class_NSProcessInfo);
  }

  /// processInfo
  static NSProcessInfo getProcessInfo() {
    final _ret = _objc_msgSend_1(_class_NSProcessInfo, _sel_processInfo);
    return NSProcessInfo.castFromPointer(_ret, retain: true, release: true);
  }

  /// environment
  objc.ObjCObjectBase get environment {
    final _ret = _objc_msgSend_2(this.pointer, _sel_environment);
    return objc.ObjCObjectBase(_ret, retain: true, release: true);
  }

  /// arguments
  objc.ObjCObjectBase get arguments {
    final _ret = _objc_msgSend_2(this.pointer, _sel_arguments);
    return objc.ObjCObjectBase(_ret, retain: true, release: true);
  }

  /// hostName
  objc.NSString get hostName {
    final _ret = _objc_msgSend_3(this.pointer, _sel_hostName);
    return objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// processName
  objc.NSString get processName {
    final _ret = _objc_msgSend_3(this.pointer, _sel_processName);
    return objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// setProcessName:
  set processName(objc.NSString value) {
    return _objc_msgSend_4(this.pointer, _sel_setProcessName_, value.pointer);
  }

  /// processIdentifier
  int get processIdentifier {
    return _objc_msgSend_5(this.pointer, _sel_processIdentifier);
  }

  /// globallyUniqueString
  objc.NSString get globallyUniqueString {
    final _ret = _objc_msgSend_3(this.pointer, _sel_globallyUniqueString);
    return objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// operatingSystem
  int operatingSystem() {
    return _objc_msgSend_6(this.pointer, _sel_operatingSystem);
  }

  /// operatingSystemName
  objc.NSString operatingSystemName() {
    final _ret = _objc_msgSend_3(this.pointer, _sel_operatingSystemName);
    return objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// Human readable, localized; appropriate for displaying to user or using in bug emails and such; NOT appropriate for parsing
  objc.NSString get operatingSystemVersionString {
    final _ret =
        _objc_msgSend_3(this.pointer, _sel_operatingSystemVersionString);
    return objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// operatingSystemVersion
  void getOperatingSystemVersion(ffi.Pointer<NSOperatingSystemVersion> stret) {
    objc.useMsgSendVariants
        ? _objc_msgSend_7Stret(stret, this.pointer, _sel_operatingSystemVersion)
        : stret.ref =
            _objc_msgSend_7(this.pointer, _sel_operatingSystemVersion);
  }

  /// processorCount
  int get processorCount {
    return _objc_msgSend_6(this.pointer, _sel_processorCount);
  }

  /// activeProcessorCount
  int get activeProcessorCount {
    return _objc_msgSend_6(this.pointer, _sel_activeProcessorCount);
  }

  /// physicalMemory
  int get physicalMemory {
    return _objc_msgSend_8(this.pointer, _sel_physicalMemory);
  }

  /// isOperatingSystemAtLeastVersion:
  bool isOperatingSystemAtLeastVersion_(NSOperatingSystemVersion version) {
    return _objc_msgSend_9(
        this.pointer, _sel_isOperatingSystemAtLeastVersion_, version);
  }

  /// systemUptime
  double get systemUptime {
    return objc.useMsgSendVariants
        ? _objc_msgSend_10Fpret(this.pointer, _sel_systemUptime)
        : _objc_msgSend_10(this.pointer, _sel_systemUptime);
  }

  /// Disable or reenable the ability to be quickly killed. The default implementations of these methods increment or decrement, respectively, a counter whose value is 1 when the process is first created. When the counter's value is 0 the application is considered to be safely killable and may be killed by the operating system without any notification or event being sent to the process first. If an application's Info.plist has an NSSupportsSuddenTermination entry whose value is true then NSApplication invokes -enableSuddenTermination automatically during application launch, which typically renders the process killable right away. You can also manually invoke -enableSuddenTermination right away in, for example, agents or daemons that don't depend on AppKit. After that, you can invoke these methods whenever the process has work it must do before it terminates. For example:
  /// - NSUserDefaults uses these to prevent process killing between the time at which a default has been set and the time at which the preferences file including that default has been written to disk.
  /// - NSDocument uses these to prevent process killing between the time at which the user has made a change to a document and the time at which the user's change has been written to disk.
  /// - You can use these whenever your application defers work that must be done before the application terminates. If for example your application ever defers writing something to disk, and it has an NSSupportsSuddenTermination entry in its Info.plist so as not to contribute to user-visible delays at logout or shutdown time, it must invoke -disableSuddenTermination when the writing is first deferred and -enableSuddenTermination after the writing is actually done.
  void disableSuddenTermination() {
    _objc_msgSend_11(this.pointer, _sel_disableSuddenTermination);
  }

  /// enableSuddenTermination
  void enableSuddenTermination() {
    _objc_msgSend_11(this.pointer, _sel_enableSuddenTermination);
  }

  /// Increment or decrement the counter tracking the number of automatic quit opt-out requests. When this counter is greater than zero, the app will be considered 'active' and ineligible for automatic termination.
  /// An example of using this would be disabling autoquitting when the user of an instant messaging application signs on, due to it requiring a background connection to be maintained even if the app is otherwise inactive.
  /// Each pair of calls should have a matching "reason" argument, which can be used to easily track why an application is or is not automatically terminable.
  /// A given reason can be used more than once at the same time (for example: two files are transferring over the network, each one disables automatic termination with the reason @"file transfer in progress")
  void disableAutomaticTermination_(objc.NSString reason) {
    _objc_msgSend_12(
        this.pointer, _sel_disableAutomaticTermination_, reason.pointer);
  }

  /// enableAutomaticTermination:
  void enableAutomaticTermination_(objc.NSString reason) {
    _objc_msgSend_12(
        this.pointer, _sel_enableAutomaticTermination_, reason.pointer);
  }

  /// Marks the calling app as supporting automatic termination. Without calling this or setting the equivalent Info.plist key (NSSupportsAutomaticTermination), the above methods (disableAutomaticTermination:/enableAutomaticTermination:) have no effect,
  /// although the counter tracking automatic termination opt-outs is still kept up to date to ensure correctness if this is called later. Currently, passing NO has no effect.
  /// This should be called during -applicationDidFinishLaunching or earlier.
  bool get automaticTerminationSupportEnabled {
    return _objc_msgSend_13(
        this.pointer, _sel_automaticTerminationSupportEnabled);
  }

  /// Marks the calling app as supporting automatic termination. Without calling this or setting the equivalent Info.plist key (NSSupportsAutomaticTermination), the above methods (disableAutomaticTermination:/enableAutomaticTermination:) have no effect,
  /// although the counter tracking automatic termination opt-outs is still kept up to date to ensure correctness if this is called later. Currently, passing NO has no effect.
  /// This should be called during -applicationDidFinishLaunching or earlier.
  set automaticTerminationSupportEnabled(bool value) {
    return _objc_msgSend_14(
        this.pointer, _sel_setAutomaticTerminationSupportEnabled_, value);
  }

  /// Pass in an activity to this API, and a non-NULL, non-empty reason string. Indicate completion of the activity by calling the corresponding endActivity: method with the result of the beginActivityWithOptions:reason: method. The reason string is used for debugging.
  objc.ObjCObjectBase beginActivityWithOptions_reason_(
      NSActivityOptions options, objc.NSString reason) {
    final _ret = _objc_msgSend_15(this.pointer,
        _sel_beginActivityWithOptions_reason_, options.value, reason.pointer);
    return objc.ObjCObjectBase(_ret, retain: true, release: true);
  }

  /// The argument to this method is the result of beginActivityWithOptions:reason:.
  void endActivity_(objc.ObjCObjectBase activity) {
    _objc_msgSend_16(this.pointer, _sel_endActivity_, activity.pointer);
  }

  /// Synchronously perform an activity. The activity will be automatically ended after your block argument returns. The reason string is used for debugging.
  void performActivityWithOptions_reason_usingBlock_(NSActivityOptions options,
      objc.NSString reason, ObjCBlock_ffiVoid block) {
    _objc_msgSend_17(
        this.pointer,
        _sel_performActivityWithOptions_reason_usingBlock_,
        options.value,
        reason.pointer,
        block.pointer);
  }

  /// Perform an expiring background task, which obtains an expiring task assertion on iOS. The block contains any work which needs to be completed as a background-priority task. The block will be scheduled on a system-provided concurrent queue. After a system-specified time, the block will be called with the `expired` parameter set to YES. The `expired` parameter will also be YES if the system decides to prematurely terminate a previous non-expiration invocation of the block.
  void performExpiringActivityWithReason_usingBlock_(
      objc.NSString reason, ObjCBlock_ffiVoid_bool block) {
    _objc_msgSend_18(
        this.pointer,
        _sel_performExpiringActivityWithReason_usingBlock_,
        reason.pointer,
        block.pointer);
  }

  /// userName
  objc.NSString get userName {
    final _ret = _objc_msgSend_3(this.pointer, _sel_userName);
    return objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// fullUserName
  objc.NSString get fullUserName {
    final _ret = _objc_msgSend_3(this.pointer, _sel_fullUserName);
    return objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// Retrieve the current thermal state of the system. On systems where thermal state is unknown or unsupported, the value returned from the thermalState property is always NSProcessInfoThermalStateNominal.
  NSProcessInfoThermalState get thermalState {
    final _ret = _objc_msgSend_19(this.pointer, _sel_thermalState);
    return NSProcessInfoThermalState.fromValue(_ret);
  }

  /// Retrieve the current setting of the system for the low power mode setting. On systems where the low power mode is unknown or unsupported, the value returned from the lowPowerModeEnabled property is always NO
  bool get lowPowerModeEnabled {
    return _objc_msgSend_13(this.pointer, _sel_isLowPowerModeEnabled);
  }

  /// isMacCatalystApp
  bool get macCatalystApp {
    return _objc_msgSend_13(this.pointer, _sel_isMacCatalystApp);
  }

  /// isiOSAppOnMac
  bool get iOSAppOnMac {
    return _objc_msgSend_13(this.pointer, _sel_isiOSAppOnMac);
  }

  /// init
  NSProcessInfo init() {
    final _ret = _objc_msgSend_2(this.pointer, _sel_init);
    return NSProcessInfo.castFromPointer(_ret, retain: true, release: true);
  }

  /// new
  static NSProcessInfo new1() {
    final _ret = _objc_msgSend_2(_class_NSProcessInfo, _sel_new);
    return NSProcessInfo.castFromPointer(_ret, retain: false, release: true);
  }

  /// allocWithZone:
  static NSProcessInfo allocWithZone_(ffi.Pointer<_NSZone> zone) {
    final _ret =
        _objc_msgSend_20(_class_NSProcessInfo, _sel_allocWithZone_, zone);
    return NSProcessInfo.castFromPointer(_ret, retain: false, release: true);
  }

  /// alloc
  static NSProcessInfo alloc() {
    final _ret = _objc_msgSend_2(_class_NSProcessInfo, _sel_alloc);
    return NSProcessInfo.castFromPointer(_ret, retain: false, release: true);
  }
}

late final _class_NSProcessInfo = objc.getClass("NSProcessInfo");
late final _sel_processInfo = objc.registerName("processInfo");
final _objc_msgSend_1 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_environment = objc.registerName("environment");
final _objc_msgSend_2 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_arguments = objc.registerName("arguments");
late final _sel_hostName = objc.registerName("hostName");
final _objc_msgSend_3 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_processName = objc.registerName("processName");
late final _sel_setProcessName_ = objc.registerName("setProcessName:");
final _objc_msgSend_4 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<objc.ObjCObject>)>();
late final _sel_processIdentifier = objc.registerName("processIdentifier");
final _objc_msgSend_5 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Int Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        int Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_globallyUniqueString =
    objc.registerName("globallyUniqueString");
late final _sel_operatingSystem = objc.registerName("operatingSystem");
final _objc_msgSend_6 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.UnsignedLong Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        int Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_operatingSystemName = objc.registerName("operatingSystemName");
late final _sel_operatingSystemVersionString =
    objc.registerName("operatingSystemVersionString");

final class NSOperatingSystemVersion extends ffi.Struct {
  @ffi.Long()
  external int majorVersion;

  @ffi.Long()
  external int minorVersion;

  @ffi.Long()
  external int patchVersion;
}

late final _sel_operatingSystemVersion =
    objc.registerName("operatingSystemVersion");
final _objc_msgSend_7 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            NSOperatingSystemVersion Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        NSOperatingSystemVersion Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
final _objc_msgSend_7Stret = objc.msgSendStretPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<NSOperatingSystemVersion>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        void Function(ffi.Pointer<NSOperatingSystemVersion>,
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_processorCount = objc.registerName("processorCount");
late final _sel_activeProcessorCount =
    objc.registerName("activeProcessorCount");
late final _sel_physicalMemory = objc.registerName("physicalMemory");
final _objc_msgSend_8 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.UnsignedLongLong Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        int Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_isOperatingSystemAtLeastVersion_ =
    objc.registerName("isOperatingSystemAtLeastVersion:");
final _objc_msgSend_9 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Bool Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, NSOperatingSystemVersion)>>()
    .asFunction<
        bool Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, NSOperatingSystemVersion)>();
late final _sel_systemUptime = objc.registerName("systemUptime");
final _objc_msgSend_10 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Double Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        double Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
final _objc_msgSend_10Fpret = objc.msgSendFpretPointer
    .cast<
        ffi.NativeFunction<
            ffi.Double Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        double Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_disableSuddenTermination =
    objc.registerName("disableSuddenTermination");
final _objc_msgSend_11 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        void Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_enableSuddenTermination =
    objc.registerName("enableSuddenTermination");
late final _sel_disableAutomaticTermination_ =
    objc.registerName("disableAutomaticTermination:");
final _objc_msgSend_12 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<objc.ObjCObject>)>();
late final _sel_enableAutomaticTermination_ =
    objc.registerName("enableAutomaticTermination:");
late final _sel_automaticTerminationSupportEnabled =
    objc.registerName("automaticTerminationSupportEnabled");
final _objc_msgSend_13 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Bool Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        bool Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_setAutomaticTerminationSupportEnabled_ =
    objc.registerName("setAutomaticTerminationSupportEnabled:");
final _objc_msgSend_14 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, ffi.Bool)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, bool)>();

/// The system has heuristics to improve battery life, performance, and responsiveness of applications for the benefit of the user. This API can be used to give hints to the system that your application has special requirements. In response to creating one of these activities, the system will disable some or all of the heuristics so your application can finish quickly while still providing responsive behavior if the user needs it.
///
/// These activities can be used when your application is performing a long-running operation. If the activity can take different amounts of time (for example, calculating the next move in a chess game), it should use this API. This will ensure correct behavior when the amount of data or the capabilities of the user's computer varies. You should put your activity into one of two major categories:
///
/// User initiated: These are finite length activities that the user has explicitly started. Examples include exporting or downloading a user specified file.
///
/// Background: These are finite length activities that are part of the normal operation of your application but are not explicitly started by the user. Examples include autosaving, indexing, and automatic downloading of files.
///
/// In addition, if your application requires high priority IO, you can include the 'NSActivityLatencyCritical' flag (using a bitwise or). This should be reserved for activities like audio or video recording.
///
/// If your activity takes place synchronously inside an event callback on the main thread, you do not need to use this API.
///
/// Be aware that failing to end these activities for an extended period of time can have significant negative impacts to the performance of your user's computer, so be sure to use only the minimum amount of time required. User preferences may override your application’s request.
///
/// This API can also be used to control auto termination or sudden termination.
///
/// id activity = [NSProcessInfo.processInfo beginActivityWithOptions:NSActivityAutomaticTerminationDisabled reason:@"Good Reason"];
/// // work
/// [NSProcessInfo.processInfo endActivity:activity];
///
/// is equivalent to:
///
/// [NSProcessInfo.processInfo disableAutomaticTermination:@"Good Reason"];
/// // work
/// [NSProcessInfo.processInfo enableAutomaticTermination:@"Good Reason"]
///
/// Since this API returns an object, it may be easier to pair begins and ends. If the object is deallocated before the -endActivity: call, the activity will be automatically ended.
///
/// This API also provides a mechanism to disable system-wide idle sleep and display idle sleep. These can have a large impact on the user experience, so be sure not to forget to end activities that disable sleep (including NSActivityUserInitiated).
enum NSActivityOptions {
  /// Used for activities that require the screen to stay powered on.
  NSActivityIdleDisplaySleepDisabled(1099511627776),

  /// Used for activities that require the computer to not idle sleep. This is included in NSActivityUserInitiated.
  NSActivityIdleSystemSleepDisabled(1048576),

  /// Prevents sudden termination. This is included in NSActivityUserInitiated.
  NSActivitySuddenTerminationDisabled(16384),

  /// Prevents automatic termination. This is included in NSActivityUserInitiated.
  NSActivityAutomaticTerminationDisabled(32768),

  /// Emits an os_signpost begin and end during the activity lifetime, intended to be used to track animation activity
  NSActivityAnimationTrackingEnabled(35184372088832),

  /// Emits an os_signpost begin and end during the activity lifetime, intended to be used to track general activity
  NSActivityTrackingEnabled(70368744177664),

  /// App is performing a user-requested action.
  NSActivityUserInitiated(16777215),
  NSActivityUserInitiatedAllowingIdleSystemSleep(15728639),

  /// App has initiated some kind of work, but not as the direct result of user request.
  NSActivityBackground(255),

  /// Used for activities that require the highest amount of timer and I/O precision available. Very few applications should need to use this constant.
  NSActivityLatencyCritical(1095216660480),
  NSActivityUserInteractive(1095233437695);

  final int value;
  const NSActivityOptions(this.value);

  static NSActivityOptions fromValue(int value) => switch (value) {
        1099511627776 => NSActivityIdleDisplaySleepDisabled,
        1048576 => NSActivityIdleSystemSleepDisabled,
        16384 => NSActivitySuddenTerminationDisabled,
        32768 => NSActivityAutomaticTerminationDisabled,
        35184372088832 => NSActivityAnimationTrackingEnabled,
        70368744177664 => NSActivityTrackingEnabled,
        16777215 => NSActivityUserInitiated,
        15728639 => NSActivityUserInitiatedAllowingIdleSystemSleep,
        255 => NSActivityBackground,
        1095216660480 => NSActivityLatencyCritical,
        1095233437695 => NSActivityUserInteractive,
        _ => throw ArgumentError("Unknown value for NSActivityOptions: $value"),
      };
}

late final _sel_beginActivityWithOptions_reason_ =
    objc.registerName("beginActivityWithOptions:reason:");
final _objc_msgSend_15 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Uint64,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            int,
            ffi.Pointer<objc.ObjCObject>)>();
late final _sel_endActivity_ = objc.registerName("endActivity:");
final _objc_msgSend_16 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<objc.ObjCObject>)>();
void _ObjCBlock_ffiVoid_fnPtrTrampoline(
  ffi.Pointer<objc.ObjCBlock> block,
) =>
    block.ref.target
        .cast<ffi.NativeFunction<ffi.Void Function()>>()
        .asFunction<void Function()>()();
void _ObjCBlock_ffiVoid_closureTrampoline(
  ffi.Pointer<objc.ObjCBlock> block,
) =>
    (objc.getBlockClosure(block) as void Function())();

class ObjCBlock_ffiVoid extends objc.ObjCBlockBase {
  ObjCBlock_ffiVoid._(ffi.Pointer<objc.ObjCBlock> pointer,
      {bool retain = false, bool release = true})
      : super(pointer, retain: retain, release: release);

  /// Returns a block that wraps the given raw block pointer.
  static ObjCBlock_ffiVoid castFromPointer(ffi.Pointer<objc.ObjCBlock> pointer,
      {bool retain = false, bool release = false}) {
    return ObjCBlock_ffiVoid._(pointer, retain: retain, release: release);
  }

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ObjCBlock_ffiVoid.fromFunctionPointer(
      ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> ptr)
      : this._(objc.newPointerBlock(
            _cFuncTrampoline ??= ffi.Pointer.fromFunction<
                        ffi.Void Function(ffi.Pointer<objc.ObjCBlock>)>(
                    _ObjCBlock_ffiVoid_fnPtrTrampoline)
                .cast(),
            ptr.cast()));
  static ffi.Pointer<ffi.Void>? _cFuncTrampoline;

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ObjCBlock_ffiVoid.fromFunction(void Function() fn)
      : this._(objc.newClosureBlock(
            _dartFuncTrampoline ??= ffi.Pointer.fromFunction<
                        ffi.Void Function(ffi.Pointer<objc.ObjCBlock>)>(
                    _ObjCBlock_ffiVoid_closureTrampoline)
                .cast(),
            () => fn()));
  static ffi.Pointer<ffi.Void>? _dartFuncTrampoline;

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// Note that unlike the default behavior of NativeCallable.listener, listener
  /// blocks do not keep the isolate alive.
  ObjCBlock_ffiVoid.listener(void Function() fn)
      : this._((objc.newClosureBlock(
            (_dartFuncListenerTrampoline ??= ffi.NativeCallable<
                        ffi.Void Function(
                            ffi.Pointer<objc.ObjCBlock>)>.listener(
                    _ObjCBlock_ffiVoid_closureTrampoline)
                  ..keepIsolateAlive = false)
                .nativeFunction
                .cast(),
            () => fn())));
  static ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlock>)>?
      _dartFuncListenerTrampoline;

  void call() => pointer.ref.invoke
          .cast<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<objc.ObjCBlock> block)>>()
          .asFunction<void Function(ffi.Pointer<objc.ObjCBlock>)>()(
        pointer,
      );
}

late final _sel_performActivityWithOptions_reason_usingBlock_ =
    objc.registerName("performActivityWithOptions:reason:usingBlock:");
final _objc_msgSend_17 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Uint64,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCBlock>)>>()
    .asFunction<
        void Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            int,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCBlock>)>();
void _ObjCBlock_ffiVoid_bool_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlock> block, bool arg0) =>
    block.ref.target
        .cast<ffi.NativeFunction<ffi.Void Function(ffi.Bool arg0)>>()
        .asFunction<void Function(bool)>()(arg0);
void _ObjCBlock_ffiVoid_bool_closureTrampoline(
        ffi.Pointer<objc.ObjCBlock> block, bool arg0) =>
    (objc.getBlockClosure(block) as void Function(bool))(arg0);

class ObjCBlock_ffiVoid_bool extends objc.ObjCBlockBase {
  ObjCBlock_ffiVoid_bool._(ffi.Pointer<objc.ObjCBlock> pointer,
      {bool retain = false, bool release = true})
      : super(pointer, retain: retain, release: release);

  /// Returns a block that wraps the given raw block pointer.
  static ObjCBlock_ffiVoid_bool castFromPointer(
      ffi.Pointer<objc.ObjCBlock> pointer,
      {bool retain = false,
      bool release = false}) {
    return ObjCBlock_ffiVoid_bool._(pointer, retain: retain, release: release);
  }

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ObjCBlock_ffiVoid_bool.fromFunctionPointer(
      ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Bool arg0)>> ptr)
      : this._(objc.newPointerBlock(
            _cFuncTrampoline ??= ffi.Pointer.fromFunction<
                    ffi.Void Function(ffi.Pointer<objc.ObjCBlock>,
                        ffi.Bool)>(_ObjCBlock_ffiVoid_bool_fnPtrTrampoline)
                .cast(),
            ptr.cast()));
  static ffi.Pointer<ffi.Void>? _cFuncTrampoline;

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ObjCBlock_ffiVoid_bool.fromFunction(void Function(bool) fn)
      : this._(objc.newClosureBlock(
            _dartFuncTrampoline ??= ffi.Pointer.fromFunction<
                    ffi.Void Function(ffi.Pointer<objc.ObjCBlock>,
                        ffi.Bool)>(_ObjCBlock_ffiVoid_bool_closureTrampoline)
                .cast(),
            (bool arg0) => fn(arg0)));
  static ffi.Pointer<ffi.Void>? _dartFuncTrampoline;

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// Note that unlike the default behavior of NativeCallable.listener, listener
  /// blocks do not keep the isolate alive.
  ObjCBlock_ffiVoid_bool.listener(void Function(bool) fn)
      : this._((objc.newClosureBlock(
            (_dartFuncListenerTrampoline ??= ffi.NativeCallable<
                        ffi.Void Function(
                            ffi.Pointer<objc.ObjCBlock>, ffi.Bool)>.listener(
                    _ObjCBlock_ffiVoid_bool_closureTrampoline)
                  ..keepIsolateAlive = false)
                .nativeFunction
                .cast(),
            (bool arg0) => fn(arg0))));
  static ffi
      .NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlock>, ffi.Bool)>?
      _dartFuncListenerTrampoline;

  void call(bool arg0) => pointer.ref.invoke
          .cast<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<objc.ObjCBlock> block, ffi.Bool arg0)>>()
          .asFunction<void Function(ffi.Pointer<objc.ObjCBlock>, bool)>()(
      pointer, arg0);
}

late final _sel_performExpiringActivityWithReason_usingBlock_ =
    objc.registerName("performExpiringActivityWithReason:usingBlock:");
final _objc_msgSend_18 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCBlock>)>>()
    .asFunction<
        void Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCBlock>)>();
late final _sel_userName = objc.registerName("userName");
late final _sel_fullUserName = objc.registerName("fullUserName");

/// Describes the current thermal state of the system.
enum NSProcessInfoThermalState {
  /// No corrective action is needed.
  NSProcessInfoThermalStateNominal(0),

  /// The system has reached a state where fans may become audible (on systems which have fans). Recommendation: Defer non-user-visible activity.
  NSProcessInfoThermalStateFair(1),

  /// Fans are running at maximum speed (on systems which have fans), system performance may be impacted. Recommendation: reduce application's usage of CPU, GPU and I/O, if possible. Switch to lower quality visual effects, reduce frame rates.
  NSProcessInfoThermalStateSerious(2),

  /// System performance is significantly impacted and the system needs to cool down. Recommendation: reduce application's usage of CPU, GPU, and I/O to the minimum level needed to respond to user actions. Consider stopping use of camera and other peripherals if your application is using them.
  NSProcessInfoThermalStateCritical(3);

  final int value;
  const NSProcessInfoThermalState(this.value);

  static NSProcessInfoThermalState fromValue(int value) => switch (value) {
        0 => NSProcessInfoThermalStateNominal,
        1 => NSProcessInfoThermalStateFair,
        2 => NSProcessInfoThermalStateSerious,
        3 => NSProcessInfoThermalStateCritical,
        _ => throw ArgumentError(
            "Unknown value for NSProcessInfoThermalState: $value"),
      };
}

late final _sel_thermalState = objc.registerName("thermalState");
final _objc_msgSend_19 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.UnsignedLong Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        int Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_isLowPowerModeEnabled =
    objc.registerName("isLowPowerModeEnabled");
late final _sel_isMacCatalystApp = objc.registerName("isMacCatalystApp");
late final _sel_isiOSAppOnMac = objc.registerName("isiOSAppOnMac");
typedef instancetype = ffi.Pointer<objc.ObjCObject>;
typedef Dartinstancetype = objc.ObjCObjectBase;
late final _sel_init = objc.registerName("init");
late final _sel_new = objc.registerName("new");

final class _NSZone extends ffi.Opaque {}

late final _sel_allocWithZone_ = objc.registerName("allocWithZone:");
final _objc_msgSend_20 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            instancetype Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<_NSZone>)>>()
    .asFunction<
        instancetype Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<_NSZone>)>();
late final _sel_alloc = objc.registerName("alloc");
final _objc_msgSend_0 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Bool Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        bool Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<objc.ObjCObject>)>();
late final _sel_isKindOfClass_ = objc.registerName("isKindOfClass:");

/// NSApplication
class NSApplication extends NSResponder {
  NSApplication._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release);

  /// Constructs a [NSApplication] that points to the same underlying object as [other].
  NSApplication.castFrom(objc.ObjCObjectBase other)
      : this._(other.pointer, retain: true, release: true);

  /// Constructs a [NSApplication] that wraps the given raw object pointer.
  NSApplication.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [NSApplication].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_0(
        obj.pointer, _sel_isKindOfClass_, _class_NSApplication);
  }

  /// sharedApplication
  static NSApplication getSharedApplication() {
    final _ret = _objc_msgSend_21(_class_NSApplication, _sel_sharedApplication);
    return NSApplication.castFromPointer(_ret, retain: true, release: true);
  }

  /// delegate
  objc.ObjCObjectBase? get delegate {
    final _ret = _objc_msgSend_22(this.pointer, _sel_delegate);
    return _ret.address == 0
        ? null
        : objc.ObjCObjectBase(_ret, retain: true, release: true);
  }

  /// setDelegate:
  set delegate(objc.ObjCObjectBase? value) {
    return _objc_msgSend_23(
        this.pointer, _sel_setDelegate_, value?.pointer ?? ffi.nullptr);
  }

  /// hide:
  void hide_(objc.ObjCObjectBase? sender) {
    _objc_msgSend_24(this.pointer, _sel_hide_, sender?.pointer ?? ffi.nullptr);
  }

  /// unhide:
  void unhide_(objc.ObjCObjectBase? sender) {
    _objc_msgSend_24(
        this.pointer, _sel_unhide_, sender?.pointer ?? ffi.nullptr);
  }

  /// unhideWithoutActivation
  void unhideWithoutActivation() {
    _objc_msgSend_11(this.pointer, _sel_unhideWithoutActivation);
  }

  /// windowWithWindowNumber:
  NSWindow? windowWithWindowNumber_(int windowNum) {
    final _ret = _objc_msgSend_294(
        this.pointer, _sel_windowWithWindowNumber_, windowNum);
    return _ret.address == 0
        ? null
        : NSWindow.castFromPointer(_ret, retain: true, release: true);
  }

  /// mainWindow
  NSWindow? get mainWindow {
    final _ret = _objc_msgSend_46(this.pointer, _sel_mainWindow);
    return _ret.address == 0
        ? null
        : NSWindow.castFromPointer(_ret, retain: true, release: true);
  }

  /// keyWindow
  NSWindow? get keyWindow {
    final _ret = _objc_msgSend_46(this.pointer, _sel_keyWindow);
    return _ret.address == 0
        ? null
        : NSWindow.castFromPointer(_ret, retain: true, release: true);
  }

  /// isActive
  bool get active {
    return _objc_msgSend_13(this.pointer, _sel_isActive);
  }

  /// isHidden
  bool get hidden {
    return _objc_msgSend_13(this.pointer, _sel_isHidden);
  }

  /// isRunning
  bool get running {
    return _objc_msgSend_13(this.pointer, _sel_isRunning);
  }

  /// deactivate
  void deactivate() {
    _objc_msgSend_11(this.pointer, _sel_deactivate);
  }

  /// Makes the receiver the active app.
  void activateIgnoringOtherApps_(bool flag) {
    _objc_msgSend_152(this.pointer, _sel_activateIgnoringOtherApps_, flag);
  }

  /// Makes the receiver the active app, if possible.
  ///
  /// You shouldn’t assume the app will be active immediately
  /// after sending this message. The framework also does not
  /// guarantee that the app will be activated at all.
  ///
  /// For cooperative activation, the other application should
  /// call `-yieldActivationToApplication:` or equivalent prior
  /// to the target application invoking `-activate`.
  ///
  /// Invoking `-activate` on an already-active application
  /// cancels any pending activation yields by the receiver.
  void activate() {
    _objc_msgSend_11(this.pointer, _sel_activate);
  }

  /// Explicitly allows another application to make itself active.
  ///
  /// Calling this method will not deactivate the current app, nor
  /// will it activate the other app. For cooperative or coordinated
  /// activation, the other app should request to be activated at
  /// some point in the future by calling `activate` or equivalent.
  void yieldActivationToApplication_(NSRunningApplication application) {
    _objc_msgSend_301(
        this.pointer, _sel_yieldActivationToApplication_, application.pointer);
  }

  /// Same as `-yieldActivationToApplication:`, but the provided
  /// bundle identifier does not have to correspond to a currently
  /// running application.
  ///
  /// This method should be used to yield activation to apps that
  /// may not be running at the time of invoking it. If it is known
  /// that the target application is currently running, use
  /// `-yieldActivationToApplication:` instead.
  void yieldActivationToApplicationWithBundleIdentifier_(
      objc.NSString bundleIdentifier) {
    _objc_msgSend_12(
        this.pointer,
        _sel_yieldActivationToApplicationWithBundleIdentifier_,
        bundleIdentifier.pointer);
  }

  /// hideOtherApplications:
  void hideOtherApplications_(objc.ObjCObjectBase? sender) {
    _objc_msgSend_24(this.pointer, _sel_hideOtherApplications_,
        sender?.pointer ?? ffi.nullptr);
  }

  /// unhideAllApplications:
  void unhideAllApplications_(objc.ObjCObjectBase? sender) {
    _objc_msgSend_24(this.pointer, _sel_unhideAllApplications_,
        sender?.pointer ?? ffi.nullptr);
  }

  /// finishLaunching
  void finishLaunching() {
    _objc_msgSend_11(this.pointer, _sel_finishLaunching);
  }

  /// run
  void run() {
    _objc_msgSend_11(this.pointer, _sel_run);
  }

  /// runModalForWindow:
  int runModalForWindow_(NSWindow window) {
    return _objc_msgSend_302(
        this.pointer, _sel_runModalForWindow_, window.pointer);
  }

  /// stop:
  void stop_(objc.ObjCObjectBase? sender) {
    _objc_msgSend_24(this.pointer, _sel_stop_, sender?.pointer ?? ffi.nullptr);
  }

  /// stopModal
  void stopModal() {
    _objc_msgSend_11(this.pointer, _sel_stopModal);
  }

  /// stopModalWithCode:
  void stopModalWithCode_(int returnCode) {
    _objc_msgSend_41(this.pointer, _sel_stopModalWithCode_, returnCode);
  }

  /// abortModal
  void abortModal() {
    _objc_msgSend_11(this.pointer, _sel_abortModal);
  }

  /// modalWindow
  NSWindow? get modalWindow {
    final _ret = _objc_msgSend_46(this.pointer, _sel_modalWindow);
    return _ret.address == 0
        ? null
        : NSWindow.castFromPointer(_ret, retain: true, release: true);
  }

  /// beginModalSessionForWindow:
  ffi.Pointer<_NSModalSession> beginModalSessionForWindow_(NSWindow window) {
    return _objc_msgSend_303(
        this.pointer, _sel_beginModalSessionForWindow_, window.pointer);
  }

  /// runModalSession:
  int runModalSession_(ffi.Pointer<_NSModalSession> session) {
    return _objc_msgSend_304(this.pointer, _sel_runModalSession_, session);
  }

  /// endModalSession:
  void endModalSession_(ffi.Pointer<_NSModalSession> session) {
    _objc_msgSend_305(this.pointer, _sel_endModalSession_, session);
  }

  /// terminate:
  void terminate_(objc.ObjCObjectBase? sender) {
    _objc_msgSend_24(
        this.pointer, _sel_terminate_, sender?.pointer ?? ffi.nullptr);
  }

  /// Inform the user that this application needs attention - call this method only if your application is not already active.
  int requestUserAttention_(NSRequestUserAttentionType requestType) {
    return _objc_msgSend_306(
        this.pointer, _sel_requestUserAttention_, requestType.value);
  }

  /// cancelUserAttentionRequest:
  void cancelUserAttentionRequest_(int request) {
    _objc_msgSend_41(this.pointer, _sel_cancelUserAttentionRequest_, request);
  }

  /// Execute a block for each of the app's windows. Set `*stop = YES` if desired, to halt the enumeration early.
  void enumerateWindowsWithOptions_usingBlock_(
      NSWindowListOptions options, ObjCBlock_ffiVoid_NSWindow_bool block) {
    _objc_msgSend_307(
        this.pointer,
        _sel_enumerateWindowsWithOptions_usingBlock_,
        options.value,
        block.pointer);
  }

  /// preventWindowOrdering
  void preventWindowOrdering() {
    _objc_msgSend_11(this.pointer, _sel_preventWindowOrdering);
  }

  /// windows
  objc.ObjCObjectBase get windows {
    final _ret = _objc_msgSend_2(this.pointer, _sel_windows);
    return objc.ObjCObjectBase(_ret, retain: true, release: true);
  }

  /// setWindowsNeedUpdate:
  void setWindowsNeedUpdate_(bool needUpdate) {
    _objc_msgSend_152(this.pointer, _sel_setWindowsNeedUpdate_, needUpdate);
  }

  /// updateWindows
  void updateWindows() {
    _objc_msgSend_11(this.pointer, _sel_updateWindows);
  }

  /// mainMenu
  NSMenu? get mainMenu {
    final _ret = _objc_msgSend_133(this.pointer, _sel_mainMenu);
    return _ret.address == 0
        ? null
        : NSMenu.castFromPointer(_ret, retain: true, release: true);
  }

  /// setMainMenu:
  set mainMenu(NSMenu? value) {
    return _objc_msgSend_134(
        this.pointer, _sel_setMainMenu_, value?.pointer ?? ffi.nullptr);
  }

  /// Set or get the Help menu for the app.  If a non-nil menu is set as the Help menu, Spotlight for Help will be installed in it; otherwise AppKit will install Spotlight for Help into a menu of its choosing (and that menu is not returned from `-helpMenu`).  If you wish to completely suppress Spotlight for Help, you can set a menu that does not appear in the menu bar.  @c NSApplication retains its Help menu and releases it when a different menu is set.
  NSMenu? get helpMenu {
    final _ret = _objc_msgSend_133(this.pointer, _sel_helpMenu);
    return _ret.address == 0
        ? null
        : NSMenu.castFromPointer(_ret, retain: true, release: true);
  }

  /// Set or get the Help menu for the app.  If a non-nil menu is set as the Help menu, Spotlight for Help will be installed in it; otherwise AppKit will install Spotlight for Help into a menu of its choosing (and that menu is not returned from `-helpMenu`).  If you wish to completely suppress Spotlight for Help, you can set a menu that does not appear in the menu bar.  @c NSApplication retains its Help menu and releases it when a different menu is set.
  set helpMenu(NSMenu? value) {
    return _objc_msgSend_134(
        this.pointer, _sel_setHelpMenu_, value?.pointer ?? ffi.nullptr);
  }

  /// applicationIconImage
  NSImage get applicationIconImage {
    final _ret = _objc_msgSend_143(this.pointer, _sel_applicationIconImage);
    return NSImage.castFromPointer(_ret, retain: true, release: true);
  }

  /// setApplicationIconImage:
  set applicationIconImage(NSImage value) {
    return _objc_msgSend_144(
        this.pointer, _sel_setApplicationIconImage_, value.pointer);
  }

  /// @return The activation policy of the application.
  NSApplicationActivationPolicy activationPolicy() {
    final _ret = _objc_msgSend_295(this.pointer, _sel_activationPolicy);
    return NSApplicationActivationPolicy.fromValue(_ret);
  }

  /// Attempts to modify the application's activation policy.  In OS X 10.9, any policy may be set; prior to 10.9, the activation policy may be changed to @c NSApplicationActivationPolicyProhibited or @c NSApplicationActivationPolicyRegular, but may not be changed to @c NSApplicationActivationPolicyAccessory.  This returns @c YES if setting the activation policy is successful, and @c NO if not.
  bool setActivationPolicy_(NSApplicationActivationPolicy activationPolicy) {
    return _objc_msgSend_308(
        this.pointer, _sel_setActivationPolicy_, activationPolicy.value);
  }

  /// dockTile
  NSDockTile get dockTile {
    final _ret = _objc_msgSend_219(this.pointer, _sel_dockTile);
    return NSDockTile.castFromPointer(_ret, retain: true, release: true);
  }

  /// reportException:
  void reportException_(NSException exception) {
    _objc_msgSend_312(this.pointer, _sel_reportException_, exception.pointer);
  }

  /// detachDrawingThread:toTarget:withObject:
  static void detachDrawingThread_toTarget_withObject_(
      ffi.Pointer<objc.ObjCSelector> selector,
      objc.ObjCObjectBase target,
      objc.ObjCObjectBase? argument) {
    _objc_msgSend_313(
        _class_NSApplication,
        _sel_detachDrawingThread_toTarget_withObject_,
        selector,
        target.pointer,
        argument?.pointer ?? ffi.nullptr);
  }

  /// If an application delegate returns NSTerminateLater from -applicationShouldTerminate:, -replyToApplicationShouldTerminate: must be called with YES or NO once the application decides if it can terminate.
  void replyToApplicationShouldTerminate_(bool shouldTerminate) {
    _objc_msgSend_152(
        this.pointer, _sel_replyToApplicationShouldTerminate_, shouldTerminate);
  }

  /// If an application delegate encounters an error while handling `-application:openFiles:` or` -application:printFiles:`, `-replyToOpenOrPrint:` should be called with @c NSApplicationDelegateReplyFailure.  If the user cancels the operation, @c NSApplicationDelegateReplyCancel should be used, and if the operation succeeds, @c NSApplicationDelegateReplySuccess should be used .
  void replyToOpenOrPrint_(NSApplicationDelegateReply reply) {
    _objc_msgSend_314(this.pointer, _sel_replyToOpenOrPrint_, reply.value);
  }

  /// Opens the character palette.
  void orderFrontCharacterPalette_(objc.ObjCObjectBase? sender) {
    _objc_msgSend_24(this.pointer, _sel_orderFrontCharacterPalette_,
        sender?.pointer ?? ffi.nullptr);
  }

  /// Gets or sets the @c presentationOptions that should be in effect for the system when this application is the active application.  Only certain combinations of @c NSApplicationPresentationOptions flags are allowed, as detailed in the AppKit Release Notes and the reference documentation for `-setPresentationOptions:`.  When given an invalid combination of option flags, `-setPresentationOptions:` raises an exception.
  NSApplicationPresentationOptions get presentationOptions {
    final _ret = _objc_msgSend_315(this.pointer, _sel_presentationOptions);
    return NSApplicationPresentationOptions.fromValue(_ret);
  }

  /// Gets or sets the @c presentationOptions that should be in effect for the system when this application is the active application.  Only certain combinations of @c NSApplicationPresentationOptions flags are allowed, as detailed in the AppKit Release Notes and the reference documentation for `-setPresentationOptions:`.  When given an invalid combination of option flags, `-setPresentationOptions:` raises an exception.
  set presentationOptions(NSApplicationPresentationOptions value) {
    return _objc_msgSend_316(
        this.pointer, _sel_setPresentationOptions_, value.value);
  }

  /// @return The set of application presentation options that are currently in effect for the system.
  /// These are the presentation options that have been put into effect by the currently active application.
  NSApplicationPresentationOptions get currentSystemPresentationOptions {
    final _ret =
        _objc_msgSend_315(this.pointer, _sel_currentSystemPresentationOptions);
    return NSApplicationPresentationOptions.fromValue(_ret);
  }

  /// occlusionState
  NSApplicationOcclusionState get occlusionState {
    final _ret = _objc_msgSend_317(this.pointer, _sel_occlusionState);
    return NSApplicationOcclusionState.fromValue(_ret);
  }

  /// isProtectedDataAvailable
  bool get protectedDataAvailable {
    return _objc_msgSend_13(this.pointer, _sel_isProtectedDataAvailable);
  }

  /// appearance
  NSAppearance? get appearance {
    final _ret = _objc_msgSend_346(this.pointer, _sel_appearance);
    return _ret.address == 0
        ? null
        : NSAppearance.castFromPointer(_ret, retain: true, release: true);
  }

  /// setAppearance:
  set appearance(NSAppearance? value) {
    return _objc_msgSend_347(
        this.pointer, _sel_setAppearance_, value?.pointer ?? ffi.nullptr);
  }

  /// effectiveAppearance
  NSAppearance get effectiveAppearance {
    final _ret = _objc_msgSend_318(this.pointer, _sel_effectiveAppearance);
    return NSAppearance.castFromPointer(_ret, retain: true, release: true);
  }

  /// sendEvent:
  void sendEvent_(NSEvent event) {
    _objc_msgSend_181(this.pointer, _sel_sendEvent_, event.pointer);
  }

  /// postEvent:atStart:
  void postEvent_atStart_(NSEvent event, bool flag) {
    _objc_msgSend_270(
        this.pointer, _sel_postEvent_atStart_, event.pointer, flag);
  }

  /// currentEvent
  NSEvent? get currentEvent {
    final _ret = _objc_msgSend_271(this.pointer, _sel_currentEvent);
    return _ret.address == 0
        ? null
        : NSEvent.castFromPointer(_ret, retain: true, release: true);
  }

  /// nextEventMatchingMask:untilDate:inMode:dequeue:
  NSEvent? nextEventMatchingMask_untilDate_inMode_dequeue_(NSEventMask mask,
      objc.NSDate? expiration, objc.NSString mode, bool deqFlag) {
    final _ret = _objc_msgSend_268(
        this.pointer,
        _sel_nextEventMatchingMask_untilDate_inMode_dequeue_,
        mask.value,
        expiration?.pointer ?? ffi.nullptr,
        mode.pointer,
        deqFlag);
    return _ret.address == 0
        ? null
        : NSEvent.castFromPointer(_ret, retain: true, release: true);
  }

  /// discardEventsMatchingMask:beforeEvent:
  void discardEventsMatchingMask_beforeEvent_(
      NSEventMask mask, NSEvent? lastEvent) {
    _objc_msgSend_269(this.pointer, _sel_discardEventsMatchingMask_beforeEvent_,
        mask.value, lastEvent?.pointer ?? ffi.nullptr);
  }

  /// sendAction:to:from:
  bool sendAction_to_from_(ffi.Pointer<objc.ObjCSelector> action,
      objc.ObjCObjectBase? target, objc.ObjCObjectBase? sender) {
    return _objc_msgSend_348(this.pointer, _sel_sendAction_to_from_, action,
        target?.pointer ?? ffi.nullptr, sender?.pointer ?? ffi.nullptr);
  }

  /// targetForAction:
  objc.ObjCObjectBase? targetForAction_(ffi.Pointer<objc.ObjCSelector> action) {
    final _ret = _objc_msgSend_349(this.pointer, _sel_targetForAction_, action);
    return _ret.address == 0
        ? null
        : objc.ObjCObjectBase(_ret, retain: true, release: true);
  }

  /// targetForAction:to:from:
  objc.ObjCObjectBase? targetForAction_to_from_(
      ffi.Pointer<objc.ObjCSelector> action,
      objc.ObjCObjectBase? target,
      objc.ObjCObjectBase? sender) {
    final _ret = _objc_msgSend_350(this.pointer, _sel_targetForAction_to_from_,
        action, target?.pointer ?? ffi.nullptr, sender?.pointer ?? ffi.nullptr);
    return _ret.address == 0
        ? null
        : objc.ObjCObjectBase(_ret, retain: true, release: true);
  }

  /// tryToPerform:with:
  bool tryToPerform_with_(
      ffi.Pointer<objc.ObjCSelector> action, objc.ObjCObjectBase? object) {
    return _objc_msgSend_179(this.pointer, _sel_tryToPerform_with_, action,
        object?.pointer ?? ffi.nullptr);
  }

  /// validRequestorForSendType:returnType:
  objc.ObjCObjectBase? validRequestorForSendType_returnType_(
      objc.NSString? sendType, objc.NSString? returnType) {
    final _ret = _objc_msgSend_180(
        this.pointer,
        _sel_validRequestorForSendType_returnType_,
        sendType?.pointer ?? ffi.nullptr,
        returnType?.pointer ?? ffi.nullptr);
    return _ret.address == 0
        ? null
        : objc.ObjCObjectBase(_ret, retain: true, release: true);
  }

  /// windowsMenu
  NSMenu? get windowsMenu {
    final _ret = _objc_msgSend_133(this.pointer, _sel_windowsMenu);
    return _ret.address == 0
        ? null
        : NSMenu.castFromPointer(_ret, retain: true, release: true);
  }

  /// setWindowsMenu:
  set windowsMenu(NSMenu? value) {
    return _objc_msgSend_134(
        this.pointer, _sel_setWindowsMenu_, value?.pointer ?? ffi.nullptr);
  }

  /// arrangeInFront:
  void arrangeInFront_(objc.ObjCObjectBase? sender) {
    _objc_msgSend_24(
        this.pointer, _sel_arrangeInFront_, sender?.pointer ?? ffi.nullptr);
  }

  /// removeWindowsItem:
  void removeWindowsItem_(NSWindow win) {
    _objc_msgSend_235(this.pointer, _sel_removeWindowsItem_, win.pointer);
  }

  /// addWindowsItem:title:filename:
  void addWindowsItem_title_filename_(
      NSWindow win, objc.NSString string, bool isFilename) {
    _objc_msgSend_351(this.pointer, _sel_addWindowsItem_title_filename_,
        win.pointer, string.pointer, isFilename);
  }

  /// changeWindowsItem:title:filename:
  void changeWindowsItem_title_filename_(
      NSWindow win, objc.NSString string, bool isFilename) {
    _objc_msgSend_351(this.pointer, _sel_changeWindowsItem_title_filename_,
        win.pointer, string.pointer, isFilename);
  }

  /// updateWindowsItem:
  void updateWindowsItem_(NSWindow win) {
    _objc_msgSend_235(this.pointer, _sel_updateWindowsItem_, win.pointer);
  }

  /// miniaturizeAll:
  void miniaturizeAll_(objc.ObjCObjectBase? sender) {
    _objc_msgSend_24(
        this.pointer, _sel_miniaturizeAll_, sender?.pointer ?? ffi.nullptr);
  }

  /// Use this method to get the status of Full Keyboard Access, as configured in the Keyboard preference pane. You may use this status to implement your own key loop or to implement in-control tabbing behavior similar to @c NSTableView. Because of the nature of the preference storage, you will not be notified of changes to the key if you attempt to observe it via key-value observing; however, calling this method is fairly inexpensive, so you should always call it when you need the underlying value instead of caching it.
  bool get fullKeyboardAccessEnabled {
    return _objc_msgSend_13(this.pointer, _sel_isFullKeyboardAccessEnabled);
  }

  /// servicesMenu
  NSMenu? get servicesMenu {
    final _ret = _objc_msgSend_133(this.pointer, _sel_servicesMenu);
    return _ret.address == 0
        ? null
        : NSMenu.castFromPointer(_ret, retain: true, release: true);
  }

  /// setServicesMenu:
  set servicesMenu(NSMenu? value) {
    return _objc_msgSend_134(
        this.pointer, _sel_setServicesMenu_, value?.pointer ?? ffi.nullptr);
  }

  /// registerServicesMenuSendTypes:returnTypes:
  void registerServicesMenuSendTypes_returnTypes_(
      objc.NSArray sendTypes, objc.NSArray returnTypes) {
    _objc_msgSend_352(
        this.pointer,
        _sel_registerServicesMenuSendTypes_returnTypes_,
        sendTypes.pointer,
        returnTypes.pointer);
  }

  /// servicesProvider
  objc.ObjCObjectBase? get servicesProvider {
    final _ret = _objc_msgSend_22(this.pointer, _sel_servicesProvider);
    return _ret.address == 0
        ? null
        : objc.ObjCObjectBase(_ret, retain: true, release: true);
  }

  /// setServicesProvider:
  set servicesProvider(objc.ObjCObjectBase? value) {
    return _objc_msgSend_23(
        this.pointer, _sel_setServicesProvider_, value?.pointer ?? ffi.nullptr);
  }

  /// orderFrontStandardAboutPanel:
  void orderFrontStandardAboutPanel_(objc.ObjCObjectBase? sender) {
    _objc_msgSend_24(this.pointer, _sel_orderFrontStandardAboutPanel_,
        sender?.pointer ?? ffi.nullptr);
  }

  /// orderFrontStandardAboutPanelWithOptions:
  void orderFrontStandardAboutPanelWithOptions_(
      objc.NSDictionary optionsDictionary) {
    _objc_msgSend_353(
        this.pointer,
        _sel_orderFrontStandardAboutPanelWithOptions_,
        optionsDictionary.pointer);
  }

  /// Returns the application-wide user interface layout direction.
  NSUserInterfaceLayoutDirection get userInterfaceLayoutDirection {
    final _ret =
        _objc_msgSend_168(this.pointer, _sel_userInterfaceLayoutDirection);
    return NSUserInterfaceLayoutDirection.fromValue(_ret);
  }

  /// Disable or reenable relaunching this app on login, if the app was running at the time the user logged out.  These methods increment and decrement a counter respectively; if the counter is 0 at the time the user logs out, then the app may be relaunched when the user logs back in.  The counter is initially zero, so by default apps are relaunched.
  ///
  /// If your app should not be relaunched because it launches via some other mechanism (e.g. launchd), then the recommended usage is to call `-[NSApp disableRelaunchOnLogin]` once, and never pair it with an -enable call.
  ///
  /// If your app should not be relaunched because it triggers a restart (e.g. an installer), then the recommended usage is to call `-[NSApp disableRelaunchOnLogin]` immediately before you attempt to trigger a restart, and `-[NSApp enableRelaunchOnLogin]` immediately after.  This is because the user may cancel restarting; if the user later restarts for another reason, then your app should be brought back.
  ///
  /// These methods are thread safe.
  void disableRelaunchOnLogin() {
    _objc_msgSend_11(this.pointer, _sel_disableRelaunchOnLogin);
  }

  /// enableRelaunchOnLogin
  void enableRelaunchOnLogin() {
    _objc_msgSend_11(this.pointer, _sel_enableRelaunchOnLogin);
  }

  /// registerForRemoteNotifications
  void registerForRemoteNotifications() {
    _objc_msgSend_11(this.pointer, _sel_registerForRemoteNotifications);
  }

  /// unregisterForRemoteNotifications
  void unregisterForRemoteNotifications() {
    _objc_msgSend_11(this.pointer, _sel_unregisterForRemoteNotifications);
  }

  /// @return @c YES if the application is currently registered for remote notifications, taking into account any systemwide settings; doesn't relate to connectivity.
  bool get registeredForRemoteNotifications {
    return _objc_msgSend_13(
        this.pointer, _sel_isRegisteredForRemoteNotifications);
  }

  /// The following are soft deprecated.
  /// Please use the `-registerForRemoteNotifications` above and `-requestAuthorizationWithOptions:` from `UserNotifications.framework`.
  void registerForRemoteNotificationTypes_(NSRemoteNotificationType types) {
    _objc_msgSend_354(
        this.pointer, _sel_registerForRemoteNotificationTypes_, types.value);
  }

  /// enabledRemoteNotificationTypes
  NSRemoteNotificationType get enabledRemoteNotificationTypes {
    final _ret =
        _objc_msgSend_355(this.pointer, _sel_enabledRemoteNotificationTypes);
    return NSRemoteNotificationType.fromValue(_ret);
  }

  /// `-runModalForWindow:relativeToWindow:` was deprecated in Mac OS X 10.0. Please use `-[NSWindow beginSheet:completionHandler:]` instead.
  int runModalForWindow_relativeToWindow_(NSWindow window, NSWindow docWindow) {
    return _objc_msgSend_356(
        this.pointer,
        _sel_runModalForWindow_relativeToWindow_,
        window.pointer,
        docWindow.pointer);
  }

  /// `-beginModalSessionForWindow:relativeToWindow:` was deprecated in Mac OS X 10.0. Please use `-[NSWindow beginSheet:completionHandler:]` instead.
  ffi.Pointer<_NSModalSession> beginModalSessionForWindow_relativeToWindow_(
      NSWindow window, NSWindow docWindow) {
    return _objc_msgSend_357(
        this.pointer,
        _sel_beginModalSessionForWindow_relativeToWindow_,
        window.pointer,
        docWindow.pointer);
  }

  /// `-application:printFiles:` was deprecated in Mac OS X 10.4.
  /// Implement `-application:printFiles:withSettings:showPrintPanels:` in your application delegate instead.
  void application_printFiles_(NSApplication sender, objc.NSArray filenames) {
    _objc_msgSend_358(this.pointer, _sel_application_printFiles_,
        sender.pointer, filenames.pointer);
  }

  /// `NSWindow`'s `-beginSheet:completionHandler:` and `-endSheet:returnCode:` should be used instead.  `NSApplication`'s `-beginSheet:modalForWindow:modalDelegate:didEndSelector:contextInfo:` will continue to work as it previously did, leaking contextInfo and failing when there is already an existing sheet.
  void beginSheet_modalForWindow_modalDelegate_didEndSelector_contextInfo_(
      NSWindow sheet,
      NSWindow docWindow,
      objc.ObjCObjectBase? modalDelegate,
      ffi.Pointer<objc.ObjCSelector> didEndSelector,
      ffi.Pointer<ffi.Void> contextInfo) {
    _objc_msgSend_359(
        this.pointer,
        _sel_beginSheet_modalForWindow_modalDelegate_didEndSelector_contextInfo_,
        sheet.pointer,
        docWindow.pointer,
        modalDelegate?.pointer ?? ffi.nullptr,
        didEndSelector,
        contextInfo);
  }

  /// endSheet:
  void endSheet_(NSWindow sheet) {
    _objc_msgSend_235(this.pointer, _sel_endSheet_, sheet.pointer);
  }

  /// endSheet:returnCode:
  void endSheet_returnCode_(NSWindow sheet, int returnCode) {
    _objc_msgSend_236(
        this.pointer, _sel_endSheet_returnCode_, sheet.pointer, returnCode);
  }

  /// makeWindowsPerform:inOrder:
  NSWindow? makeWindowsPerform_inOrder_(
      ffi.Pointer<objc.ObjCSelector> selector, bool flag) {
    final _ret = _objc_msgSend_360(
        this.pointer, _sel_makeWindowsPerform_inOrder_, selector, flag);
    return _ret.address == 0
        ? null
        : NSWindow.castFromPointer(_ret, retain: true, release: true);
  }

  /// This method is deprecated as of macOS 10.12. Beginning in OS X 10.11 it would always return nil. Prior to this it would return an undefined graphics context that was not generally suitable for drawing.
  NSGraphicsContext? get context {
    final _ret = _objc_msgSend_80(this.pointer, _sel_context);
    return _ret.address == 0
        ? null
        : NSGraphicsContext.castFromPointer(_ret, retain: true, release: true);
  }

  /// init
  NSApplication init() {
    final _ret = _objc_msgSend_2(this.pointer, _sel_init);
    return NSApplication.castFromPointer(_ret, retain: true, release: true);
  }

  /// initWithCoder:
  NSApplication? initWithCoder_(objc.NSCoder coder) {
    final _ret =
        _objc_msgSend_45(this.pointer, _sel_initWithCoder_, coder.pointer);
    return _ret.address == 0
        ? null
        : NSApplication.castFromPointer(_ret, retain: true, release: true);
  }

  /// new
  static NSApplication new1() {
    final _ret = _objc_msgSend_2(_class_NSApplication, _sel_new);
    return NSApplication.castFromPointer(_ret, retain: false, release: true);
  }

  /// allocWithZone:
  static NSApplication allocWithZone_(ffi.Pointer<_NSZone> zone) {
    final _ret =
        _objc_msgSend_20(_class_NSApplication, _sel_allocWithZone_, zone);
    return NSApplication.castFromPointer(_ret, retain: false, release: true);
  }

  /// alloc
  static NSApplication alloc() {
    final _ret = _objc_msgSend_2(_class_NSApplication, _sel_alloc);
    return NSApplication.castFromPointer(_ret, retain: false, release: true);
  }
}

late final _class_NSApplication = objc.getClass("NSApplication");
late final _sel_sharedApplication = objc.registerName("sharedApplication");
final _objc_msgSend_21 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_delegate = objc.registerName("delegate");
final _objc_msgSend_22 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_setDelegate_ = objc.registerName("setDelegate:");
final _objc_msgSend_23 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<objc.ObjCObject>)>();
late final _sel_hide_ = objc.registerName("hide:");
final _objc_msgSend_24 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<objc.ObjCObject>)>();
late final _sel_unhide_ = objc.registerName("unhide:");
late final _sel_unhideWithoutActivation =
    objc.registerName("unhideWithoutActivation");

/// NSWindow
class NSWindow extends NSResponder {
  NSWindow._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release);

  /// Constructs a [NSWindow] that points to the same underlying object as [other].
  NSWindow.castFrom(objc.ObjCObjectBase other)
      : this._(other.pointer, retain: true, release: true);

  /// Constructs a [NSWindow] that wraps the given raw object pointer.
  NSWindow.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [NSWindow].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_0(obj.pointer, _sel_isKindOfClass_, _class_NSWindow);
  }

  /// frameRectForContentRect:styleMask:
  static void frameRectForContentRect_styleMask_(
      ffi.Pointer<CGRect> stret, CGRect cRect, NSWindowStyleMask style) {
    objc.useMsgSendVariants
        ? _objc_msgSend_25Stret(stret, _class_NSWindow,
            _sel_frameRectForContentRect_styleMask_, cRect, style.value)
        : stret.ref = _objc_msgSend_25(_class_NSWindow,
            _sel_frameRectForContentRect_styleMask_, cRect, style.value);
  }

  /// contentRectForFrameRect:styleMask:
  static void contentRectForFrameRect_styleMask_(
      ffi.Pointer<CGRect> stret, CGRect fRect, NSWindowStyleMask style) {
    objc.useMsgSendVariants
        ? _objc_msgSend_25Stret(stret, _class_NSWindow,
            _sel_contentRectForFrameRect_styleMask_, fRect, style.value)
        : stret.ref = _objc_msgSend_25(_class_NSWindow,
            _sel_contentRectForFrameRect_styleMask_, fRect, style.value);
  }

  /// minFrameWidthWithTitle:styleMask:
  static double minFrameWidthWithTitle_styleMask_(
      objc.NSString title, NSWindowStyleMask style) {
    return objc.useMsgSendVariants
        ? _objc_msgSend_26Fpret(_class_NSWindow,
            _sel_minFrameWidthWithTitle_styleMask_, title.pointer, style.value)
        : _objc_msgSend_26(_class_NSWindow,
            _sel_minFrameWidthWithTitle_styleMask_, title.pointer, style.value);
  }

  /// defaultDepthLimit
  static NSWindowDepth getDefaultDepthLimit() {
    final _ret = _objc_msgSend_27(_class_NSWindow, _sel_defaultDepthLimit);
    return NSWindowDepth.fromValue(_ret);
  }

  /// frameRectForContentRect:
  void frameRectForContentRect_(ffi.Pointer<CGRect> stret, CGRect contentRect) {
    objc.useMsgSendVariants
        ? _objc_msgSend_28Stret(
            stret, this.pointer, _sel_frameRectForContentRect_, contentRect)
        : stret.ref = _objc_msgSend_28(
            this.pointer, _sel_frameRectForContentRect_, contentRect);
  }

  /// contentRectForFrameRect:
  void contentRectForFrameRect_(ffi.Pointer<CGRect> stret, CGRect frameRect) {
    objc.useMsgSendVariants
        ? _objc_msgSend_28Stret(
            stret, this.pointer, _sel_contentRectForFrameRect_, frameRect)
        : stret.ref = _objc_msgSend_28(
            this.pointer, _sel_contentRectForFrameRect_, frameRect);
  }

  /// initWithContentRect:styleMask:backing:defer:
  NSWindow initWithContentRect_styleMask_backing_defer_(CGRect contentRect,
      NSWindowStyleMask style, NSBackingStoreType backingStoreType, bool flag) {
    final _ret = _objc_msgSend_29(
        this.pointer,
        _sel_initWithContentRect_styleMask_backing_defer_,
        contentRect,
        style.value,
        backingStoreType.value,
        flag);
    return NSWindow.castFromPointer(_ret, retain: true, release: true);
  }

  /// initWithContentRect:styleMask:backing:defer:screen:
  NSWindow initWithContentRect_styleMask_backing_defer_screen_(
      CGRect contentRect,
      NSWindowStyleMask style,
      NSBackingStoreType backingStoreType,
      bool flag,
      NSScreen? screen) {
    final _ret = _objc_msgSend_30(
        this.pointer,
        _sel_initWithContentRect_styleMask_backing_defer_screen_,
        contentRect,
        style.value,
        backingStoreType.value,
        flag,
        screen?.pointer ?? ffi.nullptr);
    return NSWindow.castFromPointer(_ret, retain: true, release: true);
  }

  /// initWithCoder:
  NSWindow? initWithCoder_(objc.NSCoder coder) {
    final _ret =
        _objc_msgSend_45(this.pointer, _sel_initWithCoder_, coder.pointer);
    return _ret.address == 0
        ? null
        : NSWindow.castFromPointer(_ret, retain: true, release: true);
  }

  /// title
  objc.NSString get title {
    final _ret = _objc_msgSend_3(this.pointer, _sel_title);
    return objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// setTitle:
  set title(objc.NSString value) {
    return _objc_msgSend_4(this.pointer, _sel_setTitle_, value.pointer);
  }

  /// !
  /// Secondary text that may be displayed adjacent to or below the primary title depending on the configuration of the window.
  /// A value of empty string will remove the subtitle from the window layout.
  objc.NSString get subtitle {
    final _ret = _objc_msgSend_3(this.pointer, _sel_subtitle);
    return objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// !
  /// Secondary text that may be displayed adjacent to or below the primary title depending on the configuration of the window.
  /// A value of empty string will remove the subtitle from the window layout.
  set subtitle(objc.NSString value) {
    return _objc_msgSend_4(this.pointer, _sel_setSubtitle_, value.pointer);
  }

  /// Default value is NSWindowTitleVisible
  NSWindowTitleVisibility get titleVisibility {
    final _ret = _objc_msgSend_32(this.pointer, _sel_titleVisibility);
    return NSWindowTitleVisibility.fromValue(_ret);
  }

  /// Default value is NSWindowTitleVisible
  set titleVisibility(NSWindowTitleVisibility value) {
    return _objc_msgSend_33(
        this.pointer, _sel_setTitleVisibility_, value.value);
  }

  /// When \c YES, the titlebar doesn't draw its background, allowing all buttons to show through, and "click through" to happen. In general, this is only useful when \c NSFullSizeContentViewWindowMask is set.
  bool get titlebarAppearsTransparent {
    return _objc_msgSend_13(this.pointer, _sel_titlebarAppearsTransparent);
  }

  /// When \c YES, the titlebar doesn't draw its background, allowing all buttons to show through, and "click through" to happen. In general, this is only useful when \c NSFullSizeContentViewWindowMask is set.
  set titlebarAppearsTransparent(bool value) {
    return _objc_msgSend_14(
        this.pointer, _sel_setTitlebarAppearsTransparent_, value);
  }

  /// Specifies how the titlebar area of the window should appear when the window displays an NSToolbar
  NSWindowToolbarStyle get toolbarStyle {
    final _ret = _objc_msgSend_34(this.pointer, _sel_toolbarStyle);
    return NSWindowToolbarStyle.fromValue(_ret);
  }

  /// Specifies how the titlebar area of the window should appear when the window displays an NSToolbar
  set toolbarStyle(NSWindowToolbarStyle value) {
    return _objc_msgSend_35(this.pointer, _sel_setToolbarStyle_, value.value);
  }

  /// The \c contentLayoutRect will return the area inside the window that is for non-obscured content. Typically, this is the same thing as the `contentView`'s frame. However, for windows with the \c NSFullSizeContentViewWindowMask set, there needs to be a way to determine the portion that is not under the toolbar. The \c contentLayoutRect returns the portion of the layout that is not obscured under the toolbar. \c contentLayoutRect is in window coordinates. It is KVO compliant. */
  void getContentLayoutRect(ffi.Pointer<CGRect> stret) {
    objc.useMsgSendVariants
        ? _objc_msgSend_36Stret(stret, this.pointer, _sel_contentLayoutRect)
        : stret.ref = _objc_msgSend_36(this.pointer, _sel_contentLayoutRect);
  }

  /// \c contentLayoutGuide is a corollary to \c contentLayoutRect. It can be used by autolayout constraints to automatically bind to the \c contentLayoutRect.
  objc.ObjCObjectBase? get contentLayoutGuide {
    final _ret = _objc_msgSend_22(this.pointer, _sel_contentLayoutGuide);
    return _ret.address == 0
        ? null
        : objc.ObjCObjectBase(_ret, retain: true, release: true);
  }

  /// The following methods allow you to add accessory views to the titlebar/toolbar area of a window. See NSTitlebarAccessoryViewController for more details.
  objc.NSArray get titlebarAccessoryViewControllers {
    final _ret =
        _objc_msgSend_37(this.pointer, _sel_titlebarAccessoryViewControllers);
    return objc.NSArray.castFromPointer(_ret, retain: true, release: true);
  }

  /// The following methods allow you to add accessory views to the titlebar/toolbar area of a window. See NSTitlebarAccessoryViewController for more details.
  set titlebarAccessoryViewControllers(objc.NSArray value) {
    return _objc_msgSend_38(
        this.pointer, _sel_setTitlebarAccessoryViewControllers_, value.pointer);
  }

  /// addTitlebarAccessoryViewController:
  void addTitlebarAccessoryViewController_(
      NSTitlebarAccessoryViewController childViewController) {
    _objc_msgSend_39(this.pointer, _sel_addTitlebarAccessoryViewController_,
        childViewController.pointer);
  }

  /// insertTitlebarAccessoryViewController:atIndex:
  void insertTitlebarAccessoryViewController_atIndex_(
      NSTitlebarAccessoryViewController childViewController, int index) {
    _objc_msgSend_40(
        this.pointer,
        _sel_insertTitlebarAccessoryViewController_atIndex_,
        childViewController.pointer,
        index);
  }

  /// NOTE: you can use this method, or removeFromParentViewController, which ever is easier.
  void removeTitlebarAccessoryViewControllerAtIndex_(int index) {
    _objc_msgSend_41(this.pointer,
        _sel_removeTitlebarAccessoryViewControllerAtIndex_, index);
  }

  /// !
  /// If url is not nil and its path is not empty, the window will show a document icon in the titlebar.
  /// If the url represents a filename or other resource with a known icon, that icon will be used as the document icon.  Otherwise the default document icon will be used.  The icon can be customized using `-[[NSWindow standardWindowButton:NSWindowDocumentIconButton] setImage:customImage]`.  If url is not nil and its path is not empty, the window will have a pop-up menu which can be shown via command-click on the area containing the document icon and title.  By default, this menu will display the path components of the url.  The presence and contents of this menu can be controlled by the delegate method `-[window:shouldPopUpDocumentPathMenu:]`
  /// If the url is nil or has an empty path, the window will not show a document icon and will not have a pop-up menu available via command-click.
  objc.NSURL? get representedURL {
    final _ret = _objc_msgSend_42(this.pointer, _sel_representedURL);
    return _ret.address == 0
        ? null
        : objc.NSURL.castFromPointer(_ret, retain: true, release: true);
  }

  /// !
  /// If url is not nil and its path is not empty, the window will show a document icon in the titlebar.
  /// If the url represents a filename or other resource with a known icon, that icon will be used as the document icon.  Otherwise the default document icon will be used.  The icon can be customized using `-[[NSWindow standardWindowButton:NSWindowDocumentIconButton] setImage:customImage]`.  If url is not nil and its path is not empty, the window will have a pop-up menu which can be shown via command-click on the area containing the document icon and title.  By default, this menu will display the path components of the url.  The presence and contents of this menu can be controlled by the delegate method `-[window:shouldPopUpDocumentPathMenu:]`
  /// If the url is nil or has an empty path, the window will not show a document icon and will not have a pop-up menu available via command-click.
  set representedURL(objc.NSURL? value) {
    return _objc_msgSend_43(
        this.pointer, _sel_setRepresentedURL_, value?.pointer ?? ffi.nullptr);
  }

  /// representedFilename
  objc.NSString get representedFilename {
    final _ret = _objc_msgSend_3(this.pointer, _sel_representedFilename);
    return objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// setRepresentedFilename:
  set representedFilename(objc.NSString value) {
    return _objc_msgSend_4(
        this.pointer, _sel_setRepresentedFilename_, value.pointer);
  }

  /// setTitleWithRepresentedFilename:
  void setTitleWithRepresentedFilename_(objc.NSString filename) {
    _objc_msgSend_12(
        this.pointer, _sel_setTitleWithRepresentedFilename_, filename.pointer);
  }

  /// isExcludedFromWindowsMenu
  bool get excludedFromWindowsMenu {
    return _objc_msgSend_13(this.pointer, _sel_isExcludedFromWindowsMenu);
  }

  /// setExcludedFromWindowsMenu:
  set excludedFromWindowsMenu(bool value) {
    return _objc_msgSend_14(
        this.pointer, _sel_setExcludedFromWindowsMenu_, value);
  }

  /// contentView
  NSView? get contentView {
    final _ret = _objc_msgSend_47(this.pointer, _sel_contentView);
    return _ret.address == 0
        ? null
        : NSView.castFromPointer(_ret, retain: true, release: true);
  }

  /// setContentView:
  set contentView(NSView? value) {
    return _objc_msgSend_147(
        this.pointer, _sel_setContentView_, value?.pointer ?? ffi.nullptr);
  }

  /// delegate
  objc.ObjCObjectBase? get delegate {
    final _ret = _objc_msgSend_22(this.pointer, _sel_delegate);
    return _ret.address == 0
        ? null
        : objc.ObjCObjectBase(_ret, retain: true, release: true);
  }

  /// setDelegate:
  set delegate(objc.ObjCObjectBase? value) {
    return _objc_msgSend_23(
        this.pointer, _sel_setDelegate_, value?.pointer ?? ffi.nullptr);
  }

  /// windowNumber
  int get windowNumber {
    return _objc_msgSend_79(this.pointer, _sel_windowNumber);
  }

  /// @note The styleMask can only be set on macOS 10.6 and later. Valid \c styleMask settings have the same restrictions as the \c styleMask passed to `-initWithContentRect:styleMask:backing:defer:`.  Some \c styleMask changes will cause the view hierarchy to be rebuilt, since there is a different subclass for the top level view of a borderless window than for the top level view of a titled window.
  NSWindowStyleMask get styleMask {
    final _ret = _objc_msgSend_185(this.pointer, _sel_styleMask);
    return NSWindowStyleMask.fromValue(_ret);
  }

  /// @note The styleMask can only be set on macOS 10.6 and later. Valid \c styleMask settings have the same restrictions as the \c styleMask passed to `-initWithContentRect:styleMask:backing:defer:`.  Some \c styleMask changes will cause the view hierarchy to be rebuilt, since there is a different subclass for the top level view of a borderless window than for the top level view of a titled window.
  set styleMask(NSWindowStyleMask value) {
    return _objc_msgSend_186(this.pointer, _sel_setStyleMask_, value.value);
  }

  /// fieldEditor:forObject:
  NSText? fieldEditor_forObject_(bool createFlag, objc.ObjCObjectBase? object) {
    final _ret = _objc_msgSend_206(this.pointer, _sel_fieldEditor_forObject_,
        createFlag, object?.pointer ?? ffi.nullptr);
    return _ret.address == 0
        ? null
        : NSText.castFromPointer(_ret, retain: true, release: true);
  }

  /// endEditingFor:
  void endEditingFor_(objc.ObjCObjectBase? object) {
    _objc_msgSend_24(
        this.pointer, _sel_endEditingFor_, object?.pointer ?? ffi.nullptr);
  }

  /// constrainFrameRect:toScreen:
  void constrainFrameRect_toScreen_(
      ffi.Pointer<CGRect> stret, CGRect frameRect, NSScreen? screen) {
    objc.useMsgSendVariants
        ? _objc_msgSend_207Stret(
            stret,
            this.pointer,
            _sel_constrainFrameRect_toScreen_,
            frameRect,
            screen?.pointer ?? ffi.nullptr)
        : stret.ref = _objc_msgSend_207(
            this.pointer,
            _sel_constrainFrameRect_toScreen_,
            frameRect,
            screen?.pointer ?? ffi.nullptr);
  }

  /// setFrame:display:
  void setFrame_display_(CGRect frameRect, bool flag) {
    _objc_msgSend_208(this.pointer, _sel_setFrame_display_, frameRect, flag);
  }

  /// setContentSize:
  void setContentSize_(CGSize size) {
    _objc_msgSend_59(this.pointer, _sel_setContentSize_, size);
  }

  /// setFrameOrigin:
  void setFrameOrigin_(CGPoint point) {
    _objc_msgSend_62(this.pointer, _sel_setFrameOrigin_, point);
  }

  /// setFrameTopLeftPoint:
  void setFrameTopLeftPoint_(CGPoint point) {
    _objc_msgSend_62(this.pointer, _sel_setFrameTopLeftPoint_, point);
  }

  /// cascadeTopLeftFromPoint:
  void cascadeTopLeftFromPoint_(
      ffi.Pointer<CGPoint> stret, CGPoint topLeftPoint) {
    objc.useMsgSendVariants
        ? _objc_msgSend_70Stret(
            stret, this.pointer, _sel_cascadeTopLeftFromPoint_, topLeftPoint)
        : stret.ref = _objc_msgSend_70(
            this.pointer, _sel_cascadeTopLeftFromPoint_, topLeftPoint);
  }

  /// frame
  void getFrame(ffi.Pointer<CGRect> stret) {
    objc.useMsgSendVariants
        ? _objc_msgSend_36Stret(stret, this.pointer, _sel_frame)
        : stret.ref = _objc_msgSend_36(this.pointer, _sel_frame);
  }

  /// ! Subclasses can override \c animationResizeTime: to control the total time for the frame change.
  /// \c newFrame is the rect passed into \c setFrame:display:animate:
  double animationResizeTime_(CGRect newFrame) {
    return objc.useMsgSendVariants
        ? _objc_msgSend_209Fpret(
            this.pointer, _sel_animationResizeTime_, newFrame)
        : _objc_msgSend_209(this.pointer, _sel_animationResizeTime_, newFrame);
  }

  /// ! \c setFrame:display:animate: is equivalent to \c setFrame:display: if the \c animateFlag is NO.
  /// If the \c animationFlag is YES, this method will perform a smooth resize of the window, where the total time for the resize is specified by \c -animationResizeTime:
  void setFrame_display_animate_(
      CGRect frameRect, bool displayFlag, bool animateFlag) {
    _objc_msgSend_210(this.pointer, _sel_setFrame_display_animate_, frameRect,
        displayFlag, animateFlag);
  }

  /// inLiveResize
  bool get inLiveResize {
    return _objc_msgSend_13(this.pointer, _sel_inLiveResize);
  }

  /// resizeIncrements
  void getResizeIncrements(ffi.Pointer<CGSize> stret) {
    objc.useMsgSendVariants
        ? _objc_msgSend_98Stret(stret, this.pointer, _sel_resizeIncrements)
        : stret.ref = _objc_msgSend_98(this.pointer, _sel_resizeIncrements);
  }

  /// setResizeIncrements:
  set resizeIncrements(CGSize value) {
    return _objc_msgSend_205(this.pointer, _sel_setResizeIncrements_, value);
  }

  /// aspectRatio
  void getAspectRatio(ffi.Pointer<CGSize> stret) {
    objc.useMsgSendVariants
        ? _objc_msgSend_98Stret(stret, this.pointer, _sel_aspectRatio)
        : stret.ref = _objc_msgSend_98(this.pointer, _sel_aspectRatio);
  }

  /// setAspectRatio:
  set aspectRatio(CGSize value) {
    return _objc_msgSend_205(this.pointer, _sel_setAspectRatio_, value);
  }

  /// contentResizeIncrements
  void getContentResizeIncrements(ffi.Pointer<CGSize> stret) {
    objc.useMsgSendVariants
        ? _objc_msgSend_98Stret(
            stret, this.pointer, _sel_contentResizeIncrements)
        : stret.ref =
            _objc_msgSend_98(this.pointer, _sel_contentResizeIncrements);
  }

  /// setContentResizeIncrements:
  set contentResizeIncrements(CGSize value) {
    return _objc_msgSend_205(
        this.pointer, _sel_setContentResizeIncrements_, value);
  }

  /// contentAspectRatio
  void getContentAspectRatio(ffi.Pointer<CGSize> stret) {
    objc.useMsgSendVariants
        ? _objc_msgSend_98Stret(stret, this.pointer, _sel_contentAspectRatio)
        : stret.ref = _objc_msgSend_98(this.pointer, _sel_contentAspectRatio);
  }

  /// setContentAspectRatio:
  set contentAspectRatio(CGSize value) {
    return _objc_msgSend_205(this.pointer, _sel_setContentAspectRatio_, value);
  }

  /// viewsNeedDisplay
  bool get viewsNeedDisplay {
    return _objc_msgSend_13(this.pointer, _sel_viewsNeedDisplay);
  }

  /// setViewsNeedDisplay:
  set viewsNeedDisplay(bool value) {
    return _objc_msgSend_14(this.pointer, _sel_setViewsNeedDisplay_, value);
  }

  /// displayIfNeeded
  void displayIfNeeded() {
    _objc_msgSend_11(this.pointer, _sel_displayIfNeeded);
  }

  /// display
  void display() {
    _objc_msgSend_11(this.pointer, _sel_display);
  }

  /// preservesContentDuringLiveResize
  bool get preservesContentDuringLiveResize {
    return _objc_msgSend_13(
        this.pointer, _sel_preservesContentDuringLiveResize);
  }

  /// setPreservesContentDuringLiveResize:
  set preservesContentDuringLiveResize(bool value) {
    return _objc_msgSend_14(
        this.pointer, _sel_setPreservesContentDuringLiveResize_, value);
  }

  /// update
  void update() {
    _objc_msgSend_11(this.pointer, _sel_update);
  }

  /// makeFirstResponder:
  bool makeFirstResponder_(NSResponder? responder) {
    return _objc_msgSend_211(this.pointer, _sel_makeFirstResponder_,
        responder?.pointer ?? ffi.nullptr);
  }

  /// firstResponder is Key Value Observing (KVO) compliant.
  NSResponder? get firstResponder {
    final _ret = _objc_msgSend_177(this.pointer, _sel_firstResponder);
    return _ret.address == 0
        ? null
        : NSResponder.castFromPointer(_ret, retain: true, release: true);
  }

  /// resizeFlags
  NSEventModifierFlags get resizeFlags {
    final _ret = _objc_msgSend_78(this.pointer, _sel_resizeFlags);
    return NSEventModifierFlags.fromValue(_ret);
  }

  /// close
  void close() {
    _objc_msgSend_11(this.pointer, _sel_close);
  }

  /// isReleasedWhenClosed
  bool get releasedWhenClosed {
    return _objc_msgSend_13(this.pointer, _sel_isReleasedWhenClosed);
  }

  /// setReleasedWhenClosed:
  set releasedWhenClosed(bool value) {
    return _objc_msgSend_14(this.pointer, _sel_setReleasedWhenClosed_, value);
  }

  /// miniaturize:
  void miniaturize_(objc.ObjCObjectBase? sender) {
    _objc_msgSend_24(
        this.pointer, _sel_miniaturize_, sender?.pointer ?? ffi.nullptr);
  }

  /// deminiaturize:
  void deminiaturize_(objc.ObjCObjectBase? sender) {
    _objc_msgSend_24(
        this.pointer, _sel_deminiaturize_, sender?.pointer ?? ffi.nullptr);
  }

  /// isZoomed
  bool get zoomed {
    return _objc_msgSend_13(this.pointer, _sel_isZoomed);
  }

  /// zoom:
  void zoom_(objc.ObjCObjectBase? sender) {
    _objc_msgSend_24(this.pointer, _sel_zoom_, sender?.pointer ?? ffi.nullptr);
  }

  /// isMiniaturized
  bool get miniaturized {
    return _objc_msgSend_13(this.pointer, _sel_isMiniaturized);
  }

  /// tryToPerform:with:
  bool tryToPerform_with_(
      ffi.Pointer<objc.ObjCSelector> action, objc.ObjCObjectBase? object) {
    return _objc_msgSend_179(this.pointer, _sel_tryToPerform_with_, action,
        object?.pointer ?? ffi.nullptr);
  }

  /// validRequestorForSendType:returnType:
  objc.ObjCObjectBase? validRequestorForSendType_returnType_(
      objc.NSString? sendType, objc.NSString? returnType) {
    final _ret = _objc_msgSend_180(
        this.pointer,
        _sel_validRequestorForSendType_returnType_,
        sendType?.pointer ?? ffi.nullptr,
        returnType?.pointer ?? ffi.nullptr);
    return _ret.address == 0
        ? null
        : objc.ObjCObjectBase(_ret, retain: true, release: true);
  }

  /// backgroundColor
  NSColor get backgroundColor {
    final _ret = _objc_msgSend_212(this.pointer, _sel_backgroundColor);
    return NSColor.castFromPointer(_ret, retain: true, release: true);
  }

  /// setBackgroundColor:
  set backgroundColor(NSColor value) {
    return _objc_msgSend_213(
        this.pointer, _sel_setBackgroundColor_, value.pointer);
  }

  /// Indicates the thickness of a given border of the window. NSMinYEdge is the bottom edge of the window, while NSMaxYEdge is the top edge of the window. This method may throw an exception for values that don't apply to the current window styleMask; specifically, passing NSMaxYEdge for a non-textured window will always raise. The contentBorder does not include the titlebar or toolbar.
  void setContentBorderThickness_forEdge_(double thickness, NSRectEdge edge) {
    _objc_msgSend_214(this.pointer, _sel_setContentBorderThickness_forEdge_,
        thickness, edge.value);
  }

  /// contentBorderThicknessForEdge:
  double contentBorderThicknessForEdge_(NSRectEdge edge) {
    return objc.useMsgSendVariants
        ? _objc_msgSend_215Fpret(
            this.pointer, _sel_contentBorderThicknessForEdge_, edge.value)
        : _objc_msgSend_215(
            this.pointer, _sel_contentBorderThicknessForEdge_, edge.value);
  }

  /// setAutorecalculatesContentBorderThickness:forEdge:
  void setAutorecalculatesContentBorderThickness_forEdge_(
      bool flag, NSRectEdge edge) {
    _objc_msgSend_216(
        this.pointer,
        _sel_setAutorecalculatesContentBorderThickness_forEdge_,
        flag,
        edge.value);
  }

  /// autorecalculatesContentBorderThicknessForEdge:
  bool autorecalculatesContentBorderThicknessForEdge_(NSRectEdge edge) {
    return _objc_msgSend_217(this.pointer,
        _sel_autorecalculatesContentBorderThicknessForEdge_, edge.value);
  }

  /// Calling -setMovable with a flag of NO will disable server-side dragging of the window via titlebar or background.  -setMovableByWindowBackground:YES is ignored on a window that returns NO from -isMovable.  When a window returns NO for -isMovable, it can be assigned to a different space with its relative screen position preserved.  Note that a resizable window may still be resized, and the window frame may be changed programmatically.  Applications may choose to enable application-controlled window dragging after disabling server-side dragging (perhaps to achieve snapping or pinning) by handling the mouseDown/mouseDragged/mouseUp sequence in -sendEvent: in an NSWindow subclass.  Note that a non movable window will also not be moved (or resized) by the system in response to a display reconfiguration.
  bool get movable {
    return _objc_msgSend_13(this.pointer, _sel_isMovable);
  }

  /// Calling -setMovable with a flag of NO will disable server-side dragging of the window via titlebar or background.  -setMovableByWindowBackground:YES is ignored on a window that returns NO from -isMovable.  When a window returns NO for -isMovable, it can be assigned to a different space with its relative screen position preserved.  Note that a resizable window may still be resized, and the window frame may be changed programmatically.  Applications may choose to enable application-controlled window dragging after disabling server-side dragging (perhaps to achieve snapping or pinning) by handling the mouseDown/mouseDragged/mouseUp sequence in -sendEvent: in an NSWindow subclass.  Note that a non movable window will also not be moved (or resized) by the system in response to a display reconfiguration.
  set movable(bool value) {
    return _objc_msgSend_14(this.pointer, _sel_setMovable_, value);
  }

  /// isMovableByWindowBackground
  bool get movableByWindowBackground {
    return _objc_msgSend_13(this.pointer, _sel_isMovableByWindowBackground);
  }

  /// setMovableByWindowBackground:
  set movableByWindowBackground(bool value) {
    return _objc_msgSend_14(
        this.pointer, _sel_setMovableByWindowBackground_, value);
  }

  /// hidesOnDeactivate
  bool get hidesOnDeactivate {
    return _objc_msgSend_13(this.pointer, _sel_hidesOnDeactivate);
  }

  /// setHidesOnDeactivate:
  set hidesOnDeactivate(bool value) {
    return _objc_msgSend_14(this.pointer, _sel_setHidesOnDeactivate_, value);
  }

  /// Indicates whether a window can be hidden during `-[NSApplication hide:]`.  Default is \c YES.
  bool get canHide {
    return _objc_msgSend_13(this.pointer, _sel_canHide);
  }

  /// Indicates whether a window can be hidden during `-[NSApplication hide:]`.  Default is \c YES.
  set canHide(bool value) {
    return _objc_msgSend_14(this.pointer, _sel_setCanHide_, value);
  }

  /// center
  void center() {
    _objc_msgSend_11(this.pointer, _sel_center);
  }

  /// makeKeyAndOrderFront:
  void makeKeyAndOrderFront_(objc.ObjCObjectBase? sender) {
    _objc_msgSend_24(this.pointer, _sel_makeKeyAndOrderFront_,
        sender?.pointer ?? ffi.nullptr);
  }

  /// orderFront:
  void orderFront_(objc.ObjCObjectBase? sender) {
    _objc_msgSend_24(
        this.pointer, _sel_orderFront_, sender?.pointer ?? ffi.nullptr);
  }

  /// orderBack:
  void orderBack_(objc.ObjCObjectBase? sender) {
    _objc_msgSend_24(
        this.pointer, _sel_orderBack_, sender?.pointer ?? ffi.nullptr);
  }

  /// orderOut:
  void orderOut_(objc.ObjCObjectBase? sender) {
    _objc_msgSend_24(
        this.pointer, _sel_orderOut_, sender?.pointer ?? ffi.nullptr);
  }

  /// orderWindow:relativeTo:
  void orderWindow_relativeTo_(NSWindowOrderingMode place, int otherWin) {
    _objc_msgSend_218(
        this.pointer, _sel_orderWindow_relativeTo_, place.value, otherWin);
  }

  /// orderFrontRegardless
  void orderFrontRegardless() {
    _objc_msgSend_11(this.pointer, _sel_orderFrontRegardless);
  }

  /// miniwindowImage
  NSImage? get miniwindowImage {
    final _ret = _objc_msgSend_140(this.pointer, _sel_miniwindowImage);
    return _ret.address == 0
        ? null
        : NSImage.castFromPointer(_ret, retain: true, release: true);
  }

  /// setMiniwindowImage:
  set miniwindowImage(NSImage? value) {
    return _objc_msgSend_141(
        this.pointer, _sel_setMiniwindowImage_, value?.pointer ?? ffi.nullptr);
  }

  /// miniwindowTitle
  objc.NSString get miniwindowTitle {
    final _ret = _objc_msgSend_3(this.pointer, _sel_miniwindowTitle);
    return objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// setMiniwindowTitle:
  set miniwindowTitle(objc.NSString value) {
    return _objc_msgSend_4(
        this.pointer, _sel_setMiniwindowTitle_, value.pointer);
  }

  /// dockTile
  NSDockTile get dockTile {
    final _ret = _objc_msgSend_219(this.pointer, _sel_dockTile);
    return NSDockTile.castFromPointer(_ret, retain: true, release: true);
  }

  /// isDocumentEdited
  bool get documentEdited {
    return _objc_msgSend_13(this.pointer, _sel_isDocumentEdited);
  }

  /// setDocumentEdited:
  set documentEdited(bool value) {
    return _objc_msgSend_14(this.pointer, _sel_setDocumentEdited_, value);
  }

  /// isVisible
  bool get visible {
    return _objc_msgSend_13(this.pointer, _sel_isVisible);
  }

  /// isKeyWindow
  bool get keyWindow {
    return _objc_msgSend_13(this.pointer, _sel_isKeyWindow);
  }

  /// isMainWindow
  bool get mainWindow {
    return _objc_msgSend_13(this.pointer, _sel_isMainWindow);
  }

  /// canBecomeKeyWindow
  bool get canBecomeKeyWindow {
    return _objc_msgSend_13(this.pointer, _sel_canBecomeKeyWindow);
  }

  /// canBecomeMainWindow
  bool get canBecomeMainWindow {
    return _objc_msgSend_13(this.pointer, _sel_canBecomeMainWindow);
  }

  /// ! Makes the window key and main if eligible, updating NSAppication's `-keyWindow` and `-mainWindow` properties.
  void makeKeyWindow() {
    _objc_msgSend_11(this.pointer, _sel_makeKeyWindow);
  }

  /// ! Makes the window main if eligible. Updates NSApplication's `-mainWindow` property.
  void makeMainWindow() {
    _objc_msgSend_11(this.pointer, _sel_makeMainWindow);
  }

  /// ! Informs the window that it has become the key window. This method exists as an override point. Do not invoke directly. Instead, invoke `-makeKeyWindow`.
  void becomeKeyWindow() {
    _objc_msgSend_11(this.pointer, _sel_becomeKeyWindow);
  }

  /// ! Informs the window that it has stopped being the key window. This method exists as an override point. Do not invoke directly. Windows automatically receive this message when deactivating or when another window has become key.
  void resignKeyWindow() {
    _objc_msgSend_11(this.pointer, _sel_resignKeyWindow);
  }

  /// ! Informs the window that it has become the main window. This method exists as an override point. Do not invoke directly. Instead, invoke `-makeMainWindow`.
  void becomeMainWindow() {
    _objc_msgSend_11(this.pointer, _sel_becomeMainWindow);
  }

  /// ! Informs the window that it has stopped being the main window. This method exists as an override point. Do not invoke directly. Windows automatically receive this message when deactivating or when another window has become main.
  void resignMainWindow() {
    _objc_msgSend_11(this.pointer, _sel_resignMainWindow);
  }

  /// worksWhenModal
  bool get worksWhenModal {
    return _objc_msgSend_13(this.pointer, _sel_worksWhenModal);
  }

  /// ! Normally, application termination is prohibited when a modal window or sheet is open, without consulting the application delegate.  Some windows like the open panel or toolbar customization sheet should not prevent application termination.  `-setPreventsApplicationTerminationWhenModal:NO` on a modal window or sheet will override the default behavior and allow application termination to proceed, either through the sudden termination path if enabled, or on to the next step of consulting the application delegate.  By default, `-preventsApplicationTerminationWhenModal` returns \c YES
  bool get preventsApplicationTerminationWhenModal {
    return _objc_msgSend_13(
        this.pointer, _sel_preventsApplicationTerminationWhenModal);
  }

  /// ! Normally, application termination is prohibited when a modal window or sheet is open, without consulting the application delegate.  Some windows like the open panel or toolbar customization sheet should not prevent application termination.  `-setPreventsApplicationTerminationWhenModal:NO` on a modal window or sheet will override the default behavior and allow application termination to proceed, either through the sudden termination path if enabled, or on to the next step of consulting the application delegate.  By default, `-preventsApplicationTerminationWhenModal` returns \c YES
  set preventsApplicationTerminationWhenModal(bool value) {
    return _objc_msgSend_14(
        this.pointer, _sel_setPreventsApplicationTerminationWhenModal_, value);
  }

  /// Methods to convert window coordinates to screen coordinates
  void convertRectToScreen_(ffi.Pointer<CGRect> stret, CGRect rect) {
    objc.useMsgSendVariants
        ? _objc_msgSend_28Stret(
            stret, this.pointer, _sel_convertRectToScreen_, rect)
        : stret.ref =
            _objc_msgSend_28(this.pointer, _sel_convertRectToScreen_, rect);
  }

  /// convertRectFromScreen:
  void convertRectFromScreen_(ffi.Pointer<CGRect> stret, CGRect rect) {
    objc.useMsgSendVariants
        ? _objc_msgSend_28Stret(
            stret, this.pointer, _sel_convertRectFromScreen_, rect)
        : stret.ref =
            _objc_msgSend_28(this.pointer, _sel_convertRectFromScreen_, rect);
  }

  /// convertPointToScreen:
  void convertPointToScreen_(ffi.Pointer<CGPoint> stret, CGPoint point) {
    objc.useMsgSendVariants
        ? _objc_msgSend_70Stret(
            stret, this.pointer, _sel_convertPointToScreen_, point)
        : stret.ref =
            _objc_msgSend_70(this.pointer, _sel_convertPointToScreen_, point);
  }

  /// convertPointFromScreen:
  void convertPointFromScreen_(ffi.Pointer<CGPoint> stret, CGPoint point) {
    objc.useMsgSendVariants
        ? _objc_msgSend_70Stret(
            stret, this.pointer, _sel_convertPointFromScreen_, point)
        : stret.ref =
            _objc_msgSend_70(this.pointer, _sel_convertPointFromScreen_, point);
  }

  /// Methods to convert to/from a pixel integral backing store space
  void convertRectToBacking_(ffi.Pointer<CGRect> stret, CGRect rect) {
    objc.useMsgSendVariants
        ? _objc_msgSend_28Stret(
            stret, this.pointer, _sel_convertRectToBacking_, rect)
        : stret.ref =
            _objc_msgSend_28(this.pointer, _sel_convertRectToBacking_, rect);
  }

  /// convertRectFromBacking:
  void convertRectFromBacking_(ffi.Pointer<CGRect> stret, CGRect rect) {
    objc.useMsgSendVariants
        ? _objc_msgSend_28Stret(
            stret, this.pointer, _sel_convertRectFromBacking_, rect)
        : stret.ref =
            _objc_msgSend_28(this.pointer, _sel_convertRectFromBacking_, rect);
  }

  /// convertPointToBacking:
  void convertPointToBacking_(ffi.Pointer<CGPoint> stret, CGPoint point) {
    objc.useMsgSendVariants
        ? _objc_msgSend_70Stret(
            stret, this.pointer, _sel_convertPointToBacking_, point)
        : stret.ref =
            _objc_msgSend_70(this.pointer, _sel_convertPointToBacking_, point);
  }

  /// convertPointFromBacking:
  void convertPointFromBacking_(ffi.Pointer<CGPoint> stret, CGPoint point) {
    objc.useMsgSendVariants
        ? _objc_msgSend_70Stret(
            stret, this.pointer, _sel_convertPointFromBacking_, point)
        : stret.ref = _objc_msgSend_70(
            this.pointer, _sel_convertPointFromBacking_, point);
  }

  /// Use `NSIntegralRectWithOptions()` to produce a backing store pixel aligned rectangle from the given input rectangle in window coordinates.
  void backingAlignedRect_options_(
      ffi.Pointer<CGRect> stret, CGRect rect, NSAlignmentOptions options) {
    objc.useMsgSendVariants
        ? _objc_msgSend_69Stret(stret, this.pointer,
            _sel_backingAlignedRect_options_, rect, options.value)
        : stret.ref = _objc_msgSend_69(this.pointer,
            _sel_backingAlignedRect_options_, rect, options.value);
  }

  /// Returns the scale factor representing the number of backing store pixels corresponding to each linear unit in window space on this \c NSWindow. This method is provided for rare cases when the explicit scale factor is needed. Please use `-convert*ToBacking:` methods whenever possible.
  double get backingScaleFactor {
    return objc.useMsgSendVariants
        ? _objc_msgSend_10Fpret(this.pointer, _sel_backingScaleFactor)
        : _objc_msgSend_10(this.pointer, _sel_backingScaleFactor);
  }

  /// performClose:
  void performClose_(objc.ObjCObjectBase? sender) {
    _objc_msgSend_24(
        this.pointer, _sel_performClose_, sender?.pointer ?? ffi.nullptr);
  }

  /// performMiniaturize:
  void performMiniaturize_(objc.ObjCObjectBase? sender) {
    _objc_msgSend_24(
        this.pointer, _sel_performMiniaturize_, sender?.pointer ?? ffi.nullptr);
  }

  /// performZoom:
  void performZoom_(objc.ObjCObjectBase? sender) {
    _objc_msgSend_24(
        this.pointer, _sel_performZoom_, sender?.pointer ?? ffi.nullptr);
  }

  /// dataWithEPSInsideRect:
  objc.NSData dataWithEPSInsideRect_(CGRect rect) {
    final _ret =
        _objc_msgSend_220(this.pointer, _sel_dataWithEPSInsideRect_, rect);
    return objc.NSData.castFromPointer(_ret, retain: true, release: true);
  }

  /// dataWithPDFInsideRect:
  objc.NSData dataWithPDFInsideRect_(CGRect rect) {
    final _ret =
        _objc_msgSend_220(this.pointer, _sel_dataWithPDFInsideRect_, rect);
    return objc.NSData.castFromPointer(_ret, retain: true, release: true);
  }

  /// print:
  void print_(objc.ObjCObjectBase? sender) {
    _objc_msgSend_24(this.pointer, _sel_print_, sender?.pointer ?? ffi.nullptr);
  }

  /// !
  /// Default is \c NO. Set to \c YES to allow a window to display tooltips even when the application is in the background.  Note that, enabling tooltips in an inactive application will cause the app to do work any time the mouse passes over the window.  This can degrade system performance.
  /// Returns \c YES if this window displays tooltips even when the application is in the background.  To configure this setting you should call `-setAllowsToolTipsWhenApplicationIsInactive:` instead of overriding `-allowsToolTipsWhenApplicationIsInactive`.
  bool get allowsToolTipsWhenApplicationIsInactive {
    return _objc_msgSend_13(
        this.pointer, _sel_allowsToolTipsWhenApplicationIsInactive);
  }

  /// !
  /// Default is \c NO. Set to \c YES to allow a window to display tooltips even when the application is in the background.  Note that, enabling tooltips in an inactive application will cause the app to do work any time the mouse passes over the window.  This can degrade system performance.
  /// Returns \c YES if this window displays tooltips even when the application is in the background.  To configure this setting you should call `-setAllowsToolTipsWhenApplicationIsInactive:` instead of overriding `-allowsToolTipsWhenApplicationIsInactive`.
  set allowsToolTipsWhenApplicationIsInactive(bool value) {
    return _objc_msgSend_14(
        this.pointer, _sel_setAllowsToolTipsWhenApplicationIsInactive_, value);
  }

  /// backingType
  NSBackingStoreType get backingType {
    final _ret = _objc_msgSend_221(this.pointer, _sel_backingType);
    return NSBackingStoreType.fromValue(_ret);
  }

  /// setBackingType:
  set backingType(NSBackingStoreType value) {
    return _objc_msgSend_222(this.pointer, _sel_setBackingType_, value.value);
  }

  /// level
  int get level {
    return _objc_msgSend_79(this.pointer, _sel_level);
  }

  /// setLevel:
  set level(int value) {
    return _objc_msgSend_142(this.pointer, _sel_setLevel_, value);
  }

  /// depthLimit
  NSWindowDepth get depthLimit {
    final _ret = _objc_msgSend_27(this.pointer, _sel_depthLimit);
    return NSWindowDepth.fromValue(_ret);
  }

  /// setDepthLimit:
  set depthLimit(NSWindowDepth value) {
    return _objc_msgSend_223(this.pointer, _sel_setDepthLimit_, value.value);
  }

  /// setDynamicDepthLimit:
  void setDynamicDepthLimit_(bool flag) {
    _objc_msgSend_152(this.pointer, _sel_setDynamicDepthLimit_, flag);
  }

  /// hasDynamicDepthLimit
  bool get hasDynamicDepthLimit {
    return _objc_msgSend_13(this.pointer, _sel_hasDynamicDepthLimit);
  }

  /// ! The screen property returns the best screen for the window. If the window only intersects one screen, it returns that screen. If it intersects more than one screen, then it resolves the tie through based on what space it is mostly on. It may return nil if there are no available screens, or it is completely off screen.
  NSScreen? get screen {
    final _ret = _objc_msgSend_224(this.pointer, _sel_screen);
    return _ret.address == 0
        ? null
        : NSScreen.castFromPointer(_ret, retain: true, release: true);
  }

  /// deepestScreen
  NSScreen? get deepestScreen {
    final _ret = _objc_msgSend_224(this.pointer, _sel_deepestScreen);
    return _ret.address == 0
        ? null
        : NSScreen.castFromPointer(_ret, retain: true, release: true);
  }

  /// hasShadow
  bool get hasShadow {
    return _objc_msgSend_13(this.pointer, _sel_hasShadow);
  }

  /// setHasShadow:
  set hasShadow(bool value) {
    return _objc_msgSend_14(this.pointer, _sel_setHasShadow_, value);
  }

  /// invalidateShadow
  void invalidateShadow() {
    _objc_msgSend_11(this.pointer, _sel_invalidateShadow);
  }

  /// alphaValue
  double get alphaValue {
    return objc.useMsgSendVariants
        ? _objc_msgSend_10Fpret(this.pointer, _sel_alphaValue)
        : _objc_msgSend_10(this.pointer, _sel_alphaValue);
  }

  /// setAlphaValue:
  set alphaValue(double value) {
    return _objc_msgSend_64(this.pointer, _sel_setAlphaValue_, value);
  }

  /// isOpaque
  bool get opaque {
    return _objc_msgSend_13(this.pointer, _sel_isOpaque);
  }

  /// setOpaque:
  set opaque(bool value) {
    return _objc_msgSend_14(this.pointer, _sel_setOpaque_, value);
  }

  /// ! `-setSharingType:` specifies whether the window content can be read and/or written from another process.  The default sharing type is \c NSWindowSharingReadOnly, which means other processes can read the window content (eg. for window capture) but cannot modify it.  If you set your window sharing type to \c NSWindowSharingNone, so that the content cannot be captured, your window will also not be able to participate in a number of system services, so this setting should be used with caution.  If you set your window sharing type to \c NSWindowSharingReadWrite, other processes can both read and modify the window content.
  NSWindowSharingType get sharingType {
    final _ret = _objc_msgSend_225(this.pointer, _sel_sharingType);
    return NSWindowSharingType.fromValue(_ret);
  }

  /// ! `-setSharingType:` specifies whether the window content can be read and/or written from another process.  The default sharing type is \c NSWindowSharingReadOnly, which means other processes can read the window content (eg. for window capture) but cannot modify it.  If you set your window sharing type to \c NSWindowSharingNone, so that the content cannot be captured, your window will also not be able to participate in a number of system services, so this setting should be used with caution.  If you set your window sharing type to \c NSWindowSharingReadWrite, other processes can both read and modify the window content.
  set sharingType(NSWindowSharingType value) {
    return _objc_msgSend_226(this.pointer, _sel_setSharingType_, value.value);
  }

  /// ! Controls whether threading of view drawing should be enabled for this window.  Defaults to \c YES.  When this is set to \c YES, AppKit's view system is allowed to perform `-drawRect:` activity for the window's views on threads other than the main thread, for views that have `canDrawConcurrently == YES`.  When this is set to \c NO, the window's views will be drawn serially as on 10.5 and earlier, even though some of the views may have `canDrawConcurrently == YES`.
  bool get allowsConcurrentViewDrawing {
    return _objc_msgSend_13(this.pointer, _sel_allowsConcurrentViewDrawing);
  }

  /// ! Controls whether threading of view drawing should be enabled for this window.  Defaults to \c YES.  When this is set to \c YES, AppKit's view system is allowed to perform `-drawRect:` activity for the window's views on threads other than the main thread, for views that have `canDrawConcurrently == YES`.  When this is set to \c NO, the window's views will be drawn serially as on 10.5 and earlier, even though some of the views may have `canDrawConcurrently == YES`.
  set allowsConcurrentViewDrawing(bool value) {
    return _objc_msgSend_14(
        this.pointer, _sel_setAllowsConcurrentViewDrawing_, value);
  }

  /// displaysWhenScreenProfileChanges
  bool get displaysWhenScreenProfileChanges {
    return _objc_msgSend_13(
        this.pointer, _sel_displaysWhenScreenProfileChanges);
  }

  /// setDisplaysWhenScreenProfileChanges:
  set displaysWhenScreenProfileChanges(bool value) {
    return _objc_msgSend_14(
        this.pointer, _sel_setDisplaysWhenScreenProfileChanges_, value);
  }

  /// !
  /// In recent macOS versions this method does not do anything and should not be called.
  void disableScreenUpdatesUntilFlush() {
    _objc_msgSend_11(this.pointer, _sel_disableScreenUpdatesUntilFlush);
  }

  /// ! This API controls whether the receiver is permitted onscreen before the user has logged in.  This property is off by default.  Alert panels and windows presented by input managers are examples of windows which should have this property set.
  bool get canBecomeVisibleWithoutLogin {
    return _objc_msgSend_13(this.pointer, _sel_canBecomeVisibleWithoutLogin);
  }

  /// ! This API controls whether the receiver is permitted onscreen before the user has logged in.  This property is off by default.  Alert panels and windows presented by input managers are examples of windows which should have this property set.
  set canBecomeVisibleWithoutLogin(bool value) {
    return _objc_msgSend_14(
        this.pointer, _sel_setCanBecomeVisibleWithoutLogin_, value);
  }

  /// collectionBehavior
  NSWindowCollectionBehavior get collectionBehavior {
    final _ret = _objc_msgSend_227(this.pointer, _sel_collectionBehavior);
    return NSWindowCollectionBehavior.fromValue(_ret);
  }

  /// setCollectionBehavior:
  set collectionBehavior(NSWindowCollectionBehavior value) {
    return _objc_msgSend_228(
        this.pointer, _sel_setCollectionBehavior_, value.value);
  }

  /// ! Provides for per-window control over automatic orderFront/orderOut animation behaviors added in 10.7.  Can be set to \c NSWindowAnimationBehaviorNone to disable Appkit's automatic animations for a given window, or to one of the other non-Default \c NSWindowAnimationBehavior values to override AppKit's automatic inference of appropriate animation behavior based on the window's apparent type.
  NSWindowAnimationBehavior get animationBehavior {
    final _ret = _objc_msgSend_229(this.pointer, _sel_animationBehavior);
    return NSWindowAnimationBehavior.fromValue(_ret);
  }

  /// ! Provides for per-window control over automatic orderFront/orderOut animation behaviors added in 10.7.  Can be set to \c NSWindowAnimationBehaviorNone to disable Appkit's automatic animations for a given window, or to one of the other non-Default \c NSWindowAnimationBehavior values to override AppKit's automatic inference of appropriate animation behavior based on the window's apparent type.
  set animationBehavior(NSWindowAnimationBehavior value) {
    return _objc_msgSend_230(
        this.pointer, _sel_setAnimationBehavior_, value.value);
  }

  /// ! Returns \c YES if this window is associated with the active space.  For visible windows, this API indicates whether the window is currently visible on the active space.  For offscreen windows, it indicates whether ordering the window onscreen would make it bring it onto the active space
  bool get onActiveSpace {
    return _objc_msgSend_13(this.pointer, _sel_isOnActiveSpace);
  }

  /// ! `-toggleFullScreen:` enters or exits for full screen. A window must have \c NSWindowCollectionBehaviorFullScreenAuxiliary or \c NSWindowCollectionBehaviorFullScreenPrimary included in the \c collectionBehavior property; if it does not, this method may simply do nothing.
  void toggleFullScreen_(objc.ObjCObjectBase? sender) {
    _objc_msgSend_24(
        this.pointer, _sel_toggleFullScreen_, sender?.pointer ?? ffi.nullptr);
  }

  /// stringWithSavedFrame
  objc.NSString get stringWithSavedFrame {
    final _ret = _objc_msgSend_3(this.pointer, _sel_stringWithSavedFrame);
    return objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// setFrameFromString:
  void setFrameFromString_(objc.NSString string) {
    _objc_msgSend_12(this.pointer, _sel_setFrameFromString_, string.pointer);
  }

  /// saveFrameUsingName:
  void saveFrameUsingName_(objc.NSString name) {
    _objc_msgSend_12(this.pointer, _sel_saveFrameUsingName_, name.pointer);
  }

  /// Set force=YES to use setFrameUsingName on a non-resizable window
  bool setFrameUsingName_force_(objc.NSString name, bool force) {
    return _objc_msgSend_190(
        this.pointer, _sel_setFrameUsingName_force_, name.pointer, force);
  }

  /// setFrameUsingName:
  bool setFrameUsingName_(objc.NSString name) {
    return _objc_msgSend_191(
        this.pointer, _sel_setFrameUsingName_, name.pointer);
  }

  /// setFrameAutosaveName:
  bool setFrameAutosaveName_(objc.NSString name) {
    return _objc_msgSend_191(
        this.pointer, _sel_setFrameAutosaveName_, name.pointer);
  }

  /// frameAutosaveName
  objc.NSString get frameAutosaveName {
    final _ret = _objc_msgSend_3(this.pointer, _sel_frameAutosaveName);
    return objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// removeFrameUsingName:
  static void removeFrameUsingName_(objc.NSString name) {
    _objc_msgSend_12(_class_NSWindow, _sel_removeFrameUsingName_, name.pointer);
  }

  /// NOTE: minSize/contentMinSize and maxSize/contentMaxSize are ignored when using autolayout.
  void getMinSize(ffi.Pointer<CGSize> stret) {
    objc.useMsgSendVariants
        ? _objc_msgSend_98Stret(stret, this.pointer, _sel_minSize)
        : stret.ref = _objc_msgSend_98(this.pointer, _sel_minSize);
  }

  /// NOTE: minSize/contentMinSize and maxSize/contentMaxSize are ignored when using autolayout.
  set minSize(CGSize value) {
    return _objc_msgSend_205(this.pointer, _sel_setMinSize_, value);
  }

  /// maxSize
  void getMaxSize(ffi.Pointer<CGSize> stret) {
    objc.useMsgSendVariants
        ? _objc_msgSend_98Stret(stret, this.pointer, _sel_maxSize)
        : stret.ref = _objc_msgSend_98(this.pointer, _sel_maxSize);
  }

  /// setMaxSize:
  set maxSize(CGSize value) {
    return _objc_msgSend_205(this.pointer, _sel_setMaxSize_, value);
  }

  /// contentMinSize
  void getContentMinSize(ffi.Pointer<CGSize> stret) {
    objc.useMsgSendVariants
        ? _objc_msgSend_98Stret(stret, this.pointer, _sel_contentMinSize)
        : stret.ref = _objc_msgSend_98(this.pointer, _sel_contentMinSize);
  }

  /// setContentMinSize:
  set contentMinSize(CGSize value) {
    return _objc_msgSend_205(this.pointer, _sel_setContentMinSize_, value);
  }

  /// contentMaxSize
  void getContentMaxSize(ffi.Pointer<CGSize> stret) {
    objc.useMsgSendVariants
        ? _objc_msgSend_98Stret(stret, this.pointer, _sel_contentMaxSize)
        : stret.ref = _objc_msgSend_98(this.pointer, _sel_contentMaxSize);
  }

  /// setContentMaxSize:
  set contentMaxSize(CGSize value) {
    return _objc_msgSend_205(this.pointer, _sel_setContentMaxSize_, value);
  }

  /// These are the min and max values for a full screen tiled window.
  ///
  /// In general, one should not need to explicitly set the min/maxFullScreenContentSize. If an application does not change its window content upon entering full screen, then the normal auto layout min and max size will be sufficient, and one should not set these values. If an application does significantly rework the UI in full screen, then it may be necessary to set a min/maxFullScreenContentSize. This size is what is used to determine if a window can fit when it is in full screen in a tile. This property may be used even if the window does not support full screen, but are implicitly opted into supporting a full screen tile based on resizing behavior and window properties (see the collectionBehavior property). By default, the system uses auto layout to determine the min and max sizes. If auto layout is not used, contentMinSize and contentMaxSize are queried.
  void getMinFullScreenContentSize(ffi.Pointer<CGSize> stret) {
    objc.useMsgSendVariants
        ? _objc_msgSend_98Stret(
            stret, this.pointer, _sel_minFullScreenContentSize)
        : stret.ref =
            _objc_msgSend_98(this.pointer, _sel_minFullScreenContentSize);
  }

  /// These are the min and max values for a full screen tiled window.
  ///
  /// In general, one should not need to explicitly set the min/maxFullScreenContentSize. If an application does not change its window content upon entering full screen, then the normal auto layout min and max size will be sufficient, and one should not set these values. If an application does significantly rework the UI in full screen, then it may be necessary to set a min/maxFullScreenContentSize. This size is what is used to determine if a window can fit when it is in full screen in a tile. This property may be used even if the window does not support full screen, but are implicitly opted into supporting a full screen tile based on resizing behavior and window properties (see the collectionBehavior property). By default, the system uses auto layout to determine the min and max sizes. If auto layout is not used, contentMinSize and contentMaxSize are queried.
  set minFullScreenContentSize(CGSize value) {
    return _objc_msgSend_205(
        this.pointer, _sel_setMinFullScreenContentSize_, value);
  }

  /// maxFullScreenContentSize
  void getMaxFullScreenContentSize(ffi.Pointer<CGSize> stret) {
    objc.useMsgSendVariants
        ? _objc_msgSend_98Stret(
            stret, this.pointer, _sel_maxFullScreenContentSize)
        : stret.ref =
            _objc_msgSend_98(this.pointer, _sel_maxFullScreenContentSize);
  }

  /// setMaxFullScreenContentSize:
  set maxFullScreenContentSize(CGSize value) {
    return _objc_msgSend_205(
        this.pointer, _sel_setMaxFullScreenContentSize_, value);
  }

  /// deviceDescription
  objc.NSDictionary get deviceDescription {
    final _ret = _objc_msgSend_231(this.pointer, _sel_deviceDescription);
    return objc.NSDictionary.castFromPointer(_ret, retain: true, release: true);
  }

  /// windowController
  NSWindowController? get windowController {
    final _ret = _objc_msgSend_232(this.pointer, _sel_windowController);
    return _ret.address == 0
        ? null
        : NSWindowController.castFromPointer(_ret, retain: true, release: true);
  }

  /// setWindowController:
  set windowController(NSWindowController? value) {
    return _objc_msgSend_233(
        this.pointer, _sel_setWindowController_, value?.pointer ?? ffi.nullptr);
  }

  /// This API presents modal-sheets on this window. It replaces NSApp's -beginSheet:modalForWindow:modalDelegate:didEndSelector:contextInfo:.
  ///
  /// If the window already has a presented sheet, it will queue up sheets presented after that. Once the presented sheet is dismissed, the next queued sheet will be presented, and so forth.
  /// Critical sheets will skip this queuing process and be immediately presented on top of existing sheets. The presented sheet will be temporarily disabled and be able to be interacted with after the critical sheet is dismissed, and will then continue as normal. Critical sheets should only be used for time-critical or important events, when the presentation of the sheet needs to be guaranteed (Critical Alerts will automatically use this API).
  void beginSheet_completionHandler_(
      NSWindow sheetWindow, ObjCBlock_ffiVoid_ffiLong? handler) {
    _objc_msgSend_234(this.pointer, _sel_beginSheet_completionHandler_,
        sheetWindow.pointer, handler?.pointer ?? ffi.nullptr);
  }

  /// beginCriticalSheet:completionHandler:
  void beginCriticalSheet_completionHandler_(
      NSWindow sheetWindow, ObjCBlock_ffiVoid_ffiLong? handler) {
    _objc_msgSend_234(this.pointer, _sel_beginCriticalSheet_completionHandler_,
        sheetWindow.pointer, handler?.pointer ?? ffi.nullptr);
  }

  /// endSheet:
  void endSheet_(NSWindow sheetWindow) {
    _objc_msgSend_235(this.pointer, _sel_endSheet_, sheetWindow.pointer);
  }

  /// endSheet:returnCode:
  void endSheet_returnCode_(NSWindow sheetWindow, int returnCode) {
    _objc_msgSend_236(this.pointer, _sel_endSheet_returnCode_,
        sheetWindow.pointer, returnCode);
  }

  /// An ordered array of the sheets on the window. This consists of the presented sheets in top-to-bottom order, followed by queued sheets in the order they were queued. This does not include nested/sub-sheets.
  objc.NSArray get sheets {
    final _ret = _objc_msgSend_37(this.pointer, _sel_sheets);
    return objc.NSArray.castFromPointer(_ret, retain: true, release: true);
  }

  /// Returns the top-most sheet if there is one or more sheets, or nil if there is no sheet.
  NSWindow? get attachedSheet {
    final _ret = _objc_msgSend_46(this.pointer, _sel_attachedSheet);
    return _ret.address == 0
        ? null
        : NSWindow.castFromPointer(_ret, retain: true, release: true);
  }

  /// isSheet
  bool get sheet {
    return _objc_msgSend_13(this.pointer, _sel_isSheet);
  }

  /// !
  /// Returns the window that the sheet is directly attached to. This is based on the logical attachment of the sheet, not visual attachment.
  /// This relationship exists starting when the sheet is begun (using \c NSApplication's `-beginSheet:modalForWindow:modalDelegate:didEndSelector:contextInfo: or NSWindow's -beginSheet:completionHandler:`), and ending once it is ordered out.
  /// Returns nil if the window is not a sheet or has no sheet parent.
  NSWindow? get sheetParent {
    final _ret = _objc_msgSend_46(this.pointer, _sel_sheetParent);
    return _ret.address == 0
        ? null
        : NSWindow.castFromPointer(_ret, retain: true, release: true);
  }

  /// standardWindowButton:forStyleMask:
  static NSButton? standardWindowButton_forStyleMask_(
      NSWindowButton b, NSWindowStyleMask styleMask) {
    final _ret = _objc_msgSend_237(_class_NSWindow,
        _sel_standardWindowButton_forStyleMask_, b.value, styleMask.value);
    return _ret.address == 0
        ? null
        : NSButton.castFromPointer(_ret, retain: true, release: true);
  }

  /// standardWindowButton:
  NSButton? standardWindowButton_(NSWindowButton b) {
    final _ret =
        _objc_msgSend_238(this.pointer, _sel_standardWindowButton_, b.value);
    return _ret.address == 0
        ? null
        : NSButton.castFromPointer(_ret, retain: true, release: true);
  }

  /// addChildWindow:ordered:
  void addChildWindow_ordered_(NSWindow childWin, NSWindowOrderingMode place) {
    _objc_msgSend_239(this.pointer, _sel_addChildWindow_ordered_,
        childWin.pointer, place.value);
  }

  /// removeChildWindow:
  void removeChildWindow_(NSWindow childWin) {
    _objc_msgSend_235(this.pointer, _sel_removeChildWindow_, childWin.pointer);
  }

  /// childWindows
  objc.NSArray? get childWindows {
    final _ret = _objc_msgSend_240(this.pointer, _sel_childWindows);
    return _ret.address == 0
        ? null
        : objc.NSArray.castFromPointer(_ret, retain: true, release: true);
  }

  /// parentWindow
  NSWindow? get parentWindow {
    final _ret = _objc_msgSend_46(this.pointer, _sel_parentWindow);
    return _ret.address == 0
        ? null
        : NSWindow.castFromPointer(_ret, retain: true, release: true);
  }

  /// setParentWindow:
  set parentWindow(NSWindow? value) {
    return _objc_msgSend_241(
        this.pointer, _sel_setParentWindow_, value?.pointer ?? ffi.nullptr);
  }

  /// If set, the receiver will inherit the appearance of that object, as well as use KVO to observe its effectiveAppearance for changes. Typically this is used for child windows that are shown from a parent window or specific view. Defaults to NSApp.
  objc.NSObject get appearanceSource {
    final _ret = _objc_msgSend_242(this.pointer, _sel_appearanceSource);
    return objc.NSObject.castFromPointer(_ret, retain: true, release: true);
  }

  /// If set, the receiver will inherit the appearance of that object, as well as use KVO to observe its effectiveAppearance for changes. Typically this is used for child windows that are shown from a parent window or specific view. Defaults to NSApp.
  set appearanceSource(objc.NSObject value) {
    return _objc_msgSend_243(
        this.pointer, _sel_setAppearanceSource_, value.pointer);
  }

  /// colorSpace
  NSColorSpace? get colorSpace {
    final _ret = _objc_msgSend_244(this.pointer, _sel_colorSpace);
    return _ret.address == 0
        ? null
        : NSColorSpace.castFromPointer(_ret, retain: true, release: true);
  }

  /// setColorSpace:
  set colorSpace(NSColorSpace? value) {
    return _objc_msgSend_245(
        this.pointer, _sel_setColorSpace_, value?.pointer ?? ffi.nullptr);
  }

  /// ! `-canRepresentDisplayGamut:` returns \c YES if the colorSpace of the receiving window, and the \c colorSpace of the screen containing that window, are capable of representing the given display gamut
  bool canRepresentDisplayGamut_(NSDisplayGamut displayGamut) {
    return _objc_msgSend_246(
        this.pointer, _sel_canRepresentDisplayGamut_, displayGamut.value);
  }

  /// ! `+windowNumbersWithOptions:` returns an autoreleased array of \c NSNumbers containing windowNumbers for all visible windows satisfying options.  If no options are specified, only visible windows belonging to the calling application and on the active space are included.  If options include \c NSWindowNumberListAllApplications, visible windows belonging to all applications are included.  If options include \c NSWindowNumberListAllSpaces, visible windows on all spaces are included.  Windows on the active space are returned in z-order.
  /// Examples:
  /// To get an array of windowNumbers visible on the current space and belonging to the calling application:
  /// `windowNumbers = [NSWindow windowNumbersWithOptions:0];`
  /// To get an array of windowNumbers visible on any space and belonging to any application:
  /// `windowNumbers = [NSWindow windowNumbersWithOptions:NSWindowNumberListAllApplications|NSWindowNumberListAllSpaces];`
  /// To get an array of windowNumbers visible on any space and belonging to the calling application:
  /// `windowNumbers = [NSWindow windowNumbersWithOptions:NSWindowNumberListAllSpaces];`
  static objc.NSArray? windowNumbersWithOptions_(
      NSWindowNumberListOptions options) {
    final _ret = _objc_msgSend_247(
        _class_NSWindow, _sel_windowNumbersWithOptions_, options.value);
    return _ret.address == 0
        ? null
        : objc.NSArray.castFromPointer(_ret, retain: true, release: true);
  }

  /// ! `+windowNumberAtPoint:belowWindowWithWindowNumber:` returns the number of the frontmost window that would be hit by a mouseDown at the screen location "point".  "windowNum" can be specified to exclude a given window along with all windows above it, and may belong to any application.  If no windows are to be excluded, specify 0 for "windowNum".  The windowNumber returned may correspond to a window in another application.
  static int windowNumberAtPoint_belowWindowWithWindowNumber_(
      CGPoint point, int windowNumber) {
    return _objc_msgSend_248(
        _class_NSWindow,
        _sel_windowNumberAtPoint_belowWindowWithWindowNumber_,
        point,
        windowNumber);
  }

  /// occlusionState
  NSWindowOcclusionState get occlusionState {
    final _ret = _objc_msgSend_249(this.pointer, _sel_occlusionState);
    return NSWindowOcclusionState.fromValue(_ret);
  }

  /// ! Specifies the style of separator displayed between the window's titlebar and content.
  ///
  /// The default value is NSTitlebarSeparatorStyleAutomatic. Changing this value will override any preference made by `NSSplitViewItem`.
  NSTitlebarSeparatorStyle get titlebarSeparatorStyle {
    final _ret = _objc_msgSend_250(this.pointer, _sel_titlebarSeparatorStyle);
    return NSTitlebarSeparatorStyle.fromValue(_ret);
  }

  /// ! Specifies the style of separator displayed between the window's titlebar and content.
  ///
  /// The default value is NSTitlebarSeparatorStyleAutomatic. Changing this value will override any preference made by `NSSplitViewItem`.
  set titlebarSeparatorStyle(NSTitlebarSeparatorStyle value) {
    return _objc_msgSend_251(
        this.pointer, _sel_setTitlebarSeparatorStyle_, value.value);
  }

  /// ! The main content view controller for the window. This provides the contentView of the window. Assigning this value will remove the existing contentView and will make the contentViewController.view the main contentView for the window. The default value is nil. The contentViewController only controls the contentView, and not the title of the window. The window title can easily be bound to the contentViewController with the following: [window bind:NSTitleBinding toObject:contentViewController withKeyPath:@"title" options:nil]. Setting the contentViewController will cause the window to resize based on the current size of the contentViewController. Autolayout should be used to restrict the size of the window. The value of the contentViewController is encoded in the NIB. Directly assigning a contentView will clear out the contentViewController.
  NSViewController? get contentViewController {
    final _ret = _objc_msgSend_252(this.pointer, _sel_contentViewController);
    return _ret.address == 0
        ? null
        : NSViewController.castFromPointer(_ret, retain: true, release: true);
  }

  /// ! The main content view controller for the window. This provides the contentView of the window. Assigning this value will remove the existing contentView and will make the contentViewController.view the main contentView for the window. The default value is nil. The contentViewController only controls the contentView, and not the title of the window. The window title can easily be bound to the contentViewController with the following: [window bind:NSTitleBinding toObject:contentViewController withKeyPath:@"title" options:nil]. Setting the contentViewController will cause the window to resize based on the current size of the contentViewController. Autolayout should be used to restrict the size of the window. The value of the contentViewController is encoded in the NIB. Directly assigning a contentView will clear out the contentViewController.
  set contentViewController(NSViewController? value) {
    return _objc_msgSend_253(this.pointer, _sel_setContentViewController_,
        value?.pointer ?? ffi.nullptr);
  }

  /// ! Convenience method for creating an autoreleased titled window with the given contentViewController. A basic NSWindow with the following attributes is made: titled, closable, resizable, miniaturizable. The window's title is automatically bound to the contentViewController's title. The size of the window can easily be controlled by utilizing autolayout and applying size constraints to the view (or its subviews). The window has isReleasedWhenClosed set to NO, and it must be explicitly retained to keep the window instance alive. To have it automatically be freed when it is closed, do the following: [window retain] and [window setReleasedWhenClosed:YES].
  static NSWindow windowWithContentViewController_(
      NSViewController contentViewController) {
    final _ret = _objc_msgSend_254(_class_NSWindow,
        _sel_windowWithContentViewController_, contentViewController.pointer);
    return NSWindow.castFromPointer(_ret, retain: true, release: true);
  }

  /// ! Call to start a drag (moving the window) in the Window Server process. In general, this can be done after a mouseDown event has come in and been examined by an application or view. The view may determine it wants to allow that portion of the window to start a window drag, and can hand off the work to the Window Server process by calling this method. This allows the window to participate in space switching, and other system features. Pass the original mouseDown event to the method. The method will return right away, and a mouseUp may not get sent.
  void performWindowDragWithEvent_(NSEvent event) {
    _objc_msgSend_181(
        this.pointer, _sel_performWindowDragWithEvent_, event.pointer);
  }

  /// initialFirstResponder
  NSView? get initialFirstResponder {
    final _ret = _objc_msgSend_47(this.pointer, _sel_initialFirstResponder);
    return _ret.address == 0
        ? null
        : NSView.castFromPointer(_ret, retain: true, release: true);
  }

  /// setInitialFirstResponder:
  set initialFirstResponder(NSView? value) {
    return _objc_msgSend_147(this.pointer, _sel_setInitialFirstResponder_,
        value?.pointer ?? ffi.nullptr);
  }

  /// selectNextKeyView:
  void selectNextKeyView_(objc.ObjCObjectBase? sender) {
    _objc_msgSend_24(
        this.pointer, _sel_selectNextKeyView_, sender?.pointer ?? ffi.nullptr);
  }

  /// selectPreviousKeyView:
  void selectPreviousKeyView_(objc.ObjCObjectBase? sender) {
    _objc_msgSend_24(this.pointer, _sel_selectPreviousKeyView_,
        sender?.pointer ?? ffi.nullptr);
  }

  /// selectKeyViewFollowingView:
  void selectKeyViewFollowingView_(NSView view) {
    _objc_msgSend_53(
        this.pointer, _sel_selectKeyViewFollowingView_, view.pointer);
  }

  /// selectKeyViewPrecedingView:
  void selectKeyViewPrecedingView_(NSView view) {
    _objc_msgSend_53(
        this.pointer, _sel_selectKeyViewPrecedingView_, view.pointer);
  }

  /// keyViewSelectionDirection
  NSSelectionDirection get keyViewSelectionDirection {
    final _ret =
        _objc_msgSend_255(this.pointer, _sel_keyViewSelectionDirection);
    return NSSelectionDirection.fromValue(_ret);
  }

  /// defaultButtonCell
  NSButtonCell? get defaultButtonCell {
    final _ret = _objc_msgSend_256(this.pointer, _sel_defaultButtonCell);
    return _ret.address == 0
        ? null
        : NSButtonCell.castFromPointer(_ret, retain: true, release: true);
  }

  /// setDefaultButtonCell:
  set defaultButtonCell(NSButtonCell? value) {
    return _objc_msgSend_257(this.pointer, _sel_setDefaultButtonCell_,
        value?.pointer ?? ffi.nullptr);
  }

  /// disableKeyEquivalentForDefaultButtonCell
  void disableKeyEquivalentForDefaultButtonCell() {
    _objc_msgSend_11(
        this.pointer, _sel_disableKeyEquivalentForDefaultButtonCell);
  }

  /// enableKeyEquivalentForDefaultButtonCell
  void enableKeyEquivalentForDefaultButtonCell() {
    _objc_msgSend_11(
        this.pointer, _sel_enableKeyEquivalentForDefaultButtonCell);
  }

  /// autorecalculatesKeyViewLoop
  bool get autorecalculatesKeyViewLoop {
    return _objc_msgSend_13(this.pointer, _sel_autorecalculatesKeyViewLoop);
  }

  /// setAutorecalculatesKeyViewLoop:
  set autorecalculatesKeyViewLoop(bool value) {
    return _objc_msgSend_14(
        this.pointer, _sel_setAutorecalculatesKeyViewLoop_, value);
  }

  /// recalculateKeyViewLoop
  void recalculateKeyViewLoop() {
    _objc_msgSend_11(this.pointer, _sel_recalculateKeyViewLoop);
  }

  /// toolbar
  NSToolbar? get toolbar {
    final _ret = _objc_msgSend_258(this.pointer, _sel_toolbar);
    return _ret.address == 0
        ? null
        : NSToolbar.castFromPointer(_ret, retain: true, release: true);
  }

  /// setToolbar:
  set toolbar(NSToolbar? value) {
    return _objc_msgSend_259(
        this.pointer, _sel_setToolbar_, value?.pointer ?? ffi.nullptr);
  }

  /// toggleToolbarShown:
  void toggleToolbarShown_(objc.ObjCObjectBase? sender) {
    _objc_msgSend_24(
        this.pointer, _sel_toggleToolbarShown_, sender?.pointer ?? ffi.nullptr);
  }

  /// runToolbarCustomizationPalette:
  void runToolbarCustomizationPalette_(objc.ObjCObjectBase? sender) {
    _objc_msgSend_24(this.pointer, _sel_runToolbarCustomizationPalette_,
        sender?.pointer ?? ffi.nullptr);
  }

  /// showsToolbarButton
  bool get showsToolbarButton {
    return _objc_msgSend_13(this.pointer, _sel_showsToolbarButton);
  }

  /// setShowsToolbarButton:
  set showsToolbarButton(bool value) {
    return _objc_msgSend_14(this.pointer, _sel_setShowsToolbarButton_, value);
  }

  /// ! Allows automatic window tabbing when the value is \c YES. By default, this will be set to \c YES, but applications can explicitly opt out of all automatic tabbing by setting it to NO, and can still adopted explicit window tabbing, if desired.
  static bool getAllowsAutomaticWindowTabbing() {
    return _objc_msgSend_13(_class_NSWindow, _sel_allowsAutomaticWindowTabbing);
  }

  /// ! Allows automatic window tabbing when the value is \c YES. By default, this will be set to \c YES, but applications can explicitly opt out of all automatic tabbing by setting it to NO, and can still adopted explicit window tabbing, if desired.
  static void setAllowsAutomaticWindowTabbing(bool value) {
    return _objc_msgSend_14(
        _class_NSWindow, _sel_setAllowsAutomaticWindowTabbing_, value);
  }

  /// ! Returns the user's tabbing preference as set in System Preferences. This value should be queried anytime a new window is made to see if the user wants to automatically show it in tabs.
  static NSWindowUserTabbingPreference getUserTabbingPreference() {
    final _ret = _objc_msgSend_260(_class_NSWindow, _sel_userTabbingPreference);
    return NSWindowUserTabbingPreference.fromValue(_ret);
  }

  /// ! Get and set the tabbing mode for this window. This should be set before a window is shown. The default value is \c NSWindowTabbingModeAutomatic. When the value is \c NSWindowTabbingModeAutomatic, the system will look at the \c userTabbingPreference and automatically tab windows together based on the tabbingIdentifier, when it is appropriate to do so.
  NSWindowTabbingMode get tabbingMode {
    final _ret = _objc_msgSend_261(this.pointer, _sel_tabbingMode);
    return NSWindowTabbingMode.fromValue(_ret);
  }

  /// ! Get and set the tabbing mode for this window. This should be set before a window is shown. The default value is \c NSWindowTabbingModeAutomatic. When the value is \c NSWindowTabbingModeAutomatic, the system will look at the \c userTabbingPreference and automatically tab windows together based on the tabbingIdentifier, when it is appropriate to do so.
  set tabbingMode(NSWindowTabbingMode value) {
    return _objc_msgSend_262(this.pointer, _sel_setTabbingMode_, value.value);
  }

  /// ! Windows with the same \c tabbingIdentifier will have the ability to be tabbed together when a window is being shown. This allows aggregation of similar windows. By default, the \c tabbingIdentifier will be generated based on inherent window properties, such as the window class name, the delegate class name, the window controller class name, and some additional state. Windows can be explicitly made to group together by using the same \c tabbingIdentifier.
  objc.NSString get tabbingIdentifier {
    final _ret = _objc_msgSend_3(this.pointer, _sel_tabbingIdentifier);
    return objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// ! Windows with the same \c tabbingIdentifier will have the ability to be tabbed together when a window is being shown. This allows aggregation of similar windows. By default, the \c tabbingIdentifier will be generated based on inherent window properties, such as the window class name, the delegate class name, the window controller class name, and some additional state. Windows can be explicitly made to group together by using the same \c tabbingIdentifier.
  set tabbingIdentifier(objc.NSString value) {
    return _objc_msgSend_4(
        this.pointer, _sel_setTabbingIdentifier_, value.pointer);
  }

  /// ! Actions that can be called to perform various tabbed window behaviors. UI that is hooked up to these items can be automatically validated by calling `NSWindow`'s \c validateUserInterfaceItem.
  void selectNextTab_(objc.ObjCObjectBase? sender) {
    _objc_msgSend_24(
        this.pointer, _sel_selectNextTab_, sender?.pointer ?? ffi.nullptr);
  }

  /// selectPreviousTab:
  void selectPreviousTab_(objc.ObjCObjectBase? sender) {
    _objc_msgSend_24(
        this.pointer, _sel_selectPreviousTab_, sender?.pointer ?? ffi.nullptr);
  }

  /// moveTabToNewWindow:
  void moveTabToNewWindow_(objc.ObjCObjectBase? sender) {
    _objc_msgSend_24(
        this.pointer, _sel_moveTabToNewWindow_, sender?.pointer ?? ffi.nullptr);
  }

  /// mergeAllWindows:
  void mergeAllWindows_(objc.ObjCObjectBase? sender) {
    _objc_msgSend_24(
        this.pointer, _sel_mergeAllWindows_, sender?.pointer ?? ffi.nullptr);
  }

  /// toggleTabBar:
  void toggleTabBar_(objc.ObjCObjectBase? sender) {
    _objc_msgSend_24(
        this.pointer, _sel_toggleTabBar_, sender?.pointer ?? ffi.nullptr);
  }

  /// ! Toggle the Tab Picker / Tab Overview UI which is invoked via "Show All Tabs". Performs the toggle in an animated fashion. Use `tabGroup.isOverviewVisible` to find out if it is visible or not at a given time.
  void toggleTabOverview_(objc.ObjCObjectBase? sender) {
    _objc_msgSend_24(
        this.pointer, _sel_toggleTabOverview_, sender?.pointer ?? ffi.nullptr);
  }

  /// ! This is now a cover for `self.tabGroup.windows`, but will return nil if the window is not showing a tab bar.
  objc.NSArray? get tabbedWindows {
    final _ret = _objc_msgSend_240(this.pointer, _sel_tabbedWindows);
    return _ret.address == 0
        ? null
        : objc.NSArray.castFromPointer(_ret, retain: true, release: true);
  }

  /// ! This is now a cover for `-[self.tabGroup addWindow:]`, which allows more precise placement.
  void addTabbedWindow_ordered_(NSWindow window, NSWindowOrderingMode ordered) {
    _objc_msgSend_239(this.pointer, _sel_addTabbedWindow_ordered_,
        window.pointer, ordered.value);
  }

  /// ! Access the properties for this window when it is a tabbed window environment. See the \c NSWindowTab header and comments for more information.
  NSWindowTab get tab {
    final _ret = _objc_msgSend_263(this.pointer, _sel_tab);
    return NSWindowTab.castFromPointer(_ret, retain: true, release: true);
  }

  /// ! Represents a tab group of windows. This \c tabGroup is lazily created on demand.
  NSWindowTabGroup? get tabGroup {
    final _ret = _objc_msgSend_264(this.pointer, _sel_tabGroup);
    return _ret.address == 0
        ? null
        : NSWindowTabGroup.castFromPointer(_ret, retain: true, release: true);
  }

  /// !
  /// @abstract Attempt to move window sharing (i.e. within a SharePlay session) from the receiver to another window. In response to this request, the user may choose to transfer sharing to the new window, or simply stop sharing the content.
  /// @param window
  /// A window that is replacing the reciever in representing the user's current activity.
  /// @param completionHandler
  /// A completion block that is called after the request finishes.
  /// @param error
  /// In the event of a failed transfer request, a non-nil error contains details about the failure.
  void transferWindowSharingToWindow_completionHandler_(
      NSWindow window, ObjCBlock_ffiVoid_NSError completionHandler) {
    _objc_msgSend_265(
        this.pointer,
        _sel_transferWindowSharingToWindow_completionHandler_,
        window.pointer,
        completionHandler.pointer);
  }

  /// !
  /// @abstract Indicates whether the receiver is the subject of an active SharePlay sharing session.
  bool get hasActiveWindowSharingSession {
    return _objc_msgSend_13(this.pointer, _sel_hasActiveWindowSharingSession);
  }

  /// ! Retrieve the layout direction of the window titlebar: this includes the standard window buttons (close/minimize/maximize buttons) and the title for this window. In general, this will return "right to left" (RTL) if the primary system language is RTL. The layout direction may be RTL even in applications that do not have a RTL language localization. This value should be utilized if an application uses titlebarAppearsTransparent and places controls underneath the titlebar.
  NSUserInterfaceLayoutDirection get windowTitlebarLayoutDirection {
    final _ret =
        _objc_msgSend_168(this.pointer, _sel_windowTitlebarLayoutDirection);
    return NSUserInterfaceLayoutDirection.fromValue(_ret);
  }

  /// ! Tracks events matching the supplied mask with the supplied tracking handler until the tracking handler explicitly terminates tracking. Each event is removed from the event queue then passed to the tracking handler. If a matching event does not exist in the event queue, then the main thread blocks in the specified runloop mode until an event of the requested type is received or the timeout expires. If the timeout expires, the tracking handler is called with a nil event. A negative timeout is interpreted as 0. Use \c NSEventDurationForever to never timeout. Tracking continues until `*stop` is set to \c YES. Calls to `-nextEventMatchingMask:…` are allowed inside the trackingHandler block. This method returns once tracking is terminated.
  void trackEventsMatchingMask_timeout_mode_handler_(
      NSEventMask mask,
      double timeout,
      objc.NSString mode,
      ObjCBlock_ffiVoid_NSEvent_bool trackingHandler) {
    _objc_msgSend_266(
        this.pointer,
        _sel_trackEventsMatchingMask_timeout_mode_handler_,
        mask.value,
        timeout,
        mode.pointer,
        trackingHandler.pointer);
  }

  /// nextEventMatchingMask:
  NSEvent? nextEventMatchingMask_(NSEventMask mask) {
    final _ret = _objc_msgSend_267(
        this.pointer, _sel_nextEventMatchingMask_, mask.value);
    return _ret.address == 0
        ? null
        : NSEvent.castFromPointer(_ret, retain: true, release: true);
  }

  /// nextEventMatchingMask:untilDate:inMode:dequeue:
  NSEvent? nextEventMatchingMask_untilDate_inMode_dequeue_(NSEventMask mask,
      objc.NSDate? expiration, objc.NSString mode, bool deqFlag) {
    final _ret = _objc_msgSend_268(
        this.pointer,
        _sel_nextEventMatchingMask_untilDate_inMode_dequeue_,
        mask.value,
        expiration?.pointer ?? ffi.nullptr,
        mode.pointer,
        deqFlag);
    return _ret.address == 0
        ? null
        : NSEvent.castFromPointer(_ret, retain: true, release: true);
  }

  /// discardEventsMatchingMask:beforeEvent:
  void discardEventsMatchingMask_beforeEvent_(
      NSEventMask mask, NSEvent? lastEvent) {
    _objc_msgSend_269(this.pointer, _sel_discardEventsMatchingMask_beforeEvent_,
        mask.value, lastEvent?.pointer ?? ffi.nullptr);
  }

  /// postEvent:atStart:
  void postEvent_atStart_(NSEvent event, bool flag) {
    _objc_msgSend_270(
        this.pointer, _sel_postEvent_atStart_, event.pointer, flag);
  }

  /// sendEvent:
  void sendEvent_(NSEvent event) {
    _objc_msgSend_181(this.pointer, _sel_sendEvent_, event.pointer);
  }

  /// currentEvent
  NSEvent? get currentEvent {
    final _ret = _objc_msgSend_271(this.pointer, _sel_currentEvent);
    return _ret.address == 0
        ? null
        : NSEvent.castFromPointer(_ret, retain: true, release: true);
  }

  /// acceptsMouseMovedEvents
  bool get acceptsMouseMovedEvents {
    return _objc_msgSend_13(this.pointer, _sel_acceptsMouseMovedEvents);
  }

  /// setAcceptsMouseMovedEvents:
  set acceptsMouseMovedEvents(bool value) {
    return _objc_msgSend_14(
        this.pointer, _sel_setAcceptsMouseMovedEvents_, value);
  }

  /// ignoresMouseEvents
  bool get ignoresMouseEvents {
    return _objc_msgSend_13(this.pointer, _sel_ignoresMouseEvents);
  }

  /// setIgnoresMouseEvents:
  set ignoresMouseEvents(bool value) {
    return _objc_msgSend_14(this.pointer, _sel_setIgnoresMouseEvents_, value);
  }

  /// mouseLocationOutsideOfEventStream
  void getMouseLocationOutsideOfEventStream(ffi.Pointer<CGPoint> stret) {
    objc.useMsgSendVariants
        ? _objc_msgSend_82Stret(
            stret, this.pointer, _sel_mouseLocationOutsideOfEventStream)
        : stret.ref = _objc_msgSend_82(
            this.pointer, _sel_mouseLocationOutsideOfEventStream);
  }

  /// disableCursorRects
  void disableCursorRects() {
    _objc_msgSend_11(this.pointer, _sel_disableCursorRects);
  }

  /// enableCursorRects
  void enableCursorRects() {
    _objc_msgSend_11(this.pointer, _sel_enableCursorRects);
  }

  /// discardCursorRects
  void discardCursorRects() {
    _objc_msgSend_11(this.pointer, _sel_discardCursorRects);
  }

  /// areCursorRectsEnabled
  bool get areCursorRectsEnabled {
    return _objc_msgSend_13(this.pointer, _sel_areCursorRectsEnabled);
  }

  /// invalidateCursorRectsForView:
  void invalidateCursorRectsForView_(NSView view) {
    _objc_msgSend_53(
        this.pointer, _sel_invalidateCursorRectsForView_, view.pointer);
  }

  /// resetCursorRects
  void resetCursorRects() {
    _objc_msgSend_11(this.pointer, _sel_resetCursorRects);
  }

  /// dragImage:at:offset:event:pasteboard:source:slideBack:
  void dragImage_at_offset_event_pasteboard_source_slideBack_(
      NSImage image,
      CGPoint baseLocation,
      CGSize initialOffset,
      NSEvent event,
      NSPasteboard pboard,
      objc.ObjCObjectBase sourceObj,
      bool slideFlag) {
    _objc_msgSend_287(
        this.pointer,
        _sel_dragImage_at_offset_event_pasteboard_source_slideBack_,
        image.pointer,
        baseLocation,
        initialOffset,
        event.pointer,
        pboard.pointer,
        sourceObj.pointer,
        slideFlag);
  }

  /// registerForDraggedTypes:
  void registerForDraggedTypes_(objc.NSArray newTypes) {
    _objc_msgSend_288(
        this.pointer, _sel_registerForDraggedTypes_, newTypes.pointer);
  }

  /// unregisterDraggedTypes
  void unregisterDraggedTypes() {
    _objc_msgSend_11(this.pointer, _sel_unregisterDraggedTypes);
  }

  /// WindowRef
  NSWindow? initWithWindowRef_(ffi.Pointer<ffi.Void> windowRef) {
    final _ret =
        _objc_msgSend_289(this.pointer, _sel_initWithWindowRef_, windowRef);
    return _ret.address == 0
        ? null
        : NSWindow.castFromPointer(_ret, retain: true, release: true);
  }

  /// WindowRef
  ffi.Pointer<ffi.Void> get windowRef {
    return _objc_msgSend_87(this.pointer, _sel_windowRef);
  }

  /// Returns a new display link whose callback will be invoked in-sync with the display the window is on. If the window is not on any display the callback will not be invoked.
  CADisplayLink displayLinkWithTarget_selector_(
      objc.ObjCObjectBase target, ffi.Pointer<objc.ObjCSelector> selector) {
    final _ret = _objc_msgSend_290(this.pointer,
        _sel_displayLinkWithTarget_selector_, target.pointer, selector);
    return CADisplayLink.castFromPointer(_ret, retain: true, release: true);
  }

  /// cacheImageInRect:
  void cacheImageInRect_(CGRect rect) {
    _objc_msgSend_72(this.pointer, _sel_cacheImageInRect_, rect);
  }

  /// restoreCachedImage
  void restoreCachedImage() {
    _objc_msgSend_11(this.pointer, _sel_restoreCachedImage);
  }

  /// discardCachedImage
  void discardCachedImage() {
    _objc_msgSend_11(this.pointer, _sel_discardCachedImage);
  }

  /// menuChanged:
  static void menuChanged_(NSMenu menu) {
    _objc_msgSend_291(_class_NSWindow, _sel_menuChanged_, menu.pointer);
  }

  /// gState is unused and should not be called.
  int gState() {
    return _objc_msgSend_79(this.pointer, _sel_gState);
  }

  /// The base/screen conversion methods are deprecated in 10.7 and later. Please use one of convertRectToScreen:, convertRectFromScreen:, convertPointToScreen:, or convertPointFromScreen: instead.
  void convertBaseToScreen_(ffi.Pointer<CGPoint> stret, CGPoint point) {
    objc.useMsgSendVariants
        ? _objc_msgSend_70Stret(
            stret, this.pointer, _sel_convertBaseToScreen_, point)
        : stret.ref =
            _objc_msgSend_70(this.pointer, _sel_convertBaseToScreen_, point);
  }

  /// convertScreenToBase:
  void convertScreenToBase_(ffi.Pointer<CGPoint> stret, CGPoint point) {
    objc.useMsgSendVariants
        ? _objc_msgSend_70Stret(
            stret, this.pointer, _sel_convertScreenToBase_, point)
        : stret.ref =
            _objc_msgSend_70(this.pointer, _sel_convertScreenToBase_, point);
  }

  /// This method is deprecated and should not be used by applications targeting Mac OS X 10.7 or later.
  /// The implementation of this method will always return 1.0.  Please use -convertRectToBacking: and -backingScaleFactor instead.
  double userSpaceScaleFactor() {
    return objc.useMsgSendVariants
        ? _objc_msgSend_10Fpret(this.pointer, _sel_userSpaceScaleFactor)
        : _objc_msgSend_10(this.pointer, _sel_userSpaceScaleFactor);
  }

  /// useOptimizedDrawing:
  void useOptimizedDrawing_(bool flag) {
    _objc_msgSend_152(this.pointer, _sel_useOptimizedDrawing_, flag);
  }

  /// canStoreColor has not been needed or used in a while and is deprecated.
  bool canStoreColor() {
    return _objc_msgSend_13(this.pointer, _sel_canStoreColor);
  }

  /// disableFlushWindow
  void disableFlushWindow() {
    _objc_msgSend_11(this.pointer, _sel_disableFlushWindow);
  }

  /// enableFlushWindow
  void enableFlushWindow() {
    _objc_msgSend_11(this.pointer, _sel_enableFlushWindow);
  }

  /// isFlushWindowDisabled
  bool get flushWindowDisabled {
    return _objc_msgSend_13(this.pointer, _sel_isFlushWindowDisabled);
  }

  /// flushWindow
  void flushWindow() {
    _objc_msgSend_11(this.pointer, _sel_flushWindow);
  }

  /// flushWindowIfNeeded
  void flushWindowIfNeeded() {
    _objc_msgSend_11(this.pointer, _sel_flushWindowIfNeeded);
  }

  /// isAutodisplay
  bool get autodisplay {
    return _objc_msgSend_13(this.pointer, _sel_isAutodisplay);
  }

  /// setAutodisplay:
  set autodisplay(bool value) {
    return _objc_msgSend_14(this.pointer, _sel_setAutodisplay_, value);
  }

  /// Returns NSGraphicsContext used to render the receiver's content on the screen for the calling thread.
  NSGraphicsContext? get graphicsContext {
    final _ret = _objc_msgSend_80(this.pointer, _sel_graphicsContext);
    return _ret.address == 0
        ? null
        : NSGraphicsContext.castFromPointer(_ret, retain: true, release: true);
  }

  /// isOneShot
  bool get oneShot {
    return _objc_msgSend_13(this.pointer, _sel_isOneShot);
  }

  /// setOneShot:
  set oneShot(bool value) {
    return _objc_msgSend_14(this.pointer, _sel_setOneShot_, value);
  }

  /// preferredBackingLocation
  NSWindowBackingLocation get preferredBackingLocation {
    final _ret = _objc_msgSend_292(this.pointer, _sel_preferredBackingLocation);
    return NSWindowBackingLocation.fromValue(_ret);
  }

  /// setPreferredBackingLocation:
  set preferredBackingLocation(NSWindowBackingLocation value) {
    return _objc_msgSend_293(
        this.pointer, _sel_setPreferredBackingLocation_, value.value);
  }

  /// backingLocation
  NSWindowBackingLocation get backingLocation {
    final _ret = _objc_msgSend_292(this.pointer, _sel_backingLocation);
    return NSWindowBackingLocation.fromValue(_ret);
  }

  /// showsResizeIndicator is soft-deprecated in 10.14. It is ignored on 10.7 and newer, and should not be used.
  bool get showsResizeIndicator {
    return _objc_msgSend_13(this.pointer, _sel_showsResizeIndicator);
  }

  /// showsResizeIndicator is soft-deprecated in 10.14. It is ignored on 10.7 and newer, and should not be used.
  set showsResizeIndicator(bool value) {
    return _objc_msgSend_14(this.pointer, _sel_setShowsResizeIndicator_, value);
  }

  /// init
  NSWindow init() {
    final _ret = _objc_msgSend_2(this.pointer, _sel_init);
    return NSWindow.castFromPointer(_ret, retain: true, release: true);
  }

  /// new
  static NSWindow new1() {
    final _ret = _objc_msgSend_2(_class_NSWindow, _sel_new);
    return NSWindow.castFromPointer(_ret, retain: false, release: true);
  }

  /// allocWithZone:
  static NSWindow allocWithZone_(ffi.Pointer<_NSZone> zone) {
    final _ret = _objc_msgSend_20(_class_NSWindow, _sel_allocWithZone_, zone);
    return NSWindow.castFromPointer(_ret, retain: false, release: true);
  }

  /// alloc
  static NSWindow alloc() {
    final _ret = _objc_msgSend_2(_class_NSWindow, _sel_alloc);
    return NSWindow.castFromPointer(_ret, retain: false, release: true);
  }
}

late final _class_NSWindow = objc.getClass("NSWindow");

final class CGRect extends ffi.Struct {
  external CGPoint origin;

  external CGSize size;
}

final class CGPoint extends ffi.Struct {
  @ffi.Double()
  external double x;

  @ffi.Double()
  external double y;
}

final class CGSize extends ffi.Struct {
  @ffi.Double()
  external double width;

  @ffi.Double()
  external double height;
}

/// !
/// @typedef NSWindowStyleMask
///
/// @const NSWindowStyleMaskBorderless
/// @const NSWindowStyleMaskTitled
/// @const NSWindowStyleMaskClosable
/// @const NSWindowStyleMaskMiniaturizable
/// @const NSWindowStyleMaskResizable
/// @const NSWindowStyleMaskTexturedBackground  Textured window style is deprecated and should no longer be used. Specifies a window with textured background. Textured windows generally don't draw a top border line under the titlebar/toolbar. To get that line, use the \c NSUnifiedTitleAndToolbarWindowMask mask.
/// @const NSWindowStyleMaskUnifiedTitleAndToolbar  Specifies a window whose titlebar and toolbar have a unified look - that is, a continuous background. Under the titlebar and toolbar a horizontal separator line will appear.
/// @const NSWindowStyleMaskFullScreen  When present, the window will appear full screen. This mask is automatically toggled when \c -toggleFullScreen: is called.
/// @const NSWindowStyleMaskFullSizeContentView If set, the \c contentView will consume the full size of the window; it can be combined with other window style masks, but is only respected for windows with a titlebar. Utilizing this mask opts-in to layer-backing. Utilize the \c contentLayoutRect or auto-layout \c contentLayoutGuide to layout views underneath the titlebar/toolbar area.
/// @const NSWindowStyleMaskUtilityWindow Only applicable for \c NSPanel (or a subclass thereof).
/// @const NSWindowStyleMaskDocModalWindow Only applicable for \c NSPanel (or a subclass thereof).
/// @const NSWindowStyleMaskNonactivatingPanel  Specifies that a panel that does not activate the owning application. Only applicable for \c NSPanel (or a subclass thereof).
/// @const NSWindowStyleMaskHUDWindow Specifies a heads up display panel.  Only applicable for \c NSPanel (or a subclass thereof).
enum NSWindowStyleMask {
  NSWindowStyleMaskBorderless(0),
  NSWindowStyleMaskTitled(1),
  NSWindowStyleMaskClosable(2),
  NSWindowStyleMaskMiniaturizable(4),
  NSWindowStyleMaskResizable(8),
  NSWindowStyleMaskTexturedBackground(256),
  NSWindowStyleMaskUnifiedTitleAndToolbar(4096),
  NSWindowStyleMaskFullScreen(16384),
  NSWindowStyleMaskFullSizeContentView(32768),
  NSWindowStyleMaskUtilityWindow(16),
  NSWindowStyleMaskDocModalWindow(64),
  NSWindowStyleMaskNonactivatingPanel(128),
  NSWindowStyleMaskHUDWindow(8192);

  final int value;
  const NSWindowStyleMask(this.value);

  static NSWindowStyleMask fromValue(int value) => switch (value) {
        0 => NSWindowStyleMaskBorderless,
        1 => NSWindowStyleMaskTitled,
        2 => NSWindowStyleMaskClosable,
        4 => NSWindowStyleMaskMiniaturizable,
        8 => NSWindowStyleMaskResizable,
        256 => NSWindowStyleMaskTexturedBackground,
        4096 => NSWindowStyleMaskUnifiedTitleAndToolbar,
        16384 => NSWindowStyleMaskFullScreen,
        32768 => NSWindowStyleMaskFullSizeContentView,
        16 => NSWindowStyleMaskUtilityWindow,
        64 => NSWindowStyleMaskDocModalWindow,
        128 => NSWindowStyleMaskNonactivatingPanel,
        8192 => NSWindowStyleMaskHUDWindow,
        _ => throw ArgumentError("Unknown value for NSWindowStyleMask: $value"),
      };
}

late final _sel_frameRectForContentRect_styleMask_ =
    objc.registerName("frameRectForContentRect:styleMask:");
final _objc_msgSend_25 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            CGRect Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, CGRect, ffi.UnsignedLong)>>()
    .asFunction<
        CGRect Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, CGRect, int)>();
final _objc_msgSend_25Stret = objc.msgSendStretPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(ffi.Pointer<CGRect>, ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, CGRect, ffi.UnsignedLong)>>()
    .asFunction<
        void Function(ffi.Pointer<CGRect>, ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, CGRect, int)>();
late final _sel_contentRectForFrameRect_styleMask_ =
    objc.registerName("contentRectForFrameRect:styleMask:");
late final _sel_minFrameWidthWithTitle_styleMask_ =
    objc.registerName("minFrameWidthWithTitle:styleMask:");
final _objc_msgSend_26 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Double Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.UnsignedLong)>>()
    .asFunction<
        double Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            int)>();
final _objc_msgSend_26Fpret = objc.msgSendFpretPointer
    .cast<
        ffi.NativeFunction<
            ffi.Double Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.UnsignedLong)>>()
    .asFunction<
        double Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            int)>();

enum NSWindowDepth {
  NSWindowDepthTwentyfourBitRGB(520),
  NSWindowDepthSixtyfourBitRGB(528),
  NSWindowDepthOnehundredtwentyeightBitRGB(544);

  final int value;
  const NSWindowDepth(this.value);

  static NSWindowDepth fromValue(int value) => switch (value) {
        520 => NSWindowDepthTwentyfourBitRGB,
        528 => NSWindowDepthSixtyfourBitRGB,
        544 => NSWindowDepthOnehundredtwentyeightBitRGB,
        _ => throw ArgumentError("Unknown value for NSWindowDepth: $value"),
      };
}

late final _sel_defaultDepthLimit = objc.registerName("defaultDepthLimit");
final _objc_msgSend_27 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Int32 Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        int Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_frameRectForContentRect_ =
    objc.registerName("frameRectForContentRect:");
final _objc_msgSend_28 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            CGRect Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, CGRect)>>()
    .asFunction<
        CGRect Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, CGRect)>();
final _objc_msgSend_28Stret = objc.msgSendStretPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(ffi.Pointer<CGRect>, ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, CGRect)>>()
    .asFunction<
        void Function(ffi.Pointer<CGRect>, ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, CGRect)>();
late final _sel_contentRectForFrameRect_ =
    objc.registerName("contentRectForFrameRect:");

enum NSBackingStoreType {
  NSBackingStoreRetained(0),
  NSBackingStoreNonretained(1),
  NSBackingStoreBuffered(2);

  final int value;
  const NSBackingStoreType(this.value);

  static NSBackingStoreType fromValue(int value) => switch (value) {
        0 => NSBackingStoreRetained,
        1 => NSBackingStoreNonretained,
        2 => NSBackingStoreBuffered,
        _ =>
          throw ArgumentError("Unknown value for NSBackingStoreType: $value"),
      };
}

late final _sel_initWithContentRect_styleMask_backing_defer_ =
    objc.registerName("initWithContentRect:styleMask:backing:defer:");
final _objc_msgSend_29 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            instancetype Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                CGRect,
                ffi.UnsignedLong,
                ffi.UnsignedLong,
                ffi.Bool)>>()
    .asFunction<
        instancetype Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, CGRect, int, int, bool)>();

/// NSScreen
class NSScreen extends objc.ObjCObjectBase {
  NSScreen._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super(pointer, retain: retain, release: release);

  /// Constructs a [NSScreen] that points to the same underlying object as [other].
  NSScreen.castFrom(objc.ObjCObjectBase other)
      : this._(other.pointer, retain: true, release: true);

  /// Constructs a [NSScreen] that wraps the given raw object pointer.
  NSScreen.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [NSScreen].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_0(obj.pointer, _sel_isKindOfClass_, _class_NSScreen);
  }
}

late final _class_NSScreen = objc.getClass("NSScreen");
late final _sel_initWithContentRect_styleMask_backing_defer_screen_ =
    objc.registerName("initWithContentRect:styleMask:backing:defer:screen:");
final _objc_msgSend_30 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            instancetype Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                CGRect,
                ffi.UnsignedLong,
                ffi.UnsignedLong,
                ffi.Bool,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        instancetype Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            CGRect,
            int,
            int,
            bool,
            ffi.Pointer<objc.ObjCObject>)>();
late final _sel_initWithCoder_ = objc.registerName("initWithCoder:");
final _objc_msgSend_31 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            instancetype Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        instancetype Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<objc.ObjCObject>)>();
late final _sel_title = objc.registerName("title");
late final _sel_setTitle_ = objc.registerName("setTitle:");
late final _sel_subtitle = objc.registerName("subtitle");
late final _sel_setSubtitle_ = objc.registerName("setSubtitle:");

/// !
/// @typedef NSWindowTitleVisibility
///
/// @const NSWindowTitleVisible  The default mode has a normal window title and titlebar buttons.
/// @const NSWindowTitleHidden The always hidden mode hides the title and moves the toolbar up into the area previously occupied by the title.
enum NSWindowTitleVisibility {
  NSWindowTitleVisible(0),
  NSWindowTitleHidden(1);

  final int value;
  const NSWindowTitleVisibility(this.value);

  static NSWindowTitleVisibility fromValue(int value) => switch (value) {
        0 => NSWindowTitleVisible,
        1 => NSWindowTitleHidden,
        _ => throw ArgumentError(
            "Unknown value for NSWindowTitleVisibility: $value"),
      };
}

late final _sel_titleVisibility = objc.registerName("titleVisibility");
final _objc_msgSend_32 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.UnsignedLong Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        int Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_setTitleVisibility_ = objc.registerName("setTitleVisibility:");
final _objc_msgSend_33 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, ffi.UnsignedLong)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, int)>();
late final _sel_titlebarAppearsTransparent =
    objc.registerName("titlebarAppearsTransparent");
late final _sel_setTitlebarAppearsTransparent_ =
    objc.registerName("setTitlebarAppearsTransparent:");

/// !
/// @typedef NSWindowToolbarStyle
///
/// @const NSWindowToolbarStyleAutomatic The default value. The style will be determined by the window's given configuration.
/// @const NSWindowToolbarStyleExpanded The toolbar will appear below the window title.
/// @const NSWindowToolbarStylePreference The toolbar will appear below the window title and the items in the toolbar will attempt to have equal widths when possible.
/// @const NSWindowToolbarStyleUnified The window title will appear inline with the toolbar when visible.
/// @const NSWindowToolbarStyleUnifiedCompact Same as \c NSWindowToolbarStyleUnified, but with reduced margins in the toolbar allowing more focus to be on the contents of the window.
enum NSWindowToolbarStyle {
  NSWindowToolbarStyleAutomatic(0),
  NSWindowToolbarStyleExpanded(1),
  NSWindowToolbarStylePreference(2),
  NSWindowToolbarStyleUnified(3),
  NSWindowToolbarStyleUnifiedCompact(4);

  final int value;
  const NSWindowToolbarStyle(this.value);

  static NSWindowToolbarStyle fromValue(int value) => switch (value) {
        0 => NSWindowToolbarStyleAutomatic,
        1 => NSWindowToolbarStyleExpanded,
        2 => NSWindowToolbarStylePreference,
        3 => NSWindowToolbarStyleUnified,
        4 => NSWindowToolbarStyleUnifiedCompact,
        _ =>
          throw ArgumentError("Unknown value for NSWindowToolbarStyle: $value"),
      };
}

late final _sel_toolbarStyle = objc.registerName("toolbarStyle");
final _objc_msgSend_34 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.UnsignedLong Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        int Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_setToolbarStyle_ = objc.registerName("setToolbarStyle:");
final _objc_msgSend_35 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, ffi.UnsignedLong)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, int)>();
late final _sel_contentLayoutRect = objc.registerName("contentLayoutRect");
final _objc_msgSend_36 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            CGRect Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        CGRect Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
final _objc_msgSend_36Stret = objc.msgSendStretPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(ffi.Pointer<CGRect>, ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        void Function(ffi.Pointer<CGRect>, ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_contentLayoutGuide = objc.registerName("contentLayoutGuide");
late final _sel_titlebarAccessoryViewControllers =
    objc.registerName("titlebarAccessoryViewControllers");
final _objc_msgSend_37 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_setTitlebarAccessoryViewControllers_ =
    objc.registerName("setTitlebarAccessoryViewControllers:");
final _objc_msgSend_38 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<objc.ObjCObject>)>();

/// NSTitlebarAccessoryViewController
class NSTitlebarAccessoryViewController extends objc.ObjCObjectBase {
  NSTitlebarAccessoryViewController._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super(pointer, retain: retain, release: release);

  /// Constructs a [NSTitlebarAccessoryViewController] that points to the same underlying object as [other].
  NSTitlebarAccessoryViewController.castFrom(objc.ObjCObjectBase other)
      : this._(other.pointer, retain: true, release: true);

  /// Constructs a [NSTitlebarAccessoryViewController] that wraps the given raw object pointer.
  NSTitlebarAccessoryViewController.castFromPointer(
      ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false,
      bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [NSTitlebarAccessoryViewController].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_0(obj.pointer, _sel_isKindOfClass_,
        _class_NSTitlebarAccessoryViewController);
  }
}

late final _class_NSTitlebarAccessoryViewController =
    objc.getClass("NSTitlebarAccessoryViewController");
late final _sel_addTitlebarAccessoryViewController_ =
    objc.registerName("addTitlebarAccessoryViewController:");
final _objc_msgSend_39 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<objc.ObjCObject>)>();
late final _sel_insertTitlebarAccessoryViewController_atIndex_ =
    objc.registerName("insertTitlebarAccessoryViewController:atIndex:");
final _objc_msgSend_40 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Long)>>()
    .asFunction<
        void Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            int)>();
late final _sel_removeTitlebarAccessoryViewControllerAtIndex_ =
    objc.registerName("removeTitlebarAccessoryViewControllerAtIndex:");
final _objc_msgSend_41 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, ffi.Long)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, int)>();
late final _sel_representedURL = objc.registerName("representedURL");
final _objc_msgSend_42 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_setRepresentedURL_ = objc.registerName("setRepresentedURL:");
final _objc_msgSend_43 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<objc.ObjCObject>)>();
late final _sel_representedFilename = objc.registerName("representedFilename");
late final _sel_setRepresentedFilename_ =
    objc.registerName("setRepresentedFilename:");
late final _sel_setTitleWithRepresentedFilename_ =
    objc.registerName("setTitleWithRepresentedFilename:");
late final _sel_isExcludedFromWindowsMenu =
    objc.registerName("isExcludedFromWindowsMenu");
late final _sel_setExcludedFromWindowsMenu_ =
    objc.registerName("setExcludedFromWindowsMenu:");

/// NSView
class NSView extends NSResponder {
  NSView._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release);

  /// Constructs a [NSView] that points to the same underlying object as [other].
  NSView.castFrom(objc.ObjCObjectBase other)
      : this._(other.pointer, retain: true, release: true);

  /// Constructs a [NSView] that wraps the given raw object pointer.
  NSView.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [NSView].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_0(obj.pointer, _sel_isKindOfClass_, _class_NSView);
  }

  /// initWithFrame:
  NSView initWithFrame_(CGRect frameRect) {
    final _ret = _objc_msgSend_44(this.pointer, _sel_initWithFrame_, frameRect);
    return NSView.castFromPointer(_ret, retain: true, release: true);
  }

  /// initWithCoder:
  NSView? initWithCoder_(objc.NSCoder coder) {
    final _ret =
        _objc_msgSend_45(this.pointer, _sel_initWithCoder_, coder.pointer);
    return _ret.address == 0
        ? null
        : NSView.castFromPointer(_ret, retain: true, release: true);
  }

  /// window
  NSWindow? get window {
    final _ret = _objc_msgSend_46(this.pointer, _sel_window);
    return _ret.address == 0
        ? null
        : NSWindow.castFromPointer(_ret, retain: true, release: true);
  }

  /// superview
  NSView? get superview {
    final _ret = _objc_msgSend_47(this.pointer, _sel_superview);
    return _ret.address == 0
        ? null
        : NSView.castFromPointer(_ret, retain: true, release: true);
  }

  /// subviews
  objc.ObjCObjectBase get subviews {
    final _ret = _objc_msgSend_2(this.pointer, _sel_subviews);
    return objc.ObjCObjectBase(_ret, retain: true, release: true);
  }

  /// setSubviews:
  set subviews(objc.ObjCObjectBase value) {
    return _objc_msgSend_48(this.pointer, _sel_setSubviews_, value.pointer);
  }

  /// isDescendantOf:
  bool isDescendantOf_(NSView view) {
    return _objc_msgSend_49(this.pointer, _sel_isDescendantOf_, view.pointer);
  }

  /// ancestorSharedWithView:
  NSView? ancestorSharedWithView_(NSView view) {
    final _ret = _objc_msgSend_50(
        this.pointer, _sel_ancestorSharedWithView_, view.pointer);
    return _ret.address == 0
        ? null
        : NSView.castFromPointer(_ret, retain: true, release: true);
  }

  /// opaqueAncestor
  NSView? get opaqueAncestor {
    final _ret = _objc_msgSend_47(this.pointer, _sel_opaqueAncestor);
    return _ret.address == 0
        ? null
        : NSView.castFromPointer(_ret, retain: true, release: true);
  }

  /// isHidden
  bool get hidden {
    return _objc_msgSend_13(this.pointer, _sel_isHidden);
  }

  /// setHidden:
  set hidden(bool value) {
    return _objc_msgSend_14(this.pointer, _sel_setHidden_, value);
  }

  /// isHiddenOrHasHiddenAncestor
  bool get hiddenOrHasHiddenAncestor {
    return _objc_msgSend_13(this.pointer, _sel_isHiddenOrHasHiddenAncestor);
  }

  /// getRectsBeingDrawn:count:
  void getRectsBeingDrawn_count_(
      ffi.Pointer<ffi.Pointer<CGRect>> rects, ffi.Pointer<ffi.Long> count) {
    _objc_msgSend_51(
        this.pointer, _sel_getRectsBeingDrawn_count_, rects, count);
  }

  /// needsToDrawRect:
  bool needsToDrawRect_(CGRect rect) {
    return _objc_msgSend_52(this.pointer, _sel_needsToDrawRect_, rect);
  }

  /// wantsDefaultClipping
  bool get wantsDefaultClipping {
    return _objc_msgSend_13(this.pointer, _sel_wantsDefaultClipping);
  }

  /// viewDidHide
  void viewDidHide() {
    _objc_msgSend_11(this.pointer, _sel_viewDidHide);
  }

  /// viewDidUnhide
  void viewDidUnhide() {
    _objc_msgSend_11(this.pointer, _sel_viewDidUnhide);
  }

  /// addSubview:
  void addSubview_(NSView view) {
    _objc_msgSend_53(this.pointer, _sel_addSubview_, view.pointer);
  }

  /// addSubview:positioned:relativeTo:
  void addSubview_positioned_relativeTo_(
      NSView view, NSWindowOrderingMode place, NSView? otherView) {
    _objc_msgSend_54(this.pointer, _sel_addSubview_positioned_relativeTo_,
        view.pointer, place.value, otherView?.pointer ?? ffi.nullptr);
  }

  /// sortSubviewsUsingFunction:context:
  void sortSubviewsUsingFunction_context_(
      ffi.Pointer<
              ffi.NativeFunction<
                  ffi.Long Function(ffi.Pointer<objc.ObjCObject>,
                      ffi.Pointer<objc.ObjCObject>, ffi.Pointer<ffi.Void>)>>
          compare,
      ffi.Pointer<ffi.Void> context) {
    _objc_msgSend_55(this.pointer, _sel_sortSubviewsUsingFunction_context_,
        compare, context);
  }

  /// viewWillMoveToWindow:
  void viewWillMoveToWindow_(NSWindow? newWindow) {
    _objc_msgSend_56(this.pointer, _sel_viewWillMoveToWindow_,
        newWindow?.pointer ?? ffi.nullptr);
  }

  /// viewDidMoveToWindow
  void viewDidMoveToWindow() {
    _objc_msgSend_11(this.pointer, _sel_viewDidMoveToWindow);
  }

  /// viewWillMoveToSuperview:
  void viewWillMoveToSuperview_(NSView? newSuperview) {
    _objc_msgSend_57(this.pointer, _sel_viewWillMoveToSuperview_,
        newSuperview?.pointer ?? ffi.nullptr);
  }

  /// viewDidMoveToSuperview
  void viewDidMoveToSuperview() {
    _objc_msgSend_11(this.pointer, _sel_viewDidMoveToSuperview);
  }

  /// didAddSubview:
  void didAddSubview_(NSView subview) {
    _objc_msgSend_53(this.pointer, _sel_didAddSubview_, subview.pointer);
  }

  /// willRemoveSubview:
  void willRemoveSubview_(NSView subview) {
    _objc_msgSend_53(this.pointer, _sel_willRemoveSubview_, subview.pointer);
  }

  /// removeFromSuperview
  void removeFromSuperview() {
    _objc_msgSend_11(this.pointer, _sel_removeFromSuperview);
  }

  /// replaceSubview:with:
  void replaceSubview_with_(NSView oldView, NSView newView) {
    _objc_msgSend_58(this.pointer, _sel_replaceSubview_with_, oldView.pointer,
        newView.pointer);
  }

  /// removeFromSuperviewWithoutNeedingDisplay
  void removeFromSuperviewWithoutNeedingDisplay() {
    _objc_msgSend_11(
        this.pointer, _sel_removeFromSuperviewWithoutNeedingDisplay);
  }

  /// viewDidChangeBackingProperties
  void viewDidChangeBackingProperties() {
    _objc_msgSend_11(this.pointer, _sel_viewDidChangeBackingProperties);
  }

  /// postsFrameChangedNotifications
  bool get postsFrameChangedNotifications {
    return _objc_msgSend_13(this.pointer, _sel_postsFrameChangedNotifications);
  }

  /// setPostsFrameChangedNotifications:
  set postsFrameChangedNotifications(bool value) {
    return _objc_msgSend_14(
        this.pointer, _sel_setPostsFrameChangedNotifications_, value);
  }

  /// resizeSubviewsWithOldSize:
  void resizeSubviewsWithOldSize_(CGSize oldSize) {
    _objc_msgSend_59(this.pointer, _sel_resizeSubviewsWithOldSize_, oldSize);
  }

  /// resizeWithOldSuperviewSize:
  void resizeWithOldSuperviewSize_(CGSize oldSize) {
    _objc_msgSend_59(this.pointer, _sel_resizeWithOldSuperviewSize_, oldSize);
  }

  /// autoresizesSubviews
  bool get autoresizesSubviews {
    return _objc_msgSend_13(this.pointer, _sel_autoresizesSubviews);
  }

  /// setAutoresizesSubviews:
  set autoresizesSubviews(bool value) {
    return _objc_msgSend_14(this.pointer, _sel_setAutoresizesSubviews_, value);
  }

  /// autoresizingMask
  NSAutoresizingMaskOptions get autoresizingMask {
    final _ret = _objc_msgSend_60(this.pointer, _sel_autoresizingMask);
    return NSAutoresizingMaskOptions.fromValue(_ret);
  }

  /// setAutoresizingMask:
  set autoresizingMask(NSAutoresizingMaskOptions value) {
    return _objc_msgSend_61(
        this.pointer, _sel_setAutoresizingMask_, value.value);
  }

  /// setFrameOrigin:
  void setFrameOrigin_(CGPoint newOrigin) {
    _objc_msgSend_62(this.pointer, _sel_setFrameOrigin_, newOrigin);
  }

  /// setFrameSize:
  void setFrameSize_(CGSize newSize) {
    _objc_msgSend_59(this.pointer, _sel_setFrameSize_, newSize);
  }

  /// frame
  void getFrame(ffi.Pointer<CGRect> stret) {
    objc.useMsgSendVariants
        ? _objc_msgSend_36Stret(stret, this.pointer, _sel_frame)
        : stret.ref = _objc_msgSend_36(this.pointer, _sel_frame);
  }

  /// setFrame:
  set frame(CGRect value) {
    return _objc_msgSend_63(this.pointer, _sel_setFrame_, value);
  }

  /// frameRotation
  double get frameRotation {
    return objc.useMsgSendVariants
        ? _objc_msgSend_10Fpret(this.pointer, _sel_frameRotation)
        : _objc_msgSend_10(this.pointer, _sel_frameRotation);
  }

  /// setFrameRotation:
  set frameRotation(double value) {
    return _objc_msgSend_64(this.pointer, _sel_setFrameRotation_, value);
  }

  /// frameCenterRotation
  double get frameCenterRotation {
    return objc.useMsgSendVariants
        ? _objc_msgSend_10Fpret(this.pointer, _sel_frameCenterRotation)
        : _objc_msgSend_10(this.pointer, _sel_frameCenterRotation);
  }

  /// setFrameCenterRotation:
  set frameCenterRotation(double value) {
    return _objc_msgSend_64(this.pointer, _sel_setFrameCenterRotation_, value);
  }

  /// setBoundsOrigin:
  void setBoundsOrigin_(CGPoint newOrigin) {
    _objc_msgSend_62(this.pointer, _sel_setBoundsOrigin_, newOrigin);
  }

  /// setBoundsSize:
  void setBoundsSize_(CGSize newSize) {
    _objc_msgSend_59(this.pointer, _sel_setBoundsSize_, newSize);
  }

  /// boundsRotation
  double get boundsRotation {
    return objc.useMsgSendVariants
        ? _objc_msgSend_10Fpret(this.pointer, _sel_boundsRotation)
        : _objc_msgSend_10(this.pointer, _sel_boundsRotation);
  }

  /// setBoundsRotation:
  set boundsRotation(double value) {
    return _objc_msgSend_64(this.pointer, _sel_setBoundsRotation_, value);
  }

  /// translateOriginToPoint:
  void translateOriginToPoint_(CGPoint translation) {
    _objc_msgSend_62(this.pointer, _sel_translateOriginToPoint_, translation);
  }

  /// scaleUnitSquareToSize:
  void scaleUnitSquareToSize_(CGSize newUnitSize) {
    _objc_msgSend_59(this.pointer, _sel_scaleUnitSquareToSize_, newUnitSize);
  }

  /// rotateByAngle:
  void rotateByAngle_(double angle) {
    _objc_msgSend_65(this.pointer, _sel_rotateByAngle_, angle);
  }

  /// bounds
  void getBounds(ffi.Pointer<CGRect> stret) {
    objc.useMsgSendVariants
        ? _objc_msgSend_36Stret(stret, this.pointer, _sel_bounds)
        : stret.ref = _objc_msgSend_36(this.pointer, _sel_bounds);
  }

  /// setBounds:
  set bounds(CGRect value) {
    return _objc_msgSend_63(this.pointer, _sel_setBounds_, value);
  }

  /// isFlipped
  bool get flipped {
    return _objc_msgSend_13(this.pointer, _sel_isFlipped);
  }

  /// isRotatedFromBase
  bool get rotatedFromBase {
    return _objc_msgSend_13(this.pointer, _sel_isRotatedFromBase);
  }

  /// isRotatedOrScaledFromBase
  bool get rotatedOrScaledFromBase {
    return _objc_msgSend_13(this.pointer, _sel_isRotatedOrScaledFromBase);
  }

  /// isOpaque
  bool get opaque {
    return _objc_msgSend_13(this.pointer, _sel_isOpaque);
  }

  /// convertPoint:fromView:
  void convertPoint_fromView_(
      ffi.Pointer<CGPoint> stret, CGPoint point, NSView? view) {
    objc.useMsgSendVariants
        ? _objc_msgSend_66Stret(stret, this.pointer,
            _sel_convertPoint_fromView_, point, view?.pointer ?? ffi.nullptr)
        : stret.ref = _objc_msgSend_66(this.pointer,
            _sel_convertPoint_fromView_, point, view?.pointer ?? ffi.nullptr);
  }

  /// convertPoint:toView:
  void convertPoint_toView_(
      ffi.Pointer<CGPoint> stret, CGPoint point, NSView? view) {
    objc.useMsgSendVariants
        ? _objc_msgSend_66Stret(stret, this.pointer, _sel_convertPoint_toView_,
            point, view?.pointer ?? ffi.nullptr)
        : stret.ref = _objc_msgSend_66(this.pointer, _sel_convertPoint_toView_,
            point, view?.pointer ?? ffi.nullptr);
  }

  /// convertSize:fromView:
  void convertSize_fromView_(
      ffi.Pointer<CGSize> stret, CGSize size, NSView? view) {
    objc.useMsgSendVariants
        ? _objc_msgSend_67Stret(stret, this.pointer, _sel_convertSize_fromView_,
            size, view?.pointer ?? ffi.nullptr)
        : stret.ref = _objc_msgSend_67(this.pointer, _sel_convertSize_fromView_,
            size, view?.pointer ?? ffi.nullptr);
  }

  /// convertSize:toView:
  void convertSize_toView_(
      ffi.Pointer<CGSize> stret, CGSize size, NSView? view) {
    objc.useMsgSendVariants
        ? _objc_msgSend_67Stret(stret, this.pointer, _sel_convertSize_toView_,
            size, view?.pointer ?? ffi.nullptr)
        : stret.ref = _objc_msgSend_67(this.pointer, _sel_convertSize_toView_,
            size, view?.pointer ?? ffi.nullptr);
  }

  /// convertRect:fromView:
  void convertRect_fromView_(
      ffi.Pointer<CGRect> stret, CGRect rect, NSView? view) {
    objc.useMsgSendVariants
        ? _objc_msgSend_68Stret(stret, this.pointer, _sel_convertRect_fromView_,
            rect, view?.pointer ?? ffi.nullptr)
        : stret.ref = _objc_msgSend_68(this.pointer, _sel_convertRect_fromView_,
            rect, view?.pointer ?? ffi.nullptr);
  }

  /// convertRect:toView:
  void convertRect_toView_(
      ffi.Pointer<CGRect> stret, CGRect rect, NSView? view) {
    objc.useMsgSendVariants
        ? _objc_msgSend_68Stret(stret, this.pointer, _sel_convertRect_toView_,
            rect, view?.pointer ?? ffi.nullptr)
        : stret.ref = _objc_msgSend_68(this.pointer, _sel_convertRect_toView_,
            rect, view?.pointer ?? ffi.nullptr);
  }

  /// backingAlignedRect:options:
  void backingAlignedRect_options_(
      ffi.Pointer<CGRect> stret, CGRect rect, NSAlignmentOptions options) {
    objc.useMsgSendVariants
        ? _objc_msgSend_69Stret(stret, this.pointer,
            _sel_backingAlignedRect_options_, rect, options.value)
        : stret.ref = _objc_msgSend_69(this.pointer,
            _sel_backingAlignedRect_options_, rect, options.value);
  }

  /// centerScanRect:
  void centerScanRect_(ffi.Pointer<CGRect> stret, CGRect rect) {
    objc.useMsgSendVariants
        ? _objc_msgSend_28Stret(stret, this.pointer, _sel_centerScanRect_, rect)
        : stret.ref =
            _objc_msgSend_28(this.pointer, _sel_centerScanRect_, rect);
  }

  /// convertPointToBacking:
  void convertPointToBacking_(ffi.Pointer<CGPoint> stret, CGPoint point) {
    objc.useMsgSendVariants
        ? _objc_msgSend_70Stret(
            stret, this.pointer, _sel_convertPointToBacking_, point)
        : stret.ref =
            _objc_msgSend_70(this.pointer, _sel_convertPointToBacking_, point);
  }

  /// convertPointFromBacking:
  void convertPointFromBacking_(ffi.Pointer<CGPoint> stret, CGPoint point) {
    objc.useMsgSendVariants
        ? _objc_msgSend_70Stret(
            stret, this.pointer, _sel_convertPointFromBacking_, point)
        : stret.ref = _objc_msgSend_70(
            this.pointer, _sel_convertPointFromBacking_, point);
  }

  /// convertSizeToBacking:
  void convertSizeToBacking_(ffi.Pointer<CGSize> stret, CGSize size) {
    objc.useMsgSendVariants
        ? _objc_msgSend_71Stret(
            stret, this.pointer, _sel_convertSizeToBacking_, size)
        : stret.ref =
            _objc_msgSend_71(this.pointer, _sel_convertSizeToBacking_, size);
  }

  /// convertSizeFromBacking:
  void convertSizeFromBacking_(ffi.Pointer<CGSize> stret, CGSize size) {
    objc.useMsgSendVariants
        ? _objc_msgSend_71Stret(
            stret, this.pointer, _sel_convertSizeFromBacking_, size)
        : stret.ref =
            _objc_msgSend_71(this.pointer, _sel_convertSizeFromBacking_, size);
  }

  /// convertRectToBacking:
  void convertRectToBacking_(ffi.Pointer<CGRect> stret, CGRect rect) {
    objc.useMsgSendVariants
        ? _objc_msgSend_28Stret(
            stret, this.pointer, _sel_convertRectToBacking_, rect)
        : stret.ref =
            _objc_msgSend_28(this.pointer, _sel_convertRectToBacking_, rect);
  }

  /// convertRectFromBacking:
  void convertRectFromBacking_(ffi.Pointer<CGRect> stret, CGRect rect) {
    objc.useMsgSendVariants
        ? _objc_msgSend_28Stret(
            stret, this.pointer, _sel_convertRectFromBacking_, rect)
        : stret.ref =
            _objc_msgSend_28(this.pointer, _sel_convertRectFromBacking_, rect);
  }

  /// convertPointToLayer:
  void convertPointToLayer_(ffi.Pointer<CGPoint> stret, CGPoint point) {
    objc.useMsgSendVariants
        ? _objc_msgSend_70Stret(
            stret, this.pointer, _sel_convertPointToLayer_, point)
        : stret.ref =
            _objc_msgSend_70(this.pointer, _sel_convertPointToLayer_, point);
  }

  /// convertPointFromLayer:
  void convertPointFromLayer_(ffi.Pointer<CGPoint> stret, CGPoint point) {
    objc.useMsgSendVariants
        ? _objc_msgSend_70Stret(
            stret, this.pointer, _sel_convertPointFromLayer_, point)
        : stret.ref =
            _objc_msgSend_70(this.pointer, _sel_convertPointFromLayer_, point);
  }

  /// convertSizeToLayer:
  void convertSizeToLayer_(ffi.Pointer<CGSize> stret, CGSize size) {
    objc.useMsgSendVariants
        ? _objc_msgSend_71Stret(
            stret, this.pointer, _sel_convertSizeToLayer_, size)
        : stret.ref =
            _objc_msgSend_71(this.pointer, _sel_convertSizeToLayer_, size);
  }

  /// convertSizeFromLayer:
  void convertSizeFromLayer_(ffi.Pointer<CGSize> stret, CGSize size) {
    objc.useMsgSendVariants
        ? _objc_msgSend_71Stret(
            stret, this.pointer, _sel_convertSizeFromLayer_, size)
        : stret.ref =
            _objc_msgSend_71(this.pointer, _sel_convertSizeFromLayer_, size);
  }

  /// convertRectToLayer:
  void convertRectToLayer_(ffi.Pointer<CGRect> stret, CGRect rect) {
    objc.useMsgSendVariants
        ? _objc_msgSend_28Stret(
            stret, this.pointer, _sel_convertRectToLayer_, rect)
        : stret.ref =
            _objc_msgSend_28(this.pointer, _sel_convertRectToLayer_, rect);
  }

  /// convertRectFromLayer:
  void convertRectFromLayer_(ffi.Pointer<CGRect> stret, CGRect rect) {
    objc.useMsgSendVariants
        ? _objc_msgSend_28Stret(
            stret, this.pointer, _sel_convertRectFromLayer_, rect)
        : stret.ref =
            _objc_msgSend_28(this.pointer, _sel_convertRectFromLayer_, rect);
  }

  /// canDrawConcurrently
  bool get canDrawConcurrently {
    return _objc_msgSend_13(this.pointer, _sel_canDrawConcurrently);
  }

  /// setCanDrawConcurrently:
  set canDrawConcurrently(bool value) {
    return _objc_msgSend_14(this.pointer, _sel_setCanDrawConcurrently_, value);
  }

  /// canDraw
  bool get canDraw {
    return _objc_msgSend_13(this.pointer, _sel_canDraw);
  }

  /// setNeedsDisplayInRect:
  void setNeedsDisplayInRect_(CGRect invalidRect) {
    _objc_msgSend_72(this.pointer, _sel_setNeedsDisplayInRect_, invalidRect);
  }

  /// needsDisplay
  bool get needsDisplay {
    return _objc_msgSend_13(this.pointer, _sel_needsDisplay);
  }

  /// setNeedsDisplay:
  set needsDisplay(bool value) {
    return _objc_msgSend_14(this.pointer, _sel_setNeedsDisplay_, value);
  }

  /// lockFocus
  void lockFocus() {
    _objc_msgSend_11(this.pointer, _sel_lockFocus);
  }

  /// unlockFocus
  void unlockFocus() {
    _objc_msgSend_11(this.pointer, _sel_unlockFocus);
  }

  /// lockFocusIfCanDraw
  bool lockFocusIfCanDraw() {
    return _objc_msgSend_13(this.pointer, _sel_lockFocusIfCanDraw);
  }

  /// lockFocusIfCanDrawInContext:
  bool lockFocusIfCanDrawInContext_(NSGraphicsContext context) {
    return _objc_msgSend_73(
        this.pointer, _sel_lockFocusIfCanDrawInContext_, context.pointer);
  }

  /// focusView
  static NSView? getFocusView() {
    final _ret = _objc_msgSend_47(_class_NSView, _sel_focusView);
    return _ret.address == 0
        ? null
        : NSView.castFromPointer(_ret, retain: true, release: true);
  }

  /// visibleRect
  void getVisibleRect(ffi.Pointer<CGRect> stret) {
    objc.useMsgSendVariants
        ? _objc_msgSend_36Stret(stret, this.pointer, _sel_visibleRect)
        : stret.ref = _objc_msgSend_36(this.pointer, _sel_visibleRect);
  }

  /// display
  void display() {
    _objc_msgSend_11(this.pointer, _sel_display);
  }

  /// displayIfNeeded
  void displayIfNeeded() {
    _objc_msgSend_11(this.pointer, _sel_displayIfNeeded);
  }

  /// displayIfNeededIgnoringOpacity
  void displayIfNeededIgnoringOpacity() {
    _objc_msgSend_11(this.pointer, _sel_displayIfNeededIgnoringOpacity);
  }

  /// displayRect:
  void displayRect_(CGRect rect) {
    _objc_msgSend_72(this.pointer, _sel_displayRect_, rect);
  }

  /// displayIfNeededInRect:
  void displayIfNeededInRect_(CGRect rect) {
    _objc_msgSend_72(this.pointer, _sel_displayIfNeededInRect_, rect);
  }

  /// displayRectIgnoringOpacity:
  void displayRectIgnoringOpacity_(CGRect rect) {
    _objc_msgSend_72(this.pointer, _sel_displayRectIgnoringOpacity_, rect);
  }

  /// displayIfNeededInRectIgnoringOpacity:
  void displayIfNeededInRectIgnoringOpacity_(CGRect rect) {
    _objc_msgSend_72(
        this.pointer, _sel_displayIfNeededInRectIgnoringOpacity_, rect);
  }

  /// drawRect:
  void drawRect_(CGRect dirtyRect) {
    _objc_msgSend_72(this.pointer, _sel_drawRect_, dirtyRect);
  }

  /// displayRectIgnoringOpacity:inContext:
  void displayRectIgnoringOpacity_inContext_(
      CGRect rect, NSGraphicsContext context) {
    _objc_msgSend_74(this.pointer, _sel_displayRectIgnoringOpacity_inContext_,
        rect, context.pointer);
  }

  /// bitmapImageRepForCachingDisplayInRect:
  NSBitmapImageRep? bitmapImageRepForCachingDisplayInRect_(CGRect rect) {
    final _ret = _objc_msgSend_75(
        this.pointer, _sel_bitmapImageRepForCachingDisplayInRect_, rect);
    return _ret.address == 0
        ? null
        : NSBitmapImageRep.castFromPointer(_ret, retain: true, release: true);
  }

  /// cacheDisplayInRect:toBitmapImageRep:
  void cacheDisplayInRect_toBitmapImageRep_(
      CGRect rect, NSBitmapImageRep bitmapImageRep) {
    _objc_msgSend_76(this.pointer, _sel_cacheDisplayInRect_toBitmapImageRep_,
        rect, bitmapImageRep.pointer);
  }

  /// viewWillDraw
  void viewWillDraw() {
    _objc_msgSend_11(this.pointer, _sel_viewWillDraw);
  }

  /// scrollPoint:
  void scrollPoint_(CGPoint point) {
    _objc_msgSend_62(this.pointer, _sel_scrollPoint_, point);
  }

  /// scrollRectToVisible:
  bool scrollRectToVisible_(CGRect rect) {
    return _objc_msgSend_52(this.pointer, _sel_scrollRectToVisible_, rect);
  }

  /// autoscroll:
  bool autoscroll_(NSEvent event) {
    return _objc_msgSend_110(this.pointer, _sel_autoscroll_, event.pointer);
  }

  /// adjustScroll:
  void adjustScroll_(ffi.Pointer<CGRect> stret, CGRect newVisible) {
    objc.useMsgSendVariants
        ? _objc_msgSend_28Stret(
            stret, this.pointer, _sel_adjustScroll_, newVisible)
        : stret.ref =
            _objc_msgSend_28(this.pointer, _sel_adjustScroll_, newVisible);
  }

  /// scrollRect:by:
  void scrollRect_by_(CGRect rect, CGSize delta) {
    _objc_msgSend_111(this.pointer, _sel_scrollRect_by_, rect, delta);
  }

  /// translateRectsNeedingDisplayInRect:by:
  void translateRectsNeedingDisplayInRect_by_(CGRect clipRect, CGSize delta) {
    _objc_msgSend_111(this.pointer, _sel_translateRectsNeedingDisplayInRect_by_,
        clipRect, delta);
  }

  /// hitTest:
  NSView? hitTest_(CGPoint point) {
    final _ret = _objc_msgSend_112(this.pointer, _sel_hitTest_, point);
    return _ret.address == 0
        ? null
        : NSView.castFromPointer(_ret, retain: true, release: true);
  }

  /// mouse:inRect:
  bool mouse_inRect_(CGPoint point, CGRect rect) {
    return _objc_msgSend_113(this.pointer, _sel_mouse_inRect_, point, rect);
  }

  /// viewWithTag:
  NSView? viewWithTag_(int tag) {
    final _ret = _objc_msgSend_114(this.pointer, _sel_viewWithTag_, tag);
    return _ret.address == 0
        ? null
        : NSView.castFromPointer(_ret, retain: true, release: true);
  }

  /// tag
  int get tag {
    return _objc_msgSend_79(this.pointer, _sel_tag);
  }

  /// performKeyEquivalent:
  bool performKeyEquivalent_(NSEvent event) {
    return _objc_msgSend_110(
        this.pointer, _sel_performKeyEquivalent_, event.pointer);
  }

  /// acceptsFirstMouse:
  bool acceptsFirstMouse_(NSEvent? event) {
    return _objc_msgSend_115(
        this.pointer, _sel_acceptsFirstMouse_, event?.pointer ?? ffi.nullptr);
  }

  /// shouldDelayWindowOrderingForEvent:
  bool shouldDelayWindowOrderingForEvent_(NSEvent event) {
    return _objc_msgSend_110(
        this.pointer, _sel_shouldDelayWindowOrderingForEvent_, event.pointer);
  }

  /// needsPanelToBecomeKey
  bool get needsPanelToBecomeKey {
    return _objc_msgSend_13(this.pointer, _sel_needsPanelToBecomeKey);
  }

  /// mouseDownCanMoveWindow
  bool get mouseDownCanMoveWindow {
    return _objc_msgSend_13(this.pointer, _sel_mouseDownCanMoveWindow);
  }

  /// acceptsTouchEvents
  bool get acceptsTouchEvents {
    return _objc_msgSend_13(this.pointer, _sel_acceptsTouchEvents);
  }

  /// setAcceptsTouchEvents:
  set acceptsTouchEvents(bool value) {
    return _objc_msgSend_14(this.pointer, _sel_setAcceptsTouchEvents_, value);
  }

  /// wantsRestingTouches
  bool get wantsRestingTouches {
    return _objc_msgSend_13(this.pointer, _sel_wantsRestingTouches);
  }

  /// setWantsRestingTouches:
  set wantsRestingTouches(bool value) {
    return _objc_msgSend_14(this.pointer, _sel_setWantsRestingTouches_, value);
  }

  /// makeBackingLayer
  CALayer makeBackingLayer() {
    final _ret = _objc_msgSend_116(this.pointer, _sel_makeBackingLayer);
    return CALayer.castFromPointer(_ret, retain: true, release: true);
  }

  /// layerContentsRedrawPolicy
  NSViewLayerContentsRedrawPolicy get layerContentsRedrawPolicy {
    final _ret =
        _objc_msgSend_117(this.pointer, _sel_layerContentsRedrawPolicy);
    return NSViewLayerContentsRedrawPolicy.fromValue(_ret);
  }

  /// setLayerContentsRedrawPolicy:
  set layerContentsRedrawPolicy(NSViewLayerContentsRedrawPolicy value) {
    return _objc_msgSend_118(
        this.pointer, _sel_setLayerContentsRedrawPolicy_, value.value);
  }

  /// layerContentsPlacement
  NSViewLayerContentsPlacement get layerContentsPlacement {
    final _ret = _objc_msgSend_119(this.pointer, _sel_layerContentsPlacement);
    return NSViewLayerContentsPlacement.fromValue(_ret);
  }

  /// setLayerContentsPlacement:
  set layerContentsPlacement(NSViewLayerContentsPlacement value) {
    return _objc_msgSend_120(
        this.pointer, _sel_setLayerContentsPlacement_, value.value);
  }

  /// wantsLayer
  bool get wantsLayer {
    return _objc_msgSend_13(this.pointer, _sel_wantsLayer);
  }

  /// setWantsLayer:
  set wantsLayer(bool value) {
    return _objc_msgSend_14(this.pointer, _sel_setWantsLayer_, value);
  }

  /// layer
  CALayer? get layer {
    final _ret = _objc_msgSend_121(this.pointer, _sel_layer);
    return _ret.address == 0
        ? null
        : CALayer.castFromPointer(_ret, retain: true, release: true);
  }

  /// setLayer:
  set layer(CALayer? value) {
    return _objc_msgSend_122(
        this.pointer, _sel_setLayer_, value?.pointer ?? ffi.nullptr);
  }

  /// wantsUpdateLayer
  bool get wantsUpdateLayer {
    return _objc_msgSend_13(this.pointer, _sel_wantsUpdateLayer);
  }

  /// updateLayer
  void updateLayer() {
    _objc_msgSend_11(this.pointer, _sel_updateLayer);
  }

  /// canDrawSubviewsIntoLayer
  bool get canDrawSubviewsIntoLayer {
    return _objc_msgSend_13(this.pointer, _sel_canDrawSubviewsIntoLayer);
  }

  /// setCanDrawSubviewsIntoLayer:
  set canDrawSubviewsIntoLayer(bool value) {
    return _objc_msgSend_14(
        this.pointer, _sel_setCanDrawSubviewsIntoLayer_, value);
  }

  /// layoutSubtreeIfNeeded
  void layoutSubtreeIfNeeded() {
    _objc_msgSend_11(this.pointer, _sel_layoutSubtreeIfNeeded);
  }

  /// layout
  void layout() {
    _objc_msgSend_11(this.pointer, _sel_layout);
  }

  /// needsLayout
  bool get needsLayout {
    return _objc_msgSend_13(this.pointer, _sel_needsLayout);
  }

  /// setNeedsLayout:
  set needsLayout(bool value) {
    return _objc_msgSend_14(this.pointer, _sel_setNeedsLayout_, value);
  }

  /// alphaValue
  double get alphaValue {
    return objc.useMsgSendVariants
        ? _objc_msgSend_10Fpret(this.pointer, _sel_alphaValue)
        : _objc_msgSend_10(this.pointer, _sel_alphaValue);
  }

  /// setAlphaValue:
  set alphaValue(double value) {
    return _objc_msgSend_64(this.pointer, _sel_setAlphaValue_, value);
  }

  /// layerUsesCoreImageFilters
  bool get layerUsesCoreImageFilters {
    return _objc_msgSend_13(this.pointer, _sel_layerUsesCoreImageFilters);
  }

  /// setLayerUsesCoreImageFilters:
  set layerUsesCoreImageFilters(bool value) {
    return _objc_msgSend_14(
        this.pointer, _sel_setLayerUsesCoreImageFilters_, value);
  }

  /// backgroundFilters
  objc.ObjCObjectBase get backgroundFilters {
    final _ret = _objc_msgSend_2(this.pointer, _sel_backgroundFilters);
    return objc.ObjCObjectBase(_ret, retain: true, release: true);
  }

  /// setBackgroundFilters:
  set backgroundFilters(objc.ObjCObjectBase value) {
    return _objc_msgSend_48(
        this.pointer, _sel_setBackgroundFilters_, value.pointer);
  }

  /// compositingFilter
  CIFilter? get compositingFilter {
    final _ret = _objc_msgSend_123(this.pointer, _sel_compositingFilter);
    return _ret.address == 0
        ? null
        : CIFilter.castFromPointer(_ret, retain: true, release: true);
  }

  /// setCompositingFilter:
  set compositingFilter(CIFilter? value) {
    return _objc_msgSend_124(this.pointer, _sel_setCompositingFilter_,
        value?.pointer ?? ffi.nullptr);
  }

  /// contentFilters
  objc.ObjCObjectBase get contentFilters {
    final _ret = _objc_msgSend_2(this.pointer, _sel_contentFilters);
    return objc.ObjCObjectBase(_ret, retain: true, release: true);
  }

  /// setContentFilters:
  set contentFilters(objc.ObjCObjectBase value) {
    return _objc_msgSend_48(
        this.pointer, _sel_setContentFilters_, value.pointer);
  }

  /// shadow
  NSShadow? get shadow {
    final _ret = _objc_msgSend_125(this.pointer, _sel_shadow);
    return _ret.address == 0
        ? null
        : NSShadow.castFromPointer(_ret, retain: true, release: true);
  }

  /// setShadow:
  set shadow(NSShadow? value) {
    return _objc_msgSend_126(
        this.pointer, _sel_setShadow_, value?.pointer ?? ffi.nullptr);
  }

  /// clipsToBounds
  bool get clipsToBounds {
    return _objc_msgSend_13(this.pointer, _sel_clipsToBounds);
  }

  /// setClipsToBounds:
  set clipsToBounds(bool value) {
    return _objc_msgSend_14(this.pointer, _sel_setClipsToBounds_, value);
  }

  /// postsBoundsChangedNotifications
  bool get postsBoundsChangedNotifications {
    return _objc_msgSend_13(this.pointer, _sel_postsBoundsChangedNotifications);
  }

  /// setPostsBoundsChangedNotifications:
  set postsBoundsChangedNotifications(bool value) {
    return _objc_msgSend_14(
        this.pointer, _sel_setPostsBoundsChangedNotifications_, value);
  }

  /// enclosingScrollView
  NSScrollView? get enclosingScrollView {
    final _ret = _objc_msgSend_127(this.pointer, _sel_enclosingScrollView);
    return _ret.address == 0
        ? null
        : NSScrollView.castFromPointer(_ret, retain: true, release: true);
  }

  /// menuForEvent:
  NSMenu? menuForEvent_(NSEvent event) {
    final _ret =
        _objc_msgSend_170(this.pointer, _sel_menuForEvent_, event.pointer);
    return _ret.address == 0
        ? null
        : NSMenu.castFromPointer(_ret, retain: true, release: true);
  }

  /// defaultMenu
  static NSMenu? getDefaultMenu() {
    final _ret = _objc_msgSend_133(_class_NSView, _sel_defaultMenu);
    return _ret.address == 0
        ? null
        : NSMenu.castFromPointer(_ret, retain: true, release: true);
  }

  /// willOpenMenu:withEvent:
  void willOpenMenu_withEvent_(NSMenu menu, NSEvent event) {
    _objc_msgSend_171(this.pointer, _sel_willOpenMenu_withEvent_, menu.pointer,
        event.pointer);
  }

  /// didCloseMenu:withEvent:
  void didCloseMenu_withEvent_(NSMenu menu, NSEvent? event) {
    _objc_msgSend_172(this.pointer, _sel_didCloseMenu_withEvent_, menu.pointer,
        event?.pointer ?? ffi.nullptr);
  }

  /// toolTip
  objc.NSString? get toolTip {
    final _ret = _objc_msgSend_84(this.pointer, _sel_toolTip);
    return _ret.address == 0
        ? null
        : objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// setToolTip:
  set toolTip(objc.NSString? value) {
    return _objc_msgSend_148(
        this.pointer, _sel_setToolTip_, value?.pointer ?? ffi.nullptr);
  }

  /// addToolTipRect:owner:userData:
  int addToolTipRect_owner_userData_(
      CGRect rect, objc.ObjCObjectBase owner, ffi.Pointer<ffi.Void> data) {
    return _objc_msgSend_173(this.pointer, _sel_addToolTipRect_owner_userData_,
        rect, owner.pointer, data);
  }

  /// removeToolTip:
  void removeToolTip_(int tag) {
    _objc_msgSend_41(this.pointer, _sel_removeToolTip_, tag);
  }

  /// removeAllToolTips
  void removeAllToolTips() {
    _objc_msgSend_11(this.pointer, _sel_removeAllToolTips);
  }

  /// viewWillStartLiveResize
  void viewWillStartLiveResize() {
    _objc_msgSend_11(this.pointer, _sel_viewWillStartLiveResize);
  }

  /// viewDidEndLiveResize
  void viewDidEndLiveResize() {
    _objc_msgSend_11(this.pointer, _sel_viewDidEndLiveResize);
  }

  /// inLiveResize
  bool get inLiveResize {
    return _objc_msgSend_13(this.pointer, _sel_inLiveResize);
  }

  /// preservesContentDuringLiveResize
  bool get preservesContentDuringLiveResize {
    return _objc_msgSend_13(
        this.pointer, _sel_preservesContentDuringLiveResize);
  }

  /// rectPreservedDuringLiveResize
  void getRectPreservedDuringLiveResize(ffi.Pointer<CGRect> stret) {
    objc.useMsgSendVariants
        ? _objc_msgSend_36Stret(
            stret, this.pointer, _sel_rectPreservedDuringLiveResize)
        : stret.ref =
            _objc_msgSend_36(this.pointer, _sel_rectPreservedDuringLiveResize);
  }

  /// getRectsExposedDuringLiveResize:count:
  void getRectsExposedDuringLiveResize_count_(
      ffi.Pointer<CGRect> exposedRects, ffi.Pointer<ffi.Long> count) {
    _objc_msgSend_174(this.pointer, _sel_getRectsExposedDuringLiveResize_count_,
        exposedRects, count);
  }

  /// inputContext
  NSTextInputContext? get inputContext {
    final _ret = _objc_msgSend_175(this.pointer, _sel_inputContext);
    return _ret.address == 0
        ? null
        : NSTextInputContext.castFromPointer(_ret, retain: true, release: true);
  }

  /// rectForSmartMagnificationAtPoint:inRect:
  void rectForSmartMagnificationAtPoint_inRect_(
      ffi.Pointer<CGRect> stret, CGPoint location, CGRect visibleRect) {
    objc.useMsgSendVariants
        ? _objc_msgSend_176Stret(
            stret,
            this.pointer,
            _sel_rectForSmartMagnificationAtPoint_inRect_,
            location,
            visibleRect)
        : stret.ref = _objc_msgSend_176(
            this.pointer,
            _sel_rectForSmartMagnificationAtPoint_inRect_,
            location,
            visibleRect);
  }

  /// userInterfaceLayoutDirection
  NSUserInterfaceLayoutDirection get userInterfaceLayoutDirection {
    final _ret =
        _objc_msgSend_168(this.pointer, _sel_userInterfaceLayoutDirection);
    return NSUserInterfaceLayoutDirection.fromValue(_ret);
  }

  /// setUserInterfaceLayoutDirection:
  set userInterfaceLayoutDirection(NSUserInterfaceLayoutDirection value) {
    return _objc_msgSend_169(
        this.pointer, _sel_setUserInterfaceLayoutDirection_, value.value);
  }

  /// prepareForReuse
  void prepareForReuse() {
    _objc_msgSend_11(this.pointer, _sel_prepareForReuse);
  }

  /// isCompatibleWithResponsiveScrolling
  static bool getCompatibleWithResponsiveScrolling() {
    return _objc_msgSend_13(
        _class_NSView, _sel_isCompatibleWithResponsiveScrolling);
  }

  /// prepareContentInRect:
  void prepareContentInRect_(CGRect rect) {
    _objc_msgSend_72(this.pointer, _sel_prepareContentInRect_, rect);
  }

  /// preparedContentRect
  void getPreparedContentRect(ffi.Pointer<CGRect> stret) {
    objc.useMsgSendVariants
        ? _objc_msgSend_36Stret(stret, this.pointer, _sel_preparedContentRect)
        : stret.ref = _objc_msgSend_36(this.pointer, _sel_preparedContentRect);
  }

  /// setPreparedContentRect:
  set preparedContentRect(CGRect value) {
    return _objc_msgSend_63(this.pointer, _sel_setPreparedContentRect_, value);
  }

  /// allowsVibrancy
  bool get allowsVibrancy {
    return _objc_msgSend_13(this.pointer, _sel_allowsVibrancy);
  }

  /// viewDidChangeEffectiveAppearance
  void viewDidChangeEffectiveAppearance() {
    _objc_msgSend_11(this.pointer, _sel_viewDidChangeEffectiveAppearance);
  }

  /// init
  NSView init() {
    final _ret = _objc_msgSend_2(this.pointer, _sel_init);
    return NSView.castFromPointer(_ret, retain: true, release: true);
  }

  /// new
  static NSView new1() {
    final _ret = _objc_msgSend_2(_class_NSView, _sel_new);
    return NSView.castFromPointer(_ret, retain: false, release: true);
  }

  /// allocWithZone:
  static NSView allocWithZone_(ffi.Pointer<_NSZone> zone) {
    final _ret = _objc_msgSend_20(_class_NSView, _sel_allocWithZone_, zone);
    return NSView.castFromPointer(_ret, retain: false, release: true);
  }

  /// alloc
  static NSView alloc() {
    final _ret = _objc_msgSend_2(_class_NSView, _sel_alloc);
    return NSView.castFromPointer(_ret, retain: false, release: true);
  }
}

late final _class_NSView = objc.getClass("NSView");
late final _sel_initWithFrame_ = objc.registerName("initWithFrame:");
final _objc_msgSend_44 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            instancetype Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, CGRect)>>()
    .asFunction<
        instancetype Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, CGRect)>();
final _objc_msgSend_45 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            instancetype Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        instancetype Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<objc.ObjCObject>)>();
late final _sel_window = objc.registerName("window");
final _objc_msgSend_46 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_superview = objc.registerName("superview");
final _objc_msgSend_47 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_subviews = objc.registerName("subviews");
late final _sel_setSubviews_ = objc.registerName("setSubviews:");
final _objc_msgSend_48 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<objc.ObjCObject>)>();
late final _sel_isDescendantOf_ = objc.registerName("isDescendantOf:");
final _objc_msgSend_49 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Bool Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        bool Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<objc.ObjCObject>)>();
late final _sel_ancestorSharedWithView_ =
    objc.registerName("ancestorSharedWithView:");
final _objc_msgSend_50 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<objc.ObjCObject>)>();
late final _sel_opaqueAncestor = objc.registerName("opaqueAncestor");
late final _sel_isHidden = objc.registerName("isHidden");
late final _sel_setHidden_ = objc.registerName("setHidden:");
late final _sel_isHiddenOrHasHiddenAncestor =
    objc.registerName("isHiddenOrHasHiddenAncestor");
late final _sel_getRectsBeingDrawn_count_ =
    objc.registerName("getRectsBeingDrawn:count:");
final _objc_msgSend_51 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<ffi.Pointer<CGRect>>,
                ffi.Pointer<ffi.Long>)>>()
    .asFunction<
        void Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<ffi.Pointer<CGRect>>,
            ffi.Pointer<ffi.Long>)>();
late final _sel_needsToDrawRect_ = objc.registerName("needsToDrawRect:");
final _objc_msgSend_52 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Bool Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, CGRect)>>()
    .asFunction<
        bool Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, CGRect)>();
late final _sel_wantsDefaultClipping =
    objc.registerName("wantsDefaultClipping");
late final _sel_viewDidHide = objc.registerName("viewDidHide");
late final _sel_viewDidUnhide = objc.registerName("viewDidUnhide");
late final _sel_addSubview_ = objc.registerName("addSubview:");
final _objc_msgSend_53 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<objc.ObjCObject>)>();

enum NSWindowOrderingMode {
  NSWindowAbove(1),
  NSWindowBelow(-1),
  NSWindowOut(0);

  final int value;
  const NSWindowOrderingMode(this.value);

  static NSWindowOrderingMode fromValue(int value) => switch (value) {
        1 => NSWindowAbove,
        -1 => NSWindowBelow,
        0 => NSWindowOut,
        _ =>
          throw ArgumentError("Unknown value for NSWindowOrderingMode: $value"),
      };
}

late final _sel_addSubview_positioned_relativeTo_ =
    objc.registerName("addSubview:positioned:relativeTo:");
final _objc_msgSend_54 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Long,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        void Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            int,
            ffi.Pointer<objc.ObjCObject>)>();
late final _sel_sortSubviewsUsingFunction_context_ =
    objc.registerName("sortSubviewsUsingFunction:context:");
final _objc_msgSend_55 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<
                    ffi.NativeFunction<
                        ffi.Long Function(
                            ffi.Pointer<objc.ObjCObject>,
                            ffi.Pointer<objc.ObjCObject>,
                            ffi.Pointer<ffi.Void>)>>,
                ffi.Pointer<ffi.Void>)>>()
    .asFunction<
        void Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<
                ffi.NativeFunction<
                    ffi.Long Function(ffi.Pointer<objc.ObjCObject>,
                        ffi.Pointer<objc.ObjCObject>, ffi.Pointer<ffi.Void>)>>,
            ffi.Pointer<ffi.Void>)>();
late final _sel_viewWillMoveToWindow_ =
    objc.registerName("viewWillMoveToWindow:");
final _objc_msgSend_56 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<objc.ObjCObject>)>();
late final _sel_viewDidMoveToWindow = objc.registerName("viewDidMoveToWindow");
late final _sel_viewWillMoveToSuperview_ =
    objc.registerName("viewWillMoveToSuperview:");
final _objc_msgSend_57 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<objc.ObjCObject>)>();
late final _sel_viewDidMoveToSuperview =
    objc.registerName("viewDidMoveToSuperview");
late final _sel_didAddSubview_ = objc.registerName("didAddSubview:");
late final _sel_willRemoveSubview_ = objc.registerName("willRemoveSubview:");
late final _sel_removeFromSuperview = objc.registerName("removeFromSuperview");
late final _sel_replaceSubview_with_ =
    objc.registerName("replaceSubview:with:");
final _objc_msgSend_58 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        void Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>();
late final _sel_removeFromSuperviewWithoutNeedingDisplay =
    objc.registerName("removeFromSuperviewWithoutNeedingDisplay");
late final _sel_viewDidChangeBackingProperties =
    objc.registerName("viewDidChangeBackingProperties");
late final _sel_postsFrameChangedNotifications =
    objc.registerName("postsFrameChangedNotifications");
late final _sel_setPostsFrameChangedNotifications_ =
    objc.registerName("setPostsFrameChangedNotifications:");
late final _sel_resizeSubviewsWithOldSize_ =
    objc.registerName("resizeSubviewsWithOldSize:");
final _objc_msgSend_59 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, CGSize)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, CGSize)>();
late final _sel_resizeWithOldSuperviewSize_ =
    objc.registerName("resizeWithOldSuperviewSize:");
late final _sel_autoresizesSubviews = objc.registerName("autoresizesSubviews");
late final _sel_setAutoresizesSubviews_ =
    objc.registerName("setAutoresizesSubviews:");

enum NSAutoresizingMaskOptions {
  NSViewNotSizable(0),
  NSViewMinXMargin(1),
  NSViewWidthSizable(2),
  NSViewMaxXMargin(4),
  NSViewMinYMargin(8),
  NSViewHeightSizable(16),
  NSViewMaxYMargin(32);

  final int value;
  const NSAutoresizingMaskOptions(this.value);

  static NSAutoresizingMaskOptions fromValue(int value) => switch (value) {
        0 => NSViewNotSizable,
        1 => NSViewMinXMargin,
        2 => NSViewWidthSizable,
        4 => NSViewMaxXMargin,
        8 => NSViewMinYMargin,
        16 => NSViewHeightSizable,
        32 => NSViewMaxYMargin,
        _ => throw ArgumentError(
            "Unknown value for NSAutoresizingMaskOptions: $value"),
      };
}

late final _sel_autoresizingMask = objc.registerName("autoresizingMask");
final _objc_msgSend_60 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.UnsignedLong Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        int Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_setAutoresizingMask_ =
    objc.registerName("setAutoresizingMask:");
final _objc_msgSend_61 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, ffi.UnsignedLong)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, int)>();
late final _sel_setFrameOrigin_ = objc.registerName("setFrameOrigin:");
final _objc_msgSend_62 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, CGPoint)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, CGPoint)>();
late final _sel_setFrameSize_ = objc.registerName("setFrameSize:");
late final _sel_frame = objc.registerName("frame");
late final _sel_setFrame_ = objc.registerName("setFrame:");
final _objc_msgSend_63 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, CGRect)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, CGRect)>();
late final _sel_frameRotation = objc.registerName("frameRotation");
late final _sel_setFrameRotation_ = objc.registerName("setFrameRotation:");
final _objc_msgSend_64 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, ffi.Double)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, double)>();
late final _sel_frameCenterRotation = objc.registerName("frameCenterRotation");
late final _sel_setFrameCenterRotation_ =
    objc.registerName("setFrameCenterRotation:");
late final _sel_setBoundsOrigin_ = objc.registerName("setBoundsOrigin:");
late final _sel_setBoundsSize_ = objc.registerName("setBoundsSize:");
late final _sel_boundsRotation = objc.registerName("boundsRotation");
late final _sel_setBoundsRotation_ = objc.registerName("setBoundsRotation:");
late final _sel_translateOriginToPoint_ =
    objc.registerName("translateOriginToPoint:");
late final _sel_scaleUnitSquareToSize_ =
    objc.registerName("scaleUnitSquareToSize:");
late final _sel_rotateByAngle_ = objc.registerName("rotateByAngle:");
final _objc_msgSend_65 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, ffi.Double)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, double)>();
late final _sel_bounds = objc.registerName("bounds");
late final _sel_setBounds_ = objc.registerName("setBounds:");
late final _sel_isFlipped = objc.registerName("isFlipped");
late final _sel_isRotatedFromBase = objc.registerName("isRotatedFromBase");
late final _sel_isRotatedOrScaledFromBase =
    objc.registerName("isRotatedOrScaledFromBase");
late final _sel_isOpaque = objc.registerName("isOpaque");
late final _sel_convertPoint_fromView_ =
    objc.registerName("convertPoint:fromView:");
final _objc_msgSend_66 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            CGPoint Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                CGPoint,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        CGPoint Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            CGPoint,
            ffi.Pointer<objc.ObjCObject>)>();
final _objc_msgSend_66Stret = objc.msgSendStretPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<CGPoint>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                CGPoint,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        void Function(
            ffi.Pointer<CGPoint>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            CGPoint,
            ffi.Pointer<objc.ObjCObject>)>();
late final _sel_convertPoint_toView_ =
    objc.registerName("convertPoint:toView:");
late final _sel_convertSize_fromView_ =
    objc.registerName("convertSize:fromView:");
final _objc_msgSend_67 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            CGSize Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                CGSize,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        CGSize Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            CGSize,
            ffi.Pointer<objc.ObjCObject>)>();
final _objc_msgSend_67Stret = objc.msgSendStretPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<CGSize>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                CGSize,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        void Function(
            ffi.Pointer<CGSize>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            CGSize,
            ffi.Pointer<objc.ObjCObject>)>();
late final _sel_convertSize_toView_ = objc.registerName("convertSize:toView:");
late final _sel_convertRect_fromView_ =
    objc.registerName("convertRect:fromView:");
final _objc_msgSend_68 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            CGRect Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                CGRect,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        CGRect Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            CGRect,
            ffi.Pointer<objc.ObjCObject>)>();
final _objc_msgSend_68Stret = objc.msgSendStretPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<CGRect>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                CGRect,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        void Function(
            ffi.Pointer<CGRect>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            CGRect,
            ffi.Pointer<objc.ObjCObject>)>();
late final _sel_convertRect_toView_ = objc.registerName("convertRect:toView:");

enum NSAlignmentOptions {
  NSAlignMinXInward(1),
  NSAlignMinYInward(2),
  NSAlignMaxXInward(4),
  NSAlignMaxYInward(8),
  NSAlignWidthInward(16),
  NSAlignHeightInward(32),
  NSAlignMinXOutward(256),
  NSAlignMinYOutward(512),
  NSAlignMaxXOutward(1024),
  NSAlignMaxYOutward(2048),
  NSAlignWidthOutward(4096),
  NSAlignHeightOutward(8192),
  NSAlignMinXNearest(65536),
  NSAlignMinYNearest(131072),
  NSAlignMaxXNearest(262144),
  NSAlignMaxYNearest(524288),
  NSAlignWidthNearest(1048576),
  NSAlignHeightNearest(2097152),
  NSAlignRectFlipped(-9223372036854775808),
  NSAlignAllEdgesInward(15),
  NSAlignAllEdgesOutward(3840),
  NSAlignAllEdgesNearest(983040);

  final int value;
  const NSAlignmentOptions(this.value);

  static NSAlignmentOptions fromValue(int value) => switch (value) {
        1 => NSAlignMinXInward,
        2 => NSAlignMinYInward,
        4 => NSAlignMaxXInward,
        8 => NSAlignMaxYInward,
        16 => NSAlignWidthInward,
        32 => NSAlignHeightInward,
        256 => NSAlignMinXOutward,
        512 => NSAlignMinYOutward,
        1024 => NSAlignMaxXOutward,
        2048 => NSAlignMaxYOutward,
        4096 => NSAlignWidthOutward,
        8192 => NSAlignHeightOutward,
        65536 => NSAlignMinXNearest,
        131072 => NSAlignMinYNearest,
        262144 => NSAlignMaxXNearest,
        524288 => NSAlignMaxYNearest,
        1048576 => NSAlignWidthNearest,
        2097152 => NSAlignHeightNearest,
        -9223372036854775808 => NSAlignRectFlipped,
        15 => NSAlignAllEdgesInward,
        3840 => NSAlignAllEdgesOutward,
        983040 => NSAlignAllEdgesNearest,
        _ =>
          throw ArgumentError("Unknown value for NSAlignmentOptions: $value"),
      };
}

late final _sel_backingAlignedRect_options_ =
    objc.registerName("backingAlignedRect:options:");
final _objc_msgSend_69 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            CGRect Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, CGRect, ffi.LongLong)>>()
    .asFunction<
        CGRect Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, CGRect, int)>();
final _objc_msgSend_69Stret = objc.msgSendStretPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(ffi.Pointer<CGRect>, ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, CGRect, ffi.LongLong)>>()
    .asFunction<
        void Function(ffi.Pointer<CGRect>, ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, CGRect, int)>();
late final _sel_centerScanRect_ = objc.registerName("centerScanRect:");
late final _sel_convertPointToBacking_ =
    objc.registerName("convertPointToBacking:");
final _objc_msgSend_70 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            CGPoint Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, CGPoint)>>()
    .asFunction<
        CGPoint Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, CGPoint)>();
final _objc_msgSend_70Stret = objc.msgSendStretPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<CGPoint>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                CGPoint)>>()
    .asFunction<
        void Function(ffi.Pointer<CGPoint>, ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, CGPoint)>();
late final _sel_convertPointFromBacking_ =
    objc.registerName("convertPointFromBacking:");
late final _sel_convertSizeToBacking_ =
    objc.registerName("convertSizeToBacking:");
final _objc_msgSend_71 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            CGSize Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, CGSize)>>()
    .asFunction<
        CGSize Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, CGSize)>();
final _objc_msgSend_71Stret = objc.msgSendStretPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(ffi.Pointer<CGSize>, ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, CGSize)>>()
    .asFunction<
        void Function(ffi.Pointer<CGSize>, ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, CGSize)>();
late final _sel_convertSizeFromBacking_ =
    objc.registerName("convertSizeFromBacking:");
late final _sel_convertRectToBacking_ =
    objc.registerName("convertRectToBacking:");
late final _sel_convertRectFromBacking_ =
    objc.registerName("convertRectFromBacking:");
late final _sel_convertPointToLayer_ =
    objc.registerName("convertPointToLayer:");
late final _sel_convertPointFromLayer_ =
    objc.registerName("convertPointFromLayer:");
late final _sel_convertSizeToLayer_ = objc.registerName("convertSizeToLayer:");
late final _sel_convertSizeFromLayer_ =
    objc.registerName("convertSizeFromLayer:");
late final _sel_convertRectToLayer_ = objc.registerName("convertRectToLayer:");
late final _sel_convertRectFromLayer_ =
    objc.registerName("convertRectFromLayer:");
late final _sel_canDrawConcurrently = objc.registerName("canDrawConcurrently");
late final _sel_setCanDrawConcurrently_ =
    objc.registerName("setCanDrawConcurrently:");
late final _sel_canDraw = objc.registerName("canDraw");
late final _sel_setNeedsDisplayInRect_ =
    objc.registerName("setNeedsDisplayInRect:");
final _objc_msgSend_72 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, CGRect)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, CGRect)>();
late final _sel_needsDisplay = objc.registerName("needsDisplay");
late final _sel_setNeedsDisplay_ = objc.registerName("setNeedsDisplay:");
late final _sel_lockFocus = objc.registerName("lockFocus");
late final _sel_unlockFocus = objc.registerName("unlockFocus");
late final _sel_lockFocusIfCanDraw = objc.registerName("lockFocusIfCanDraw");

/// NSGraphicsContext
class NSGraphicsContext extends objc.ObjCObjectBase {
  NSGraphicsContext._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super(pointer, retain: retain, release: release);

  /// Constructs a [NSGraphicsContext] that points to the same underlying object as [other].
  NSGraphicsContext.castFrom(objc.ObjCObjectBase other)
      : this._(other.pointer, retain: true, release: true);

  /// Constructs a [NSGraphicsContext] that wraps the given raw object pointer.
  NSGraphicsContext.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [NSGraphicsContext].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_0(
        obj.pointer, _sel_isKindOfClass_, _class_NSGraphicsContext);
  }
}

late final _class_NSGraphicsContext = objc.getClass("NSGraphicsContext");
late final _sel_lockFocusIfCanDrawInContext_ =
    objc.registerName("lockFocusIfCanDrawInContext:");
final _objc_msgSend_73 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Bool Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        bool Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<objc.ObjCObject>)>();
late final _sel_focusView = objc.registerName("focusView");
late final _sel_visibleRect = objc.registerName("visibleRect");
late final _sel_display = objc.registerName("display");
late final _sel_displayIfNeeded = objc.registerName("displayIfNeeded");
late final _sel_displayIfNeededIgnoringOpacity =
    objc.registerName("displayIfNeededIgnoringOpacity");
late final _sel_displayRect_ = objc.registerName("displayRect:");
late final _sel_displayIfNeededInRect_ =
    objc.registerName("displayIfNeededInRect:");
late final _sel_displayRectIgnoringOpacity_ =
    objc.registerName("displayRectIgnoringOpacity:");
late final _sel_displayIfNeededInRectIgnoringOpacity_ =
    objc.registerName("displayIfNeededInRectIgnoringOpacity:");
late final _sel_drawRect_ = objc.registerName("drawRect:");
late final _sel_displayRectIgnoringOpacity_inContext_ =
    objc.registerName("displayRectIgnoringOpacity:inContext:");
final _objc_msgSend_74 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                CGRect,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        void Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            CGRect,
            ffi.Pointer<objc.ObjCObject>)>();

/// NSBitmapImageRep
class NSBitmapImageRep extends objc.ObjCObjectBase {
  NSBitmapImageRep._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super(pointer, retain: retain, release: release);

  /// Constructs a [NSBitmapImageRep] that points to the same underlying object as [other].
  NSBitmapImageRep.castFrom(objc.ObjCObjectBase other)
      : this._(other.pointer, retain: true, release: true);

  /// Constructs a [NSBitmapImageRep] that wraps the given raw object pointer.
  NSBitmapImageRep.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [NSBitmapImageRep].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_0(
        obj.pointer, _sel_isKindOfClass_, _class_NSBitmapImageRep);
  }
}

late final _class_NSBitmapImageRep = objc.getClass("NSBitmapImageRep");
late final _sel_bitmapImageRepForCachingDisplayInRect_ =
    objc.registerName("bitmapImageRepForCachingDisplayInRect:");
final _objc_msgSend_75 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, CGRect)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, CGRect)>();
late final _sel_cacheDisplayInRect_toBitmapImageRep_ =
    objc.registerName("cacheDisplayInRect:toBitmapImageRep:");
final _objc_msgSend_76 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                CGRect,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        void Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            CGRect,
            ffi.Pointer<objc.ObjCObject>)>();
late final _sel_viewWillDraw = objc.registerName("viewWillDraw");
late final _sel_scrollPoint_ = objc.registerName("scrollPoint:");
late final _sel_scrollRectToVisible_ =
    objc.registerName("scrollRectToVisible:");

/// NSEvent
class NSEvent extends objc.NSObject {
  NSEvent._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release);

  /// Constructs a [NSEvent] that points to the same underlying object as [other].
  NSEvent.castFrom(objc.ObjCObjectBase other)
      : this._(other.pointer, retain: true, release: true);

  /// Constructs a [NSEvent] that wraps the given raw object pointer.
  NSEvent.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [NSEvent].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_0(obj.pointer, _sel_isKindOfClass_, _class_NSEvent);
  }

  /// type
  NSEventType get type {
    final _ret = _objc_msgSend_77(this.pointer, _sel_type);
    return NSEventType.fromValue(_ret);
  }

  /// modifierFlags
  static NSEventModifierFlags getModifierFlags() {
    final _ret = _objc_msgSend_78(_class_NSEvent, _sel_modifierFlags);
    return NSEventModifierFlags.fromValue(_ret);
  }

  /// timestamp
  double get timestamp {
    return objc.useMsgSendVariants
        ? _objc_msgSend_10Fpret(this.pointer, _sel_timestamp)
        : _objc_msgSend_10(this.pointer, _sel_timestamp);
  }

  /// window
  NSWindow? get window {
    final _ret = _objc_msgSend_46(this.pointer, _sel_window);
    return _ret.address == 0
        ? null
        : NSWindow.castFromPointer(_ret, retain: true, release: true);
  }

  /// windowNumber
  int get windowNumber {
    return _objc_msgSend_79(this.pointer, _sel_windowNumber);
  }

  /// context
  NSGraphicsContext? get context {
    final _ret = _objc_msgSend_80(this.pointer, _sel_context);
    return _ret.address == 0
        ? null
        : NSGraphicsContext.castFromPointer(_ret, retain: true, release: true);
  }

  /// clickCount
  int get clickCount {
    return _objc_msgSend_79(this.pointer, _sel_clickCount);
  }

  /// buttonNumber
  int get buttonNumber {
    return _objc_msgSend_79(this.pointer, _sel_buttonNumber);
  }

  /// eventNumber
  int get eventNumber {
    return _objc_msgSend_79(this.pointer, _sel_eventNumber);
  }

  /// pressure
  double get pressure {
    return objc.useMsgSendVariants
        ? _objc_msgSend_81Fpret(this.pointer, _sel_pressure)
        : _objc_msgSend_81(this.pointer, _sel_pressure);
  }

  /// locationInWindow
  void getLocationInWindow(ffi.Pointer<CGPoint> stret) {
    objc.useMsgSendVariants
        ? _objc_msgSend_82Stret(stret, this.pointer, _sel_locationInWindow)
        : stret.ref = _objc_msgSend_82(this.pointer, _sel_locationInWindow);
  }

  /// deltaX
  double get deltaX {
    return objc.useMsgSendVariants
        ? _objc_msgSend_10Fpret(this.pointer, _sel_deltaX)
        : _objc_msgSend_10(this.pointer, _sel_deltaX);
  }

  /// deltaY
  double get deltaY {
    return objc.useMsgSendVariants
        ? _objc_msgSend_10Fpret(this.pointer, _sel_deltaY)
        : _objc_msgSend_10(this.pointer, _sel_deltaY);
  }

  /// deltaZ
  double get deltaZ {
    return objc.useMsgSendVariants
        ? _objc_msgSend_10Fpret(this.pointer, _sel_deltaZ)
        : _objc_msgSend_10(this.pointer, _sel_deltaZ);
  }

  /// hasPreciseScrollingDeltas
  bool get hasPreciseScrollingDeltas {
    return _objc_msgSend_13(this.pointer, _sel_hasPreciseScrollingDeltas);
  }

  /// scrollingDeltaX
  double get scrollingDeltaX {
    return objc.useMsgSendVariants
        ? _objc_msgSend_10Fpret(this.pointer, _sel_scrollingDeltaX)
        : _objc_msgSend_10(this.pointer, _sel_scrollingDeltaX);
  }

  /// scrollingDeltaY
  double get scrollingDeltaY {
    return objc.useMsgSendVariants
        ? _objc_msgSend_10Fpret(this.pointer, _sel_scrollingDeltaY)
        : _objc_msgSend_10(this.pointer, _sel_scrollingDeltaY);
  }

  /// momentumPhase
  NSEventPhase get momentumPhase {
    final _ret = _objc_msgSend_83(this.pointer, _sel_momentumPhase);
    return NSEventPhase.fromValue(_ret);
  }

  /// isDirectionInvertedFromDevice
  bool get directionInvertedFromDevice {
    return _objc_msgSend_13(this.pointer, _sel_isDirectionInvertedFromDevice);
  }

  /// characters
  objc.NSString? get characters {
    final _ret = _objc_msgSend_84(this.pointer, _sel_characters);
    return _ret.address == 0
        ? null
        : objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// charactersIgnoringModifiers
  objc.NSString? get charactersIgnoringModifiers {
    final _ret =
        _objc_msgSend_84(this.pointer, _sel_charactersIgnoringModifiers);
    return _ret.address == 0
        ? null
        : objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// charactersByApplyingModifiers:
  objc.NSString? charactersByApplyingModifiers_(
      NSEventModifierFlags modifiers) {
    final _ret = _objc_msgSend_85(
        this.pointer, _sel_charactersByApplyingModifiers_, modifiers.value);
    return _ret.address == 0
        ? null
        : objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// isARepeat
  bool get ARepeat {
    return _objc_msgSend_13(this.pointer, _sel_isARepeat);
  }

  /// keyCode
  int get keyCode {
    return _objc_msgSend_86(this.pointer, _sel_keyCode);
  }

  /// trackingNumber
  int get trackingNumber {
    return _objc_msgSend_79(this.pointer, _sel_trackingNumber);
  }

  /// userData
  ffi.Pointer<ffi.Void> get userData {
    return _objc_msgSend_87(this.pointer, _sel_userData);
  }

  /// trackingArea
  NSTrackingArea? get trackingArea {
    final _ret = _objc_msgSend_88(this.pointer, _sel_trackingArea);
    return _ret.address == 0
        ? null
        : NSTrackingArea.castFromPointer(_ret, retain: true, release: true);
  }

  /// subtype
  NSEventSubtype get subtype {
    final _ret = _objc_msgSend_89(this.pointer, _sel_subtype);
    return NSEventSubtype.fromValue(_ret);
  }

  /// data1
  int get data1 {
    return _objc_msgSend_79(this.pointer, _sel_data1);
  }

  /// data2
  int get data2 {
    return _objc_msgSend_79(this.pointer, _sel_data2);
  }

  /// eventRef
  ffi.Pointer<ffi.Void> get eventRef {
    return _objc_msgSend_87(this.pointer, _sel_eventRef);
  }

  /// eventWithEventRef:
  static NSEvent? eventWithEventRef_(ffi.Pointer<ffi.Void> eventRef) {
    final _ret =
        _objc_msgSend_90(_class_NSEvent, _sel_eventWithEventRef_, eventRef);
    return _ret.address == 0
        ? null
        : NSEvent.castFromPointer(_ret, retain: true, release: true);
  }

  /// CGEvent
  ffi.Pointer<__CGEvent> get CGEvent {
    return _objc_msgSend_91(this.pointer, _sel_CGEvent);
  }

  /// eventWithCGEvent:
  static NSEvent? eventWithCGEvent_(ffi.Pointer<__CGEvent> cgEvent) {
    final _ret =
        _objc_msgSend_92(_class_NSEvent, _sel_eventWithCGEvent_, cgEvent);
    return _ret.address == 0
        ? null
        : NSEvent.castFromPointer(_ret, retain: true, release: true);
  }

  /// isMouseCoalescingEnabled
  static bool getMouseCoalescingEnabled() {
    return _objc_msgSend_13(_class_NSEvent, _sel_isMouseCoalescingEnabled);
  }

  /// setMouseCoalescingEnabled:
  static void setMouseCoalescingEnabled(bool value) {
    return _objc_msgSend_14(
        _class_NSEvent, _sel_setMouseCoalescingEnabled_, value);
  }

  /// magnification
  double get magnification {
    return objc.useMsgSendVariants
        ? _objc_msgSend_10Fpret(this.pointer, _sel_magnification)
        : _objc_msgSend_10(this.pointer, _sel_magnification);
  }

  /// deviceID
  int get deviceID {
    return _objc_msgSend_6(this.pointer, _sel_deviceID);
  }

  /// rotation
  double get rotation {
    return objc.useMsgSendVariants
        ? _objc_msgSend_81Fpret(this.pointer, _sel_rotation)
        : _objc_msgSend_81(this.pointer, _sel_rotation);
  }

  /// absoluteX
  int get absoluteX {
    return _objc_msgSend_79(this.pointer, _sel_absoluteX);
  }

  /// absoluteY
  int get absoluteY {
    return _objc_msgSend_79(this.pointer, _sel_absoluteY);
  }

  /// absoluteZ
  int get absoluteZ {
    return _objc_msgSend_79(this.pointer, _sel_absoluteZ);
  }

  /// buttonMask
  NSEventButtonMask get buttonMask {
    final _ret = _objc_msgSend_93(this.pointer, _sel_buttonMask);
    return NSEventButtonMask.fromValue(_ret);
  }

  /// tilt
  void getTilt(ffi.Pointer<CGPoint> stret) {
    objc.useMsgSendVariants
        ? _objc_msgSend_82Stret(stret, this.pointer, _sel_tilt)
        : stret.ref = _objc_msgSend_82(this.pointer, _sel_tilt);
  }

  /// tangentialPressure
  double get tangentialPressure {
    return objc.useMsgSendVariants
        ? _objc_msgSend_81Fpret(this.pointer, _sel_tangentialPressure)
        : _objc_msgSend_81(this.pointer, _sel_tangentialPressure);
  }

  /// vendorDefined
  objc.ObjCObjectBase get vendorDefined {
    final _ret = _objc_msgSend_2(this.pointer, _sel_vendorDefined);
    return objc.ObjCObjectBase(_ret, retain: true, release: true);
  }

  /// vendorID
  int get vendorID {
    return _objc_msgSend_6(this.pointer, _sel_vendorID);
  }

  /// tabletID
  int get tabletID {
    return _objc_msgSend_6(this.pointer, _sel_tabletID);
  }

  /// pointingDeviceID
  int get pointingDeviceID {
    return _objc_msgSend_6(this.pointer, _sel_pointingDeviceID);
  }

  /// systemTabletID
  int get systemTabletID {
    return _objc_msgSend_6(this.pointer, _sel_systemTabletID);
  }

  /// vendorPointingDeviceType
  int get vendorPointingDeviceType {
    return _objc_msgSend_6(this.pointer, _sel_vendorPointingDeviceType);
  }

  /// pointingDeviceSerialNumber
  int get pointingDeviceSerialNumber {
    return _objc_msgSend_6(this.pointer, _sel_pointingDeviceSerialNumber);
  }

  /// uniqueID
  int get uniqueID {
    return _objc_msgSend_8(this.pointer, _sel_uniqueID);
  }

  /// capabilityMask
  int get capabilityMask {
    return _objc_msgSend_6(this.pointer, _sel_capabilityMask);
  }

  /// pointingDeviceType
  NSPointingDeviceType get pointingDeviceType {
    final _ret = _objc_msgSend_94(this.pointer, _sel_pointingDeviceType);
    return NSPointingDeviceType.fromValue(_ret);
  }

  /// isEnteringProximity
  bool get enteringProximity {
    return _objc_msgSend_13(this.pointer, _sel_isEnteringProximity);
  }

  /// touchesMatchingPhase:inView:
  objc.ObjCObjectBase touchesMatchingPhase_inView_(
      NSTouchPhase phase, NSView? view) {
    final _ret = _objc_msgSend_95(
        this.pointer,
        _sel_touchesMatchingPhase_inView_,
        phase.value,
        view?.pointer ?? ffi.nullptr);
    return objc.ObjCObjectBase(_ret, retain: true, release: true);
  }

  /// allTouches
  objc.ObjCObjectBase allTouches() {
    final _ret = _objc_msgSend_2(this.pointer, _sel_allTouches);
    return objc.ObjCObjectBase(_ret, retain: true, release: true);
  }

  /// touchesForView:
  objc.ObjCObjectBase touchesForView_(NSView view) {
    final _ret =
        _objc_msgSend_96(this.pointer, _sel_touchesForView_, view.pointer);
    return objc.ObjCObjectBase(_ret, retain: true, release: true);
  }

  /// coalescedTouchesForTouch:
  objc.ObjCObjectBase coalescedTouchesForTouch_(NSTouch touch) {
    final _ret = _objc_msgSend_99(
        this.pointer, _sel_coalescedTouchesForTouch_, touch.pointer);
    return objc.ObjCObjectBase(_ret, retain: true, release: true);
  }

  /// phase
  NSEventPhase get phase {
    final _ret = _objc_msgSend_83(this.pointer, _sel_phase);
    return NSEventPhase.fromValue(_ret);
  }

  /// stage
  int get stage {
    return _objc_msgSend_79(this.pointer, _sel_stage);
  }

  /// stageTransition
  double get stageTransition {
    return objc.useMsgSendVariants
        ? _objc_msgSend_10Fpret(this.pointer, _sel_stageTransition)
        : _objc_msgSend_10(this.pointer, _sel_stageTransition);
  }

  /// associatedEventsMask
  NSEventMask get associatedEventsMask {
    final _ret = _objc_msgSend_100(this.pointer, _sel_associatedEventsMask);
    return NSEventMask.fromValue(_ret);
  }

  /// pressureBehavior
  NSPressureBehavior get pressureBehavior {
    final _ret = _objc_msgSend_101(this.pointer, _sel_pressureBehavior);
    return NSPressureBehavior.fromValue(_ret);
  }

  /// isSwipeTrackingFromScrollEventsEnabled
  static bool getSwipeTrackingFromScrollEventsEnabled() {
    return _objc_msgSend_13(
        _class_NSEvent, _sel_isSwipeTrackingFromScrollEventsEnabled);
  }

  /// trackSwipeEventWithOptions:dampenAmountThresholdMin:max:usingHandler:
  void trackSwipeEventWithOptions_dampenAmountThresholdMin_max_usingHandler_(
      NSEventSwipeTrackingOptions options,
      double minDampenThreshold,
      double maxDampenThreshold,
      ObjCBlock_ffiVoid_ffiDouble_NSEventPhase_bool_bool trackingHandler) {
    _objc_msgSend_102(
        this.pointer,
        _sel_trackSwipeEventWithOptions_dampenAmountThresholdMin_max_usingHandler_,
        options.value,
        minDampenThreshold,
        maxDampenThreshold,
        trackingHandler.pointer);
  }

  /// startPeriodicEventsAfterDelay:withPeriod:
  static void startPeriodicEventsAfterDelay_withPeriod_(
      double delay, double period) {
    _objc_msgSend_103(_class_NSEvent,
        _sel_startPeriodicEventsAfterDelay_withPeriod_, delay, period);
  }

  /// stopPeriodicEvents
  static void stopPeriodicEvents() {
    _objc_msgSend_11(_class_NSEvent, _sel_stopPeriodicEvents);
  }

  /// mouseEventWithType:location:modifierFlags:timestamp:windowNumber:context:eventNumber:clickCount:pressure:
  static NSEvent?
      mouseEventWithType_location_modifierFlags_timestamp_windowNumber_context_eventNumber_clickCount_pressure_(
          NSEventType type,
          CGPoint location,
          NSEventModifierFlags flags,
          double time,
          int wNum,
          NSGraphicsContext? unusedPassNil,
          int eNum,
          int cNum,
          double pressure) {
    final _ret = _objc_msgSend_104(
        _class_NSEvent,
        _sel_mouseEventWithType_location_modifierFlags_timestamp_windowNumber_context_eventNumber_clickCount_pressure_,
        type.value,
        location,
        flags.value,
        time,
        wNum,
        unusedPassNil?.pointer ?? ffi.nullptr,
        eNum,
        cNum,
        pressure);
    return _ret.address == 0
        ? null
        : NSEvent.castFromPointer(_ret, retain: true, release: true);
  }

  /// keyEventWithType:location:modifierFlags:timestamp:windowNumber:context:characters:charactersIgnoringModifiers:isARepeat:keyCode:
  static NSEvent?
      keyEventWithType_location_modifierFlags_timestamp_windowNumber_context_characters_charactersIgnoringModifiers_isARepeat_keyCode_(
          NSEventType type,
          CGPoint location,
          NSEventModifierFlags flags,
          double time,
          int wNum,
          NSGraphicsContext? unusedPassNil,
          objc.NSString keys,
          objc.NSString ukeys,
          bool flag,
          int code) {
    final _ret = _objc_msgSend_105(
        _class_NSEvent,
        _sel_keyEventWithType_location_modifierFlags_timestamp_windowNumber_context_characters_charactersIgnoringModifiers_isARepeat_keyCode_,
        type.value,
        location,
        flags.value,
        time,
        wNum,
        unusedPassNil?.pointer ?? ffi.nullptr,
        keys.pointer,
        ukeys.pointer,
        flag,
        code);
    return _ret.address == 0
        ? null
        : NSEvent.castFromPointer(_ret, retain: true, release: true);
  }

  /// enterExitEventWithType:location:modifierFlags:timestamp:windowNumber:context:eventNumber:trackingNumber:userData:
  static NSEvent?
      enterExitEventWithType_location_modifierFlags_timestamp_windowNumber_context_eventNumber_trackingNumber_userData_(
          NSEventType type,
          CGPoint location,
          NSEventModifierFlags flags,
          double time,
          int wNum,
          NSGraphicsContext? unusedPassNil,
          int eNum,
          int tNum,
          ffi.Pointer<ffi.Void> data) {
    final _ret = _objc_msgSend_106(
        _class_NSEvent,
        _sel_enterExitEventWithType_location_modifierFlags_timestamp_windowNumber_context_eventNumber_trackingNumber_userData_,
        type.value,
        location,
        flags.value,
        time,
        wNum,
        unusedPassNil?.pointer ?? ffi.nullptr,
        eNum,
        tNum,
        data);
    return _ret.address == 0
        ? null
        : NSEvent.castFromPointer(_ret, retain: true, release: true);
  }

  /// otherEventWithType:location:modifierFlags:timestamp:windowNumber:context:subtype:data1:data2:
  static NSEvent?
      otherEventWithType_location_modifierFlags_timestamp_windowNumber_context_subtype_data1_data2_(
          NSEventType type,
          CGPoint location,
          NSEventModifierFlags flags,
          double time,
          int wNum,
          NSGraphicsContext? unusedPassNil,
          int subtype,
          int d1,
          int d2) {
    final _ret = _objc_msgSend_107(
        _class_NSEvent,
        _sel_otherEventWithType_location_modifierFlags_timestamp_windowNumber_context_subtype_data1_data2_,
        type.value,
        location,
        flags.value,
        time,
        wNum,
        unusedPassNil?.pointer ?? ffi.nullptr,
        subtype,
        d1,
        d2);
    return _ret.address == 0
        ? null
        : NSEvent.castFromPointer(_ret, retain: true, release: true);
  }

  /// mouseLocation
  static void getMouseLocation(ffi.Pointer<CGPoint> stret) {
    objc.useMsgSendVariants
        ? _objc_msgSend_82Stret(stret, _class_NSEvent, _sel_mouseLocation)
        : stret.ref = _objc_msgSend_82(_class_NSEvent, _sel_mouseLocation);
  }

  /// pressedMouseButtons
  static int getPressedMouseButtons() {
    return _objc_msgSend_6(_class_NSEvent, _sel_pressedMouseButtons);
  }

  /// doubleClickInterval
  static double getDoubleClickInterval() {
    return objc.useMsgSendVariants
        ? _objc_msgSend_10Fpret(_class_NSEvent, _sel_doubleClickInterval)
        : _objc_msgSend_10(_class_NSEvent, _sel_doubleClickInterval);
  }

  /// keyRepeatDelay
  static double getKeyRepeatDelay() {
    return objc.useMsgSendVariants
        ? _objc_msgSend_10Fpret(_class_NSEvent, _sel_keyRepeatDelay)
        : _objc_msgSend_10(_class_NSEvent, _sel_keyRepeatDelay);
  }

  /// keyRepeatInterval
  static double getKeyRepeatInterval() {
    return objc.useMsgSendVariants
        ? _objc_msgSend_10Fpret(_class_NSEvent, _sel_keyRepeatInterval)
        : _objc_msgSend_10(_class_NSEvent, _sel_keyRepeatInterval);
  }

  /// addGlobalMonitorForEventsMatchingMask:handler:
  static objc.ObjCObjectBase? addGlobalMonitorForEventsMatchingMask_handler_(
      NSEventMask mask, ObjCBlock_ffiVoid_NSEvent block) {
    final _ret = _objc_msgSend_108(
        _class_NSEvent,
        _sel_addGlobalMonitorForEventsMatchingMask_handler_,
        mask.value,
        block.pointer);
    return _ret.address == 0
        ? null
        : objc.ObjCObjectBase(_ret, retain: true, release: true);
  }

  /// addLocalMonitorForEventsMatchingMask:handler:
  static objc.ObjCObjectBase? addLocalMonitorForEventsMatchingMask_handler_(
      NSEventMask mask, ObjCBlock_NSEvent_NSEvent block) {
    final _ret = _objc_msgSend_109(
        _class_NSEvent,
        _sel_addLocalMonitorForEventsMatchingMask_handler_,
        mask.value,
        block.pointer);
    return _ret.address == 0
        ? null
        : objc.ObjCObjectBase(_ret, retain: true, release: true);
  }

  /// removeMonitor:
  static void removeMonitor_(objc.ObjCObjectBase eventMonitor) {
    _objc_msgSend_16(_class_NSEvent, _sel_removeMonitor_, eventMonitor.pointer);
  }

  /// init
  NSEvent init() {
    final _ret = _objc_msgSend_2(this.pointer, _sel_init);
    return NSEvent.castFromPointer(_ret, retain: true, release: true);
  }

  /// new
  static NSEvent new1() {
    final _ret = _objc_msgSend_2(_class_NSEvent, _sel_new);
    return NSEvent.castFromPointer(_ret, retain: false, release: true);
  }

  /// allocWithZone:
  static NSEvent allocWithZone_(ffi.Pointer<_NSZone> zone) {
    final _ret = _objc_msgSend_20(_class_NSEvent, _sel_allocWithZone_, zone);
    return NSEvent.castFromPointer(_ret, retain: false, release: true);
  }

  /// alloc
  static NSEvent alloc() {
    final _ret = _objc_msgSend_2(_class_NSEvent, _sel_alloc);
    return NSEvent.castFromPointer(_ret, retain: false, release: true);
  }
}

late final _class_NSEvent = objc.getClass("NSEvent");

enum NSEventType {
  NSEventTypeLeftMouseDown(1),
  NSEventTypeLeftMouseUp(2),
  NSEventTypeRightMouseDown(3),
  NSEventTypeRightMouseUp(4),
  NSEventTypeMouseMoved(5),
  NSEventTypeLeftMouseDragged(6),
  NSEventTypeRightMouseDragged(7),
  NSEventTypeMouseEntered(8),
  NSEventTypeMouseExited(9),
  NSEventTypeKeyDown(10),
  NSEventTypeKeyUp(11),
  NSEventTypeFlagsChanged(12),
  NSEventTypeAppKitDefined(13),
  NSEventTypeSystemDefined(14),
  NSEventTypeApplicationDefined(15),
  NSEventTypePeriodic(16),
  NSEventTypeCursorUpdate(17),
  NSEventTypeScrollWheel(22),
  NSEventTypeTabletPoint(23),
  NSEventTypeTabletProximity(24),
  NSEventTypeOtherMouseDown(25),
  NSEventTypeOtherMouseUp(26),
  NSEventTypeOtherMouseDragged(27),
  NSEventTypeGesture(29),
  NSEventTypeMagnify(30),
  NSEventTypeSwipe(31),
  NSEventTypeRotate(18),
  NSEventTypeBeginGesture(19),
  NSEventTypeEndGesture(20),
  NSEventTypeSmartMagnify(32),
  NSEventTypeQuickLook(33),
  NSEventTypePressure(34),
  NSEventTypeDirectTouch(37),
  NSEventTypeChangeMode(38);

  final int value;
  const NSEventType(this.value);

  static NSEventType fromValue(int value) => switch (value) {
        1 => NSEventTypeLeftMouseDown,
        2 => NSEventTypeLeftMouseUp,
        3 => NSEventTypeRightMouseDown,
        4 => NSEventTypeRightMouseUp,
        5 => NSEventTypeMouseMoved,
        6 => NSEventTypeLeftMouseDragged,
        7 => NSEventTypeRightMouseDragged,
        8 => NSEventTypeMouseEntered,
        9 => NSEventTypeMouseExited,
        10 => NSEventTypeKeyDown,
        11 => NSEventTypeKeyUp,
        12 => NSEventTypeFlagsChanged,
        13 => NSEventTypeAppKitDefined,
        14 => NSEventTypeSystemDefined,
        15 => NSEventTypeApplicationDefined,
        16 => NSEventTypePeriodic,
        17 => NSEventTypeCursorUpdate,
        22 => NSEventTypeScrollWheel,
        23 => NSEventTypeTabletPoint,
        24 => NSEventTypeTabletProximity,
        25 => NSEventTypeOtherMouseDown,
        26 => NSEventTypeOtherMouseUp,
        27 => NSEventTypeOtherMouseDragged,
        29 => NSEventTypeGesture,
        30 => NSEventTypeMagnify,
        31 => NSEventTypeSwipe,
        18 => NSEventTypeRotate,
        19 => NSEventTypeBeginGesture,
        20 => NSEventTypeEndGesture,
        32 => NSEventTypeSmartMagnify,
        33 => NSEventTypeQuickLook,
        34 => NSEventTypePressure,
        37 => NSEventTypeDirectTouch,
        38 => NSEventTypeChangeMode,
        _ => throw ArgumentError("Unknown value for NSEventType: $value"),
      };
}

late final _sel_type = objc.registerName("type");
final _objc_msgSend_77 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.UnsignedLong Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        int Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();

enum NSEventModifierFlags {
  NSEventModifierFlagCapsLock(65536),
  NSEventModifierFlagShift(131072),
  NSEventModifierFlagControl(262144),
  NSEventModifierFlagOption(524288),
  NSEventModifierFlagCommand(1048576),
  NSEventModifierFlagNumericPad(2097152),
  NSEventModifierFlagHelp(4194304),
  NSEventModifierFlagFunction(8388608),
  NSEventModifierFlagDeviceIndependentFlagsMask(4294901760);

  final int value;
  const NSEventModifierFlags(this.value);

  static NSEventModifierFlags fromValue(int value) => switch (value) {
        65536 => NSEventModifierFlagCapsLock,
        131072 => NSEventModifierFlagShift,
        262144 => NSEventModifierFlagControl,
        524288 => NSEventModifierFlagOption,
        1048576 => NSEventModifierFlagCommand,
        2097152 => NSEventModifierFlagNumericPad,
        4194304 => NSEventModifierFlagHelp,
        8388608 => NSEventModifierFlagFunction,
        4294901760 => NSEventModifierFlagDeviceIndependentFlagsMask,
        _ =>
          throw ArgumentError("Unknown value for NSEventModifierFlags: $value"),
      };
}

late final _sel_modifierFlags = objc.registerName("modifierFlags");
final _objc_msgSend_78 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.UnsignedLong Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        int Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_timestamp = objc.registerName("timestamp");
late final _sel_windowNumber = objc.registerName("windowNumber");
final _objc_msgSend_79 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Long Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        int Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_context = objc.registerName("context");
final _objc_msgSend_80 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_clickCount = objc.registerName("clickCount");
late final _sel_buttonNumber = objc.registerName("buttonNumber");
late final _sel_eventNumber = objc.registerName("eventNumber");
late final _sel_pressure = objc.registerName("pressure");
final _objc_msgSend_81 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Float Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        double Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
final _objc_msgSend_81Fpret = objc.msgSendFpretPointer
    .cast<
        ffi.NativeFunction<
            ffi.Float Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        double Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_locationInWindow = objc.registerName("locationInWindow");
final _objc_msgSend_82 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            CGPoint Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        CGPoint Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
final _objc_msgSend_82Stret = objc.msgSendStretPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<CGPoint>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        void Function(ffi.Pointer<CGPoint>, ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_deltaX = objc.registerName("deltaX");
late final _sel_deltaY = objc.registerName("deltaY");
late final _sel_deltaZ = objc.registerName("deltaZ");
late final _sel_hasPreciseScrollingDeltas =
    objc.registerName("hasPreciseScrollingDeltas");
late final _sel_scrollingDeltaX = objc.registerName("scrollingDeltaX");
late final _sel_scrollingDeltaY = objc.registerName("scrollingDeltaY");

enum NSEventPhase {
  NSEventPhaseNone(0),
  NSEventPhaseBegan(1),
  NSEventPhaseStationary(2),
  NSEventPhaseChanged(4),
  NSEventPhaseEnded(8),
  NSEventPhaseCancelled(16),
  NSEventPhaseMayBegin(32);

  final int value;
  const NSEventPhase(this.value);

  static NSEventPhase fromValue(int value) => switch (value) {
        0 => NSEventPhaseNone,
        1 => NSEventPhaseBegan,
        2 => NSEventPhaseStationary,
        4 => NSEventPhaseChanged,
        8 => NSEventPhaseEnded,
        16 => NSEventPhaseCancelled,
        32 => NSEventPhaseMayBegin,
        _ => throw ArgumentError("Unknown value for NSEventPhase: $value"),
      };
}

late final _sel_momentumPhase = objc.registerName("momentumPhase");
final _objc_msgSend_83 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.UnsignedLong Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        int Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_isDirectionInvertedFromDevice =
    objc.registerName("isDirectionInvertedFromDevice");
late final _sel_characters = objc.registerName("characters");
final _objc_msgSend_84 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_charactersIgnoringModifiers =
    objc.registerName("charactersIgnoringModifiers");
late final _sel_charactersByApplyingModifiers_ =
    objc.registerName("charactersByApplyingModifiers:");
final _objc_msgSend_85 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, ffi.UnsignedLong)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, int)>();
late final _sel_isARepeat = objc.registerName("isARepeat");
late final _sel_keyCode = objc.registerName("keyCode");
final _objc_msgSend_86 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.UnsignedShort Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        int Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_trackingNumber = objc.registerName("trackingNumber");
late final _sel_userData = objc.registerName("userData");
final _objc_msgSend_87 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<ffi.Void> Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        ffi.Pointer<ffi.Void> Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();

/// NSTrackingArea
class NSTrackingArea extends objc.ObjCObjectBase {
  NSTrackingArea._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super(pointer, retain: retain, release: release);

  /// Constructs a [NSTrackingArea] that points to the same underlying object as [other].
  NSTrackingArea.castFrom(objc.ObjCObjectBase other)
      : this._(other.pointer, retain: true, release: true);

  /// Constructs a [NSTrackingArea] that wraps the given raw object pointer.
  NSTrackingArea.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [NSTrackingArea].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_0(
        obj.pointer, _sel_isKindOfClass_, _class_NSTrackingArea);
  }
}

late final _class_NSTrackingArea = objc.getClass("NSTrackingArea");
late final _sel_trackingArea = objc.registerName("trackingArea");
final _objc_msgSend_88 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();

enum NSEventSubtype {
  NSEventSubtypeWindowExposed(0),
  NSEventSubtypeApplicationActivated(1),
  NSEventSubtypeApplicationDeactivated(2),
  NSEventSubtypeWindowMoved(4),
  NSEventSubtypeScreenChanged(8),
  NSEventSubtypeTouch(3);

  static const NSEventSubtypePowerOff = NSEventSubtypeApplicationActivated;
  static const NSEventSubtypeMouseEvent = NSEventSubtypeWindowExposed;
  static const NSEventSubtypeTabletPoint = NSEventSubtypeApplicationActivated;
  static const NSEventSubtypeTabletProximity =
      NSEventSubtypeApplicationDeactivated;

  final int value;
  const NSEventSubtype(this.value);

  static NSEventSubtype fromValue(int value) => switch (value) {
        0 => NSEventSubtypeWindowExposed,
        1 => NSEventSubtypeApplicationActivated,
        2 => NSEventSubtypeApplicationDeactivated,
        4 => NSEventSubtypeWindowMoved,
        8 => NSEventSubtypeScreenChanged,
        3 => NSEventSubtypeTouch,
        _ => throw ArgumentError("Unknown value for NSEventSubtype: $value"),
      };

  @override
  String toString() {
    if (this == NSEventSubtypeWindowExposed)
      return "NSEventSubtype.NSEventSubtypeWindowExposed, NSEventSubtype.NSEventSubtypeMouseEvent";
    if (this == NSEventSubtypeApplicationActivated)
      return "NSEventSubtype.NSEventSubtypeApplicationActivated, NSEventSubtype.NSEventSubtypePowerOff, NSEventSubtype.NSEventSubtypeTabletPoint";
    if (this == NSEventSubtypeApplicationDeactivated)
      return "NSEventSubtype.NSEventSubtypeApplicationDeactivated, NSEventSubtype.NSEventSubtypeTabletProximity";
    return super.toString();
  }
}

late final _sel_subtype = objc.registerName("subtype");
final _objc_msgSend_89 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.UnsignedShort Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        int Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_data1 = objc.registerName("data1");
late final _sel_data2 = objc.registerName("data2");
late final _sel_eventRef = objc.registerName("eventRef");
late final _sel_eventWithEventRef_ = objc.registerName("eventWithEventRef:");
final _objc_msgSend_90 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<ffi.Void>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<ffi.Void>)>();

final class __CGEvent extends ffi.Opaque {}

late final _sel_CGEvent = objc.registerName("CGEvent");
final _objc_msgSend_91 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<__CGEvent> Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        ffi.Pointer<__CGEvent> Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_eventWithCGEvent_ = objc.registerName("eventWithCGEvent:");
final _objc_msgSend_92 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<__CGEvent>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<__CGEvent>)>();
late final _sel_isMouseCoalescingEnabled =
    objc.registerName("isMouseCoalescingEnabled");
late final _sel_setMouseCoalescingEnabled_ =
    objc.registerName("setMouseCoalescingEnabled:");
late final _sel_magnification = objc.registerName("magnification");
late final _sel_deviceID = objc.registerName("deviceID");
late final _sel_rotation = objc.registerName("rotation");
late final _sel_absoluteX = objc.registerName("absoluteX");
late final _sel_absoluteY = objc.registerName("absoluteY");
late final _sel_absoluteZ = objc.registerName("absoluteZ");

enum NSEventButtonMask {
  NSEventButtonMaskPenTip(1),
  NSEventButtonMaskPenLowerSide(2),
  NSEventButtonMaskPenUpperSide(4);

  final int value;
  const NSEventButtonMask(this.value);

  static NSEventButtonMask fromValue(int value) => switch (value) {
        1 => NSEventButtonMaskPenTip,
        2 => NSEventButtonMaskPenLowerSide,
        4 => NSEventButtonMaskPenUpperSide,
        _ => throw ArgumentError("Unknown value for NSEventButtonMask: $value"),
      };
}

late final _sel_buttonMask = objc.registerName("buttonMask");
final _objc_msgSend_93 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.UnsignedLong Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        int Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_tilt = objc.registerName("tilt");
late final _sel_tangentialPressure = objc.registerName("tangentialPressure");
late final _sel_vendorDefined = objc.registerName("vendorDefined");
late final _sel_vendorID = objc.registerName("vendorID");
late final _sel_tabletID = objc.registerName("tabletID");
late final _sel_pointingDeviceID = objc.registerName("pointingDeviceID");
late final _sel_systemTabletID = objc.registerName("systemTabletID");
late final _sel_vendorPointingDeviceType =
    objc.registerName("vendorPointingDeviceType");
late final _sel_pointingDeviceSerialNumber =
    objc.registerName("pointingDeviceSerialNumber");
late final _sel_uniqueID = objc.registerName("uniqueID");
late final _sel_capabilityMask = objc.registerName("capabilityMask");

enum NSPointingDeviceType {
  NSPointingDeviceTypeUnknown(0),
  NSPointingDeviceTypePen(1),
  NSPointingDeviceTypeCursor(2),
  NSPointingDeviceTypeEraser(3);

  final int value;
  const NSPointingDeviceType(this.value);

  static NSPointingDeviceType fromValue(int value) => switch (value) {
        0 => NSPointingDeviceTypeUnknown,
        1 => NSPointingDeviceTypePen,
        2 => NSPointingDeviceTypeCursor,
        3 => NSPointingDeviceTypeEraser,
        _ =>
          throw ArgumentError("Unknown value for NSPointingDeviceType: $value"),
      };
}

late final _sel_pointingDeviceType = objc.registerName("pointingDeviceType");
final _objc_msgSend_94 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.UnsignedLong Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        int Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_isEnteringProximity = objc.registerName("isEnteringProximity");

enum NSTouchPhase {
  NSTouchPhaseBegan(1),
  NSTouchPhaseMoved(2),
  NSTouchPhaseStationary(4),
  NSTouchPhaseEnded(8),
  NSTouchPhaseCancelled(16),
  NSTouchPhaseTouching(7),
  NSTouchPhaseAny(-1);

  final int value;
  const NSTouchPhase(this.value);

  static NSTouchPhase fromValue(int value) => switch (value) {
        1 => NSTouchPhaseBegan,
        2 => NSTouchPhaseMoved,
        4 => NSTouchPhaseStationary,
        8 => NSTouchPhaseEnded,
        16 => NSTouchPhaseCancelled,
        7 => NSTouchPhaseTouching,
        -1 => NSTouchPhaseAny,
        _ => throw ArgumentError("Unknown value for NSTouchPhase: $value"),
      };
}

late final _sel_touchesMatchingPhase_inView_ =
    objc.registerName("touchesMatchingPhase:inView:");
final _objc_msgSend_95 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Long,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            int,
            ffi.Pointer<objc.ObjCObject>)>();
late final _sel_allTouches = objc.registerName("allTouches");
late final _sel_touchesForView_ = objc.registerName("touchesForView:");
final _objc_msgSend_96 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<objc.ObjCObject>)>();

/// NSTouch
class NSTouch extends objc.NSObject {
  NSTouch._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release);

  /// Constructs a [NSTouch] that points to the same underlying object as [other].
  NSTouch.castFrom(objc.ObjCObjectBase other)
      : this._(other.pointer, retain: true, release: true);

  /// Constructs a [NSTouch] that wraps the given raw object pointer.
  NSTouch.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [NSTouch].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_0(obj.pointer, _sel_isKindOfClass_, _class_NSTouch);
  }

  /// identity
  objc.ObjCObjectBase get identity {
    final _ret = _objc_msgSend_2(this.pointer, _sel_identity);
    return objc.ObjCObjectBase(_ret, retain: true, release: true);
  }

  /// phase
  NSTouchPhase get phase {
    final _ret = _objc_msgSend_97(this.pointer, _sel_phase);
    return NSTouchPhase.fromValue(_ret);
  }

  /// normalizedPosition
  void getNormalizedPosition(ffi.Pointer<CGPoint> stret) {
    objc.useMsgSendVariants
        ? _objc_msgSend_82Stret(stret, this.pointer, _sel_normalizedPosition)
        : stret.ref = _objc_msgSend_82(this.pointer, _sel_normalizedPosition);
  }

  /// isResting
  bool get resting {
    return _objc_msgSend_13(this.pointer, _sel_isResting);
  }

  /// device
  objc.ObjCObjectBase? get device {
    final _ret = _objc_msgSend_22(this.pointer, _sel_device);
    return _ret.address == 0
        ? null
        : objc.ObjCObjectBase(_ret, retain: true, release: true);
  }

  /// deviceSize
  void getDeviceSize(ffi.Pointer<CGSize> stret) {
    objc.useMsgSendVariants
        ? _objc_msgSend_98Stret(stret, this.pointer, _sel_deviceSize)
        : stret.ref = _objc_msgSend_98(this.pointer, _sel_deviceSize);
  }

  /// init
  NSTouch init() {
    final _ret = _objc_msgSend_2(this.pointer, _sel_init);
    return NSTouch.castFromPointer(_ret, retain: true, release: true);
  }

  /// new
  static NSTouch new1() {
    final _ret = _objc_msgSend_2(_class_NSTouch, _sel_new);
    return NSTouch.castFromPointer(_ret, retain: false, release: true);
  }

  /// allocWithZone:
  static NSTouch allocWithZone_(ffi.Pointer<_NSZone> zone) {
    final _ret = _objc_msgSend_20(_class_NSTouch, _sel_allocWithZone_, zone);
    return NSTouch.castFromPointer(_ret, retain: false, release: true);
  }

  /// alloc
  static NSTouch alloc() {
    final _ret = _objc_msgSend_2(_class_NSTouch, _sel_alloc);
    return NSTouch.castFromPointer(_ret, retain: false, release: true);
  }
}

late final _class_NSTouch = objc.getClass("NSTouch");
late final _sel_identity = objc.registerName("identity");
late final _sel_phase = objc.registerName("phase");
final _objc_msgSend_97 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Long Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        int Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_normalizedPosition = objc.registerName("normalizedPosition");
late final _sel_isResting = objc.registerName("isResting");
late final _sel_device = objc.registerName("device");
late final _sel_deviceSize = objc.registerName("deviceSize");
final _objc_msgSend_98 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            CGSize Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        CGSize Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
final _objc_msgSend_98Stret = objc.msgSendStretPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(ffi.Pointer<CGSize>, ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        void Function(ffi.Pointer<CGSize>, ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_coalescedTouchesForTouch_ =
    objc.registerName("coalescedTouchesForTouch:");
final _objc_msgSend_99 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<objc.ObjCObject>)>();
late final _sel_stage = objc.registerName("stage");
late final _sel_stageTransition = objc.registerName("stageTransition");

enum NSEventMask {
  NSEventMaskLeftMouseDown(2),
  NSEventMaskLeftMouseUp(4),
  NSEventMaskRightMouseDown(8),
  NSEventMaskRightMouseUp(16),
  NSEventMaskMouseMoved(32),
  NSEventMaskLeftMouseDragged(64),
  NSEventMaskRightMouseDragged(128),
  NSEventMaskMouseEntered(256),
  NSEventMaskMouseExited(512),
  NSEventMaskKeyDown(1024),
  NSEventMaskKeyUp(2048),
  NSEventMaskFlagsChanged(4096),
  NSEventMaskAppKitDefined(8192),
  NSEventMaskSystemDefined(16384),
  NSEventMaskApplicationDefined(32768),
  NSEventMaskPeriodic(65536),
  NSEventMaskCursorUpdate(131072),
  NSEventMaskScrollWheel(4194304),
  NSEventMaskTabletPoint(8388608),
  NSEventMaskTabletProximity(16777216),
  NSEventMaskOtherMouseDown(33554432),
  NSEventMaskOtherMouseUp(67108864),
  NSEventMaskOtherMouseDragged(134217728),
  NSEventMaskGesture(536870912),
  NSEventMaskMagnify(1073741824),
  NSEventMaskSwipe(2147483648),
  NSEventMaskRotate(262144),
  NSEventMaskBeginGesture(524288),
  NSEventMaskEndGesture(1048576),
  NSEventMaskSmartMagnify(4294967296),
  NSEventMaskPressure(17179869184),
  NSEventMaskDirectTouch(137438953472),
  NSEventMaskChangeMode(274877906944),
  NSEventMaskAny(-1);

  final int value;
  const NSEventMask(this.value);

  static NSEventMask fromValue(int value) => switch (value) {
        2 => NSEventMaskLeftMouseDown,
        4 => NSEventMaskLeftMouseUp,
        8 => NSEventMaskRightMouseDown,
        16 => NSEventMaskRightMouseUp,
        32 => NSEventMaskMouseMoved,
        64 => NSEventMaskLeftMouseDragged,
        128 => NSEventMaskRightMouseDragged,
        256 => NSEventMaskMouseEntered,
        512 => NSEventMaskMouseExited,
        1024 => NSEventMaskKeyDown,
        2048 => NSEventMaskKeyUp,
        4096 => NSEventMaskFlagsChanged,
        8192 => NSEventMaskAppKitDefined,
        16384 => NSEventMaskSystemDefined,
        32768 => NSEventMaskApplicationDefined,
        65536 => NSEventMaskPeriodic,
        131072 => NSEventMaskCursorUpdate,
        4194304 => NSEventMaskScrollWheel,
        8388608 => NSEventMaskTabletPoint,
        16777216 => NSEventMaskTabletProximity,
        33554432 => NSEventMaskOtherMouseDown,
        67108864 => NSEventMaskOtherMouseUp,
        134217728 => NSEventMaskOtherMouseDragged,
        536870912 => NSEventMaskGesture,
        1073741824 => NSEventMaskMagnify,
        2147483648 => NSEventMaskSwipe,
        262144 => NSEventMaskRotate,
        524288 => NSEventMaskBeginGesture,
        1048576 => NSEventMaskEndGesture,
        4294967296 => NSEventMaskSmartMagnify,
        17179869184 => NSEventMaskPressure,
        137438953472 => NSEventMaskDirectTouch,
        274877906944 => NSEventMaskChangeMode,
        -1 => NSEventMaskAny,
        _ => throw ArgumentError("Unknown value for NSEventMask: $value"),
      };
}

late final _sel_associatedEventsMask =
    objc.registerName("associatedEventsMask");
final _objc_msgSend_100 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.LongLong Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        int Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();

enum NSPressureBehavior {
  NSPressureBehaviorUnknown(-1),
  NSPressureBehaviorPrimaryDefault(0),
  NSPressureBehaviorPrimaryClick(1),
  NSPressureBehaviorPrimaryGeneric(2),
  NSPressureBehaviorPrimaryAccelerator(3),
  NSPressureBehaviorPrimaryDeepClick(5),
  NSPressureBehaviorPrimaryDeepDrag(6);

  final int value;
  const NSPressureBehavior(this.value);

  static NSPressureBehavior fromValue(int value) => switch (value) {
        -1 => NSPressureBehaviorUnknown,
        0 => NSPressureBehaviorPrimaryDefault,
        1 => NSPressureBehaviorPrimaryClick,
        2 => NSPressureBehaviorPrimaryGeneric,
        3 => NSPressureBehaviorPrimaryAccelerator,
        5 => NSPressureBehaviorPrimaryDeepClick,
        6 => NSPressureBehaviorPrimaryDeepDrag,
        _ =>
          throw ArgumentError("Unknown value for NSPressureBehavior: $value"),
      };
}

late final _sel_pressureBehavior = objc.registerName("pressureBehavior");
final _objc_msgSend_101 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Long Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        int Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_isSwipeTrackingFromScrollEventsEnabled =
    objc.registerName("isSwipeTrackingFromScrollEventsEnabled");

enum NSEventSwipeTrackingOptions {
  NSEventSwipeTrackingLockDirection(1),
  NSEventSwipeTrackingClampGestureAmount(2);

  final int value;
  const NSEventSwipeTrackingOptions(this.value);

  static NSEventSwipeTrackingOptions fromValue(int value) => switch (value) {
        1 => NSEventSwipeTrackingLockDirection,
        2 => NSEventSwipeTrackingClampGestureAmount,
        _ => throw ArgumentError(
            "Unknown value for NSEventSwipeTrackingOptions: $value"),
      };
}

void _ObjCBlock_ffiVoid_ffiDouble_NSEventPhase_bool_bool_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlock> block,
        double arg0,
        int arg1,
        bool arg2,
        ffi.Pointer<ffi.Bool> arg3) =>
    block.ref.target
            .cast<
                ffi.NativeFunction<
                    ffi.Void Function(ffi.Double arg0, ffi.UnsignedLong arg1,
                        ffi.Bool arg2, ffi.Pointer<ffi.Bool> arg3)>>()
            .asFunction<
                void Function(double, int, bool, ffi.Pointer<ffi.Bool>)>()(
        arg0, arg1, arg2, arg3);
void _ObjCBlock_ffiVoid_ffiDouble_NSEventPhase_bool_bool_closureTrampoline(
        ffi.Pointer<objc.ObjCBlock> block,
        double arg0,
        int arg1,
        bool arg2,
        ffi.Pointer<ffi.Bool> arg3) =>
    (objc.getBlockClosure(block) as void Function(
        double, int, bool, ffi.Pointer<ffi.Bool>))(arg0, arg1, arg2, arg3);

class ObjCBlock_ffiVoid_ffiDouble_NSEventPhase_bool_bool
    extends objc.ObjCBlockBase {
  ObjCBlock_ffiVoid_ffiDouble_NSEventPhase_bool_bool._(
      ffi.Pointer<objc.ObjCBlock> pointer,
      {bool retain = false,
      bool release = true})
      : super(pointer, retain: retain, release: release);

  /// Returns a block that wraps the given raw block pointer.
  static ObjCBlock_ffiVoid_ffiDouble_NSEventPhase_bool_bool castFromPointer(
      ffi.Pointer<objc.ObjCBlock> pointer,
      {bool retain = false,
      bool release = false}) {
    return ObjCBlock_ffiVoid_ffiDouble_NSEventPhase_bool_bool._(pointer,
        retain: retain, release: release);
  }

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ObjCBlock_ffiVoid_ffiDouble_NSEventPhase_bool_bool.fromFunctionPointer(
      ffi.Pointer<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Double arg0, ffi.UnsignedLong arg1,
                      ffi.Bool arg2, ffi.Pointer<ffi.Bool> arg3)>>
          ptr)
      : this._(objc.newPointerBlock(
            _cFuncTrampoline ??= ffi.Pointer.fromFunction<
                        ffi.Void Function(
                            ffi.Pointer<objc.ObjCBlock>,
                            ffi.Double,
                            ffi.UnsignedLong,
                            ffi.Bool,
                            ffi.Pointer<ffi.Bool>)>(
                    _ObjCBlock_ffiVoid_ffiDouble_NSEventPhase_bool_bool_fnPtrTrampoline)
                .cast(),
            ptr.cast()));
  static ffi.Pointer<ffi.Void>? _cFuncTrampoline;

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ObjCBlock_ffiVoid_ffiDouble_NSEventPhase_bool_bool.fromFunction(
      void Function(double, NSEventPhase, bool, ffi.Pointer<ffi.Bool>) fn)
      : this._(objc.newClosureBlock(
            _dartFuncTrampoline ??= ffi.Pointer.fromFunction<
                        ffi.Void Function(
                            ffi.Pointer<objc.ObjCBlock>,
                            ffi.Double,
                            ffi.UnsignedLong,
                            ffi.Bool,
                            ffi.Pointer<ffi.Bool>)>(
                    _ObjCBlock_ffiVoid_ffiDouble_NSEventPhase_bool_bool_closureTrampoline)
                .cast(),
            (double arg0, int arg1, bool arg2, ffi.Pointer<ffi.Bool> arg3) =>
                fn(arg0, NSEventPhase.fromValue(arg1), arg2, arg3)));
  static ffi.Pointer<ffi.Void>? _dartFuncTrampoline;

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// Note that unlike the default behavior of NativeCallable.listener, listener
  /// blocks do not keep the isolate alive.
  ObjCBlock_ffiVoid_ffiDouble_NSEventPhase_bool_bool.listener(
      void Function(double, NSEventPhase, bool, ffi.Pointer<ffi.Bool>) fn)
      : this._((objc.newClosureBlock(
            (_dartFuncListenerTrampoline ??= ffi.NativeCallable<
                        ffi.Void Function(
                            ffi.Pointer<objc.ObjCBlock>,
                            ffi.Double,
                            ffi.UnsignedLong,
                            ffi.Bool,
                            ffi.Pointer<ffi.Bool>)>.listener(
                    _ObjCBlock_ffiVoid_ffiDouble_NSEventPhase_bool_bool_closureTrampoline)
                  ..keepIsolateAlive = false)
                .nativeFunction
                .cast(),
            (double arg0, int arg1, bool arg2, ffi.Pointer<ffi.Bool> arg3) =>
                fn(arg0, NSEventPhase.fromValue(arg1), arg2, arg3))));
  static ffi.NativeCallable<
      ffi.Void Function(
          ffi.Pointer<objc.ObjCBlock>,
          ffi.Double,
          ffi.UnsignedLong,
          ffi.Bool,
          ffi.Pointer<ffi.Bool>)>? _dartFuncListenerTrampoline;

  void call(double arg0, NSEventPhase arg1, bool arg2,
          ffi.Pointer<ffi.Bool> arg3) =>
      pointer.ref.invoke
              .cast<
                  ffi.NativeFunction<
                      ffi.Void Function(
                          ffi.Pointer<objc.ObjCBlock> block,
                          ffi.Double arg0,
                          ffi.UnsignedLong arg1,
                          ffi.Bool arg2,
                          ffi.Pointer<ffi.Bool> arg3)>>()
              .asFunction<
                  void Function(ffi.Pointer<objc.ObjCBlock>, double, int, bool,
                      ffi.Pointer<ffi.Bool>)>()(
          pointer, arg0, arg1.value, arg2, arg3);
}

late final _sel_trackSwipeEventWithOptions_dampenAmountThresholdMin_max_usingHandler_ =
    objc.registerName(
        "trackSwipeEventWithOptions:dampenAmountThresholdMin:max:usingHandler:");
final _objc_msgSend_102 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.UnsignedLong,
                ffi.Double,
                ffi.Double,
                ffi.Pointer<objc.ObjCBlock>)>>()
    .asFunction<
        void Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            int,
            double,
            double,
            ffi.Pointer<objc.ObjCBlock>)>();
late final _sel_startPeriodicEventsAfterDelay_withPeriod_ =
    objc.registerName("startPeriodicEventsAfterDelay:withPeriod:");
final _objc_msgSend_103 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, ffi.Double, ffi.Double)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, double, double)>();
late final _sel_stopPeriodicEvents = objc.registerName("stopPeriodicEvents");
late final _sel_mouseEventWithType_location_modifierFlags_timestamp_windowNumber_context_eventNumber_clickCount_pressure_ =
    objc.registerName(
        "mouseEventWithType:location:modifierFlags:timestamp:windowNumber:context:eventNumber:clickCount:pressure:");
final _objc_msgSend_104 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.UnsignedLong,
                CGPoint,
                ffi.UnsignedLong,
                ffi.Double,
                ffi.Long,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Long,
                ffi.Long,
                ffi.Float)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            int,
            CGPoint,
            int,
            double,
            int,
            ffi.Pointer<objc.ObjCObject>,
            int,
            int,
            double)>();
late final _sel_keyEventWithType_location_modifierFlags_timestamp_windowNumber_context_characters_charactersIgnoringModifiers_isARepeat_keyCode_ =
    objc.registerName(
        "keyEventWithType:location:modifierFlags:timestamp:windowNumber:context:characters:charactersIgnoringModifiers:isARepeat:keyCode:");
final _objc_msgSend_105 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.UnsignedLong,
                CGPoint,
                ffi.UnsignedLong,
                ffi.Double,
                ffi.Long,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Bool,
                ffi.UnsignedShort)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            int,
            CGPoint,
            int,
            double,
            int,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            bool,
            int)>();
late final _sel_enterExitEventWithType_location_modifierFlags_timestamp_windowNumber_context_eventNumber_trackingNumber_userData_ =
    objc.registerName(
        "enterExitEventWithType:location:modifierFlags:timestamp:windowNumber:context:eventNumber:trackingNumber:userData:");
final _objc_msgSend_106 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.UnsignedLong,
                CGPoint,
                ffi.UnsignedLong,
                ffi.Double,
                ffi.Long,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Long,
                ffi.Long,
                ffi.Pointer<ffi.Void>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            int,
            CGPoint,
            int,
            double,
            int,
            ffi.Pointer<objc.ObjCObject>,
            int,
            int,
            ffi.Pointer<ffi.Void>)>();
late final _sel_otherEventWithType_location_modifierFlags_timestamp_windowNumber_context_subtype_data1_data2_ =
    objc.registerName(
        "otherEventWithType:location:modifierFlags:timestamp:windowNumber:context:subtype:data1:data2:");
final _objc_msgSend_107 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.UnsignedLong,
                CGPoint,
                ffi.UnsignedLong,
                ffi.Double,
                ffi.Long,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Short,
                ffi.Long,
                ffi.Long)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            int,
            CGPoint,
            int,
            double,
            int,
            ffi.Pointer<objc.ObjCObject>,
            int,
            int,
            int)>();
late final _sel_mouseLocation = objc.registerName("mouseLocation");
late final _sel_pressedMouseButtons = objc.registerName("pressedMouseButtons");
late final _sel_doubleClickInterval = objc.registerName("doubleClickInterval");
late final _sel_keyRepeatDelay = objc.registerName("keyRepeatDelay");
late final _sel_keyRepeatInterval = objc.registerName("keyRepeatInterval");
void _ObjCBlock_ffiVoid_NSEvent_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlock> block, ffi.Pointer<objc.ObjCObject> arg0) =>
    block.ref.target
        .cast<
            ffi.NativeFunction<
                ffi.Void Function(ffi.Pointer<objc.ObjCObject> arg0)>>()
        .asFunction<void Function(ffi.Pointer<objc.ObjCObject>)>()(arg0);
void _ObjCBlock_ffiVoid_NSEvent_closureTrampoline(
        ffi.Pointer<objc.ObjCBlock> block, ffi.Pointer<objc.ObjCObject> arg0) =>
    (objc.getBlockClosure(block) as void Function(
        ffi.Pointer<objc.ObjCObject>))(arg0);

class ObjCBlock_ffiVoid_NSEvent extends objc.ObjCBlockBase {
  ObjCBlock_ffiVoid_NSEvent._(ffi.Pointer<objc.ObjCBlock> pointer,
      {bool retain = false, bool release = true})
      : super(pointer, retain: retain, release: release);

  /// Returns a block that wraps the given raw block pointer.
  static ObjCBlock_ffiVoid_NSEvent castFromPointer(
      ffi.Pointer<objc.ObjCBlock> pointer,
      {bool retain = false,
      bool release = false}) {
    return ObjCBlock_ffiVoid_NSEvent._(pointer,
        retain: retain, release: release);
  }

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ObjCBlock_ffiVoid_NSEvent.fromFunctionPointer(
      ffi.Pointer<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<objc.ObjCObject> arg0)>>
          ptr)
      : this._(objc.newPointerBlock(
            _cFuncTrampoline ??= ffi.Pointer.fromFunction<
                        ffi.Void Function(ffi.Pointer<objc.ObjCBlock>,
                            ffi.Pointer<objc.ObjCObject>)>(
                    _ObjCBlock_ffiVoid_NSEvent_fnPtrTrampoline)
                .cast(),
            ptr.cast()));
  static ffi.Pointer<ffi.Void>? _cFuncTrampoline;

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ObjCBlock_ffiVoid_NSEvent.fromFunction(void Function(NSEvent) fn)
      : this._(objc.newClosureBlock(
            _dartFuncTrampoline ??= ffi.Pointer.fromFunction<
                        ffi.Void Function(ffi.Pointer<objc.ObjCBlock>,
                            ffi.Pointer<objc.ObjCObject>)>(
                    _ObjCBlock_ffiVoid_NSEvent_closureTrampoline)
                .cast(),
            (ffi.Pointer<objc.ObjCObject> arg0) => fn(
                NSEvent.castFromPointer(arg0, retain: true, release: true))));
  static ffi.Pointer<ffi.Void>? _dartFuncTrampoline;

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// Note that unlike the default behavior of NativeCallable.listener, listener
  /// blocks do not keep the isolate alive.
  ObjCBlock_ffiVoid_NSEvent.listener(void Function(NSEvent) fn)
      : this._(wrapListenerBlock_ObjCBlock_ffiVoid_NSEvent(objc.newClosureBlock(
            (_dartFuncListenerTrampoline ??= ffi.NativeCallable<
                        ffi.Void Function(ffi.Pointer<objc.ObjCBlock>,
                            ffi.Pointer<objc.ObjCObject>)>.listener(
                    _ObjCBlock_ffiVoid_NSEvent_closureTrampoline)
                  ..keepIsolateAlive = false)
                .nativeFunction
                .cast(),
            (ffi.Pointer<objc.ObjCObject> arg0) => fn(
                NSEvent.castFromPointer(arg0, retain: false, release: true)))));
  static ffi.NativeCallable<
          ffi.Void Function(
              ffi.Pointer<objc.ObjCBlock>, ffi.Pointer<objc.ObjCObject>)>?
      _dartFuncListenerTrampoline;

  void call(NSEvent arg0) => pointer.ref.invoke
      .cast<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<objc.ObjCBlock> block,
                  ffi.Pointer<objc.ObjCObject> arg0)>>()
      .asFunction<
          void Function(ffi.Pointer<objc.ObjCBlock>,
              ffi.Pointer<objc.ObjCObject>)>()(pointer, arg0.pointer);
}

late final _sel_addGlobalMonitorForEventsMatchingMask_handler_ =
    objc.registerName("addGlobalMonitorForEventsMatchingMask:handler:");
final _objc_msgSend_108 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.LongLong,
                ffi.Pointer<objc.ObjCBlock>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            int,
            ffi.Pointer<objc.ObjCBlock>)>();
ffi.Pointer<objc.ObjCObject> _ObjCBlock_NSEvent_NSEvent_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlock> block, ffi.Pointer<objc.ObjCObject> arg0) =>
    block.ref.target
        .cast<
            ffi.NativeFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<objc.ObjCObject> arg0)>>()
        .asFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>)>()(arg0);
ffi.Pointer<objc.ObjCObject> _ObjCBlock_NSEvent_NSEvent_closureTrampoline(
        ffi.Pointer<objc.ObjCBlock> block, ffi.Pointer<objc.ObjCObject> arg0) =>
    (objc.getBlockClosure(block) as ffi.Pointer<objc.ObjCObject> Function(
        ffi.Pointer<objc.ObjCObject>))(arg0);

class ObjCBlock_NSEvent_NSEvent extends objc.ObjCBlockBase {
  ObjCBlock_NSEvent_NSEvent._(ffi.Pointer<objc.ObjCBlock> pointer,
      {bool retain = false, bool release = true})
      : super(pointer, retain: retain, release: release);

  /// Returns a block that wraps the given raw block pointer.
  static ObjCBlock_NSEvent_NSEvent castFromPointer(
      ffi.Pointer<objc.ObjCBlock> pointer,
      {bool retain = false,
      bool release = false}) {
    return ObjCBlock_NSEvent_NSEvent._(pointer,
        retain: retain, release: release);
  }

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ObjCBlock_NSEvent_NSEvent.fromFunctionPointer(
      ffi.Pointer<
              ffi.NativeFunction<
                  ffi.Pointer<objc.ObjCObject> Function(
                      ffi.Pointer<objc.ObjCObject> arg0)>>
          ptr)
      : this._(objc.newPointerBlock(
            _cFuncTrampoline ??= ffi.Pointer.fromFunction<
                        ffi.Pointer<objc.ObjCObject> Function(
                            ffi.Pointer<objc.ObjCBlock>,
                            ffi.Pointer<objc.ObjCObject>)>(
                    _ObjCBlock_NSEvent_NSEvent_fnPtrTrampoline)
                .cast(),
            ptr.cast()));
  static ffi.Pointer<ffi.Void>? _cFuncTrampoline;

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ObjCBlock_NSEvent_NSEvent.fromFunction(NSEvent? Function(NSEvent) fn)
      : this._(objc.newClosureBlock(
            _dartFuncTrampoline ??= ffi.Pointer.fromFunction<
                        ffi.Pointer<objc.ObjCObject> Function(
                            ffi.Pointer<objc.ObjCBlock>,
                            ffi.Pointer<objc.ObjCObject>)>(
                    _ObjCBlock_NSEvent_NSEvent_closureTrampoline)
                .cast(),
            (ffi.Pointer<objc.ObjCObject> arg0) =>
                fn(NSEvent.castFromPointer(arg0, retain: true, release: true))
                    ?.retainAndReturnPointer() ??
                ffi.nullptr));
  static ffi.Pointer<ffi.Void>? _dartFuncTrampoline;

  NSEvent? call(NSEvent arg0) => pointer.ref.invoke
              .cast<
                  ffi.NativeFunction<
                      ffi.Pointer<objc.ObjCObject> Function(
                          ffi.Pointer<objc.ObjCBlock> block,
                          ffi.Pointer<objc.ObjCObject> arg0)>>()
              .asFunction<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCBlock>, ffi.Pointer<objc.ObjCObject>)>()
              (pointer, arg0.pointer)
              .address ==
          0
      ? null
      : NSEvent.castFromPointer(
          pointer.ref.invoke.cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCBlock> block, ffi.Pointer<objc.ObjCObject> arg0)>>().asFunction<
              ffi.Pointer<objc.ObjCObject> Function(
                  ffi.Pointer<objc.ObjCBlock>, ffi.Pointer<objc.ObjCObject>)>()(pointer, arg0.pointer),
          retain: false,
          release: true);
}

late final _sel_addLocalMonitorForEventsMatchingMask_handler_ =
    objc.registerName("addLocalMonitorForEventsMatchingMask:handler:");
final _objc_msgSend_109 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.LongLong,
                ffi.Pointer<objc.ObjCBlock>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            int,
            ffi.Pointer<objc.ObjCBlock>)>();
late final _sel_removeMonitor_ = objc.registerName("removeMonitor:");
late final _sel_autoscroll_ = objc.registerName("autoscroll:");
final _objc_msgSend_110 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Bool Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        bool Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<objc.ObjCObject>)>();
late final _sel_adjustScroll_ = objc.registerName("adjustScroll:");
late final _sel_scrollRect_by_ = objc.registerName("scrollRect:by:");
final _objc_msgSend_111 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, CGRect, CGSize)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, CGRect, CGSize)>();
late final _sel_translateRectsNeedingDisplayInRect_by_ =
    objc.registerName("translateRectsNeedingDisplayInRect:by:");
late final _sel_hitTest_ = objc.registerName("hitTest:");
final _objc_msgSend_112 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, CGPoint)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, CGPoint)>();
late final _sel_mouse_inRect_ = objc.registerName("mouse:inRect:");
final _objc_msgSend_113 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Bool Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, CGPoint, CGRect)>>()
    .asFunction<
        bool Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, CGPoint, CGRect)>();
late final _sel_viewWithTag_ = objc.registerName("viewWithTag:");
final _objc_msgSend_114 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, ffi.Long)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, int)>();
late final _sel_tag = objc.registerName("tag");
late final _sel_performKeyEquivalent_ =
    objc.registerName("performKeyEquivalent:");
late final _sel_acceptsFirstMouse_ = objc.registerName("acceptsFirstMouse:");
final _objc_msgSend_115 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Bool Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        bool Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<objc.ObjCObject>)>();
late final _sel_shouldDelayWindowOrderingForEvent_ =
    objc.registerName("shouldDelayWindowOrderingForEvent:");
late final _sel_needsPanelToBecomeKey =
    objc.registerName("needsPanelToBecomeKey");
late final _sel_mouseDownCanMoveWindow =
    objc.registerName("mouseDownCanMoveWindow");
late final _sel_acceptsTouchEvents = objc.registerName("acceptsTouchEvents");
late final _sel_setAcceptsTouchEvents_ =
    objc.registerName("setAcceptsTouchEvents:");
late final _sel_wantsRestingTouches = objc.registerName("wantsRestingTouches");
late final _sel_setWantsRestingTouches_ =
    objc.registerName("setWantsRestingTouches:");

/// CALayer
class CALayer extends objc.ObjCObjectBase {
  CALayer._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super(pointer, retain: retain, release: release);

  /// Constructs a [CALayer] that points to the same underlying object as [other].
  CALayer.castFrom(objc.ObjCObjectBase other)
      : this._(other.pointer, retain: true, release: true);

  /// Constructs a [CALayer] that wraps the given raw object pointer.
  CALayer.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [CALayer].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_0(obj.pointer, _sel_isKindOfClass_, _class_CALayer);
  }
}

late final _class_CALayer = objc.getClass("CALayer");
late final _sel_makeBackingLayer = objc.registerName("makeBackingLayer");
final _objc_msgSend_116 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();

enum NSViewLayerContentsRedrawPolicy {
  NSViewLayerContentsRedrawNever(0),
  NSViewLayerContentsRedrawOnSetNeedsDisplay(1),
  NSViewLayerContentsRedrawDuringViewResize(2),
  NSViewLayerContentsRedrawBeforeViewResize(3),
  NSViewLayerContentsRedrawCrossfade(4);

  final int value;
  const NSViewLayerContentsRedrawPolicy(this.value);

  static NSViewLayerContentsRedrawPolicy fromValue(int value) =>
      switch (value) {
        0 => NSViewLayerContentsRedrawNever,
        1 => NSViewLayerContentsRedrawOnSetNeedsDisplay,
        2 => NSViewLayerContentsRedrawDuringViewResize,
        3 => NSViewLayerContentsRedrawBeforeViewResize,
        4 => NSViewLayerContentsRedrawCrossfade,
        _ => throw ArgumentError(
            "Unknown value for NSViewLayerContentsRedrawPolicy: $value"),
      };
}

late final _sel_layerContentsRedrawPolicy =
    objc.registerName("layerContentsRedrawPolicy");
final _objc_msgSend_117 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.UnsignedLong Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        int Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_setLayerContentsRedrawPolicy_ =
    objc.registerName("setLayerContentsRedrawPolicy:");
final _objc_msgSend_118 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, ffi.UnsignedLong)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, int)>();

enum NSViewLayerContentsPlacement {
  NSViewLayerContentsPlacementScaleAxesIndependently(0),
  NSViewLayerContentsPlacementScaleProportionallyToFit(1),
  NSViewLayerContentsPlacementScaleProportionallyToFill(2),
  NSViewLayerContentsPlacementCenter(3),
  NSViewLayerContentsPlacementTop(4),
  NSViewLayerContentsPlacementTopRight(5),
  NSViewLayerContentsPlacementRight(6),
  NSViewLayerContentsPlacementBottomRight(7),
  NSViewLayerContentsPlacementBottom(8),
  NSViewLayerContentsPlacementBottomLeft(9),
  NSViewLayerContentsPlacementLeft(10),
  NSViewLayerContentsPlacementTopLeft(11);

  final int value;
  const NSViewLayerContentsPlacement(this.value);

  static NSViewLayerContentsPlacement fromValue(int value) => switch (value) {
        0 => NSViewLayerContentsPlacementScaleAxesIndependently,
        1 => NSViewLayerContentsPlacementScaleProportionallyToFit,
        2 => NSViewLayerContentsPlacementScaleProportionallyToFill,
        3 => NSViewLayerContentsPlacementCenter,
        4 => NSViewLayerContentsPlacementTop,
        5 => NSViewLayerContentsPlacementTopRight,
        6 => NSViewLayerContentsPlacementRight,
        7 => NSViewLayerContentsPlacementBottomRight,
        8 => NSViewLayerContentsPlacementBottom,
        9 => NSViewLayerContentsPlacementBottomLeft,
        10 => NSViewLayerContentsPlacementLeft,
        11 => NSViewLayerContentsPlacementTopLeft,
        _ => throw ArgumentError(
            "Unknown value for NSViewLayerContentsPlacement: $value"),
      };
}

late final _sel_layerContentsPlacement =
    objc.registerName("layerContentsPlacement");
final _objc_msgSend_119 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.UnsignedLong Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        int Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_setLayerContentsPlacement_ =
    objc.registerName("setLayerContentsPlacement:");
final _objc_msgSend_120 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, ffi.UnsignedLong)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, int)>();
late final _sel_wantsLayer = objc.registerName("wantsLayer");
late final _sel_setWantsLayer_ = objc.registerName("setWantsLayer:");
late final _sel_layer = objc.registerName("layer");
final _objc_msgSend_121 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_setLayer_ = objc.registerName("setLayer:");
final _objc_msgSend_122 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<objc.ObjCObject>)>();
late final _sel_wantsUpdateLayer = objc.registerName("wantsUpdateLayer");
late final _sel_updateLayer = objc.registerName("updateLayer");
late final _sel_canDrawSubviewsIntoLayer =
    objc.registerName("canDrawSubviewsIntoLayer");
late final _sel_setCanDrawSubviewsIntoLayer_ =
    objc.registerName("setCanDrawSubviewsIntoLayer:");
late final _sel_layoutSubtreeIfNeeded =
    objc.registerName("layoutSubtreeIfNeeded");
late final _sel_layout = objc.registerName("layout");
late final _sel_needsLayout = objc.registerName("needsLayout");
late final _sel_setNeedsLayout_ = objc.registerName("setNeedsLayout:");
late final _sel_alphaValue = objc.registerName("alphaValue");
late final _sel_setAlphaValue_ = objc.registerName("setAlphaValue:");
late final _sel_layerUsesCoreImageFilters =
    objc.registerName("layerUsesCoreImageFilters");
late final _sel_setLayerUsesCoreImageFilters_ =
    objc.registerName("setLayerUsesCoreImageFilters:");
late final _sel_backgroundFilters = objc.registerName("backgroundFilters");
late final _sel_setBackgroundFilters_ =
    objc.registerName("setBackgroundFilters:");

/// CIFilter
class CIFilter extends objc.ObjCObjectBase {
  CIFilter._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super(pointer, retain: retain, release: release);

  /// Constructs a [CIFilter] that points to the same underlying object as [other].
  CIFilter.castFrom(objc.ObjCObjectBase other)
      : this._(other.pointer, retain: true, release: true);

  /// Constructs a [CIFilter] that wraps the given raw object pointer.
  CIFilter.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [CIFilter].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_0(obj.pointer, _sel_isKindOfClass_, _class_CIFilter);
  }
}

late final _class_CIFilter = objc.getClass("CIFilter");
late final _sel_compositingFilter = objc.registerName("compositingFilter");
final _objc_msgSend_123 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_setCompositingFilter_ =
    objc.registerName("setCompositingFilter:");
final _objc_msgSend_124 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<objc.ObjCObject>)>();
late final _sel_contentFilters = objc.registerName("contentFilters");
late final _sel_setContentFilters_ = objc.registerName("setContentFilters:");

/// NSShadow
class NSShadow extends objc.ObjCObjectBase {
  NSShadow._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super(pointer, retain: retain, release: release);

  /// Constructs a [NSShadow] that points to the same underlying object as [other].
  NSShadow.castFrom(objc.ObjCObjectBase other)
      : this._(other.pointer, retain: true, release: true);

  /// Constructs a [NSShadow] that wraps the given raw object pointer.
  NSShadow.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [NSShadow].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_0(obj.pointer, _sel_isKindOfClass_, _class_NSShadow);
  }
}

late final _class_NSShadow = objc.getClass("NSShadow");
late final _sel_shadow = objc.registerName("shadow");
final _objc_msgSend_125 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_setShadow_ = objc.registerName("setShadow:");
final _objc_msgSend_126 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<objc.ObjCObject>)>();
late final _sel_clipsToBounds = objc.registerName("clipsToBounds");
late final _sel_setClipsToBounds_ = objc.registerName("setClipsToBounds:");
late final _sel_postsBoundsChangedNotifications =
    objc.registerName("postsBoundsChangedNotifications");
late final _sel_setPostsBoundsChangedNotifications_ =
    objc.registerName("setPostsBoundsChangedNotifications:");

/// NSScrollView
class NSScrollView extends objc.ObjCObjectBase {
  NSScrollView._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super(pointer, retain: retain, release: release);

  /// Constructs a [NSScrollView] that points to the same underlying object as [other].
  NSScrollView.castFrom(objc.ObjCObjectBase other)
      : this._(other.pointer, retain: true, release: true);

  /// Constructs a [NSScrollView] that wraps the given raw object pointer.
  NSScrollView.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [NSScrollView].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_0(
        obj.pointer, _sel_isKindOfClass_, _class_NSScrollView);
  }
}

late final _class_NSScrollView = objc.getClass("NSScrollView");
late final _sel_enclosingScrollView = objc.registerName("enclosingScrollView");
final _objc_msgSend_127 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();

/// NSMenu
class NSMenu extends objc.NSObject {
  NSMenu._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release);

  /// Constructs a [NSMenu] that points to the same underlying object as [other].
  NSMenu.castFrom(objc.ObjCObjectBase other)
      : this._(other.pointer, retain: true, release: true);

  /// Constructs a [NSMenu] that wraps the given raw object pointer.
  NSMenu.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [NSMenu].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_0(obj.pointer, _sel_isKindOfClass_, _class_NSMenu);
  }

  /// initWithTitle:
  NSMenu initWithTitle_(objc.NSString title) {
    final _ret =
        _objc_msgSend_128(this.pointer, _sel_initWithTitle_, title.pointer);
    return NSMenu.castFromPointer(_ret, retain: true, release: true);
  }

  /// initWithCoder:
  NSMenu initWithCoder_(objc.NSCoder coder) {
    final _ret =
        _objc_msgSend_31(this.pointer, _sel_initWithCoder_, coder.pointer);
    return NSMenu.castFromPointer(_ret, retain: true, release: true);
  }

  /// title
  objc.NSString get title {
    final _ret = _objc_msgSend_3(this.pointer, _sel_title);
    return objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// setTitle:
  set title(objc.NSString value) {
    return _objc_msgSend_4(this.pointer, _sel_setTitle_, value.pointer);
  }

  /// popUpContextMenu:withEvent:forView:
  static void popUpContextMenu_withEvent_forView_(
      NSMenu menu, NSEvent event, NSView view) {
    _objc_msgSend_129(_class_NSMenu, _sel_popUpContextMenu_withEvent_forView_,
        menu.pointer, event.pointer, view.pointer);
  }

  /// popUpContextMenu:withEvent:forView:withFont:
  static void popUpContextMenu_withEvent_forView_withFont_(
      NSMenu menu, NSEvent event, NSView view, NSFont? font) {
    _objc_msgSend_130(
        _class_NSMenu,
        _sel_popUpContextMenu_withEvent_forView_withFont_,
        menu.pointer,
        event.pointer,
        view.pointer,
        font?.pointer ?? ffi.nullptr);
  }

  /// popUpMenuPositioningItem:atLocation:inView:
  bool popUpMenuPositioningItem_atLocation_inView_(
      NSMenuItem? item, CGPoint location, NSView? view) {
    return _objc_msgSend_151(
        this.pointer,
        _sel_popUpMenuPositioningItem_atLocation_inView_,
        item?.pointer ?? ffi.nullptr,
        location,
        view?.pointer ?? ffi.nullptr);
  }

  /// setMenuBarVisible:
  static void setMenuBarVisible_(bool visible) {
    _objc_msgSend_152(_class_NSMenu, _sel_setMenuBarVisible_, visible);
  }

  /// menuBarVisible
  static bool menuBarVisible() {
    return _objc_msgSend_13(_class_NSMenu, _sel_menuBarVisible);
  }

  /// supermenu
  NSMenu? get supermenu {
    final _ret = _objc_msgSend_133(this.pointer, _sel_supermenu);
    return _ret.address == 0
        ? null
        : NSMenu.castFromPointer(_ret, retain: true, release: true);
  }

  /// setSupermenu:
  set supermenu(NSMenu? value) {
    return _objc_msgSend_134(
        this.pointer, _sel_setSupermenu_, value?.pointer ?? ffi.nullptr);
  }

  /// insertItem:atIndex:
  void insertItem_atIndex_(NSMenuItem newItem, int index) {
    _objc_msgSend_153(
        this.pointer, _sel_insertItem_atIndex_, newItem.pointer, index);
  }

  /// addItem:
  void addItem_(NSMenuItem newItem) {
    _objc_msgSend_154(this.pointer, _sel_addItem_, newItem.pointer);
  }

  /// insertItemWithTitle:action:keyEquivalent:atIndex:
  NSMenuItem insertItemWithTitle_action_keyEquivalent_atIndex_(
      objc.NSString string,
      ffi.Pointer<objc.ObjCSelector> selector,
      objc.NSString charCode,
      int index) {
    final _ret = _objc_msgSend_155(
        this.pointer,
        _sel_insertItemWithTitle_action_keyEquivalent_atIndex_,
        string.pointer,
        selector,
        charCode.pointer,
        index);
    return NSMenuItem.castFromPointer(_ret, retain: true, release: true);
  }

  /// addItemWithTitle:action:keyEquivalent:
  NSMenuItem addItemWithTitle_action_keyEquivalent_(objc.NSString string,
      ffi.Pointer<objc.ObjCSelector> selector, objc.NSString charCode) {
    final _ret = _objc_msgSend_156(
        this.pointer,
        _sel_addItemWithTitle_action_keyEquivalent_,
        string.pointer,
        selector,
        charCode.pointer);
    return NSMenuItem.castFromPointer(_ret, retain: true, release: true);
  }

  /// removeItemAtIndex:
  void removeItemAtIndex_(int index) {
    _objc_msgSend_41(this.pointer, _sel_removeItemAtIndex_, index);
  }

  /// removeItem:
  void removeItem_(NSMenuItem item) {
    _objc_msgSend_154(this.pointer, _sel_removeItem_, item.pointer);
  }

  /// setSubmenu:forItem:
  void setSubmenu_forItem_(NSMenu? menu, NSMenuItem item) {
    _objc_msgSend_157(this.pointer, _sel_setSubmenu_forItem_,
        menu?.pointer ?? ffi.nullptr, item.pointer);
  }

  /// removeAllItems
  void removeAllItems() {
    _objc_msgSend_11(this.pointer, _sel_removeAllItems);
  }

  /// itemArray
  objc.ObjCObjectBase get itemArray {
    final _ret = _objc_msgSend_2(this.pointer, _sel_itemArray);
    return objc.ObjCObjectBase(_ret, retain: true, release: true);
  }

  /// setItemArray:
  set itemArray(objc.ObjCObjectBase value) {
    return _objc_msgSend_48(this.pointer, _sel_setItemArray_, value.pointer);
  }

  /// numberOfItems
  int get numberOfItems {
    return _objc_msgSend_79(this.pointer, _sel_numberOfItems);
  }

  /// itemAtIndex:
  NSMenuItem? itemAtIndex_(int index) {
    final _ret = _objc_msgSend_158(this.pointer, _sel_itemAtIndex_, index);
    return _ret.address == 0
        ? null
        : NSMenuItem.castFromPointer(_ret, retain: true, release: true);
  }

  /// indexOfItem:
  int indexOfItem_(NSMenuItem item) {
    return _objc_msgSend_159(this.pointer, _sel_indexOfItem_, item.pointer);
  }

  /// indexOfItemWithTitle:
  int indexOfItemWithTitle_(objc.NSString title) {
    return _objc_msgSend_160(
        this.pointer, _sel_indexOfItemWithTitle_, title.pointer);
  }

  /// indexOfItemWithTag:
  int indexOfItemWithTag_(int tag) {
    return _objc_msgSend_161(this.pointer, _sel_indexOfItemWithTag_, tag);
  }

  /// indexOfItemWithRepresentedObject:
  int indexOfItemWithRepresentedObject_(objc.ObjCObjectBase? object) {
    return _objc_msgSend_162(this.pointer,
        _sel_indexOfItemWithRepresentedObject_, object?.pointer ?? ffi.nullptr);
  }

  /// indexOfItemWithSubmenu:
  int indexOfItemWithSubmenu_(NSMenu? submenu) {
    return _objc_msgSend_163(this.pointer, _sel_indexOfItemWithSubmenu_,
        submenu?.pointer ?? ffi.nullptr);
  }

  /// indexOfItemWithTarget:andAction:
  int indexOfItemWithTarget_andAction_(objc.ObjCObjectBase? target,
      ffi.Pointer<objc.ObjCSelector> actionSelector) {
    return _objc_msgSend_164(
        this.pointer,
        _sel_indexOfItemWithTarget_andAction_,
        target?.pointer ?? ffi.nullptr,
        actionSelector);
  }

  /// itemWithTitle:
  NSMenuItem? itemWithTitle_(objc.NSString title) {
    final _ret =
        _objc_msgSend_165(this.pointer, _sel_itemWithTitle_, title.pointer);
    return _ret.address == 0
        ? null
        : NSMenuItem.castFromPointer(_ret, retain: true, release: true);
  }

  /// itemWithTag:
  NSMenuItem? itemWithTag_(int tag) {
    final _ret = _objc_msgSend_158(this.pointer, _sel_itemWithTag_, tag);
    return _ret.address == 0
        ? null
        : NSMenuItem.castFromPointer(_ret, retain: true, release: true);
  }

  /// autoenablesItems
  bool get autoenablesItems {
    return _objc_msgSend_13(this.pointer, _sel_autoenablesItems);
  }

  /// setAutoenablesItems:
  set autoenablesItems(bool value) {
    return _objc_msgSend_14(this.pointer, _sel_setAutoenablesItems_, value);
  }

  /// update
  void update() {
    _objc_msgSend_11(this.pointer, _sel_update);
  }

  /// performKeyEquivalent:
  bool performKeyEquivalent_(NSEvent event) {
    return _objc_msgSend_110(
        this.pointer, _sel_performKeyEquivalent_, event.pointer);
  }

  /// itemChanged:
  void itemChanged_(NSMenuItem item) {
    _objc_msgSend_154(this.pointer, _sel_itemChanged_, item.pointer);
  }

  /// performActionForItemAtIndex:
  void performActionForItemAtIndex_(int index) {
    _objc_msgSend_41(this.pointer, _sel_performActionForItemAtIndex_, index);
  }

  /// delegate
  objc.ObjCObjectBase? get delegate {
    final _ret = _objc_msgSend_22(this.pointer, _sel_delegate);
    return _ret.address == 0
        ? null
        : objc.ObjCObjectBase(_ret, retain: true, release: true);
  }

  /// setDelegate:
  set delegate(objc.ObjCObjectBase? value) {
    return _objc_msgSend_23(
        this.pointer, _sel_setDelegate_, value?.pointer ?? ffi.nullptr);
  }

  /// menuBarHeight
  double get menuBarHeight {
    return objc.useMsgSendVariants
        ? _objc_msgSend_10Fpret(this.pointer, _sel_menuBarHeight)
        : _objc_msgSend_10(this.pointer, _sel_menuBarHeight);
  }

  /// cancelTracking
  void cancelTracking() {
    _objc_msgSend_11(this.pointer, _sel_cancelTracking);
  }

  /// cancelTrackingWithoutAnimation
  void cancelTrackingWithoutAnimation() {
    _objc_msgSend_11(this.pointer, _sel_cancelTrackingWithoutAnimation);
  }

  /// highlightedItem
  NSMenuItem? get highlightedItem {
    final _ret = _objc_msgSend_135(this.pointer, _sel_highlightedItem);
    return _ret.address == 0
        ? null
        : NSMenuItem.castFromPointer(_ret, retain: true, release: true);
  }

  /// minimumWidth
  double get minimumWidth {
    return objc.useMsgSendVariants
        ? _objc_msgSend_10Fpret(this.pointer, _sel_minimumWidth)
        : _objc_msgSend_10(this.pointer, _sel_minimumWidth);
  }

  /// setMinimumWidth:
  set minimumWidth(double value) {
    return _objc_msgSend_64(this.pointer, _sel_setMinimumWidth_, value);
  }

  /// size
  void getSize(ffi.Pointer<CGSize> stret) {
    objc.useMsgSendVariants
        ? _objc_msgSend_98Stret(stret, this.pointer, _sel_size)
        : stret.ref = _objc_msgSend_98(this.pointer, _sel_size);
  }

  /// font
  NSFont get font {
    final _ret = _objc_msgSend_166(this.pointer, _sel_font);
    return NSFont.castFromPointer(_ret, retain: true, release: true);
  }

  /// setFont:
  set font(NSFont value) {
    return _objc_msgSend_167(this.pointer, _sel_setFont_, value.pointer);
  }

  /// allowsContextMenuPlugIns
  bool get allowsContextMenuPlugIns {
    return _objc_msgSend_13(this.pointer, _sel_allowsContextMenuPlugIns);
  }

  /// setAllowsContextMenuPlugIns:
  set allowsContextMenuPlugIns(bool value) {
    return _objc_msgSend_14(
        this.pointer, _sel_setAllowsContextMenuPlugIns_, value);
  }

  /// showsStateColumn
  bool get showsStateColumn {
    return _objc_msgSend_13(this.pointer, _sel_showsStateColumn);
  }

  /// setShowsStateColumn:
  set showsStateColumn(bool value) {
    return _objc_msgSend_14(this.pointer, _sel_setShowsStateColumn_, value);
  }

  /// userInterfaceLayoutDirection
  NSUserInterfaceLayoutDirection get userInterfaceLayoutDirection {
    final _ret =
        _objc_msgSend_168(this.pointer, _sel_userInterfaceLayoutDirection);
    return NSUserInterfaceLayoutDirection.fromValue(_ret);
  }

  /// setUserInterfaceLayoutDirection:
  set userInterfaceLayoutDirection(NSUserInterfaceLayoutDirection value) {
    return _objc_msgSend_169(
        this.pointer, _sel_setUserInterfaceLayoutDirection_, value.value);
  }

  /// init
  NSMenu init() {
    final _ret = _objc_msgSend_2(this.pointer, _sel_init);
    return NSMenu.castFromPointer(_ret, retain: true, release: true);
  }

  /// new
  static NSMenu new1() {
    final _ret = _objc_msgSend_2(_class_NSMenu, _sel_new);
    return NSMenu.castFromPointer(_ret, retain: false, release: true);
  }

  /// allocWithZone:
  static NSMenu allocWithZone_(ffi.Pointer<_NSZone> zone) {
    final _ret = _objc_msgSend_20(_class_NSMenu, _sel_allocWithZone_, zone);
    return NSMenu.castFromPointer(_ret, retain: false, release: true);
  }

  /// alloc
  static NSMenu alloc() {
    final _ret = _objc_msgSend_2(_class_NSMenu, _sel_alloc);
    return NSMenu.castFromPointer(_ret, retain: false, release: true);
  }
}

late final _class_NSMenu = objc.getClass("NSMenu");
late final _sel_initWithTitle_ = objc.registerName("initWithTitle:");
final _objc_msgSend_128 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            instancetype Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        instancetype Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<objc.ObjCObject>)>();
late final _sel_popUpContextMenu_withEvent_forView_ =
    objc.registerName("popUpContextMenu:withEvent:forView:");
final _objc_msgSend_129 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        void Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>();

/// NSFont
class NSFont extends objc.ObjCObjectBase {
  NSFont._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super(pointer, retain: retain, release: release);

  /// Constructs a [NSFont] that points to the same underlying object as [other].
  NSFont.castFrom(objc.ObjCObjectBase other)
      : this._(other.pointer, retain: true, release: true);

  /// Constructs a [NSFont] that wraps the given raw object pointer.
  NSFont.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [NSFont].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_0(obj.pointer, _sel_isKindOfClass_, _class_NSFont);
  }
}

late final _class_NSFont = objc.getClass("NSFont");
late final _sel_popUpContextMenu_withEvent_forView_withFont_ =
    objc.registerName("popUpContextMenu:withEvent:forView:withFont:");
final _objc_msgSend_130 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        void Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>();

/// NSMenuItem
class NSMenuItem extends objc.NSObject {
  NSMenuItem._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release);

  /// Constructs a [NSMenuItem] that points to the same underlying object as [other].
  NSMenuItem.castFrom(objc.ObjCObjectBase other)
      : this._(other.pointer, retain: true, release: true);

  /// Constructs a [NSMenuItem] that wraps the given raw object pointer.
  NSMenuItem.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [NSMenuItem].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_0(obj.pointer, _sel_isKindOfClass_, _class_NSMenuItem);
  }

  /// usesUserKeyEquivalents
  static bool getUsesUserKeyEquivalents() {
    return _objc_msgSend_13(_class_NSMenuItem, _sel_usesUserKeyEquivalents);
  }

  /// setUsesUserKeyEquivalents:
  static void setUsesUserKeyEquivalents(bool value) {
    return _objc_msgSend_14(
        _class_NSMenuItem, _sel_setUsesUserKeyEquivalents_, value);
  }

  /// separatorItem
  static NSMenuItem separatorItem() {
    final _ret = _objc_msgSend_131(_class_NSMenuItem, _sel_separatorItem);
    return NSMenuItem.castFromPointer(_ret, retain: true, release: true);
  }

  /// sectionHeaderWithTitle:
  static NSMenuItem sectionHeaderWithTitle_(objc.NSString title) {
    final _ret = _objc_msgSend_128(
        _class_NSMenuItem, _sel_sectionHeaderWithTitle_, title.pointer);
    return NSMenuItem.castFromPointer(_ret, retain: true, release: true);
  }

  /// initWithTitle:action:keyEquivalent:
  NSMenuItem initWithTitle_action_keyEquivalent_(objc.NSString string,
      ffi.Pointer<objc.ObjCSelector> selector, objc.NSString charCode) {
    final _ret = _objc_msgSend_132(
        this.pointer,
        _sel_initWithTitle_action_keyEquivalent_,
        string.pointer,
        selector,
        charCode.pointer);
    return NSMenuItem.castFromPointer(_ret, retain: true, release: true);
  }

  /// initWithCoder:
  NSMenuItem initWithCoder_(objc.NSCoder coder) {
    final _ret =
        _objc_msgSend_31(this.pointer, _sel_initWithCoder_, coder.pointer);
    return NSMenuItem.castFromPointer(_ret, retain: true, release: true);
  }

  /// menu
  NSMenu? get menu {
    final _ret = _objc_msgSend_133(this.pointer, _sel_menu);
    return _ret.address == 0
        ? null
        : NSMenu.castFromPointer(_ret, retain: true, release: true);
  }

  /// setMenu:
  set menu(NSMenu? value) {
    return _objc_msgSend_134(
        this.pointer, _sel_setMenu_, value?.pointer ?? ffi.nullptr);
  }

  /// hasSubmenu
  bool get hasSubmenu {
    return _objc_msgSend_13(this.pointer, _sel_hasSubmenu);
  }

  /// submenu
  NSMenu? get submenu {
    final _ret = _objc_msgSend_133(this.pointer, _sel_submenu);
    return _ret.address == 0
        ? null
        : NSMenu.castFromPointer(_ret, retain: true, release: true);
  }

  /// setSubmenu:
  set submenu(NSMenu? value) {
    return _objc_msgSend_134(
        this.pointer, _sel_setSubmenu_, value?.pointer ?? ffi.nullptr);
  }

  /// parentItem
  NSMenuItem? get parentItem {
    final _ret = _objc_msgSend_135(this.pointer, _sel_parentItem);
    return _ret.address == 0
        ? null
        : NSMenuItem.castFromPointer(_ret, retain: true, release: true);
  }

  /// title
  objc.NSString get title {
    final _ret = _objc_msgSend_3(this.pointer, _sel_title);
    return objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// setTitle:
  set title(objc.NSString value) {
    return _objc_msgSend_4(this.pointer, _sel_setTitle_, value.pointer);
  }

  /// attributedTitle
  NSAttributedString? get attributedTitle {
    final _ret = _objc_msgSend_137(this.pointer, _sel_attributedTitle);
    return _ret.address == 0
        ? null
        : NSAttributedString.castFromPointer(_ret, retain: true, release: true);
  }

  /// setAttributedTitle:
  set attributedTitle(NSAttributedString? value) {
    return _objc_msgSend_138(
        this.pointer, _sel_setAttributedTitle_, value?.pointer ?? ffi.nullptr);
  }

  /// isSeparatorItem
  bool get separatorItem1 {
    return _objc_msgSend_13(this.pointer, _sel_isSeparatorItem);
  }

  /// isSectionHeader
  bool get sectionHeader {
    return _objc_msgSend_13(this.pointer, _sel_isSectionHeader);
  }

  /// keyEquivalent
  objc.NSString get keyEquivalent {
    final _ret = _objc_msgSend_3(this.pointer, _sel_keyEquivalent);
    return objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// setKeyEquivalent:
  set keyEquivalent(objc.NSString value) {
    return _objc_msgSend_4(this.pointer, _sel_setKeyEquivalent_, value.pointer);
  }

  /// keyEquivalentModifierMask
  NSEventModifierFlags get keyEquivalentModifierMask {
    final _ret = _objc_msgSend_78(this.pointer, _sel_keyEquivalentModifierMask);
    return NSEventModifierFlags.fromValue(_ret);
  }

  /// setKeyEquivalentModifierMask:
  set keyEquivalentModifierMask(NSEventModifierFlags value) {
    return _objc_msgSend_139(
        this.pointer, _sel_setKeyEquivalentModifierMask_, value.value);
  }

  /// userKeyEquivalent
  objc.NSString get userKeyEquivalent {
    final _ret = _objc_msgSend_3(this.pointer, _sel_userKeyEquivalent);
    return objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// allowsKeyEquivalentWhenHidden
  bool get allowsKeyEquivalentWhenHidden {
    return _objc_msgSend_13(this.pointer, _sel_allowsKeyEquivalentWhenHidden);
  }

  /// setAllowsKeyEquivalentWhenHidden:
  set allowsKeyEquivalentWhenHidden(bool value) {
    return _objc_msgSend_14(
        this.pointer, _sel_setAllowsKeyEquivalentWhenHidden_, value);
  }

  /// allowsAutomaticKeyEquivalentLocalization
  bool get allowsAutomaticKeyEquivalentLocalization {
    return _objc_msgSend_13(
        this.pointer, _sel_allowsAutomaticKeyEquivalentLocalization);
  }

  /// setAllowsAutomaticKeyEquivalentLocalization:
  set allowsAutomaticKeyEquivalentLocalization(bool value) {
    return _objc_msgSend_14(
        this.pointer, _sel_setAllowsAutomaticKeyEquivalentLocalization_, value);
  }

  /// allowsAutomaticKeyEquivalentMirroring
  bool get allowsAutomaticKeyEquivalentMirroring {
    return _objc_msgSend_13(
        this.pointer, _sel_allowsAutomaticKeyEquivalentMirroring);
  }

  /// setAllowsAutomaticKeyEquivalentMirroring:
  set allowsAutomaticKeyEquivalentMirroring(bool value) {
    return _objc_msgSend_14(
        this.pointer, _sel_setAllowsAutomaticKeyEquivalentMirroring_, value);
  }

  /// image
  NSImage? get image {
    final _ret = _objc_msgSend_140(this.pointer, _sel_image);
    return _ret.address == 0
        ? null
        : NSImage.castFromPointer(_ret, retain: true, release: true);
  }

  /// setImage:
  set image(NSImage? value) {
    return _objc_msgSend_141(
        this.pointer, _sel_setImage_, value?.pointer ?? ffi.nullptr);
  }

  /// state
  int get state {
    return _objc_msgSend_79(this.pointer, _sel_state);
  }

  /// setState:
  set state(int value) {
    return _objc_msgSend_142(this.pointer, _sel_setState_, value);
  }

  /// onStateImage
  NSImage get onStateImage {
    final _ret = _objc_msgSend_143(this.pointer, _sel_onStateImage);
    return NSImage.castFromPointer(_ret, retain: true, release: true);
  }

  /// setOnStateImage:
  set onStateImage(NSImage value) {
    return _objc_msgSend_144(
        this.pointer, _sel_setOnStateImage_, value.pointer);
  }

  /// offStateImage
  NSImage? get offStateImage {
    final _ret = _objc_msgSend_140(this.pointer, _sel_offStateImage);
    return _ret.address == 0
        ? null
        : NSImage.castFromPointer(_ret, retain: true, release: true);
  }

  /// setOffStateImage:
  set offStateImage(NSImage? value) {
    return _objc_msgSend_141(
        this.pointer, _sel_setOffStateImage_, value?.pointer ?? ffi.nullptr);
  }

  /// mixedStateImage
  NSImage get mixedStateImage {
    final _ret = _objc_msgSend_143(this.pointer, _sel_mixedStateImage);
    return NSImage.castFromPointer(_ret, retain: true, release: true);
  }

  /// setMixedStateImage:
  set mixedStateImage(NSImage value) {
    return _objc_msgSend_144(
        this.pointer, _sel_setMixedStateImage_, value.pointer);
  }

  /// isEnabled
  bool get enabled {
    return _objc_msgSend_13(this.pointer, _sel_isEnabled);
  }

  /// setEnabled:
  set enabled(bool value) {
    return _objc_msgSend_14(this.pointer, _sel_setEnabled_, value);
  }

  /// isAlternate
  bool get alternate {
    return _objc_msgSend_13(this.pointer, _sel_isAlternate);
  }

  /// setAlternate:
  set alternate(bool value) {
    return _objc_msgSend_14(this.pointer, _sel_setAlternate_, value);
  }

  /// indentationLevel
  int get indentationLevel {
    return _objc_msgSend_79(this.pointer, _sel_indentationLevel);
  }

  /// setIndentationLevel:
  set indentationLevel(int value) {
    return _objc_msgSend_142(this.pointer, _sel_setIndentationLevel_, value);
  }

  /// target
  objc.ObjCObjectBase? get target {
    final _ret = _objc_msgSend_22(this.pointer, _sel_target);
    return _ret.address == 0
        ? null
        : objc.ObjCObjectBase(_ret, retain: true, release: true);
  }

  /// setTarget:
  set target(objc.ObjCObjectBase? value) {
    return _objc_msgSend_23(
        this.pointer, _sel_setTarget_, value?.pointer ?? ffi.nullptr);
  }

  /// action
  ffi.Pointer<objc.ObjCSelector> get action {
    return _objc_msgSend_145(this.pointer, _sel_action);
  }

  /// setAction:
  set action(ffi.Pointer<objc.ObjCSelector> value) {
    return _objc_msgSend_146(this.pointer, _sel_setAction_, value);
  }

  /// tag
  int get tag {
    return _objc_msgSend_79(this.pointer, _sel_tag);
  }

  /// setTag:
  set tag(int value) {
    return _objc_msgSend_142(this.pointer, _sel_setTag_, value);
  }

  /// representedObject
  objc.ObjCObjectBase? get representedObject {
    final _ret = _objc_msgSend_22(this.pointer, _sel_representedObject);
    return _ret.address == 0
        ? null
        : objc.ObjCObjectBase(_ret, retain: true, release: true);
  }

  /// setRepresentedObject:
  set representedObject(objc.ObjCObjectBase? value) {
    return _objc_msgSend_23(this.pointer, _sel_setRepresentedObject_,
        value?.pointer ?? ffi.nullptr);
  }

  /// view
  NSView? get view {
    final _ret = _objc_msgSend_47(this.pointer, _sel_view);
    return _ret.address == 0
        ? null
        : NSView.castFromPointer(_ret, retain: true, release: true);
  }

  /// setView:
  set view(NSView? value) {
    return _objc_msgSend_147(
        this.pointer, _sel_setView_, value?.pointer ?? ffi.nullptr);
  }

  /// isHighlighted
  bool get highlighted {
    return _objc_msgSend_13(this.pointer, _sel_isHighlighted);
  }

  /// isHidden
  bool get hidden {
    return _objc_msgSend_13(this.pointer, _sel_isHidden);
  }

  /// setHidden:
  set hidden(bool value) {
    return _objc_msgSend_14(this.pointer, _sel_setHidden_, value);
  }

  /// isHiddenOrHasHiddenAncestor
  bool get hiddenOrHasHiddenAncestor {
    return _objc_msgSend_13(this.pointer, _sel_isHiddenOrHasHiddenAncestor);
  }

  /// toolTip
  objc.NSString? get toolTip {
    final _ret = _objc_msgSend_84(this.pointer, _sel_toolTip);
    return _ret.address == 0
        ? null
        : objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// setToolTip:
  set toolTip(objc.NSString? value) {
    return _objc_msgSend_148(
        this.pointer, _sel_setToolTip_, value?.pointer ?? ffi.nullptr);
  }

  /// badge
  NSMenuItemBadge? get badge {
    final _ret = _objc_msgSend_149(this.pointer, _sel_badge);
    return _ret.address == 0
        ? null
        : NSMenuItemBadge.castFromPointer(_ret, retain: true, release: true);
  }

  /// setBadge:
  set badge(NSMenuItemBadge? value) {
    return _objc_msgSend_150(
        this.pointer, _sel_setBadge_, value?.pointer ?? ffi.nullptr);
  }

  /// init
  NSMenuItem init() {
    final _ret = _objc_msgSend_2(this.pointer, _sel_init);
    return NSMenuItem.castFromPointer(_ret, retain: true, release: true);
  }

  /// new
  static NSMenuItem new1() {
    final _ret = _objc_msgSend_2(_class_NSMenuItem, _sel_new);
    return NSMenuItem.castFromPointer(_ret, retain: false, release: true);
  }

  /// allocWithZone:
  static NSMenuItem allocWithZone_(ffi.Pointer<_NSZone> zone) {
    final _ret = _objc_msgSend_20(_class_NSMenuItem, _sel_allocWithZone_, zone);
    return NSMenuItem.castFromPointer(_ret, retain: false, release: true);
  }

  /// alloc
  static NSMenuItem alloc() {
    final _ret = _objc_msgSend_2(_class_NSMenuItem, _sel_alloc);
    return NSMenuItem.castFromPointer(_ret, retain: false, release: true);
  }
}

late final _class_NSMenuItem = objc.getClass("NSMenuItem");
late final _sel_usesUserKeyEquivalents =
    objc.registerName("usesUserKeyEquivalents");
late final _sel_setUsesUserKeyEquivalents_ =
    objc.registerName("setUsesUserKeyEquivalents:");
late final _sel_separatorItem = objc.registerName("separatorItem");
final _objc_msgSend_131 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_sectionHeaderWithTitle_ =
    objc.registerName("sectionHeaderWithTitle:");
late final _sel_initWithTitle_action_keyEquivalent_ =
    objc.registerName("initWithTitle:action:keyEquivalent:");
final _objc_msgSend_132 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            instancetype Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        instancetype Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>)>();
late final _sel_menu = objc.registerName("menu");
final _objc_msgSend_133 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_setMenu_ = objc.registerName("setMenu:");
final _objc_msgSend_134 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<objc.ObjCObject>)>();
late final _sel_hasSubmenu = objc.registerName("hasSubmenu");
late final _sel_submenu = objc.registerName("submenu");
late final _sel_setSubmenu_ = objc.registerName("setSubmenu:");
late final _sel_parentItem = objc.registerName("parentItem");
final _objc_msgSend_135 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();

/// NSAttributedString
class NSAttributedString extends objc.NSObject {
  NSAttributedString._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release);

  /// Constructs a [NSAttributedString] that points to the same underlying object as [other].
  NSAttributedString.castFrom(objc.ObjCObjectBase other)
      : this._(other.pointer, retain: true, release: true);

  /// Constructs a [NSAttributedString] that wraps the given raw object pointer.
  NSAttributedString.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [NSAttributedString].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_0(
        obj.pointer, _sel_isKindOfClass_, _class_NSAttributedString);
  }

  /// string
  objc.NSString get string {
    final _ret = _objc_msgSend_3(this.pointer, _sel_string);
    return objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// attributesAtIndex:effectiveRange:
  objc.ObjCObjectBase attributesAtIndex_effectiveRange_(
      int location, ffi.Pointer<_NSRange> range) {
    final _ret = _objc_msgSend_136(
        this.pointer, _sel_attributesAtIndex_effectiveRange_, location, range);
    return objc.ObjCObjectBase(_ret, retain: true, release: true);
  }

  /// init
  NSAttributedString init() {
    final _ret = _objc_msgSend_2(this.pointer, _sel_init);
    return NSAttributedString.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// new
  static NSAttributedString new1() {
    final _ret = _objc_msgSend_2(_class_NSAttributedString, _sel_new);
    return NSAttributedString.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// allocWithZone:
  static NSAttributedString allocWithZone_(ffi.Pointer<_NSZone> zone) {
    final _ret =
        _objc_msgSend_20(_class_NSAttributedString, _sel_allocWithZone_, zone);
    return NSAttributedString.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// alloc
  static NSAttributedString alloc() {
    final _ret = _objc_msgSend_2(_class_NSAttributedString, _sel_alloc);
    return NSAttributedString.castFromPointer(_ret,
        retain: false, release: true);
  }
}

late final _class_NSAttributedString = objc.getClass("NSAttributedString");
late final _sel_string = objc.registerName("string");

final class _NSRange extends ffi.Struct {
  @ffi.UnsignedLong()
  external int location;

  @ffi.UnsignedLong()
  external int length;
}

late final _sel_attributesAtIndex_effectiveRange_ =
    objc.registerName("attributesAtIndex:effectiveRange:");
final _objc_msgSend_136 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.UnsignedLong,
                ffi.Pointer<_NSRange>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, int, ffi.Pointer<_NSRange>)>();
late final _sel_attributedTitle = objc.registerName("attributedTitle");
final _objc_msgSend_137 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_setAttributedTitle_ = objc.registerName("setAttributedTitle:");
final _objc_msgSend_138 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<objc.ObjCObject>)>();
late final _sel_isSeparatorItem = objc.registerName("isSeparatorItem");
late final _sel_isSectionHeader = objc.registerName("isSectionHeader");
late final _sel_keyEquivalent = objc.registerName("keyEquivalent");
late final _sel_setKeyEquivalent_ = objc.registerName("setKeyEquivalent:");
late final _sel_keyEquivalentModifierMask =
    objc.registerName("keyEquivalentModifierMask");
late final _sel_setKeyEquivalentModifierMask_ =
    objc.registerName("setKeyEquivalentModifierMask:");
final _objc_msgSend_139 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, ffi.UnsignedLong)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, int)>();
late final _sel_userKeyEquivalent = objc.registerName("userKeyEquivalent");
late final _sel_allowsKeyEquivalentWhenHidden =
    objc.registerName("allowsKeyEquivalentWhenHidden");
late final _sel_setAllowsKeyEquivalentWhenHidden_ =
    objc.registerName("setAllowsKeyEquivalentWhenHidden:");
late final _sel_allowsAutomaticKeyEquivalentLocalization =
    objc.registerName("allowsAutomaticKeyEquivalentLocalization");
late final _sel_setAllowsAutomaticKeyEquivalentLocalization_ =
    objc.registerName("setAllowsAutomaticKeyEquivalentLocalization:");
late final _sel_allowsAutomaticKeyEquivalentMirroring =
    objc.registerName("allowsAutomaticKeyEquivalentMirroring");
late final _sel_setAllowsAutomaticKeyEquivalentMirroring_ =
    objc.registerName("setAllowsAutomaticKeyEquivalentMirroring:");

/// NSImage
class NSImage extends objc.ObjCObjectBase {
  NSImage._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super(pointer, retain: retain, release: release);

  /// Constructs a [NSImage] that points to the same underlying object as [other].
  NSImage.castFrom(objc.ObjCObjectBase other)
      : this._(other.pointer, retain: true, release: true);

  /// Constructs a [NSImage] that wraps the given raw object pointer.
  NSImage.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [NSImage].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_0(obj.pointer, _sel_isKindOfClass_, _class_NSImage);
  }
}

late final _class_NSImage = objc.getClass("NSImage");
late final _sel_image = objc.registerName("image");
final _objc_msgSend_140 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_setImage_ = objc.registerName("setImage:");
final _objc_msgSend_141 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<objc.ObjCObject>)>();
late final _sel_state = objc.registerName("state");
late final _sel_setState_ = objc.registerName("setState:");
final _objc_msgSend_142 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, ffi.Long)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, int)>();
late final _sel_onStateImage = objc.registerName("onStateImage");
final _objc_msgSend_143 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_setOnStateImage_ = objc.registerName("setOnStateImage:");
final _objc_msgSend_144 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<objc.ObjCObject>)>();
late final _sel_offStateImage = objc.registerName("offStateImage");
late final _sel_setOffStateImage_ = objc.registerName("setOffStateImage:");
late final _sel_mixedStateImage = objc.registerName("mixedStateImage");
late final _sel_setMixedStateImage_ = objc.registerName("setMixedStateImage:");
late final _sel_isEnabled = objc.registerName("isEnabled");
late final _sel_setEnabled_ = objc.registerName("setEnabled:");
late final _sel_isAlternate = objc.registerName("isAlternate");
late final _sel_setAlternate_ = objc.registerName("setAlternate:");
late final _sel_indentationLevel = objc.registerName("indentationLevel");
late final _sel_setIndentationLevel_ =
    objc.registerName("setIndentationLevel:");
late final _sel_target = objc.registerName("target");
late final _sel_setTarget_ = objc.registerName("setTarget:");
late final _sel_action = objc.registerName("action");
final _objc_msgSend_145 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCSelector> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCSelector> Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_setAction_ = objc.registerName("setAction:");
final _objc_msgSend_146 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_setTag_ = objc.registerName("setTag:");
late final _sel_representedObject = objc.registerName("representedObject");
late final _sel_setRepresentedObject_ =
    objc.registerName("setRepresentedObject:");
late final _sel_view = objc.registerName("view");
late final _sel_setView_ = objc.registerName("setView:");
final _objc_msgSend_147 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<objc.ObjCObject>)>();
late final _sel_isHighlighted = objc.registerName("isHighlighted");
late final _sel_toolTip = objc.registerName("toolTip");
late final _sel_setToolTip_ = objc.registerName("setToolTip:");
final _objc_msgSend_148 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<objc.ObjCObject>)>();

/// NSMenuItemBadge
class NSMenuItemBadge extends objc.ObjCObjectBase {
  NSMenuItemBadge._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super(pointer, retain: retain, release: release);

  /// Constructs a [NSMenuItemBadge] that points to the same underlying object as [other].
  NSMenuItemBadge.castFrom(objc.ObjCObjectBase other)
      : this._(other.pointer, retain: true, release: true);

  /// Constructs a [NSMenuItemBadge] that wraps the given raw object pointer.
  NSMenuItemBadge.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [NSMenuItemBadge].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_0(
        obj.pointer, _sel_isKindOfClass_, _class_NSMenuItemBadge);
  }
}

late final _class_NSMenuItemBadge = objc.getClass("NSMenuItemBadge");
late final _sel_badge = objc.registerName("badge");
final _objc_msgSend_149 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_setBadge_ = objc.registerName("setBadge:");
final _objc_msgSend_150 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<objc.ObjCObject>)>();
late final _sel_popUpMenuPositioningItem_atLocation_inView_ =
    objc.registerName("popUpMenuPositioningItem:atLocation:inView:");
final _objc_msgSend_151 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Bool Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                CGPoint,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        bool Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            CGPoint,
            ffi.Pointer<objc.ObjCObject>)>();
late final _sel_setMenuBarVisible_ = objc.registerName("setMenuBarVisible:");
final _objc_msgSend_152 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, ffi.Bool)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, bool)>();
late final _sel_menuBarVisible = objc.registerName("menuBarVisible");
late final _sel_supermenu = objc.registerName("supermenu");
late final _sel_setSupermenu_ = objc.registerName("setSupermenu:");
late final _sel_insertItem_atIndex_ = objc.registerName("insertItem:atIndex:");
final _objc_msgSend_153 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Long)>>()
    .asFunction<
        void Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            int)>();
late final _sel_addItem_ = objc.registerName("addItem:");
final _objc_msgSend_154 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<objc.ObjCObject>)>();
late final _sel_insertItemWithTitle_action_keyEquivalent_atIndex_ =
    objc.registerName("insertItemWithTitle:action:keyEquivalent:atIndex:");
final _objc_msgSend_155 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Long)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            int)>();
late final _sel_addItemWithTitle_action_keyEquivalent_ =
    objc.registerName("addItemWithTitle:action:keyEquivalent:");
final _objc_msgSend_156 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>)>();
late final _sel_removeItemAtIndex_ = objc.registerName("removeItemAtIndex:");
late final _sel_removeItem_ = objc.registerName("removeItem:");
late final _sel_setSubmenu_forItem_ = objc.registerName("setSubmenu:forItem:");
final _objc_msgSend_157 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        void Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>();
late final _sel_removeAllItems = objc.registerName("removeAllItems");
late final _sel_itemArray = objc.registerName("itemArray");
late final _sel_setItemArray_ = objc.registerName("setItemArray:");
late final _sel_numberOfItems = objc.registerName("numberOfItems");
late final _sel_itemAtIndex_ = objc.registerName("itemAtIndex:");
final _objc_msgSend_158 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, ffi.Long)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, int)>();
late final _sel_indexOfItem_ = objc.registerName("indexOfItem:");
final _objc_msgSend_159 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Long Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        int Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<objc.ObjCObject>)>();
late final _sel_indexOfItemWithTitle_ =
    objc.registerName("indexOfItemWithTitle:");
final _objc_msgSend_160 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Long Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        int Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<objc.ObjCObject>)>();
late final _sel_indexOfItemWithTag_ = objc.registerName("indexOfItemWithTag:");
final _objc_msgSend_161 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Long Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, ffi.Long)>>()
    .asFunction<
        int Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, int)>();
late final _sel_indexOfItemWithRepresentedObject_ =
    objc.registerName("indexOfItemWithRepresentedObject:");
final _objc_msgSend_162 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Long Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        int Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<objc.ObjCObject>)>();
late final _sel_indexOfItemWithSubmenu_ =
    objc.registerName("indexOfItemWithSubmenu:");
final _objc_msgSend_163 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Long Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        int Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<objc.ObjCObject>)>();
late final _sel_indexOfItemWithTarget_andAction_ =
    objc.registerName("indexOfItemWithTarget:andAction:");
final _objc_msgSend_164 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Long Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        int Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_itemWithTitle_ = objc.registerName("itemWithTitle:");
final _objc_msgSend_165 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<objc.ObjCObject>)>();
late final _sel_itemWithTag_ = objc.registerName("itemWithTag:");
late final _sel_autoenablesItems = objc.registerName("autoenablesItems");
late final _sel_setAutoenablesItems_ =
    objc.registerName("setAutoenablesItems:");
late final _sel_update = objc.registerName("update");
late final _sel_itemChanged_ = objc.registerName("itemChanged:");
late final _sel_performActionForItemAtIndex_ =
    objc.registerName("performActionForItemAtIndex:");
late final _sel_menuBarHeight = objc.registerName("menuBarHeight");
late final _sel_cancelTracking = objc.registerName("cancelTracking");
late final _sel_cancelTrackingWithoutAnimation =
    objc.registerName("cancelTrackingWithoutAnimation");
late final _sel_highlightedItem = objc.registerName("highlightedItem");
late final _sel_minimumWidth = objc.registerName("minimumWidth");
late final _sel_setMinimumWidth_ = objc.registerName("setMinimumWidth:");
late final _sel_size = objc.registerName("size");
late final _sel_font = objc.registerName("font");
final _objc_msgSend_166 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_setFont_ = objc.registerName("setFont:");
final _objc_msgSend_167 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<objc.ObjCObject>)>();
late final _sel_allowsContextMenuPlugIns =
    objc.registerName("allowsContextMenuPlugIns");
late final _sel_setAllowsContextMenuPlugIns_ =
    objc.registerName("setAllowsContextMenuPlugIns:");
late final _sel_showsStateColumn = objc.registerName("showsStateColumn");
late final _sel_setShowsStateColumn_ =
    objc.registerName("setShowsStateColumn:");

enum NSUserInterfaceLayoutDirection {
  NSUserInterfaceLayoutDirectionLeftToRight(0),
  NSUserInterfaceLayoutDirectionRightToLeft(1);

  final int value;
  const NSUserInterfaceLayoutDirection(this.value);

  static NSUserInterfaceLayoutDirection fromValue(int value) => switch (value) {
        0 => NSUserInterfaceLayoutDirectionLeftToRight,
        1 => NSUserInterfaceLayoutDirectionRightToLeft,
        _ => throw ArgumentError(
            "Unknown value for NSUserInterfaceLayoutDirection: $value"),
      };
}

late final _sel_userInterfaceLayoutDirection =
    objc.registerName("userInterfaceLayoutDirection");
final _objc_msgSend_168 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.UnsignedLong Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        int Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_setUserInterfaceLayoutDirection_ =
    objc.registerName("setUserInterfaceLayoutDirection:");
final _objc_msgSend_169 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, ffi.UnsignedLong)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, int)>();
late final _sel_menuForEvent_ = objc.registerName("menuForEvent:");
final _objc_msgSend_170 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<objc.ObjCObject>)>();
late final _sel_defaultMenu = objc.registerName("defaultMenu");
late final _sel_willOpenMenu_withEvent_ =
    objc.registerName("willOpenMenu:withEvent:");
final _objc_msgSend_171 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        void Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>();
late final _sel_didCloseMenu_withEvent_ =
    objc.registerName("didCloseMenu:withEvent:");
final _objc_msgSend_172 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        void Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>();
late final _sel_addToolTipRect_owner_userData_ =
    objc.registerName("addToolTipRect:owner:userData:");
final _objc_msgSend_173 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Long Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                CGRect,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<ffi.Void>)>>()
    .asFunction<
        int Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            CGRect,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<ffi.Void>)>();
late final _sel_removeToolTip_ = objc.registerName("removeToolTip:");
late final _sel_removeAllToolTips = objc.registerName("removeAllToolTips");
late final _sel_viewWillStartLiveResize =
    objc.registerName("viewWillStartLiveResize");
late final _sel_viewDidEndLiveResize =
    objc.registerName("viewDidEndLiveResize");
late final _sel_inLiveResize = objc.registerName("inLiveResize");
late final _sel_preservesContentDuringLiveResize =
    objc.registerName("preservesContentDuringLiveResize");
late final _sel_rectPreservedDuringLiveResize =
    objc.registerName("rectPreservedDuringLiveResize");
late final _sel_getRectsExposedDuringLiveResize_count_ =
    objc.registerName("getRectsExposedDuringLiveResize:count:");
final _objc_msgSend_174 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<CGRect>,
                ffi.Pointer<ffi.Long>)>>()
    .asFunction<
        void Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<CGRect>,
            ffi.Pointer<ffi.Long>)>();

/// NSTextInputContext
class NSTextInputContext extends objc.ObjCObjectBase {
  NSTextInputContext._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super(pointer, retain: retain, release: release);

  /// Constructs a [NSTextInputContext] that points to the same underlying object as [other].
  NSTextInputContext.castFrom(objc.ObjCObjectBase other)
      : this._(other.pointer, retain: true, release: true);

  /// Constructs a [NSTextInputContext] that wraps the given raw object pointer.
  NSTextInputContext.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [NSTextInputContext].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_0(
        obj.pointer, _sel_isKindOfClass_, _class_NSTextInputContext);
  }
}

late final _class_NSTextInputContext = objc.getClass("NSTextInputContext");
late final _sel_inputContext = objc.registerName("inputContext");
final _objc_msgSend_175 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_rectForSmartMagnificationAtPoint_inRect_ =
    objc.registerName("rectForSmartMagnificationAtPoint:inRect:");
final _objc_msgSend_176 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            CGRect Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, CGPoint, CGRect)>>()
    .asFunction<
        CGRect Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, CGPoint, CGRect)>();
final _objc_msgSend_176Stret = objc.msgSendStretPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(ffi.Pointer<CGRect>, ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, CGPoint, CGRect)>>()
    .asFunction<
        void Function(ffi.Pointer<CGRect>, ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, CGPoint, CGRect)>();
late final _sel_prepareForReuse = objc.registerName("prepareForReuse");
late final _sel_isCompatibleWithResponsiveScrolling =
    objc.registerName("isCompatibleWithResponsiveScrolling");
late final _sel_prepareContentInRect_ =
    objc.registerName("prepareContentInRect:");
late final _sel_preparedContentRect = objc.registerName("preparedContentRect");
late final _sel_setPreparedContentRect_ =
    objc.registerName("setPreparedContentRect:");
late final _sel_allowsVibrancy = objc.registerName("allowsVibrancy");
late final _sel_viewDidChangeEffectiveAppearance =
    objc.registerName("viewDidChangeEffectiveAppearance");

/// NSResponder
class NSResponder extends objc.NSObject {
  NSResponder._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release);

  /// Constructs a [NSResponder] that points to the same underlying object as [other].
  NSResponder.castFrom(objc.ObjCObjectBase other)
      : this._(other.pointer, retain: true, release: true);

  /// Constructs a [NSResponder] that wraps the given raw object pointer.
  NSResponder.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [NSResponder].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_0(
        obj.pointer, _sel_isKindOfClass_, _class_NSResponder);
  }

  /// init
  NSResponder init() {
    final _ret = _objc_msgSend_2(this.pointer, _sel_init);
    return NSResponder.castFromPointer(_ret, retain: true, release: true);
  }

  /// initWithCoder:
  NSResponder? initWithCoder_(objc.NSCoder coder) {
    final _ret =
        _objc_msgSend_45(this.pointer, _sel_initWithCoder_, coder.pointer);
    return _ret.address == 0
        ? null
        : NSResponder.castFromPointer(_ret, retain: true, release: true);
  }

  /// nextResponder
  NSResponder? get nextResponder {
    final _ret = _objc_msgSend_177(this.pointer, _sel_nextResponder);
    return _ret.address == 0
        ? null
        : NSResponder.castFromPointer(_ret, retain: true, release: true);
  }

  /// setNextResponder:
  set nextResponder(NSResponder? value) {
    return _objc_msgSend_178(
        this.pointer, _sel_setNextResponder_, value?.pointer ?? ffi.nullptr);
  }

  /// tryToPerform:with:
  bool tryToPerform_with_(
      ffi.Pointer<objc.ObjCSelector> action, objc.ObjCObjectBase? object) {
    return _objc_msgSend_179(this.pointer, _sel_tryToPerform_with_, action,
        object?.pointer ?? ffi.nullptr);
  }

  /// performKeyEquivalent:
  bool performKeyEquivalent_(NSEvent event) {
    return _objc_msgSend_110(
        this.pointer, _sel_performKeyEquivalent_, event.pointer);
  }

  /// validRequestorForSendType:returnType:
  objc.ObjCObjectBase? validRequestorForSendType_returnType_(
      objc.NSString? sendType, objc.NSString? returnType) {
    final _ret = _objc_msgSend_180(
        this.pointer,
        _sel_validRequestorForSendType_returnType_,
        sendType?.pointer ?? ffi.nullptr,
        returnType?.pointer ?? ffi.nullptr);
    return _ret.address == 0
        ? null
        : objc.ObjCObjectBase(_ret, retain: true, release: true);
  }

  /// mouseDown:
  void mouseDown_(NSEvent event) {
    _objc_msgSend_181(this.pointer, _sel_mouseDown_, event.pointer);
  }

  /// rightMouseDown:
  void rightMouseDown_(NSEvent event) {
    _objc_msgSend_181(this.pointer, _sel_rightMouseDown_, event.pointer);
  }

  /// otherMouseDown:
  void otherMouseDown_(NSEvent event) {
    _objc_msgSend_181(this.pointer, _sel_otherMouseDown_, event.pointer);
  }

  /// mouseUp:
  void mouseUp_(NSEvent event) {
    _objc_msgSend_181(this.pointer, _sel_mouseUp_, event.pointer);
  }

  /// rightMouseUp:
  void rightMouseUp_(NSEvent event) {
    _objc_msgSend_181(this.pointer, _sel_rightMouseUp_, event.pointer);
  }

  /// otherMouseUp:
  void otherMouseUp_(NSEvent event) {
    _objc_msgSend_181(this.pointer, _sel_otherMouseUp_, event.pointer);
  }

  /// mouseMoved:
  void mouseMoved_(NSEvent event) {
    _objc_msgSend_181(this.pointer, _sel_mouseMoved_, event.pointer);
  }

  /// mouseDragged:
  void mouseDragged_(NSEvent event) {
    _objc_msgSend_181(this.pointer, _sel_mouseDragged_, event.pointer);
  }

  /// scrollWheel:
  void scrollWheel_(NSEvent event) {
    _objc_msgSend_181(this.pointer, _sel_scrollWheel_, event.pointer);
  }

  /// rightMouseDragged:
  void rightMouseDragged_(NSEvent event) {
    _objc_msgSend_181(this.pointer, _sel_rightMouseDragged_, event.pointer);
  }

  /// otherMouseDragged:
  void otherMouseDragged_(NSEvent event) {
    _objc_msgSend_181(this.pointer, _sel_otherMouseDragged_, event.pointer);
  }

  /// mouseEntered:
  void mouseEntered_(NSEvent event) {
    _objc_msgSend_181(this.pointer, _sel_mouseEntered_, event.pointer);
  }

  /// mouseExited:
  void mouseExited_(NSEvent event) {
    _objc_msgSend_181(this.pointer, _sel_mouseExited_, event.pointer);
  }

  /// keyDown:
  void keyDown_(NSEvent event) {
    _objc_msgSend_181(this.pointer, _sel_keyDown_, event.pointer);
  }

  /// keyUp:
  void keyUp_(NSEvent event) {
    _objc_msgSend_181(this.pointer, _sel_keyUp_, event.pointer);
  }

  /// flagsChanged:
  void flagsChanged_(NSEvent event) {
    _objc_msgSend_181(this.pointer, _sel_flagsChanged_, event.pointer);
  }

  /// tabletPoint:
  void tabletPoint_(NSEvent event) {
    _objc_msgSend_181(this.pointer, _sel_tabletPoint_, event.pointer);
  }

  /// tabletProximity:
  void tabletProximity_(NSEvent event) {
    _objc_msgSend_181(this.pointer, _sel_tabletProximity_, event.pointer);
  }

  /// cursorUpdate:
  void cursorUpdate_(NSEvent event) {
    _objc_msgSend_181(this.pointer, _sel_cursorUpdate_, event.pointer);
  }

  /// magnifyWithEvent:
  void magnifyWithEvent_(NSEvent event) {
    _objc_msgSend_181(this.pointer, _sel_magnifyWithEvent_, event.pointer);
  }

  /// rotateWithEvent:
  void rotateWithEvent_(NSEvent event) {
    _objc_msgSend_181(this.pointer, _sel_rotateWithEvent_, event.pointer);
  }

  /// swipeWithEvent:
  void swipeWithEvent_(NSEvent event) {
    _objc_msgSend_181(this.pointer, _sel_swipeWithEvent_, event.pointer);
  }

  /// beginGestureWithEvent:
  void beginGestureWithEvent_(NSEvent event) {
    _objc_msgSend_181(this.pointer, _sel_beginGestureWithEvent_, event.pointer);
  }

  /// endGestureWithEvent:
  void endGestureWithEvent_(NSEvent event) {
    _objc_msgSend_181(this.pointer, _sel_endGestureWithEvent_, event.pointer);
  }

  /// smartMagnifyWithEvent:
  void smartMagnifyWithEvent_(NSEvent event) {
    _objc_msgSend_181(this.pointer, _sel_smartMagnifyWithEvent_, event.pointer);
  }

  /// changeModeWithEvent:
  void changeModeWithEvent_(NSEvent event) {
    _objc_msgSend_181(this.pointer, _sel_changeModeWithEvent_, event.pointer);
  }

  /// touchesBeganWithEvent:
  void touchesBeganWithEvent_(NSEvent event) {
    _objc_msgSend_181(this.pointer, _sel_touchesBeganWithEvent_, event.pointer);
  }

  /// touchesMovedWithEvent:
  void touchesMovedWithEvent_(NSEvent event) {
    _objc_msgSend_181(this.pointer, _sel_touchesMovedWithEvent_, event.pointer);
  }

  /// touchesEndedWithEvent:
  void touchesEndedWithEvent_(NSEvent event) {
    _objc_msgSend_181(this.pointer, _sel_touchesEndedWithEvent_, event.pointer);
  }

  /// touchesCancelledWithEvent:
  void touchesCancelledWithEvent_(NSEvent event) {
    _objc_msgSend_181(
        this.pointer, _sel_touchesCancelledWithEvent_, event.pointer);
  }

  /// quickLookWithEvent:
  void quickLookWithEvent_(NSEvent event) {
    _objc_msgSend_181(this.pointer, _sel_quickLookWithEvent_, event.pointer);
  }

  /// pressureChangeWithEvent:
  void pressureChangeWithEvent_(NSEvent event) {
    _objc_msgSend_181(
        this.pointer, _sel_pressureChangeWithEvent_, event.pointer);
  }

  /// noResponderFor:
  void noResponderFor_(ffi.Pointer<objc.ObjCSelector> eventSelector) {
    _objc_msgSend_182(this.pointer, _sel_noResponderFor_, eventSelector);
  }

  /// acceptsFirstResponder
  bool get acceptsFirstResponder {
    return _objc_msgSend_13(this.pointer, _sel_acceptsFirstResponder);
  }

  /// becomeFirstResponder
  bool becomeFirstResponder() {
    return _objc_msgSend_13(this.pointer, _sel_becomeFirstResponder);
  }

  /// resignFirstResponder
  bool resignFirstResponder() {
    return _objc_msgSend_13(this.pointer, _sel_resignFirstResponder);
  }

  /// interpretKeyEvents:
  void interpretKeyEvents_(objc.ObjCObjectBase eventArray) {
    _objc_msgSend_16(
        this.pointer, _sel_interpretKeyEvents_, eventArray.pointer);
  }

  /// flushBufferedKeyEvents
  void flushBufferedKeyEvents() {
    _objc_msgSend_11(this.pointer, _sel_flushBufferedKeyEvents);
  }

  /// menu
  NSMenu? get menu {
    final _ret = _objc_msgSend_133(this.pointer, _sel_menu);
    return _ret.address == 0
        ? null
        : NSMenu.castFromPointer(_ret, retain: true, release: true);
  }

  /// setMenu:
  set menu(NSMenu? value) {
    return _objc_msgSend_134(
        this.pointer, _sel_setMenu_, value?.pointer ?? ffi.nullptr);
  }

  /// showContextHelp:
  void showContextHelp_(objc.ObjCObjectBase? sender) {
    _objc_msgSend_24(
        this.pointer, _sel_showContextHelp_, sender?.pointer ?? ffi.nullptr);
  }

  /// helpRequested:
  void helpRequested_(NSEvent eventPtr) {
    _objc_msgSend_181(this.pointer, _sel_helpRequested_, eventPtr.pointer);
  }

  /// shouldBeTreatedAsInkEvent:
  bool shouldBeTreatedAsInkEvent_(NSEvent event) {
    return _objc_msgSend_110(
        this.pointer, _sel_shouldBeTreatedAsInkEvent_, event.pointer);
  }

  /// wantsScrollEventsForSwipeTrackingOnAxis:
  bool wantsScrollEventsForSwipeTrackingOnAxis_(NSEventGestureAxis axis) {
    return _objc_msgSend_183(this.pointer,
        _sel_wantsScrollEventsForSwipeTrackingOnAxis_, axis.value);
  }

  /// wantsForwardedScrollEventsForAxis:
  bool wantsForwardedScrollEventsForAxis_(NSEventGestureAxis axis) {
    return _objc_msgSend_183(
        this.pointer, _sel_wantsForwardedScrollEventsForAxis_, axis.value);
  }

  /// supplementalTargetForAction:sender:
  objc.ObjCObjectBase? supplementalTargetForAction_sender_(
      ffi.Pointer<objc.ObjCSelector> action, objc.ObjCObjectBase? sender) {
    final _ret = _objc_msgSend_184(
        this.pointer,
        _sel_supplementalTargetForAction_sender_,
        action,
        sender?.pointer ?? ffi.nullptr);
    return _ret.address == 0
        ? null
        : objc.ObjCObjectBase(_ret, retain: true, release: true);
  }

  /// new
  static NSResponder new1() {
    final _ret = _objc_msgSend_2(_class_NSResponder, _sel_new);
    return NSResponder.castFromPointer(_ret, retain: false, release: true);
  }

  /// allocWithZone:
  static NSResponder allocWithZone_(ffi.Pointer<_NSZone> zone) {
    final _ret =
        _objc_msgSend_20(_class_NSResponder, _sel_allocWithZone_, zone);
    return NSResponder.castFromPointer(_ret, retain: false, release: true);
  }

  /// alloc
  static NSResponder alloc() {
    final _ret = _objc_msgSend_2(_class_NSResponder, _sel_alloc);
    return NSResponder.castFromPointer(_ret, retain: false, release: true);
  }
}

late final _class_NSResponder = objc.getClass("NSResponder");
late final _sel_nextResponder = objc.registerName("nextResponder");
final _objc_msgSend_177 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_setNextResponder_ = objc.registerName("setNextResponder:");
final _objc_msgSend_178 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<objc.ObjCObject>)>();
late final _sel_tryToPerform_with_ = objc.registerName("tryToPerform:with:");
final _objc_msgSend_179 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Bool Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        bool Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>)>();
late final _sel_validRequestorForSendType_returnType_ =
    objc.registerName("validRequestorForSendType:returnType:");
final _objc_msgSend_180 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>();
late final _sel_mouseDown_ = objc.registerName("mouseDown:");
final _objc_msgSend_181 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<objc.ObjCObject>)>();
late final _sel_rightMouseDown_ = objc.registerName("rightMouseDown:");
late final _sel_otherMouseDown_ = objc.registerName("otherMouseDown:");
late final _sel_mouseUp_ = objc.registerName("mouseUp:");
late final _sel_rightMouseUp_ = objc.registerName("rightMouseUp:");
late final _sel_otherMouseUp_ = objc.registerName("otherMouseUp:");
late final _sel_mouseMoved_ = objc.registerName("mouseMoved:");
late final _sel_mouseDragged_ = objc.registerName("mouseDragged:");
late final _sel_scrollWheel_ = objc.registerName("scrollWheel:");
late final _sel_rightMouseDragged_ = objc.registerName("rightMouseDragged:");
late final _sel_otherMouseDragged_ = objc.registerName("otherMouseDragged:");
late final _sel_mouseEntered_ = objc.registerName("mouseEntered:");
late final _sel_mouseExited_ = objc.registerName("mouseExited:");
late final _sel_keyDown_ = objc.registerName("keyDown:");
late final _sel_keyUp_ = objc.registerName("keyUp:");
late final _sel_flagsChanged_ = objc.registerName("flagsChanged:");
late final _sel_tabletPoint_ = objc.registerName("tabletPoint:");
late final _sel_tabletProximity_ = objc.registerName("tabletProximity:");
late final _sel_cursorUpdate_ = objc.registerName("cursorUpdate:");
late final _sel_magnifyWithEvent_ = objc.registerName("magnifyWithEvent:");
late final _sel_rotateWithEvent_ = objc.registerName("rotateWithEvent:");
late final _sel_swipeWithEvent_ = objc.registerName("swipeWithEvent:");
late final _sel_beginGestureWithEvent_ =
    objc.registerName("beginGestureWithEvent:");
late final _sel_endGestureWithEvent_ =
    objc.registerName("endGestureWithEvent:");
late final _sel_smartMagnifyWithEvent_ =
    objc.registerName("smartMagnifyWithEvent:");
late final _sel_changeModeWithEvent_ =
    objc.registerName("changeModeWithEvent:");
late final _sel_touchesBeganWithEvent_ =
    objc.registerName("touchesBeganWithEvent:");
late final _sel_touchesMovedWithEvent_ =
    objc.registerName("touchesMovedWithEvent:");
late final _sel_touchesEndedWithEvent_ =
    objc.registerName("touchesEndedWithEvent:");
late final _sel_touchesCancelledWithEvent_ =
    objc.registerName("touchesCancelledWithEvent:");
late final _sel_quickLookWithEvent_ = objc.registerName("quickLookWithEvent:");
late final _sel_pressureChangeWithEvent_ =
    objc.registerName("pressureChangeWithEvent:");
late final _sel_noResponderFor_ = objc.registerName("noResponderFor:");
final _objc_msgSend_182 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_acceptsFirstResponder =
    objc.registerName("acceptsFirstResponder");
late final _sel_becomeFirstResponder =
    objc.registerName("becomeFirstResponder");
late final _sel_resignFirstResponder =
    objc.registerName("resignFirstResponder");
late final _sel_interpretKeyEvents_ = objc.registerName("interpretKeyEvents:");
late final _sel_flushBufferedKeyEvents =
    objc.registerName("flushBufferedKeyEvents");
late final _sel_showContextHelp_ = objc.registerName("showContextHelp:");
late final _sel_helpRequested_ = objc.registerName("helpRequested:");
late final _sel_shouldBeTreatedAsInkEvent_ =
    objc.registerName("shouldBeTreatedAsInkEvent:");

enum NSEventGestureAxis {
  NSEventGestureAxisNone(0),
  NSEventGestureAxisHorizontal(1),
  NSEventGestureAxisVertical(2);

  final int value;
  const NSEventGestureAxis(this.value);

  static NSEventGestureAxis fromValue(int value) => switch (value) {
        0 => NSEventGestureAxisNone,
        1 => NSEventGestureAxisHorizontal,
        2 => NSEventGestureAxisVertical,
        _ =>
          throw ArgumentError("Unknown value for NSEventGestureAxis: $value"),
      };
}

late final _sel_wantsScrollEventsForSwipeTrackingOnAxis_ =
    objc.registerName("wantsScrollEventsForSwipeTrackingOnAxis:");
final _objc_msgSend_183 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Bool Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, ffi.UnsignedLong)>>()
    .asFunction<
        bool Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, int)>();
late final _sel_wantsForwardedScrollEventsForAxis_ =
    objc.registerName("wantsForwardedScrollEventsForAxis:");
late final _sel_supplementalTargetForAction_sender_ =
    objc.registerName("supplementalTargetForAction:sender:");
final _objc_msgSend_184 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>)>();
late final _sel_contentView = objc.registerName("contentView");
late final _sel_setContentView_ = objc.registerName("setContentView:");
late final _sel_styleMask = objc.registerName("styleMask");
final _objc_msgSend_185 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.UnsignedLong Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        int Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_setStyleMask_ = objc.registerName("setStyleMask:");
final _objc_msgSend_186 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, ffi.UnsignedLong)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, int)>();

/// NSText
class NSText extends NSView {
  NSText._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release);

  /// Constructs a [NSText] that points to the same underlying object as [other].
  NSText.castFrom(objc.ObjCObjectBase other)
      : this._(other.pointer, retain: true, release: true);

  /// Constructs a [NSText] that wraps the given raw object pointer.
  NSText.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [NSText].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_0(obj.pointer, _sel_isKindOfClass_, _class_NSText);
  }

  /// initWithFrame:
  NSText initWithFrame_(CGRect frameRect) {
    final _ret = _objc_msgSend_44(this.pointer, _sel_initWithFrame_, frameRect);
    return NSText.castFromPointer(_ret, retain: true, release: true);
  }

  /// initWithCoder:
  NSText? initWithCoder_(objc.NSCoder coder) {
    final _ret =
        _objc_msgSend_45(this.pointer, _sel_initWithCoder_, coder.pointer);
    return _ret.address == 0
        ? null
        : NSText.castFromPointer(_ret, retain: true, release: true);
  }

  /// string
  objc.NSString get string {
    final _ret = _objc_msgSend_3(this.pointer, _sel_string);
    return objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// setString:
  set string(objc.NSString value) {
    return _objc_msgSend_4(this.pointer, _sel_setString_, value.pointer);
  }

  /// replaceCharactersInRange:withString:
  void replaceCharactersInRange_withString_(
      _NSRange range, objc.NSString string) {
    _objc_msgSend_187(this.pointer, _sel_replaceCharactersInRange_withString_,
        range, string.pointer);
  }

  /// replaceCharactersInRange:withRTF:
  void replaceCharactersInRange_withRTF_(_NSRange range, objc.NSData rtfData) {
    _objc_msgSend_188(this.pointer, _sel_replaceCharactersInRange_withRTF_,
        range, rtfData.pointer);
  }

  /// replaceCharactersInRange:withRTFD:
  void replaceCharactersInRange_withRTFD_(
      _NSRange range, objc.NSData rtfdData) {
    _objc_msgSend_188(this.pointer, _sel_replaceCharactersInRange_withRTFD_,
        range, rtfdData.pointer);
  }

  /// RTFFromRange:
  objc.NSData? RTFFromRange_(_NSRange range) {
    final _ret = _objc_msgSend_189(this.pointer, _sel_RTFFromRange_, range);
    return _ret.address == 0
        ? null
        : objc.NSData.castFromPointer(_ret, retain: true, release: true);
  }

  /// RTFDFromRange:
  objc.NSData? RTFDFromRange_(_NSRange range) {
    final _ret = _objc_msgSend_189(this.pointer, _sel_RTFDFromRange_, range);
    return _ret.address == 0
        ? null
        : objc.NSData.castFromPointer(_ret, retain: true, release: true);
  }

  /// writeRTFDToFile:atomically:
  bool writeRTFDToFile_atomically_(objc.NSString path, bool flag) {
    return _objc_msgSend_190(
        this.pointer, _sel_writeRTFDToFile_atomically_, path.pointer, flag);
  }

  /// readRTFDFromFile:
  bool readRTFDFromFile_(objc.NSString path) {
    return _objc_msgSend_191(
        this.pointer, _sel_readRTFDFromFile_, path.pointer);
  }

  /// delegate
  objc.ObjCObjectBase? get delegate {
    final _ret = _objc_msgSend_22(this.pointer, _sel_delegate);
    return _ret.address == 0
        ? null
        : objc.ObjCObjectBase(_ret, retain: true, release: true);
  }

  /// setDelegate:
  set delegate(objc.ObjCObjectBase? value) {
    return _objc_msgSend_23(
        this.pointer, _sel_setDelegate_, value?.pointer ?? ffi.nullptr);
  }

  /// isEditable
  bool get editable {
    return _objc_msgSend_13(this.pointer, _sel_isEditable);
  }

  /// setEditable:
  set editable(bool value) {
    return _objc_msgSend_14(this.pointer, _sel_setEditable_, value);
  }

  /// isSelectable
  bool get selectable {
    return _objc_msgSend_13(this.pointer, _sel_isSelectable);
  }

  /// setSelectable:
  set selectable(bool value) {
    return _objc_msgSend_14(this.pointer, _sel_setSelectable_, value);
  }

  /// isRichText
  bool get richText {
    return _objc_msgSend_13(this.pointer, _sel_isRichText);
  }

  /// setRichText:
  set richText(bool value) {
    return _objc_msgSend_14(this.pointer, _sel_setRichText_, value);
  }

  /// importsGraphics
  bool get importsGraphics {
    return _objc_msgSend_13(this.pointer, _sel_importsGraphics);
  }

  /// setImportsGraphics:
  set importsGraphics(bool value) {
    return _objc_msgSend_14(this.pointer, _sel_setImportsGraphics_, value);
  }

  /// isFieldEditor
  bool get fieldEditor {
    return _objc_msgSend_13(this.pointer, _sel_isFieldEditor);
  }

  /// setFieldEditor:
  set fieldEditor(bool value) {
    return _objc_msgSend_14(this.pointer, _sel_setFieldEditor_, value);
  }

  /// usesFontPanel
  bool get usesFontPanel {
    return _objc_msgSend_13(this.pointer, _sel_usesFontPanel);
  }

  /// setUsesFontPanel:
  set usesFontPanel(bool value) {
    return _objc_msgSend_14(this.pointer, _sel_setUsesFontPanel_, value);
  }

  /// drawsBackground
  bool get drawsBackground {
    return _objc_msgSend_13(this.pointer, _sel_drawsBackground);
  }

  /// setDrawsBackground:
  set drawsBackground(bool value) {
    return _objc_msgSend_14(this.pointer, _sel_setDrawsBackground_, value);
  }

  /// backgroundColor
  NSColor? get backgroundColor {
    final _ret = _objc_msgSend_192(this.pointer, _sel_backgroundColor);
    return _ret.address == 0
        ? null
        : NSColor.castFromPointer(_ret, retain: true, release: true);
  }

  /// setBackgroundColor:
  set backgroundColor(NSColor? value) {
    return _objc_msgSend_193(
        this.pointer, _sel_setBackgroundColor_, value?.pointer ?? ffi.nullptr);
  }

  /// isRulerVisible
  bool get rulerVisible {
    return _objc_msgSend_13(this.pointer, _sel_isRulerVisible);
  }

  /// selectedRange
  void getSelectedRange(ffi.Pointer<_NSRange> stret) {
    objc.useMsgSendVariants
        ? _objc_msgSend_194Stret(stret, this.pointer, _sel_selectedRange)
        : stret.ref = _objc_msgSend_194(this.pointer, _sel_selectedRange);
  }

  /// setSelectedRange:
  set selectedRange(_NSRange value) {
    return _objc_msgSend_195(this.pointer, _sel_setSelectedRange_, value);
  }

  /// scrollRangeToVisible:
  void scrollRangeToVisible_(_NSRange range) {
    _objc_msgSend_196(this.pointer, _sel_scrollRangeToVisible_, range);
  }

  /// font
  NSFont? get font {
    final _ret = _objc_msgSend_197(this.pointer, _sel_font);
    return _ret.address == 0
        ? null
        : NSFont.castFromPointer(_ret, retain: true, release: true);
  }

  /// setFont:
  set font(NSFont? value) {
    return _objc_msgSend_198(
        this.pointer, _sel_setFont_, value?.pointer ?? ffi.nullptr);
  }

  /// textColor
  NSColor? get textColor {
    final _ret = _objc_msgSend_192(this.pointer, _sel_textColor);
    return _ret.address == 0
        ? null
        : NSColor.castFromPointer(_ret, retain: true, release: true);
  }

  /// setTextColor:
  set textColor(NSColor? value) {
    return _objc_msgSend_193(
        this.pointer, _sel_setTextColor_, value?.pointer ?? ffi.nullptr);
  }

  /// alignment
  NSTextAlignment get alignment {
    final _ret = _objc_msgSend_199(this.pointer, _sel_alignment);
    return NSTextAlignment.fromValue(_ret);
  }

  /// setAlignment:
  set alignment(NSTextAlignment value) {
    return _objc_msgSend_200(this.pointer, _sel_setAlignment_, value.value);
  }

  /// baseWritingDirection
  NSWritingDirection get baseWritingDirection {
    final _ret = _objc_msgSend_201(this.pointer, _sel_baseWritingDirection);
    return NSWritingDirection.fromValue(_ret);
  }

  /// setBaseWritingDirection:
  set baseWritingDirection(NSWritingDirection value) {
    return _objc_msgSend_202(
        this.pointer, _sel_setBaseWritingDirection_, value.value);
  }

  /// setTextColor:range:
  void setTextColor_range_(NSColor? color, _NSRange range) {
    _objc_msgSend_203(this.pointer, _sel_setTextColor_range_,
        color?.pointer ?? ffi.nullptr, range);
  }

  /// setFont:range:
  void setFont_range_(NSFont font, _NSRange range) {
    _objc_msgSend_204(this.pointer, _sel_setFont_range_, font.pointer, range);
  }

  /// maxSize
  void getMaxSize(ffi.Pointer<CGSize> stret) {
    objc.useMsgSendVariants
        ? _objc_msgSend_98Stret(stret, this.pointer, _sel_maxSize)
        : stret.ref = _objc_msgSend_98(this.pointer, _sel_maxSize);
  }

  /// setMaxSize:
  set maxSize(CGSize value) {
    return _objc_msgSend_205(this.pointer, _sel_setMaxSize_, value);
  }

  /// minSize
  void getMinSize(ffi.Pointer<CGSize> stret) {
    objc.useMsgSendVariants
        ? _objc_msgSend_98Stret(stret, this.pointer, _sel_minSize)
        : stret.ref = _objc_msgSend_98(this.pointer, _sel_minSize);
  }

  /// setMinSize:
  set minSize(CGSize value) {
    return _objc_msgSend_205(this.pointer, _sel_setMinSize_, value);
  }

  /// isHorizontallyResizable
  bool get horizontallyResizable {
    return _objc_msgSend_13(this.pointer, _sel_isHorizontallyResizable);
  }

  /// setHorizontallyResizable:
  set horizontallyResizable(bool value) {
    return _objc_msgSend_14(
        this.pointer, _sel_setHorizontallyResizable_, value);
  }

  /// isVerticallyResizable
  bool get verticallyResizable {
    return _objc_msgSend_13(this.pointer, _sel_isVerticallyResizable);
  }

  /// setVerticallyResizable:
  set verticallyResizable(bool value) {
    return _objc_msgSend_14(this.pointer, _sel_setVerticallyResizable_, value);
  }

  /// sizeToFit
  void sizeToFit() {
    _objc_msgSend_11(this.pointer, _sel_sizeToFit);
  }

  /// copy:
  void copy_(objc.ObjCObjectBase? sender) {
    _objc_msgSend_24(this.pointer, _sel_copy_, sender?.pointer ?? ffi.nullptr);
  }

  /// copyFont:
  void copyFont_(objc.ObjCObjectBase? sender) {
    _objc_msgSend_24(
        this.pointer, _sel_copyFont_, sender?.pointer ?? ffi.nullptr);
  }

  /// copyRuler:
  void copyRuler_(objc.ObjCObjectBase? sender) {
    _objc_msgSend_24(
        this.pointer, _sel_copyRuler_, sender?.pointer ?? ffi.nullptr);
  }

  /// cut:
  void cut_(objc.ObjCObjectBase? sender) {
    _objc_msgSend_24(this.pointer, _sel_cut_, sender?.pointer ?? ffi.nullptr);
  }

  /// delete:
  void delete_(objc.ObjCObjectBase? sender) {
    _objc_msgSend_24(
        this.pointer, _sel_delete_, sender?.pointer ?? ffi.nullptr);
  }

  /// paste:
  void paste_(objc.ObjCObjectBase? sender) {
    _objc_msgSend_24(this.pointer, _sel_paste_, sender?.pointer ?? ffi.nullptr);
  }

  /// pasteFont:
  void pasteFont_(objc.ObjCObjectBase? sender) {
    _objc_msgSend_24(
        this.pointer, _sel_pasteFont_, sender?.pointer ?? ffi.nullptr);
  }

  /// pasteRuler:
  void pasteRuler_(objc.ObjCObjectBase? sender) {
    _objc_msgSend_24(
        this.pointer, _sel_pasteRuler_, sender?.pointer ?? ffi.nullptr);
  }

  /// selectAll:
  void selectAll_(objc.ObjCObjectBase? sender) {
    _objc_msgSend_24(
        this.pointer, _sel_selectAll_, sender?.pointer ?? ffi.nullptr);
  }

  /// changeFont:
  void changeFont_(objc.ObjCObjectBase? sender) {
    _objc_msgSend_24(
        this.pointer, _sel_changeFont_, sender?.pointer ?? ffi.nullptr);
  }

  /// alignLeft:
  void alignLeft_(objc.ObjCObjectBase? sender) {
    _objc_msgSend_24(
        this.pointer, _sel_alignLeft_, sender?.pointer ?? ffi.nullptr);
  }

  /// alignRight:
  void alignRight_(objc.ObjCObjectBase? sender) {
    _objc_msgSend_24(
        this.pointer, _sel_alignRight_, sender?.pointer ?? ffi.nullptr);
  }

  /// alignCenter:
  void alignCenter_(objc.ObjCObjectBase? sender) {
    _objc_msgSend_24(
        this.pointer, _sel_alignCenter_, sender?.pointer ?? ffi.nullptr);
  }

  /// subscript:
  void subscript_(objc.ObjCObjectBase? sender) {
    _objc_msgSend_24(
        this.pointer, _sel_subscript_, sender?.pointer ?? ffi.nullptr);
  }

  /// superscript:
  void superscript_(objc.ObjCObjectBase? sender) {
    _objc_msgSend_24(
        this.pointer, _sel_superscript_, sender?.pointer ?? ffi.nullptr);
  }

  /// underline:
  void underline_(objc.ObjCObjectBase? sender) {
    _objc_msgSend_24(
        this.pointer, _sel_underline_, sender?.pointer ?? ffi.nullptr);
  }

  /// unscript:
  void unscript_(objc.ObjCObjectBase? sender) {
    _objc_msgSend_24(
        this.pointer, _sel_unscript_, sender?.pointer ?? ffi.nullptr);
  }

  /// showGuessPanel:
  void showGuessPanel_(objc.ObjCObjectBase? sender) {
    _objc_msgSend_24(
        this.pointer, _sel_showGuessPanel_, sender?.pointer ?? ffi.nullptr);
  }

  /// checkSpelling:
  void checkSpelling_(objc.ObjCObjectBase? sender) {
    _objc_msgSend_24(
        this.pointer, _sel_checkSpelling_, sender?.pointer ?? ffi.nullptr);
  }

  /// toggleRuler:
  void toggleRuler_(objc.ObjCObjectBase? sender) {
    _objc_msgSend_24(
        this.pointer, _sel_toggleRuler_, sender?.pointer ?? ffi.nullptr);
  }

  /// focusView
  static NSView? getFocusView() {
    final _ret = _objc_msgSend_47(_class_NSText, _sel_focusView);
    return _ret.address == 0
        ? null
        : NSView.castFromPointer(_ret, retain: true, release: true);
  }

  /// defaultMenu
  static NSMenu? getDefaultMenu() {
    final _ret = _objc_msgSend_133(_class_NSText, _sel_defaultMenu);
    return _ret.address == 0
        ? null
        : NSMenu.castFromPointer(_ret, retain: true, release: true);
  }

  /// isCompatibleWithResponsiveScrolling
  static bool getCompatibleWithResponsiveScrolling() {
    return _objc_msgSend_13(
        _class_NSText, _sel_isCompatibleWithResponsiveScrolling);
  }

  /// init
  NSText init() {
    final _ret = _objc_msgSend_2(this.pointer, _sel_init);
    return NSText.castFromPointer(_ret, retain: true, release: true);
  }

  /// new
  static NSText new1() {
    final _ret = _objc_msgSend_2(_class_NSText, _sel_new);
    return NSText.castFromPointer(_ret, retain: false, release: true);
  }

  /// allocWithZone:
  static NSText allocWithZone_(ffi.Pointer<_NSZone> zone) {
    final _ret = _objc_msgSend_20(_class_NSText, _sel_allocWithZone_, zone);
    return NSText.castFromPointer(_ret, retain: false, release: true);
  }

  /// alloc
  static NSText alloc() {
    final _ret = _objc_msgSend_2(_class_NSText, _sel_alloc);
    return NSText.castFromPointer(_ret, retain: false, release: true);
  }
}

late final _class_NSText = objc.getClass("NSText");
late final _sel_setString_ = objc.registerName("setString:");
late final _sel_replaceCharactersInRange_withString_ =
    objc.registerName("replaceCharactersInRange:withString:");
final _objc_msgSend_187 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                _NSRange,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        void Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            _NSRange,
            ffi.Pointer<objc.ObjCObject>)>();
late final _sel_replaceCharactersInRange_withRTF_ =
    objc.registerName("replaceCharactersInRange:withRTF:");
final _objc_msgSend_188 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                _NSRange,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        void Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            _NSRange,
            ffi.Pointer<objc.ObjCObject>)>();
late final _sel_replaceCharactersInRange_withRTFD_ =
    objc.registerName("replaceCharactersInRange:withRTFD:");
late final _sel_RTFFromRange_ = objc.registerName("RTFFromRange:");
final _objc_msgSend_189 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, _NSRange)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, _NSRange)>();
late final _sel_RTFDFromRange_ = objc.registerName("RTFDFromRange:");
late final _sel_writeRTFDToFile_atomically_ =
    objc.registerName("writeRTFDToFile:atomically:");
final _objc_msgSend_190 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Bool Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Bool)>>()
    .asFunction<
        bool Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            bool)>();
late final _sel_readRTFDFromFile_ = objc.registerName("readRTFDFromFile:");
final _objc_msgSend_191 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Bool Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        bool Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<objc.ObjCObject>)>();
late final _sel_isEditable = objc.registerName("isEditable");
late final _sel_setEditable_ = objc.registerName("setEditable:");
late final _sel_isSelectable = objc.registerName("isSelectable");
late final _sel_setSelectable_ = objc.registerName("setSelectable:");
late final _sel_isRichText = objc.registerName("isRichText");
late final _sel_setRichText_ = objc.registerName("setRichText:");
late final _sel_importsGraphics = objc.registerName("importsGraphics");
late final _sel_setImportsGraphics_ = objc.registerName("setImportsGraphics:");
late final _sel_isFieldEditor = objc.registerName("isFieldEditor");
late final _sel_setFieldEditor_ = objc.registerName("setFieldEditor:");
late final _sel_usesFontPanel = objc.registerName("usesFontPanel");
late final _sel_setUsesFontPanel_ = objc.registerName("setUsesFontPanel:");
late final _sel_drawsBackground = objc.registerName("drawsBackground");
late final _sel_setDrawsBackground_ = objc.registerName("setDrawsBackground:");

/// NSColor
class NSColor extends objc.ObjCObjectBase {
  NSColor._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super(pointer, retain: retain, release: release);

  /// Constructs a [NSColor] that points to the same underlying object as [other].
  NSColor.castFrom(objc.ObjCObjectBase other)
      : this._(other.pointer, retain: true, release: true);

  /// Constructs a [NSColor] that wraps the given raw object pointer.
  NSColor.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [NSColor].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_0(obj.pointer, _sel_isKindOfClass_, _class_NSColor);
  }
}

late final _class_NSColor = objc.getClass("NSColor");
late final _sel_backgroundColor = objc.registerName("backgroundColor");
final _objc_msgSend_192 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_setBackgroundColor_ = objc.registerName("setBackgroundColor:");
final _objc_msgSend_193 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<objc.ObjCObject>)>();
late final _sel_isRulerVisible = objc.registerName("isRulerVisible");
late final _sel_selectedRange = objc.registerName("selectedRange");
final _objc_msgSend_194 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            _NSRange Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        _NSRange Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
final _objc_msgSend_194Stret = objc.msgSendStretPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<_NSRange>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        void Function(ffi.Pointer<_NSRange>, ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_setSelectedRange_ = objc.registerName("setSelectedRange:");
final _objc_msgSend_195 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, _NSRange)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, _NSRange)>();
late final _sel_scrollRangeToVisible_ =
    objc.registerName("scrollRangeToVisible:");
final _objc_msgSend_196 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, _NSRange)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, _NSRange)>();
final _objc_msgSend_197 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
final _objc_msgSend_198 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<objc.ObjCObject>)>();
late final _sel_textColor = objc.registerName("textColor");
late final _sel_setTextColor_ = objc.registerName("setTextColor:");

enum NSTextAlignment {
  NSTextAlignmentLeft(0),
  NSTextAlignmentCenter(1),
  NSTextAlignmentRight(2),
  NSTextAlignmentJustified(3),
  NSTextAlignmentNatural(4);

  final int value;
  const NSTextAlignment(this.value);

  static NSTextAlignment fromValue(int value) => switch (value) {
        0 => NSTextAlignmentLeft,
        1 => NSTextAlignmentCenter,
        2 => NSTextAlignmentRight,
        3 => NSTextAlignmentJustified,
        4 => NSTextAlignmentNatural,
        _ => throw ArgumentError("Unknown value for NSTextAlignment: $value"),
      };
}

late final _sel_alignment = objc.registerName("alignment");
final _objc_msgSend_199 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.UnsignedLong Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        int Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_setAlignment_ = objc.registerName("setAlignment:");
final _objc_msgSend_200 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, ffi.UnsignedLong)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, int)>();

enum NSWritingDirection {
  NSWritingDirectionNatural(-1),
  NSWritingDirectionLeftToRight(0),
  NSWritingDirectionRightToLeft(1);

  final int value;
  const NSWritingDirection(this.value);

  static NSWritingDirection fromValue(int value) => switch (value) {
        -1 => NSWritingDirectionNatural,
        0 => NSWritingDirectionLeftToRight,
        1 => NSWritingDirectionRightToLeft,
        _ =>
          throw ArgumentError("Unknown value for NSWritingDirection: $value"),
      };
}

late final _sel_baseWritingDirection =
    objc.registerName("baseWritingDirection");
final _objc_msgSend_201 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Long Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        int Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_setBaseWritingDirection_ =
    objc.registerName("setBaseWritingDirection:");
final _objc_msgSend_202 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, ffi.Long)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, int)>();
late final _sel_setTextColor_range_ = objc.registerName("setTextColor:range:");
final _objc_msgSend_203 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                _NSRange)>>()
    .asFunction<
        void Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            _NSRange)>();
late final _sel_setFont_range_ = objc.registerName("setFont:range:");
final _objc_msgSend_204 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                _NSRange)>>()
    .asFunction<
        void Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            _NSRange)>();
late final _sel_maxSize = objc.registerName("maxSize");
late final _sel_setMaxSize_ = objc.registerName("setMaxSize:");
final _objc_msgSend_205 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, CGSize)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, CGSize)>();
late final _sel_minSize = objc.registerName("minSize");
late final _sel_setMinSize_ = objc.registerName("setMinSize:");
late final _sel_isHorizontallyResizable =
    objc.registerName("isHorizontallyResizable");
late final _sel_setHorizontallyResizable_ =
    objc.registerName("setHorizontallyResizable:");
late final _sel_isVerticallyResizable =
    objc.registerName("isVerticallyResizable");
late final _sel_setVerticallyResizable_ =
    objc.registerName("setVerticallyResizable:");
late final _sel_sizeToFit = objc.registerName("sizeToFit");
late final _sel_copy_ = objc.registerName("copy:");
late final _sel_copyFont_ = objc.registerName("copyFont:");
late final _sel_copyRuler_ = objc.registerName("copyRuler:");
late final _sel_cut_ = objc.registerName("cut:");
late final _sel_delete_ = objc.registerName("delete:");
late final _sel_paste_ = objc.registerName("paste:");
late final _sel_pasteFont_ = objc.registerName("pasteFont:");
late final _sel_pasteRuler_ = objc.registerName("pasteRuler:");
late final _sel_selectAll_ = objc.registerName("selectAll:");
late final _sel_changeFont_ = objc.registerName("changeFont:");
late final _sel_alignLeft_ = objc.registerName("alignLeft:");
late final _sel_alignRight_ = objc.registerName("alignRight:");
late final _sel_alignCenter_ = objc.registerName("alignCenter:");
late final _sel_subscript_ = objc.registerName("subscript:");
late final _sel_superscript_ = objc.registerName("superscript:");
late final _sel_underline_ = objc.registerName("underline:");
late final _sel_unscript_ = objc.registerName("unscript:");
late final _sel_showGuessPanel_ = objc.registerName("showGuessPanel:");
late final _sel_checkSpelling_ = objc.registerName("checkSpelling:");
late final _sel_toggleRuler_ = objc.registerName("toggleRuler:");
late final _sel_fieldEditor_forObject_ =
    objc.registerName("fieldEditor:forObject:");
final _objc_msgSend_206 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Bool,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            bool,
            ffi.Pointer<objc.ObjCObject>)>();
late final _sel_endEditingFor_ = objc.registerName("endEditingFor:");
late final _sel_constrainFrameRect_toScreen_ =
    objc.registerName("constrainFrameRect:toScreen:");
final _objc_msgSend_207 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            CGRect Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                CGRect,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        CGRect Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            CGRect,
            ffi.Pointer<objc.ObjCObject>)>();
final _objc_msgSend_207Stret = objc.msgSendStretPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<CGRect>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                CGRect,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        void Function(
            ffi.Pointer<CGRect>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            CGRect,
            ffi.Pointer<objc.ObjCObject>)>();
late final _sel_setFrame_display_ = objc.registerName("setFrame:display:");
final _objc_msgSend_208 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, CGRect, ffi.Bool)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, CGRect, bool)>();
late final _sel_setContentSize_ = objc.registerName("setContentSize:");
late final _sel_setFrameTopLeftPoint_ =
    objc.registerName("setFrameTopLeftPoint:");
late final _sel_cascadeTopLeftFromPoint_ =
    objc.registerName("cascadeTopLeftFromPoint:");
late final _sel_animationResizeTime_ =
    objc.registerName("animationResizeTime:");
final _objc_msgSend_209 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Double Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, CGRect)>>()
    .asFunction<
        double Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, CGRect)>();
final _objc_msgSend_209Fpret = objc.msgSendFpretPointer
    .cast<
        ffi.NativeFunction<
            ffi.Double Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, CGRect)>>()
    .asFunction<
        double Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, CGRect)>();
late final _sel_setFrame_display_animate_ =
    objc.registerName("setFrame:display:animate:");
final _objc_msgSend_210 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, CGRect, ffi.Bool, ffi.Bool)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, CGRect, bool, bool)>();
late final _sel_resizeIncrements = objc.registerName("resizeIncrements");
late final _sel_setResizeIncrements_ =
    objc.registerName("setResizeIncrements:");
late final _sel_aspectRatio = objc.registerName("aspectRatio");
late final _sel_setAspectRatio_ = objc.registerName("setAspectRatio:");
late final _sel_contentResizeIncrements =
    objc.registerName("contentResizeIncrements");
late final _sel_setContentResizeIncrements_ =
    objc.registerName("setContentResizeIncrements:");
late final _sel_contentAspectRatio = objc.registerName("contentAspectRatio");
late final _sel_setContentAspectRatio_ =
    objc.registerName("setContentAspectRatio:");
late final _sel_viewsNeedDisplay = objc.registerName("viewsNeedDisplay");
late final _sel_setViewsNeedDisplay_ =
    objc.registerName("setViewsNeedDisplay:");
late final _sel_setPreservesContentDuringLiveResize_ =
    objc.registerName("setPreservesContentDuringLiveResize:");
late final _sel_makeFirstResponder_ = objc.registerName("makeFirstResponder:");
final _objc_msgSend_211 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Bool Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        bool Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<objc.ObjCObject>)>();
late final _sel_firstResponder = objc.registerName("firstResponder");
late final _sel_resizeFlags = objc.registerName("resizeFlags");
late final _sel_close = objc.registerName("close");
late final _sel_isReleasedWhenClosed =
    objc.registerName("isReleasedWhenClosed");
late final _sel_setReleasedWhenClosed_ =
    objc.registerName("setReleasedWhenClosed:");
late final _sel_miniaturize_ = objc.registerName("miniaturize:");
late final _sel_deminiaturize_ = objc.registerName("deminiaturize:");
late final _sel_isZoomed = objc.registerName("isZoomed");
late final _sel_zoom_ = objc.registerName("zoom:");
late final _sel_isMiniaturized = objc.registerName("isMiniaturized");
final _objc_msgSend_212 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
final _objc_msgSend_213 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<objc.ObjCObject>)>();

enum NSRectEdge {
  NSRectEdgeMinX(0),
  NSRectEdgeMinY(1),
  NSRectEdgeMaxX(2),
  NSRectEdgeMaxY(3);

  static const NSMinXEdge = NSRectEdgeMinX;
  static const NSMinYEdge = NSRectEdgeMinY;
  static const NSMaxXEdge = NSRectEdgeMaxX;
  static const NSMaxYEdge = NSRectEdgeMaxY;

  final int value;
  const NSRectEdge(this.value);

  static NSRectEdge fromValue(int value) => switch (value) {
        0 => NSRectEdgeMinX,
        1 => NSRectEdgeMinY,
        2 => NSRectEdgeMaxX,
        3 => NSRectEdgeMaxY,
        _ => throw ArgumentError("Unknown value for NSRectEdge: $value"),
      };

  @override
  String toString() {
    if (this == NSRectEdgeMinX)
      return "NSRectEdge.NSRectEdgeMinX, NSRectEdge.NSMinXEdge";
    if (this == NSRectEdgeMinY)
      return "NSRectEdge.NSRectEdgeMinY, NSRectEdge.NSMinYEdge";
    if (this == NSRectEdgeMaxX)
      return "NSRectEdge.NSRectEdgeMaxX, NSRectEdge.NSMaxXEdge";
    if (this == NSRectEdgeMaxY)
      return "NSRectEdge.NSRectEdgeMaxY, NSRectEdge.NSMaxYEdge";
    return super.toString();
  }
}

late final _sel_setContentBorderThickness_forEdge_ =
    objc.registerName("setContentBorderThickness:forEdge:");
final _objc_msgSend_214 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Double,
                ffi.UnsignedLong)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, double, int)>();
late final _sel_contentBorderThicknessForEdge_ =
    objc.registerName("contentBorderThicknessForEdge:");
final _objc_msgSend_215 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Double Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, ffi.UnsignedLong)>>()
    .asFunction<
        double Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, int)>();
final _objc_msgSend_215Fpret = objc.msgSendFpretPointer
    .cast<
        ffi.NativeFunction<
            ffi.Double Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, ffi.UnsignedLong)>>()
    .asFunction<
        double Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, int)>();
late final _sel_setAutorecalculatesContentBorderThickness_forEdge_ =
    objc.registerName("setAutorecalculatesContentBorderThickness:forEdge:");
final _objc_msgSend_216 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, ffi.Bool, ffi.UnsignedLong)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, bool, int)>();
late final _sel_autorecalculatesContentBorderThicknessForEdge_ =
    objc.registerName("autorecalculatesContentBorderThicknessForEdge:");
final _objc_msgSend_217 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Bool Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, ffi.UnsignedLong)>>()
    .asFunction<
        bool Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, int)>();
late final _sel_isMovable = objc.registerName("isMovable");
late final _sel_setMovable_ = objc.registerName("setMovable:");
late final _sel_isMovableByWindowBackground =
    objc.registerName("isMovableByWindowBackground");
late final _sel_setMovableByWindowBackground_ =
    objc.registerName("setMovableByWindowBackground:");
late final _sel_hidesOnDeactivate = objc.registerName("hidesOnDeactivate");
late final _sel_setHidesOnDeactivate_ =
    objc.registerName("setHidesOnDeactivate:");
late final _sel_canHide = objc.registerName("canHide");
late final _sel_setCanHide_ = objc.registerName("setCanHide:");
late final _sel_center = objc.registerName("center");
late final _sel_makeKeyAndOrderFront_ =
    objc.registerName("makeKeyAndOrderFront:");
late final _sel_orderFront_ = objc.registerName("orderFront:");
late final _sel_orderBack_ = objc.registerName("orderBack:");
late final _sel_orderOut_ = objc.registerName("orderOut:");
late final _sel_orderWindow_relativeTo_ =
    objc.registerName("orderWindow:relativeTo:");
final _objc_msgSend_218 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, ffi.Long, ffi.Long)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, int, int)>();
late final _sel_orderFrontRegardless =
    objc.registerName("orderFrontRegardless");
late final _sel_miniwindowImage = objc.registerName("miniwindowImage");
late final _sel_setMiniwindowImage_ = objc.registerName("setMiniwindowImage:");
late final _sel_miniwindowTitle = objc.registerName("miniwindowTitle");
late final _sel_setMiniwindowTitle_ = objc.registerName("setMiniwindowTitle:");

/// NSDockTile
class NSDockTile extends objc.ObjCObjectBase {
  NSDockTile._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super(pointer, retain: retain, release: release);

  /// Constructs a [NSDockTile] that points to the same underlying object as [other].
  NSDockTile.castFrom(objc.ObjCObjectBase other)
      : this._(other.pointer, retain: true, release: true);

  /// Constructs a [NSDockTile] that wraps the given raw object pointer.
  NSDockTile.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [NSDockTile].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_0(obj.pointer, _sel_isKindOfClass_, _class_NSDockTile);
  }
}

late final _class_NSDockTile = objc.getClass("NSDockTile");
late final _sel_dockTile = objc.registerName("dockTile");
final _objc_msgSend_219 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_isDocumentEdited = objc.registerName("isDocumentEdited");
late final _sel_setDocumentEdited_ = objc.registerName("setDocumentEdited:");
late final _sel_isVisible = objc.registerName("isVisible");
late final _sel_isKeyWindow = objc.registerName("isKeyWindow");
late final _sel_isMainWindow = objc.registerName("isMainWindow");
late final _sel_canBecomeKeyWindow = objc.registerName("canBecomeKeyWindow");
late final _sel_canBecomeMainWindow = objc.registerName("canBecomeMainWindow");
late final _sel_makeKeyWindow = objc.registerName("makeKeyWindow");
late final _sel_makeMainWindow = objc.registerName("makeMainWindow");
late final _sel_becomeKeyWindow = objc.registerName("becomeKeyWindow");
late final _sel_resignKeyWindow = objc.registerName("resignKeyWindow");
late final _sel_becomeMainWindow = objc.registerName("becomeMainWindow");
late final _sel_resignMainWindow = objc.registerName("resignMainWindow");
late final _sel_worksWhenModal = objc.registerName("worksWhenModal");
late final _sel_preventsApplicationTerminationWhenModal =
    objc.registerName("preventsApplicationTerminationWhenModal");
late final _sel_setPreventsApplicationTerminationWhenModal_ =
    objc.registerName("setPreventsApplicationTerminationWhenModal:");
late final _sel_convertRectToScreen_ =
    objc.registerName("convertRectToScreen:");
late final _sel_convertRectFromScreen_ =
    objc.registerName("convertRectFromScreen:");
late final _sel_convertPointToScreen_ =
    objc.registerName("convertPointToScreen:");
late final _sel_convertPointFromScreen_ =
    objc.registerName("convertPointFromScreen:");
late final _sel_backingScaleFactor = objc.registerName("backingScaleFactor");
late final _sel_performClose_ = objc.registerName("performClose:");
late final _sel_performMiniaturize_ = objc.registerName("performMiniaturize:");
late final _sel_performZoom_ = objc.registerName("performZoom:");
late final _sel_dataWithEPSInsideRect_ =
    objc.registerName("dataWithEPSInsideRect:");
final _objc_msgSend_220 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, CGRect)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, CGRect)>();
late final _sel_dataWithPDFInsideRect_ =
    objc.registerName("dataWithPDFInsideRect:");
late final _sel_print_ = objc.registerName("print:");
late final _sel_allowsToolTipsWhenApplicationIsInactive =
    objc.registerName("allowsToolTipsWhenApplicationIsInactive");
late final _sel_setAllowsToolTipsWhenApplicationIsInactive_ =
    objc.registerName("setAllowsToolTipsWhenApplicationIsInactive:");
late final _sel_backingType = objc.registerName("backingType");
final _objc_msgSend_221 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.UnsignedLong Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        int Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_setBackingType_ = objc.registerName("setBackingType:");
final _objc_msgSend_222 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, ffi.UnsignedLong)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, int)>();
late final _sel_level = objc.registerName("level");
late final _sel_setLevel_ = objc.registerName("setLevel:");
late final _sel_depthLimit = objc.registerName("depthLimit");
late final _sel_setDepthLimit_ = objc.registerName("setDepthLimit:");
final _objc_msgSend_223 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, ffi.Int32)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, int)>();
late final _sel_setDynamicDepthLimit_ =
    objc.registerName("setDynamicDepthLimit:");
late final _sel_hasDynamicDepthLimit =
    objc.registerName("hasDynamicDepthLimit");
late final _sel_screen = objc.registerName("screen");
final _objc_msgSend_224 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_deepestScreen = objc.registerName("deepestScreen");
late final _sel_hasShadow = objc.registerName("hasShadow");
late final _sel_setHasShadow_ = objc.registerName("setHasShadow:");
late final _sel_invalidateShadow = objc.registerName("invalidateShadow");
late final _sel_setOpaque_ = objc.registerName("setOpaque:");

/// !
/// @typedef NSWindowSharingType
///
/// @const NSWindowSharingNone          Window contents may not be read by another process.
/// @const NSWindowSharingReadOnly   Window contents may be read but not modified by another process.
/// @const NSWindowSharingReadWrite  Window contents may be read or modified by another process.
enum NSWindowSharingType {
  NSWindowSharingNone(0),
  NSWindowSharingReadOnly(1),
  NSWindowSharingReadWrite(2);

  final int value;
  const NSWindowSharingType(this.value);

  static NSWindowSharingType fromValue(int value) => switch (value) {
        0 => NSWindowSharingNone,
        1 => NSWindowSharingReadOnly,
        2 => NSWindowSharingReadWrite,
        _ =>
          throw ArgumentError("Unknown value for NSWindowSharingType: $value"),
      };
}

late final _sel_sharingType = objc.registerName("sharingType");
final _objc_msgSend_225 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.UnsignedLong Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        int Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_setSharingType_ = objc.registerName("setSharingType:");
final _objc_msgSend_226 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, ffi.UnsignedLong)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, int)>();
late final _sel_allowsConcurrentViewDrawing =
    objc.registerName("allowsConcurrentViewDrawing");
late final _sel_setAllowsConcurrentViewDrawing_ =
    objc.registerName("setAllowsConcurrentViewDrawing:");
late final _sel_displaysWhenScreenProfileChanges =
    objc.registerName("displaysWhenScreenProfileChanges");
late final _sel_setDisplaysWhenScreenProfileChanges_ =
    objc.registerName("setDisplaysWhenScreenProfileChanges:");
late final _sel_disableScreenUpdatesUntilFlush =
    objc.registerName("disableScreenUpdatesUntilFlush");
late final _sel_canBecomeVisibleWithoutLogin =
    objc.registerName("canBecomeVisibleWithoutLogin");
late final _sel_setCanBecomeVisibleWithoutLogin_ =
    objc.registerName("setCanBecomeVisibleWithoutLogin:");

/// !
/// @typedef NSWindowCollectionBehavior
///
/// @const NSWindowCollectionBehaviorPrimary Marks a window as primary. This collection behavior should commonly be used for document or viewer windows.
/// @const NSWindowCollectionBehaviorAuxiliary Marks a window as auxiliary. This collection behavior should commonly be used for About or Settings windows, as well as utility panes.
/// @const NSWindowCollectionBehaviorCanJoinAllApplications Marks a window as able to join all applications, allowing it to join other apps' sets and full screen spaces when eligible. This collection behavior should commonly be used for floating windows and system overlays.
///
/// @discussion You may specify at most one of @c NSWindowCollectionBehaviorPrimary, @c NSWindowCollectionBehaviorAuxiliary, or @c NSWindowCollectionBehaviorCanJoinAllApplications. If unspecified, the window gets the default treatment determined by its other collection behaviors.
///
/// @const NSWindowCollectionBehaviorDefault
/// @const NSWindowCollectionBehaviorCanJoinAllSpaces
/// @const NSWindowCollectionBehaviorMoveToActiveSpace
///
/// @discussion You may specify at most one of \c NSWindowCollectionBehaviorManaged, \c NSWindowCollectionBehaviorTransient, or \c NSWindowCollectionBehaviorStationary.  If neither is specified, the window gets the default behavior determined by its window level.
///
/// @const NSWindowCollectionBehaviorManaged Participates in spaces, exposé.  Default behavior if `windowLevel == NSNormalWindowLevel`.
/// @const NSWindowCollectionBehaviorTransient Floats in spaces, hidden by exposé.  Default behavior if `windowLevel != NSNormalWindowLevel`.
/// @const NSWindowCollectionBehaviorStationary Unaffected by exposé.  Stays visible and stationary, like desktop window.
///
/// @discussion You may specify at most one of \c NSWindowCollectionBehaviorParticipatesInCycle or \c NSWindowCollectionBehaviorIgnoresCycle.  If unspecified, the window gets the default behavior determined by its window level.
///
/// @const NSWindowCollectionBehaviorParticipatesInCycle Default behavior if `windowLevel != NSNormalWindowLevel`.
/// @const NSWindowCollectionBehaviorIgnoresCycle Default behavior if `windowLevel != NSNormalWindowLevel`.
///
/// @discussion You may specify at most one of \c NSWindowCollectionBehaviorFullScreenPrimary, \c NSWindowCollectionBehaviorFullScreenAuxiliary, or \c NSWindowCollectionBehaviorFullScreenNone.
///
/// @const NSWindowCollectionBehaviorFullScreenPrimary The frontmost window with this collection behavior will be the fullscreen window.
/// @const NSWindowCollectionBehaviorFullScreenAuxiliary Windows with this collection behavior can be shown with the fullscreen window.
/// @const NSWindowCollectionBehaviorFullScreenNone The window can not be made fullscreen when this bit is set.
///
/// @discussion You may specify at most one of \c NSWindowCollectionBehaviorFullScreenAllowsTiling or \c NSWindowCollectionBehaviorFullScreenDisallowsTiling, or an assertion will be raised.
///
/// The default behavior is to allow any window to participate in full screen tiling, as long as it meets certain requirements, such as being resizable and not a panel or sheet. Windows which are not full screen capable can still become a secondary tile in full screen. A window can explicitly allow itself to be placed into a full screen tile by including \c NSWindowCollectionBehaviorFullScreenAllowsTiling. Even if a window allows itself to be placed in a tile, it still may not be put in the tile if its \c minFullScreenContentSize is too large to fit. A window can explicitly disallow itself from being placed in a full screen tile by including \c NSWindowCollectionBehaviorFullScreenDisallowsTiling. This is useful for non-full screen capable windows to explicitly prevent themselves from being tiled. It can also be used by a full screen window to prevent any other windows from being placed in its full screen tile.
///
/// @const NSWindowCollectionBehaviorFullScreenAllowsTiling This window can be a full screen tile window. It does not have to have \c NSWindowCollectionBehaviorFullScreenPrimary set.
/// @const NSWindowCollectionBehaviorFullScreenDisallowsTiling This window can NOT be made a full screen tile window; it still may be allowed to be a regular \c NSWindowCollectionBehaviorFullScreenPrimary window.
enum NSWindowCollectionBehavior {
  NSWindowCollectionBehaviorDefault(0),
  NSWindowCollectionBehaviorCanJoinAllSpaces(1),
  NSWindowCollectionBehaviorMoveToActiveSpace(2),
  NSWindowCollectionBehaviorManaged(4),
  NSWindowCollectionBehaviorTransient(8),
  NSWindowCollectionBehaviorStationary(16),
  NSWindowCollectionBehaviorParticipatesInCycle(32),
  NSWindowCollectionBehaviorIgnoresCycle(64),
  NSWindowCollectionBehaviorFullScreenPrimary(128),
  NSWindowCollectionBehaviorFullScreenAuxiliary(256),
  NSWindowCollectionBehaviorFullScreenNone(512),
  NSWindowCollectionBehaviorFullScreenAllowsTiling(2048),
  NSWindowCollectionBehaviorFullScreenDisallowsTiling(4096),
  NSWindowCollectionBehaviorPrimary(65536),
  NSWindowCollectionBehaviorAuxiliary(131072),
  NSWindowCollectionBehaviorCanJoinAllApplications(262144);

  final int value;
  const NSWindowCollectionBehavior(this.value);

  static NSWindowCollectionBehavior fromValue(int value) => switch (value) {
        0 => NSWindowCollectionBehaviorDefault,
        1 => NSWindowCollectionBehaviorCanJoinAllSpaces,
        2 => NSWindowCollectionBehaviorMoveToActiveSpace,
        4 => NSWindowCollectionBehaviorManaged,
        8 => NSWindowCollectionBehaviorTransient,
        16 => NSWindowCollectionBehaviorStationary,
        32 => NSWindowCollectionBehaviorParticipatesInCycle,
        64 => NSWindowCollectionBehaviorIgnoresCycle,
        128 => NSWindowCollectionBehaviorFullScreenPrimary,
        256 => NSWindowCollectionBehaviorFullScreenAuxiliary,
        512 => NSWindowCollectionBehaviorFullScreenNone,
        2048 => NSWindowCollectionBehaviorFullScreenAllowsTiling,
        4096 => NSWindowCollectionBehaviorFullScreenDisallowsTiling,
        65536 => NSWindowCollectionBehaviorPrimary,
        131072 => NSWindowCollectionBehaviorAuxiliary,
        262144 => NSWindowCollectionBehaviorCanJoinAllApplications,
        _ => throw ArgumentError(
            "Unknown value for NSWindowCollectionBehavior: $value"),
      };
}

late final _sel_collectionBehavior = objc.registerName("collectionBehavior");
final _objc_msgSend_227 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.UnsignedLong Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        int Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_setCollectionBehavior_ =
    objc.registerName("setCollectionBehavior:");
final _objc_msgSend_228 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, ffi.UnsignedLong)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, int)>();

/// !
/// @typedef NSWindowAnimationBehavior
///
/// @const NSWindowAnimationBehaviorDefault  Let AppKit infer animation behavior for this window.
/// @const NSWindowAnimationBehaviorNone     Suppress inferred animations (don't animate).
/// @const NSWindowAnimationBehaviorDocumentWindow
/// @const NSWindowAnimationBehaviorUtilityWindow
/// @const NSWindowAnimationBehaviorAlertPanel
enum NSWindowAnimationBehavior {
  NSWindowAnimationBehaviorDefault(0),
  NSWindowAnimationBehaviorNone(2),
  NSWindowAnimationBehaviorDocumentWindow(3),
  NSWindowAnimationBehaviorUtilityWindow(4),
  NSWindowAnimationBehaviorAlertPanel(5);

  final int value;
  const NSWindowAnimationBehavior(this.value);

  static NSWindowAnimationBehavior fromValue(int value) => switch (value) {
        0 => NSWindowAnimationBehaviorDefault,
        2 => NSWindowAnimationBehaviorNone,
        3 => NSWindowAnimationBehaviorDocumentWindow,
        4 => NSWindowAnimationBehaviorUtilityWindow,
        5 => NSWindowAnimationBehaviorAlertPanel,
        _ => throw ArgumentError(
            "Unknown value for NSWindowAnimationBehavior: $value"),
      };
}

late final _sel_animationBehavior = objc.registerName("animationBehavior");
final _objc_msgSend_229 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.UnsignedLong Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        int Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_setAnimationBehavior_ =
    objc.registerName("setAnimationBehavior:");
final _objc_msgSend_230 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, ffi.UnsignedLong)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, int)>();
late final _sel_isOnActiveSpace = objc.registerName("isOnActiveSpace");
late final _sel_toggleFullScreen_ = objc.registerName("toggleFullScreen:");
late final _sel_stringWithSavedFrame =
    objc.registerName("stringWithSavedFrame");
late final _sel_setFrameFromString_ = objc.registerName("setFrameFromString:");
late final _sel_saveFrameUsingName_ = objc.registerName("saveFrameUsingName:");
late final _sel_setFrameUsingName_force_ =
    objc.registerName("setFrameUsingName:force:");
late final _sel_setFrameUsingName_ = objc.registerName("setFrameUsingName:");
late final _sel_setFrameAutosaveName_ =
    objc.registerName("setFrameAutosaveName:");
late final _sel_frameAutosaveName = objc.registerName("frameAutosaveName");
late final _sel_removeFrameUsingName_ =
    objc.registerName("removeFrameUsingName:");
late final _sel_contentMinSize = objc.registerName("contentMinSize");
late final _sel_setContentMinSize_ = objc.registerName("setContentMinSize:");
late final _sel_contentMaxSize = objc.registerName("contentMaxSize");
late final _sel_setContentMaxSize_ = objc.registerName("setContentMaxSize:");
late final _sel_minFullScreenContentSize =
    objc.registerName("minFullScreenContentSize");
late final _sel_setMinFullScreenContentSize_ =
    objc.registerName("setMinFullScreenContentSize:");
late final _sel_maxFullScreenContentSize =
    objc.registerName("maxFullScreenContentSize");
late final _sel_setMaxFullScreenContentSize_ =
    objc.registerName("setMaxFullScreenContentSize:");
late final _sel_deviceDescription = objc.registerName("deviceDescription");
final _objc_msgSend_231 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();

/// NSWindowController
class NSWindowController extends objc.ObjCObjectBase {
  NSWindowController._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super(pointer, retain: retain, release: release);

  /// Constructs a [NSWindowController] that points to the same underlying object as [other].
  NSWindowController.castFrom(objc.ObjCObjectBase other)
      : this._(other.pointer, retain: true, release: true);

  /// Constructs a [NSWindowController] that wraps the given raw object pointer.
  NSWindowController.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [NSWindowController].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_0(
        obj.pointer, _sel_isKindOfClass_, _class_NSWindowController);
  }
}

late final _class_NSWindowController = objc.getClass("NSWindowController");
late final _sel_windowController = objc.registerName("windowController");
final _objc_msgSend_232 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_setWindowController_ =
    objc.registerName("setWindowController:");
final _objc_msgSend_233 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<objc.ObjCObject>)>();
void _ObjCBlock_ffiVoid_ffiLong_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlock> block, int arg0) =>
    block.ref.target
        .cast<ffi.NativeFunction<ffi.Void Function(ffi.Long arg0)>>()
        .asFunction<void Function(int)>()(arg0);
void _ObjCBlock_ffiVoid_ffiLong_closureTrampoline(
        ffi.Pointer<objc.ObjCBlock> block, int arg0) =>
    (objc.getBlockClosure(block) as void Function(int))(arg0);

class ObjCBlock_ffiVoid_ffiLong extends objc.ObjCBlockBase {
  ObjCBlock_ffiVoid_ffiLong._(ffi.Pointer<objc.ObjCBlock> pointer,
      {bool retain = false, bool release = true})
      : super(pointer, retain: retain, release: release);

  /// Returns a block that wraps the given raw block pointer.
  static ObjCBlock_ffiVoid_ffiLong castFromPointer(
      ffi.Pointer<objc.ObjCBlock> pointer,
      {bool retain = false,
      bool release = false}) {
    return ObjCBlock_ffiVoid_ffiLong._(pointer,
        retain: retain, release: release);
  }

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ObjCBlock_ffiVoid_ffiLong.fromFunctionPointer(
      ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Long arg0)>> ptr)
      : this._(objc.newPointerBlock(
            _cFuncTrampoline ??= ffi.Pointer.fromFunction<
                    ffi.Void Function(ffi.Pointer<objc.ObjCBlock>,
                        ffi.Long)>(_ObjCBlock_ffiVoid_ffiLong_fnPtrTrampoline)
                .cast(),
            ptr.cast()));
  static ffi.Pointer<ffi.Void>? _cFuncTrampoline;

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ObjCBlock_ffiVoid_ffiLong.fromFunction(void Function(int) fn)
      : this._(objc.newClosureBlock(
            _dartFuncTrampoline ??= ffi.Pointer.fromFunction<
                    ffi.Void Function(ffi.Pointer<objc.ObjCBlock>,
                        ffi.Long)>(_ObjCBlock_ffiVoid_ffiLong_closureTrampoline)
                .cast(),
            (int arg0) => fn(arg0)));
  static ffi.Pointer<ffi.Void>? _dartFuncTrampoline;

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// Note that unlike the default behavior of NativeCallable.listener, listener
  /// blocks do not keep the isolate alive.
  ObjCBlock_ffiVoid_ffiLong.listener(void Function(int) fn)
      : this._((objc.newClosureBlock(
            (_dartFuncListenerTrampoline ??= ffi.NativeCallable<
                        ffi.Void Function(
                            ffi.Pointer<objc.ObjCBlock>, ffi.Long)>.listener(
                    _ObjCBlock_ffiVoid_ffiLong_closureTrampoline)
                  ..keepIsolateAlive = false)
                .nativeFunction
                .cast(),
            (int arg0) => fn(arg0))));
  static ffi
      .NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlock>, ffi.Long)>?
      _dartFuncListenerTrampoline;

  void call(int arg0) => pointer.ref.invoke
          .cast<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<objc.ObjCBlock> block, ffi.Long arg0)>>()
          .asFunction<void Function(ffi.Pointer<objc.ObjCBlock>, int)>()(
      pointer, arg0);
}

late final _sel_beginSheet_completionHandler_ =
    objc.registerName("beginSheet:completionHandler:");
final _objc_msgSend_234 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCBlock>)>>()
    .asFunction<
        void Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCBlock>)>();
late final _sel_beginCriticalSheet_completionHandler_ =
    objc.registerName("beginCriticalSheet:completionHandler:");
late final _sel_endSheet_ = objc.registerName("endSheet:");
final _objc_msgSend_235 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<objc.ObjCObject>)>();
late final _sel_endSheet_returnCode_ =
    objc.registerName("endSheet:returnCode:");
final _objc_msgSend_236 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Long)>>()
    .asFunction<
        void Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            int)>();
late final _sel_sheets = objc.registerName("sheets");
late final _sel_attachedSheet = objc.registerName("attachedSheet");
late final _sel_isSheet = objc.registerName("isSheet");
late final _sel_sheetParent = objc.registerName("sheetParent");

/// NSButton
class NSButton extends objc.ObjCObjectBase {
  NSButton._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super(pointer, retain: retain, release: release);

  /// Constructs a [NSButton] that points to the same underlying object as [other].
  NSButton.castFrom(objc.ObjCObjectBase other)
      : this._(other.pointer, retain: true, release: true);

  /// Constructs a [NSButton] that wraps the given raw object pointer.
  NSButton.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [NSButton].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_0(obj.pointer, _sel_isKindOfClass_, _class_NSButton);
  }
}

late final _class_NSButton = objc.getClass("NSButton");

/// !
/// @typedef NSWindowButton
///
/// Standard window buttons.
enum NSWindowButton {
  NSWindowCloseButton(0),
  NSWindowMiniaturizeButton(1),
  NSWindowZoomButton(2),
  NSWindowToolbarButton(3),
  NSWindowDocumentIconButton(4),
  NSWindowDocumentVersionsButton(6);

  final int value;
  const NSWindowButton(this.value);

  static NSWindowButton fromValue(int value) => switch (value) {
        0 => NSWindowCloseButton,
        1 => NSWindowMiniaturizeButton,
        2 => NSWindowZoomButton,
        3 => NSWindowToolbarButton,
        4 => NSWindowDocumentIconButton,
        6 => NSWindowDocumentVersionsButton,
        _ => throw ArgumentError("Unknown value for NSWindowButton: $value"),
      };
}

late final _sel_standardWindowButton_forStyleMask_ =
    objc.registerName("standardWindowButton:forStyleMask:");
final _objc_msgSend_237 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.UnsignedLong,
                ffi.UnsignedLong)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, int, int)>();
late final _sel_standardWindowButton_ =
    objc.registerName("standardWindowButton:");
final _objc_msgSend_238 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, ffi.UnsignedLong)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, int)>();
late final _sel_addChildWindow_ordered_ =
    objc.registerName("addChildWindow:ordered:");
final _objc_msgSend_239 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Long)>>()
    .asFunction<
        void Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            int)>();
late final _sel_removeChildWindow_ = objc.registerName("removeChildWindow:");
late final _sel_childWindows = objc.registerName("childWindows");
final _objc_msgSend_240 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_parentWindow = objc.registerName("parentWindow");
late final _sel_setParentWindow_ = objc.registerName("setParentWindow:");
final _objc_msgSend_241 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<objc.ObjCObject>)>();
late final _sel_appearanceSource = objc.registerName("appearanceSource");
final _objc_msgSend_242 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_setAppearanceSource_ =
    objc.registerName("setAppearanceSource:");
final _objc_msgSend_243 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<objc.ObjCObject>)>();

/// NSColorSpace
class NSColorSpace extends objc.ObjCObjectBase {
  NSColorSpace._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super(pointer, retain: retain, release: release);

  /// Constructs a [NSColorSpace] that points to the same underlying object as [other].
  NSColorSpace.castFrom(objc.ObjCObjectBase other)
      : this._(other.pointer, retain: true, release: true);

  /// Constructs a [NSColorSpace] that wraps the given raw object pointer.
  NSColorSpace.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [NSColorSpace].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_0(
        obj.pointer, _sel_isKindOfClass_, _class_NSColorSpace);
  }
}

late final _class_NSColorSpace = objc.getClass("NSColorSpace");
late final _sel_colorSpace = objc.registerName("colorSpace");
final _objc_msgSend_244 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_setColorSpace_ = objc.registerName("setColorSpace:");
final _objc_msgSend_245 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<objc.ObjCObject>)>();

enum NSDisplayGamut {
  NSDisplayGamutSRGB(1),
  NSDisplayGamutP3(2);

  final int value;
  const NSDisplayGamut(this.value);

  static NSDisplayGamut fromValue(int value) => switch (value) {
        1 => NSDisplayGamutSRGB,
        2 => NSDisplayGamutP3,
        _ => throw ArgumentError("Unknown value for NSDisplayGamut: $value"),
      };
}

late final _sel_canRepresentDisplayGamut_ =
    objc.registerName("canRepresentDisplayGamut:");
final _objc_msgSend_246 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Bool Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, ffi.UnsignedLong)>>()
    .asFunction<
        bool Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, int)>();

/// !
/// @typedef NSWindowNumberListOptions
///
/// Options used in `+windowNumbersWithOptions:`.  If no options are specified, the returned list contains window numbers for visible windows on the active space belonging to the calling application.
///
/// @const NSWindowNumberListAllApplications
/// @const NSWindowNumberListAllSpaces
enum NSWindowNumberListOptions {
  NSWindowNumberListAllApplications(1),
  NSWindowNumberListAllSpaces(16);

  final int value;
  const NSWindowNumberListOptions(this.value);

  static NSWindowNumberListOptions fromValue(int value) => switch (value) {
        1 => NSWindowNumberListAllApplications,
        16 => NSWindowNumberListAllSpaces,
        _ => throw ArgumentError(
            "Unknown value for NSWindowNumberListOptions: $value"),
      };
}

late final _sel_windowNumbersWithOptions_ =
    objc.registerName("windowNumbersWithOptions:");
final _objc_msgSend_247 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, ffi.UnsignedLong)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, int)>();
late final _sel_windowNumberAtPoint_belowWindowWithWindowNumber_ =
    objc.registerName("windowNumberAtPoint:belowWindowWithWindowNumber:");
final _objc_msgSend_248 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Long Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, CGPoint, ffi.Long)>>()
    .asFunction<
        int Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, CGPoint, int)>();

/// !
/// @typedef NSWindowOcclusionState
///
/// @const NSWindowOcclusionStateVisible If set, at least part of the window is visible. If not set, the entire window is occluded. Windows with non-rectangular shapes may be completely occluded on screen but still count as visible, if their bounding box falls into a visible region. Windows that are completely transparent may also still count as visible.
enum NSWindowOcclusionState {
  NSWindowOcclusionStateVisible(2);

  final int value;
  const NSWindowOcclusionState(this.value);

  static NSWindowOcclusionState fromValue(int value) => switch (value) {
        2 => NSWindowOcclusionStateVisible,
        _ => throw ArgumentError(
            "Unknown value for NSWindowOcclusionState: $value"),
      };
}

late final _sel_occlusionState = objc.registerName("occlusionState");
final _objc_msgSend_249 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.UnsignedLong Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        int Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();

enum NSTitlebarSeparatorStyle {
  NSTitlebarSeparatorStyleAutomatic(0),
  NSTitlebarSeparatorStyleNone(1),
  NSTitlebarSeparatorStyleLine(2),
  NSTitlebarSeparatorStyleShadow(3);

  final int value;
  const NSTitlebarSeparatorStyle(this.value);

  static NSTitlebarSeparatorStyle fromValue(int value) => switch (value) {
        0 => NSTitlebarSeparatorStyleAutomatic,
        1 => NSTitlebarSeparatorStyleNone,
        2 => NSTitlebarSeparatorStyleLine,
        3 => NSTitlebarSeparatorStyleShadow,
        _ => throw ArgumentError(
            "Unknown value for NSTitlebarSeparatorStyle: $value"),
      };
}

late final _sel_titlebarSeparatorStyle =
    objc.registerName("titlebarSeparatorStyle");
final _objc_msgSend_250 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.UnsignedLong Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        int Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_setTitlebarSeparatorStyle_ =
    objc.registerName("setTitlebarSeparatorStyle:");
final _objc_msgSend_251 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, ffi.UnsignedLong)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, int)>();

/// NSViewController
class NSViewController extends objc.ObjCObjectBase {
  NSViewController._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super(pointer, retain: retain, release: release);

  /// Constructs a [NSViewController] that points to the same underlying object as [other].
  NSViewController.castFrom(objc.ObjCObjectBase other)
      : this._(other.pointer, retain: true, release: true);

  /// Constructs a [NSViewController] that wraps the given raw object pointer.
  NSViewController.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [NSViewController].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_0(
        obj.pointer, _sel_isKindOfClass_, _class_NSViewController);
  }
}

late final _class_NSViewController = objc.getClass("NSViewController");
late final _sel_contentViewController =
    objc.registerName("contentViewController");
final _objc_msgSend_252 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_setContentViewController_ =
    objc.registerName("setContentViewController:");
final _objc_msgSend_253 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<objc.ObjCObject>)>();
late final _sel_windowWithContentViewController_ =
    objc.registerName("windowWithContentViewController:");
final _objc_msgSend_254 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            instancetype Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        instancetype Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<objc.ObjCObject>)>();
late final _sel_performWindowDragWithEvent_ =
    objc.registerName("performWindowDragWithEvent:");
late final _sel_initialFirstResponder =
    objc.registerName("initialFirstResponder");
late final _sel_setInitialFirstResponder_ =
    objc.registerName("setInitialFirstResponder:");
late final _sel_selectNextKeyView_ = objc.registerName("selectNextKeyView:");
late final _sel_selectPreviousKeyView_ =
    objc.registerName("selectPreviousKeyView:");
late final _sel_selectKeyViewFollowingView_ =
    objc.registerName("selectKeyViewFollowingView:");
late final _sel_selectKeyViewPrecedingView_ =
    objc.registerName("selectKeyViewPrecedingView:");

enum NSSelectionDirection {
  NSDirectSelection(0),
  NSSelectingNext(1),
  NSSelectingPrevious(2);

  final int value;
  const NSSelectionDirection(this.value);

  static NSSelectionDirection fromValue(int value) => switch (value) {
        0 => NSDirectSelection,
        1 => NSSelectingNext,
        2 => NSSelectingPrevious,
        _ =>
          throw ArgumentError("Unknown value for NSSelectionDirection: $value"),
      };
}

late final _sel_keyViewSelectionDirection =
    objc.registerName("keyViewSelectionDirection");
final _objc_msgSend_255 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.UnsignedLong Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        int Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();

/// NSButtonCell
class NSButtonCell extends objc.ObjCObjectBase {
  NSButtonCell._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super(pointer, retain: retain, release: release);

  /// Constructs a [NSButtonCell] that points to the same underlying object as [other].
  NSButtonCell.castFrom(objc.ObjCObjectBase other)
      : this._(other.pointer, retain: true, release: true);

  /// Constructs a [NSButtonCell] that wraps the given raw object pointer.
  NSButtonCell.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [NSButtonCell].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_0(
        obj.pointer, _sel_isKindOfClass_, _class_NSButtonCell);
  }
}

late final _class_NSButtonCell = objc.getClass("NSButtonCell");
late final _sel_defaultButtonCell = objc.registerName("defaultButtonCell");
final _objc_msgSend_256 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_setDefaultButtonCell_ =
    objc.registerName("setDefaultButtonCell:");
final _objc_msgSend_257 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<objc.ObjCObject>)>();
late final _sel_disableKeyEquivalentForDefaultButtonCell =
    objc.registerName("disableKeyEquivalentForDefaultButtonCell");
late final _sel_enableKeyEquivalentForDefaultButtonCell =
    objc.registerName("enableKeyEquivalentForDefaultButtonCell");
late final _sel_autorecalculatesKeyViewLoop =
    objc.registerName("autorecalculatesKeyViewLoop");
late final _sel_setAutorecalculatesKeyViewLoop_ =
    objc.registerName("setAutorecalculatesKeyViewLoop:");
late final _sel_recalculateKeyViewLoop =
    objc.registerName("recalculateKeyViewLoop");

/// NSToolbar
class NSToolbar extends objc.ObjCObjectBase {
  NSToolbar._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super(pointer, retain: retain, release: release);

  /// Constructs a [NSToolbar] that points to the same underlying object as [other].
  NSToolbar.castFrom(objc.ObjCObjectBase other)
      : this._(other.pointer, retain: true, release: true);

  /// Constructs a [NSToolbar] that wraps the given raw object pointer.
  NSToolbar.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [NSToolbar].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_0(obj.pointer, _sel_isKindOfClass_, _class_NSToolbar);
  }
}

late final _class_NSToolbar = objc.getClass("NSToolbar");
late final _sel_toolbar = objc.registerName("toolbar");
final _objc_msgSend_258 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_setToolbar_ = objc.registerName("setToolbar:");
final _objc_msgSend_259 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<objc.ObjCObject>)>();
late final _sel_toggleToolbarShown_ = objc.registerName("toggleToolbarShown:");
late final _sel_runToolbarCustomizationPalette_ =
    objc.registerName("runToolbarCustomizationPalette:");
late final _sel_showsToolbarButton = objc.registerName("showsToolbarButton");
late final _sel_setShowsToolbarButton_ =
    objc.registerName("setShowsToolbarButton:");
late final _sel_allowsAutomaticWindowTabbing =
    objc.registerName("allowsAutomaticWindowTabbing");
late final _sel_setAllowsAutomaticWindowTabbing_ =
    objc.registerName("setAllowsAutomaticWindowTabbing:");

enum NSWindowUserTabbingPreference {
  NSWindowUserTabbingPreferenceManual(0),
  NSWindowUserTabbingPreferenceAlways(1),
  NSWindowUserTabbingPreferenceInFullScreen(2);

  final int value;
  const NSWindowUserTabbingPreference(this.value);

  static NSWindowUserTabbingPreference fromValue(int value) => switch (value) {
        0 => NSWindowUserTabbingPreferenceManual,
        1 => NSWindowUserTabbingPreferenceAlways,
        2 => NSWindowUserTabbingPreferenceInFullScreen,
        _ => throw ArgumentError(
            "Unknown value for NSWindowUserTabbingPreference: $value"),
      };
}

late final _sel_userTabbingPreference =
    objc.registerName("userTabbingPreference");
final _objc_msgSend_260 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.UnsignedLong Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        int Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();

/// !
/// @typedef NSWindowTabbingMode
///
/// @const NSWindowTabbingModeAutomatic The system automatically prefers to tab this window when appropriate.
/// @const NSWindowTabbingModePreferred The window explicitly should prefer to tab when shown.
/// @const NSWindowTabbingModeDisallowed The window explicitly should not prefer to tab when shown.
enum NSWindowTabbingMode {
  NSWindowTabbingModeAutomatic(0),
  NSWindowTabbingModePreferred(1),
  NSWindowTabbingModeDisallowed(2);

  final int value;
  const NSWindowTabbingMode(this.value);

  static NSWindowTabbingMode fromValue(int value) => switch (value) {
        0 => NSWindowTabbingModeAutomatic,
        1 => NSWindowTabbingModePreferred,
        2 => NSWindowTabbingModeDisallowed,
        _ =>
          throw ArgumentError("Unknown value for NSWindowTabbingMode: $value"),
      };
}

late final _sel_tabbingMode = objc.registerName("tabbingMode");
final _objc_msgSend_261 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.UnsignedLong Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        int Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_setTabbingMode_ = objc.registerName("setTabbingMode:");
final _objc_msgSend_262 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, ffi.UnsignedLong)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, int)>();
late final _sel_tabbingIdentifier = objc.registerName("tabbingIdentifier");
late final _sel_setTabbingIdentifier_ =
    objc.registerName("setTabbingIdentifier:");
late final _sel_selectNextTab_ = objc.registerName("selectNextTab:");
late final _sel_selectPreviousTab_ = objc.registerName("selectPreviousTab:");
late final _sel_moveTabToNewWindow_ = objc.registerName("moveTabToNewWindow:");
late final _sel_mergeAllWindows_ = objc.registerName("mergeAllWindows:");
late final _sel_toggleTabBar_ = objc.registerName("toggleTabBar:");
late final _sel_toggleTabOverview_ = objc.registerName("toggleTabOverview:");
late final _sel_tabbedWindows = objc.registerName("tabbedWindows");
late final _sel_addTabbedWindow_ordered_ =
    objc.registerName("addTabbedWindow:ordered:");

/// NSWindowTab
class NSWindowTab extends objc.ObjCObjectBase {
  NSWindowTab._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super(pointer, retain: retain, release: release);

  /// Constructs a [NSWindowTab] that points to the same underlying object as [other].
  NSWindowTab.castFrom(objc.ObjCObjectBase other)
      : this._(other.pointer, retain: true, release: true);

  /// Constructs a [NSWindowTab] that wraps the given raw object pointer.
  NSWindowTab.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [NSWindowTab].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_0(
        obj.pointer, _sel_isKindOfClass_, _class_NSWindowTab);
  }
}

late final _class_NSWindowTab = objc.getClass("NSWindowTab");
late final _sel_tab = objc.registerName("tab");
final _objc_msgSend_263 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();

/// NSWindowTabGroup
class NSWindowTabGroup extends objc.ObjCObjectBase {
  NSWindowTabGroup._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super(pointer, retain: retain, release: release);

  /// Constructs a [NSWindowTabGroup] that points to the same underlying object as [other].
  NSWindowTabGroup.castFrom(objc.ObjCObjectBase other)
      : this._(other.pointer, retain: true, release: true);

  /// Constructs a [NSWindowTabGroup] that wraps the given raw object pointer.
  NSWindowTabGroup.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [NSWindowTabGroup].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_0(
        obj.pointer, _sel_isKindOfClass_, _class_NSWindowTabGroup);
  }
}

late final _class_NSWindowTabGroup = objc.getClass("NSWindowTabGroup");
late final _sel_tabGroup = objc.registerName("tabGroup");
final _objc_msgSend_264 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
void _ObjCBlock_ffiVoid_NSError_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlock> block, ffi.Pointer<objc.ObjCObject> arg0) =>
    block.ref.target
        .cast<
            ffi.NativeFunction<
                ffi.Void Function(ffi.Pointer<objc.ObjCObject> arg0)>>()
        .asFunction<void Function(ffi.Pointer<objc.ObjCObject>)>()(arg0);
void _ObjCBlock_ffiVoid_NSError_closureTrampoline(
        ffi.Pointer<objc.ObjCBlock> block, ffi.Pointer<objc.ObjCObject> arg0) =>
    (objc.getBlockClosure(block) as void Function(
        ffi.Pointer<objc.ObjCObject>))(arg0);

class ObjCBlock_ffiVoid_NSError extends objc.ObjCBlockBase {
  ObjCBlock_ffiVoid_NSError._(ffi.Pointer<objc.ObjCBlock> pointer,
      {bool retain = false, bool release = true})
      : super(pointer, retain: retain, release: release);

  /// Returns a block that wraps the given raw block pointer.
  static ObjCBlock_ffiVoid_NSError castFromPointer(
      ffi.Pointer<objc.ObjCBlock> pointer,
      {bool retain = false,
      bool release = false}) {
    return ObjCBlock_ffiVoid_NSError._(pointer,
        retain: retain, release: release);
  }

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ObjCBlock_ffiVoid_NSError.fromFunctionPointer(
      ffi.Pointer<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<objc.ObjCObject> arg0)>>
          ptr)
      : this._(objc.newPointerBlock(
            _cFuncTrampoline ??= ffi.Pointer.fromFunction<
                        ffi.Void Function(ffi.Pointer<objc.ObjCBlock>,
                            ffi.Pointer<objc.ObjCObject>)>(
                    _ObjCBlock_ffiVoid_NSError_fnPtrTrampoline)
                .cast(),
            ptr.cast()));
  static ffi.Pointer<ffi.Void>? _cFuncTrampoline;

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ObjCBlock_ffiVoid_NSError.fromFunction(void Function(objc.NSError?) fn)
      : this._(objc.newClosureBlock(
            _dartFuncTrampoline ??= ffi.Pointer.fromFunction<
                        ffi.Void Function(ffi.Pointer<objc.ObjCBlock>,
                            ffi.Pointer<objc.ObjCObject>)>(
                    _ObjCBlock_ffiVoid_NSError_closureTrampoline)
                .cast(),
            (ffi.Pointer<objc.ObjCObject> arg0) => fn(arg0.address == 0
                ? null
                : objc.NSError.castFromPointer(arg0,
                    retain: true, release: true))));
  static ffi.Pointer<ffi.Void>? _dartFuncTrampoline;

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// Note that unlike the default behavior of NativeCallable.listener, listener
  /// blocks do not keep the isolate alive.
  ObjCBlock_ffiVoid_NSError.listener(void Function(objc.NSError?) fn)
      : this._(wrapListenerBlock_ObjCBlock_ffiVoid_NSError(objc.newClosureBlock(
            (_dartFuncListenerTrampoline ??= ffi.NativeCallable<
                        ffi.Void Function(ffi.Pointer<objc.ObjCBlock>,
                            ffi.Pointer<objc.ObjCObject>)>.listener(
                    _ObjCBlock_ffiVoid_NSError_closureTrampoline)
                  ..keepIsolateAlive = false)
                .nativeFunction
                .cast(),
            (ffi.Pointer<objc.ObjCObject> arg0) => fn(arg0.address == 0
                ? null
                : objc.NSError.castFromPointer(arg0,
                    retain: false, release: true)))));
  static ffi.NativeCallable<
          ffi.Void Function(
              ffi.Pointer<objc.ObjCBlock>, ffi.Pointer<objc.ObjCObject>)>?
      _dartFuncListenerTrampoline;

  void call(objc.NSError? arg0) => pointer.ref.invoke
          .cast<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<objc.ObjCBlock> block,
                      ffi.Pointer<objc.ObjCObject> arg0)>>()
          .asFunction<
              void Function(
                  ffi.Pointer<objc.ObjCBlock>, ffi.Pointer<objc.ObjCObject>)>()(
      pointer, arg0?.pointer ?? ffi.nullptr);
}

late final _sel_transferWindowSharingToWindow_completionHandler_ =
    objc.registerName("transferWindowSharingToWindow:completionHandler:");
final _objc_msgSend_265 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCBlock>)>>()
    .asFunction<
        void Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCBlock>)>();
late final _sel_hasActiveWindowSharingSession =
    objc.registerName("hasActiveWindowSharingSession");
late final _sel_windowTitlebarLayoutDirection =
    objc.registerName("windowTitlebarLayoutDirection");
void _ObjCBlock_ffiVoid_NSEvent_bool_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlock> block,
        ffi.Pointer<objc.ObjCObject> arg0,
        ffi.Pointer<ffi.Bool> arg1) =>
    block.ref.target
        .cast<
            ffi.NativeFunction<
                ffi.Void Function(ffi.Pointer<objc.ObjCObject> arg0,
                    ffi.Pointer<ffi.Bool> arg1)>>()
        .asFunction<
            void Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<ffi.Bool>)>()(arg0, arg1);
void _ObjCBlock_ffiVoid_NSEvent_bool_closureTrampoline(
        ffi.Pointer<objc.ObjCBlock> block,
        ffi.Pointer<objc.ObjCObject> arg0,
        ffi.Pointer<ffi.Bool> arg1) =>
    (objc.getBlockClosure(block) as void Function(
        ffi.Pointer<objc.ObjCObject>, ffi.Pointer<ffi.Bool>))(arg0, arg1);

class ObjCBlock_ffiVoid_NSEvent_bool extends objc.ObjCBlockBase {
  ObjCBlock_ffiVoid_NSEvent_bool._(ffi.Pointer<objc.ObjCBlock> pointer,
      {bool retain = false, bool release = true})
      : super(pointer, retain: retain, release: release);

  /// Returns a block that wraps the given raw block pointer.
  static ObjCBlock_ffiVoid_NSEvent_bool castFromPointer(
      ffi.Pointer<objc.ObjCBlock> pointer,
      {bool retain = false,
      bool release = false}) {
    return ObjCBlock_ffiVoid_NSEvent_bool._(pointer,
        retain: retain, release: release);
  }

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ObjCBlock_ffiVoid_NSEvent_bool.fromFunctionPointer(
      ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObject> arg0, ffi.Pointer<ffi.Bool> arg1)>>
          ptr)
      : this._(objc.newPointerBlock(
            _cFuncTrampoline ??= ffi.Pointer.fromFunction<
                        ffi.Void Function(
                            ffi.Pointer<objc.ObjCBlock>,
                            ffi.Pointer<objc.ObjCObject>,
                            ffi.Pointer<ffi.Bool>)>(
                    _ObjCBlock_ffiVoid_NSEvent_bool_fnPtrTrampoline)
                .cast(),
            ptr.cast()));
  static ffi.Pointer<ffi.Void>? _cFuncTrampoline;

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ObjCBlock_ffiVoid_NSEvent_bool.fromFunction(
      void Function(NSEvent?, ffi.Pointer<ffi.Bool>) fn)
      : this._(objc.newClosureBlock(
            _dartFuncTrampoline ??= ffi.Pointer.fromFunction<
                        ffi.Void Function(
                            ffi.Pointer<objc.ObjCBlock>,
                            ffi.Pointer<objc.ObjCObject>,
                            ffi.Pointer<ffi.Bool>)>(
                    _ObjCBlock_ffiVoid_NSEvent_bool_closureTrampoline)
                .cast(),
            (ffi.Pointer<objc.ObjCObject> arg0, ffi.Pointer<ffi.Bool> arg1) => fn(
                arg0.address == 0
                    ? null
                    : NSEvent.castFromPointer(arg0, retain: true, release: true),
                arg1)));
  static ffi.Pointer<ffi.Void>? _dartFuncTrampoline;

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// Note that unlike the default behavior of NativeCallable.listener, listener
  /// blocks do not keep the isolate alive.
  ObjCBlock_ffiVoid_NSEvent_bool.listener(
      void Function(NSEvent?, ffi.Pointer<ffi.Bool>) fn)
      : this._(wrapListenerBlock_ObjCBlock_ffiVoid_NSEvent_bool(objc.newClosureBlock(
            (_dartFuncListenerTrampoline ??= ffi.NativeCallable<
                        ffi.Void Function(
                            ffi.Pointer<objc.ObjCBlock>,
                            ffi.Pointer<objc.ObjCObject>,
                            ffi.Pointer<ffi.Bool>)>.listener(
                    _ObjCBlock_ffiVoid_NSEvent_bool_closureTrampoline)
                  ..keepIsolateAlive = false)
                .nativeFunction
                .cast(),
            (ffi.Pointer<objc.ObjCObject> arg0, ffi.Pointer<ffi.Bool> arg1) => fn(
                arg0.address == 0 ? null : NSEvent.castFromPointer(arg0, retain: false, release: true), arg1))));
  static ffi.NativeCallable<
      ffi.Void Function(
          ffi.Pointer<objc.ObjCBlock>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<ffi.Bool>)>? _dartFuncListenerTrampoline;

  void call(NSEvent? arg0, ffi.Pointer<ffi.Bool> arg1) => pointer.ref.invoke
          .cast<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<objc.ObjCBlock> block,
                      ffi.Pointer<objc.ObjCObject> arg0,
                      ffi.Pointer<ffi.Bool> arg1)>>()
          .asFunction<
              void Function(ffi.Pointer<objc.ObjCBlock>,
                  ffi.Pointer<objc.ObjCObject>, ffi.Pointer<ffi.Bool>)>()(
      pointer, arg0?.pointer ?? ffi.nullptr, arg1);
}

late final _sel_trackEventsMatchingMask_timeout_mode_handler_ =
    objc.registerName("trackEventsMatchingMask:timeout:mode:handler:");
final _objc_msgSend_266 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.LongLong,
                ffi.Double,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCBlock>)>>()
    .asFunction<
        void Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            int,
            double,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCBlock>)>();
late final _sel_nextEventMatchingMask_ =
    objc.registerName("nextEventMatchingMask:");
final _objc_msgSend_267 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, ffi.LongLong)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, int)>();
late final _sel_nextEventMatchingMask_untilDate_inMode_dequeue_ =
    objc.registerName("nextEventMatchingMask:untilDate:inMode:dequeue:");
final _objc_msgSend_268 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.LongLong,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Bool)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            int,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            bool)>();
late final _sel_discardEventsMatchingMask_beforeEvent_ =
    objc.registerName("discardEventsMatchingMask:beforeEvent:");
final _objc_msgSend_269 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.LongLong,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        void Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            int,
            ffi.Pointer<objc.ObjCObject>)>();
late final _sel_postEvent_atStart_ = objc.registerName("postEvent:atStart:");
final _objc_msgSend_270 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Bool)>>()
    .asFunction<
        void Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            bool)>();
late final _sel_sendEvent_ = objc.registerName("sendEvent:");
late final _sel_currentEvent = objc.registerName("currentEvent");
final _objc_msgSend_271 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_acceptsMouseMovedEvents =
    objc.registerName("acceptsMouseMovedEvents");
late final _sel_setAcceptsMouseMovedEvents_ =
    objc.registerName("setAcceptsMouseMovedEvents:");
late final _sel_ignoresMouseEvents = objc.registerName("ignoresMouseEvents");
late final _sel_setIgnoresMouseEvents_ =
    objc.registerName("setIgnoresMouseEvents:");
late final _sel_mouseLocationOutsideOfEventStream =
    objc.registerName("mouseLocationOutsideOfEventStream");
late final _sel_disableCursorRects = objc.registerName("disableCursorRects");
late final _sel_enableCursorRects = objc.registerName("enableCursorRects");
late final _sel_discardCursorRects = objc.registerName("discardCursorRects");
late final _sel_areCursorRectsEnabled =
    objc.registerName("areCursorRectsEnabled");
late final _sel_invalidateCursorRectsForView_ =
    objc.registerName("invalidateCursorRectsForView:");
late final _sel_resetCursorRects = objc.registerName("resetCursorRects");

/// NSPasteboard
class NSPasteboard extends objc.NSObject {
  NSPasteboard._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release);

  /// Constructs a [NSPasteboard] that points to the same underlying object as [other].
  NSPasteboard.castFrom(objc.ObjCObjectBase other)
      : this._(other.pointer, retain: true, release: true);

  /// Constructs a [NSPasteboard] that wraps the given raw object pointer.
  NSPasteboard.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [NSPasteboard].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_0(
        obj.pointer, _sel_isKindOfClass_, _class_NSPasteboard);
  }

  /// generalPasteboard
  static NSPasteboard getGeneralPasteboard() {
    final _ret = _objc_msgSend_272(_class_NSPasteboard, _sel_generalPasteboard);
    return NSPasteboard.castFromPointer(_ret, retain: true, release: true);
  }

  /// pasteboardWithName:
  static NSPasteboard pasteboardWithName_(objc.NSString name) {
    final _ret = _objc_msgSend_273(
        _class_NSPasteboard, _sel_pasteboardWithName_, name.pointer);
    return NSPasteboard.castFromPointer(_ret, retain: true, release: true);
  }

  /// pasteboardWithUniqueName
  static NSPasteboard pasteboardWithUniqueName() {
    final _ret =
        _objc_msgSend_272(_class_NSPasteboard, _sel_pasteboardWithUniqueName);
    return NSPasteboard.castFromPointer(_ret, retain: true, release: true);
  }

  /// name
  objc.NSString get name {
    final _ret = _objc_msgSend_3(this.pointer, _sel_name);
    return objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// changeCount
  int get changeCount {
    return _objc_msgSend_79(this.pointer, _sel_changeCount);
  }

  /// releaseGlobally
  void releaseGlobally() {
    _objc_msgSend_11(this.pointer, _sel_releaseGlobally);
  }

  /// prepareForNewContentsWithOptions:
  int prepareForNewContentsWithOptions_(NSPasteboardContentsOptions options) {
    return _objc_msgSend_274(
        this.pointer, _sel_prepareForNewContentsWithOptions_, options.value);
  }

  /// clearContents
  int clearContents() {
    return _objc_msgSend_79(this.pointer, _sel_clearContents);
  }

  /// writeObjects:
  bool writeObjects_(objc.NSArray objects) {
    return _objc_msgSend_275(this.pointer, _sel_writeObjects_, objects.pointer);
  }

  /// readObjectsForClasses:options:
  objc.NSArray? readObjectsForClasses_options_(
      objc.NSArray classArray, objc.NSDictionary? options) {
    final _ret = _objc_msgSend_276(
        this.pointer,
        _sel_readObjectsForClasses_options_,
        classArray.pointer,
        options?.pointer ?? ffi.nullptr);
    return _ret.address == 0
        ? null
        : objc.NSArray.castFromPointer(_ret, retain: true, release: true);
  }

  /// pasteboardItems
  objc.NSArray? get pasteboardItems {
    final _ret = _objc_msgSend_240(this.pointer, _sel_pasteboardItems);
    return _ret.address == 0
        ? null
        : objc.NSArray.castFromPointer(_ret, retain: true, release: true);
  }

  /// indexOfPasteboardItem:
  int indexOfPasteboardItem_(NSPasteboardItem pasteboardItem) {
    return _objc_msgSend_277(
        this.pointer, _sel_indexOfPasteboardItem_, pasteboardItem.pointer);
  }

  /// canReadItemWithDataConformingToTypes:
  bool canReadItemWithDataConformingToTypes_(objc.NSArray types) {
    return _objc_msgSend_275(this.pointer,
        _sel_canReadItemWithDataConformingToTypes_, types.pointer);
  }

  /// canReadObjectForClasses:options:
  bool canReadObjectForClasses_options_(
      objc.NSArray classArray, objc.NSDictionary? options) {
    return _objc_msgSend_278(
        this.pointer,
        _sel_canReadObjectForClasses_options_,
        classArray.pointer,
        options?.pointer ?? ffi.nullptr);
  }

  /// declareTypes:owner:
  int declareTypes_owner_(
      objc.NSArray newTypes, objc.ObjCObjectBase? newOwner) {
    return _objc_msgSend_279(this.pointer, _sel_declareTypes_owner_,
        newTypes.pointer, newOwner?.pointer ?? ffi.nullptr);
  }

  /// addTypes:owner:
  int addTypes_owner_(objc.NSArray newTypes, objc.ObjCObjectBase? newOwner) {
    return _objc_msgSend_279(this.pointer, _sel_addTypes_owner_,
        newTypes.pointer, newOwner?.pointer ?? ffi.nullptr);
  }

  /// types
  objc.NSArray? get types {
    final _ret = _objc_msgSend_240(this.pointer, _sel_types);
    return _ret.address == 0
        ? null
        : objc.NSArray.castFromPointer(_ret, retain: true, release: true);
  }

  /// availableTypeFromArray:
  objc.NSString? availableTypeFromArray_(objc.NSArray types) {
    final _ret = _objc_msgSend_280(
        this.pointer, _sel_availableTypeFromArray_, types.pointer);
    return _ret.address == 0
        ? null
        : objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// setData:forType:
  bool setData_forType_(objc.NSData? data, objc.NSString dataType) {
    return _objc_msgSend_281(this.pointer, _sel_setData_forType_,
        data?.pointer ?? ffi.nullptr, dataType.pointer);
  }

  /// setPropertyList:forType:
  bool setPropertyList_forType_(
      objc.ObjCObjectBase plist, objc.NSString dataType) {
    return _objc_msgSend_282(this.pointer, _sel_setPropertyList_forType_,
        plist.pointer, dataType.pointer);
  }

  /// setString:forType:
  bool setString_forType_(objc.NSString string, objc.NSString dataType) {
    return _objc_msgSend_283(this.pointer, _sel_setString_forType_,
        string.pointer, dataType.pointer);
  }

  /// dataForType:
  objc.NSData? dataForType_(objc.NSString dataType) {
    final _ret =
        _objc_msgSend_284(this.pointer, _sel_dataForType_, dataType.pointer);
    return _ret.address == 0
        ? null
        : objc.NSData.castFromPointer(_ret, retain: true, release: true);
  }

  /// propertyListForType:
  objc.ObjCObjectBase? propertyListForType_(objc.NSString dataType) {
    final _ret = _objc_msgSend_285(
        this.pointer, _sel_propertyListForType_, dataType.pointer);
    return _ret.address == 0
        ? null
        : objc.ObjCObjectBase(_ret, retain: true, release: true);
  }

  /// stringForType:
  objc.NSString? stringForType_(objc.NSString dataType) {
    final _ret =
        _objc_msgSend_286(this.pointer, _sel_stringForType_, dataType.pointer);
    return _ret.address == 0
        ? null
        : objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// init
  NSPasteboard init() {
    final _ret = _objc_msgSend_2(this.pointer, _sel_init);
    return NSPasteboard.castFromPointer(_ret, retain: true, release: true);
  }

  /// new
  static NSPasteboard new1() {
    final _ret = _objc_msgSend_2(_class_NSPasteboard, _sel_new);
    return NSPasteboard.castFromPointer(_ret, retain: false, release: true);
  }

  /// allocWithZone:
  static NSPasteboard allocWithZone_(ffi.Pointer<_NSZone> zone) {
    final _ret =
        _objc_msgSend_20(_class_NSPasteboard, _sel_allocWithZone_, zone);
    return NSPasteboard.castFromPointer(_ret, retain: false, release: true);
  }

  /// alloc
  static NSPasteboard alloc() {
    final _ret = _objc_msgSend_2(_class_NSPasteboard, _sel_alloc);
    return NSPasteboard.castFromPointer(_ret, retain: false, release: true);
  }
}

late final _class_NSPasteboard = objc.getClass("NSPasteboard");
late final _sel_generalPasteboard = objc.registerName("generalPasteboard");
final _objc_msgSend_272 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_pasteboardWithName_ = objc.registerName("pasteboardWithName:");
final _objc_msgSend_273 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<objc.ObjCObject>)>();
late final _sel_pasteboardWithUniqueName =
    objc.registerName("pasteboardWithUniqueName");
late final _sel_name = objc.registerName("name");
late final _sel_changeCount = objc.registerName("changeCount");
late final _sel_releaseGlobally = objc.registerName("releaseGlobally");

enum NSPasteboardContentsOptions {
  NSPasteboardContentsCurrentHostOnly(1);

  final int value;
  const NSPasteboardContentsOptions(this.value);

  static NSPasteboardContentsOptions fromValue(int value) => switch (value) {
        1 => NSPasteboardContentsCurrentHostOnly,
        _ => throw ArgumentError(
            "Unknown value for NSPasteboardContentsOptions: $value"),
      };
}

late final _sel_prepareForNewContentsWithOptions_ =
    objc.registerName("prepareForNewContentsWithOptions:");
final _objc_msgSend_274 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Long Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, ffi.UnsignedLong)>>()
    .asFunction<
        int Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, int)>();
late final _sel_clearContents = objc.registerName("clearContents");
late final _sel_writeObjects_ = objc.registerName("writeObjects:");
final _objc_msgSend_275 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Bool Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        bool Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<objc.ObjCObject>)>();
late final _sel_readObjectsForClasses_options_ =
    objc.registerName("readObjectsForClasses:options:");
final _objc_msgSend_276 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>();
late final _sel_pasteboardItems = objc.registerName("pasteboardItems");

/// NSPasteboardItem
class NSPasteboardItem extends objc.ObjCObjectBase {
  NSPasteboardItem._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super(pointer, retain: retain, release: release);

  /// Constructs a [NSPasteboardItem] that points to the same underlying object as [other].
  NSPasteboardItem.castFrom(objc.ObjCObjectBase other)
      : this._(other.pointer, retain: true, release: true);

  /// Constructs a [NSPasteboardItem] that wraps the given raw object pointer.
  NSPasteboardItem.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [NSPasteboardItem].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_0(
        obj.pointer, _sel_isKindOfClass_, _class_NSPasteboardItem);
  }
}

late final _class_NSPasteboardItem = objc.getClass("NSPasteboardItem");
late final _sel_indexOfPasteboardItem_ =
    objc.registerName("indexOfPasteboardItem:");
final _objc_msgSend_277 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.UnsignedLong Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        int Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<objc.ObjCObject>)>();
late final _sel_canReadItemWithDataConformingToTypes_ =
    objc.registerName("canReadItemWithDataConformingToTypes:");
late final _sel_canReadObjectForClasses_options_ =
    objc.registerName("canReadObjectForClasses:options:");
final _objc_msgSend_278 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Bool Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        bool Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>();
late final _sel_declareTypes_owner_ = objc.registerName("declareTypes:owner:");
final _objc_msgSend_279 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Long Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        int Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>();
late final _sel_addTypes_owner_ = objc.registerName("addTypes:owner:");
late final _sel_types = objc.registerName("types");
late final _sel_availableTypeFromArray_ =
    objc.registerName("availableTypeFromArray:");
final _objc_msgSend_280 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<objc.ObjCObject>)>();
late final _sel_setData_forType_ = objc.registerName("setData:forType:");
final _objc_msgSend_281 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Bool Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        bool Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>();
late final _sel_setPropertyList_forType_ =
    objc.registerName("setPropertyList:forType:");
final _objc_msgSend_282 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Bool Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        bool Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>();
late final _sel_setString_forType_ = objc.registerName("setString:forType:");
final _objc_msgSend_283 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Bool Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        bool Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>();
late final _sel_dataForType_ = objc.registerName("dataForType:");
final _objc_msgSend_284 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<objc.ObjCObject>)>();
late final _sel_propertyListForType_ =
    objc.registerName("propertyListForType:");
final _objc_msgSend_285 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<objc.ObjCObject>)>();
late final _sel_stringForType_ = objc.registerName("stringForType:");
final _objc_msgSend_286 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<objc.ObjCObject>)>();
late final _sel_dragImage_at_offset_event_pasteboard_source_slideBack_ =
    objc.registerName("dragImage:at:offset:event:pasteboard:source:slideBack:");
final _objc_msgSend_287 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                CGPoint,
                CGSize,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Bool)>>()
    .asFunction<
        void Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            CGPoint,
            CGSize,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            bool)>();
late final _sel_registerForDraggedTypes_ =
    objc.registerName("registerForDraggedTypes:");
final _objc_msgSend_288 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<objc.ObjCObject>)>();
late final _sel_unregisterDraggedTypes =
    objc.registerName("unregisterDraggedTypes");
late final _sel_initWithWindowRef_ = objc.registerName("initWithWindowRef:");
final _objc_msgSend_289 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<ffi.Void>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<ffi.Void>)>();
late final _sel_windowRef = objc.registerName("windowRef");

/// CADisplayLink
class CADisplayLink extends objc.ObjCObjectBase {
  CADisplayLink._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super(pointer, retain: retain, release: release);

  /// Constructs a [CADisplayLink] that points to the same underlying object as [other].
  CADisplayLink.castFrom(objc.ObjCObjectBase other)
      : this._(other.pointer, retain: true, release: true);

  /// Constructs a [CADisplayLink] that wraps the given raw object pointer.
  CADisplayLink.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [CADisplayLink].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_0(
        obj.pointer, _sel_isKindOfClass_, _class_CADisplayLink);
  }
}

late final _class_CADisplayLink = objc.getClass("CADisplayLink");
late final _sel_displayLinkWithTarget_selector_ =
    objc.registerName("displayLinkWithTarget:selector:");
final _objc_msgSend_290 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_cacheImageInRect_ = objc.registerName("cacheImageInRect:");
late final _sel_restoreCachedImage = objc.registerName("restoreCachedImage");
late final _sel_discardCachedImage = objc.registerName("discardCachedImage");
late final _sel_menuChanged_ = objc.registerName("menuChanged:");
final _objc_msgSend_291 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<objc.ObjCObject>)>();
late final _sel_gState = objc.registerName("gState");
late final _sel_convertBaseToScreen_ =
    objc.registerName("convertBaseToScreen:");
late final _sel_convertScreenToBase_ =
    objc.registerName("convertScreenToBase:");
late final _sel_userSpaceScaleFactor =
    objc.registerName("userSpaceScaleFactor");
late final _sel_useOptimizedDrawing_ =
    objc.registerName("useOptimizedDrawing:");
late final _sel_canStoreColor = objc.registerName("canStoreColor");
late final _sel_disableFlushWindow = objc.registerName("disableFlushWindow");
late final _sel_enableFlushWindow = objc.registerName("enableFlushWindow");
late final _sel_isFlushWindowDisabled =
    objc.registerName("isFlushWindowDisabled");
late final _sel_flushWindow = objc.registerName("flushWindow");
late final _sel_flushWindowIfNeeded = objc.registerName("flushWindowIfNeeded");
late final _sel_isAutodisplay = objc.registerName("isAutodisplay");
late final _sel_setAutodisplay_ = objc.registerName("setAutodisplay:");
late final _sel_graphicsContext = objc.registerName("graphicsContext");
late final _sel_isOneShot = objc.registerName("isOneShot");
late final _sel_setOneShot_ = objc.registerName("setOneShot:");

enum NSWindowBackingLocation {
  /// System determines if window backing store is in VRAM or main memory
  NSWindowBackingLocationDefault(0),

  /// Window backing store is in VRAM
  NSWindowBackingLocationVideoMemory(1),

  /// Window backing store is in main memory
  NSWindowBackingLocationMainMemory(2);

  final int value;
  const NSWindowBackingLocation(this.value);

  static NSWindowBackingLocation fromValue(int value) => switch (value) {
        0 => NSWindowBackingLocationDefault,
        1 => NSWindowBackingLocationVideoMemory,
        2 => NSWindowBackingLocationMainMemory,
        _ => throw ArgumentError(
            "Unknown value for NSWindowBackingLocation: $value"),
      };
}

late final _sel_preferredBackingLocation =
    objc.registerName("preferredBackingLocation");
final _objc_msgSend_292 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.UnsignedLong Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        int Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_setPreferredBackingLocation_ =
    objc.registerName("setPreferredBackingLocation:");
final _objc_msgSend_293 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, ffi.UnsignedLong)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, int)>();
late final _sel_backingLocation = objc.registerName("backingLocation");
late final _sel_showsResizeIndicator =
    objc.registerName("showsResizeIndicator");
late final _sel_setShowsResizeIndicator_ =
    objc.registerName("setShowsResizeIndicator:");
late final _sel_windowWithWindowNumber_ =
    objc.registerName("windowWithWindowNumber:");
final _objc_msgSend_294 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, ffi.Long)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, int)>();
late final _sel_mainWindow = objc.registerName("mainWindow");
late final _sel_keyWindow = objc.registerName("keyWindow");
late final _sel_isActive = objc.registerName("isActive");
late final _sel_isRunning = objc.registerName("isRunning");
late final _sel_deactivate = objc.registerName("deactivate");
late final _sel_activateIgnoringOtherApps_ =
    objc.registerName("activateIgnoringOtherApps:");
late final _sel_activate = objc.registerName("activate");

/// NSRunningApplication
class NSRunningApplication extends objc.NSObject {
  NSRunningApplication._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release);

  /// Constructs a [NSRunningApplication] that points to the same underlying object as [other].
  NSRunningApplication.castFrom(objc.ObjCObjectBase other)
      : this._(other.pointer, retain: true, release: true);

  /// Constructs a [NSRunningApplication] that wraps the given raw object pointer.
  NSRunningApplication.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [NSRunningApplication].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_0(
        obj.pointer, _sel_isKindOfClass_, _class_NSRunningApplication);
  }

  /// isTerminated
  bool get terminated {
    return _objc_msgSend_13(this.pointer, _sel_isTerminated);
  }

  /// isFinishedLaunching
  bool get finishedLaunching {
    return _objc_msgSend_13(this.pointer, _sel_isFinishedLaunching);
  }

  /// isHidden
  bool get hidden {
    return _objc_msgSend_13(this.pointer, _sel_isHidden);
  }

  /// isActive
  bool get active {
    return _objc_msgSend_13(this.pointer, _sel_isActive);
  }

  /// ownsMenuBar
  bool get ownsMenuBar {
    return _objc_msgSend_13(this.pointer, _sel_ownsMenuBar);
  }

  /// activationPolicy
  NSApplicationActivationPolicy get activationPolicy {
    final _ret = _objc_msgSend_295(this.pointer, _sel_activationPolicy);
    return NSApplicationActivationPolicy.fromValue(_ret);
  }

  /// localizedName
  objc.NSString? get localizedName {
    final _ret = _objc_msgSend_84(this.pointer, _sel_localizedName);
    return _ret.address == 0
        ? null
        : objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// bundleIdentifier
  objc.NSString? get bundleIdentifier {
    final _ret = _objc_msgSend_84(this.pointer, _sel_bundleIdentifier);
    return _ret.address == 0
        ? null
        : objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// bundleURL
  objc.NSURL? get bundleURL {
    final _ret = _objc_msgSend_42(this.pointer, _sel_bundleURL);
    return _ret.address == 0
        ? null
        : objc.NSURL.castFromPointer(_ret, retain: true, release: true);
  }

  /// executableURL
  objc.NSURL? get executableURL {
    final _ret = _objc_msgSend_42(this.pointer, _sel_executableURL);
    return _ret.address == 0
        ? null
        : objc.NSURL.castFromPointer(_ret, retain: true, release: true);
  }

  /// processIdentifier
  int get processIdentifier {
    return _objc_msgSend_5(this.pointer, _sel_processIdentifier);
  }

  /// launchDate
  objc.NSDate? get launchDate {
    final _ret = _objc_msgSend_296(this.pointer, _sel_launchDate);
    return _ret.address == 0
        ? null
        : objc.NSDate.castFromPointer(_ret, retain: true, release: true);
  }

  /// icon
  NSImage? get icon {
    final _ret = _objc_msgSend_140(this.pointer, _sel_icon);
    return _ret.address == 0
        ? null
        : NSImage.castFromPointer(_ret, retain: true, release: true);
  }

  /// executableArchitecture
  int get executableArchitecture {
    return _objc_msgSend_79(this.pointer, _sel_executableArchitecture);
  }

  /// hide
  bool hide1() {
    return _objc_msgSend_13(this.pointer, _sel_hide);
  }

  /// unhide
  bool unhide() {
    return _objc_msgSend_13(this.pointer, _sel_unhide);
  }

  /// activateFromApplication:options:
  bool activateFromApplication_options_(NSRunningApplication application,
      NSApplicationActivationOptions options) {
    return _objc_msgSend_297(
        this.pointer,
        _sel_activateFromApplication_options_,
        application.pointer,
        options.value);
  }

  /// activateWithOptions:
  bool activateWithOptions_(NSApplicationActivationOptions options) {
    return _objc_msgSend_298(
        this.pointer, _sel_activateWithOptions_, options.value);
  }

  /// terminate
  bool terminate() {
    return _objc_msgSend_13(this.pointer, _sel_terminate);
  }

  /// forceTerminate
  bool forceTerminate() {
    return _objc_msgSend_13(this.pointer, _sel_forceTerminate);
  }

  /// runningApplicationsWithBundleIdentifier:
  static objc.ObjCObjectBase runningApplicationsWithBundleIdentifier_(
      objc.NSString bundleIdentifier) {
    final _ret = _objc_msgSend_128(
        _class_NSRunningApplication,
        _sel_runningApplicationsWithBundleIdentifier_,
        bundleIdentifier.pointer);
    return objc.ObjCObjectBase(_ret, retain: true, release: true);
  }

  /// runningApplicationWithProcessIdentifier:
  static NSRunningApplication? runningApplicationWithProcessIdentifier_(
      int pid) {
    final _ret = _objc_msgSend_299(_class_NSRunningApplication,
        _sel_runningApplicationWithProcessIdentifier_, pid);
    return _ret.address == 0
        ? null
        : NSRunningApplication.castFromPointer(_ret,
            retain: true, release: true);
  }

  /// currentApplication
  static NSRunningApplication getCurrentApplication() {
    final _ret =
        _objc_msgSend_300(_class_NSRunningApplication, _sel_currentApplication);
    return NSRunningApplication.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// terminateAutomaticallyTerminableApplications
  static void terminateAutomaticallyTerminableApplications() {
    _objc_msgSend_11(_class_NSRunningApplication,
        _sel_terminateAutomaticallyTerminableApplications);
  }

  /// init
  NSRunningApplication init() {
    final _ret = _objc_msgSend_2(this.pointer, _sel_init);
    return NSRunningApplication.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// new
  static NSRunningApplication new1() {
    final _ret = _objc_msgSend_2(_class_NSRunningApplication, _sel_new);
    return NSRunningApplication.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// allocWithZone:
  static NSRunningApplication allocWithZone_(ffi.Pointer<_NSZone> zone) {
    final _ret = _objc_msgSend_20(
        _class_NSRunningApplication, _sel_allocWithZone_, zone);
    return NSRunningApplication.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// alloc
  static NSRunningApplication alloc() {
    final _ret = _objc_msgSend_2(_class_NSRunningApplication, _sel_alloc);
    return NSRunningApplication.castFromPointer(_ret,
        retain: false, release: true);
  }
}

late final _class_NSRunningApplication = objc.getClass("NSRunningApplication");
late final _sel_isTerminated = objc.registerName("isTerminated");
late final _sel_isFinishedLaunching = objc.registerName("isFinishedLaunching");
late final _sel_ownsMenuBar = objc.registerName("ownsMenuBar");

enum NSApplicationActivationPolicy {
  NSApplicationActivationPolicyRegular(0),
  NSApplicationActivationPolicyAccessory(1),
  NSApplicationActivationPolicyProhibited(2);

  final int value;
  const NSApplicationActivationPolicy(this.value);

  static NSApplicationActivationPolicy fromValue(int value) => switch (value) {
        0 => NSApplicationActivationPolicyRegular,
        1 => NSApplicationActivationPolicyAccessory,
        2 => NSApplicationActivationPolicyProhibited,
        _ => throw ArgumentError(
            "Unknown value for NSApplicationActivationPolicy: $value"),
      };
}

late final _sel_activationPolicy = objc.registerName("activationPolicy");
final _objc_msgSend_295 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.UnsignedLong Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        int Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_localizedName = objc.registerName("localizedName");
late final _sel_bundleIdentifier = objc.registerName("bundleIdentifier");
late final _sel_bundleURL = objc.registerName("bundleURL");
late final _sel_executableURL = objc.registerName("executableURL");
late final _sel_launchDate = objc.registerName("launchDate");
final _objc_msgSend_296 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_icon = objc.registerName("icon");
late final _sel_executableArchitecture =
    objc.registerName("executableArchitecture");
late final _sel_hide = objc.registerName("hide");
late final _sel_unhide = objc.registerName("unhide");

enum NSApplicationActivationOptions {
  NSApplicationActivateAllWindows(1),
  NSApplicationActivateIgnoringOtherApps(2);

  final int value;
  const NSApplicationActivationOptions(this.value);

  static NSApplicationActivationOptions fromValue(int value) => switch (value) {
        1 => NSApplicationActivateAllWindows,
        2 => NSApplicationActivateIgnoringOtherApps,
        _ => throw ArgumentError(
            "Unknown value for NSApplicationActivationOptions: $value"),
      };
}

late final _sel_activateFromApplication_options_ =
    objc.registerName("activateFromApplication:options:");
final _objc_msgSend_297 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Bool Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.UnsignedLong)>>()
    .asFunction<
        bool Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            int)>();
late final _sel_activateWithOptions_ =
    objc.registerName("activateWithOptions:");
final _objc_msgSend_298 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Bool Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, ffi.UnsignedLong)>>()
    .asFunction<
        bool Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, int)>();
late final _sel_terminate = objc.registerName("terminate");
late final _sel_forceTerminate = objc.registerName("forceTerminate");
late final _sel_runningApplicationsWithBundleIdentifier_ =
    objc.registerName("runningApplicationsWithBundleIdentifier:");
late final _sel_runningApplicationWithProcessIdentifier_ =
    objc.registerName("runningApplicationWithProcessIdentifier:");
final _objc_msgSend_299 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            instancetype Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, ffi.Int)>>()
    .asFunction<
        instancetype Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, int)>();
late final _sel_currentApplication = objc.registerName("currentApplication");
final _objc_msgSend_300 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_terminateAutomaticallyTerminableApplications =
    objc.registerName("terminateAutomaticallyTerminableApplications");
late final _sel_yieldActivationToApplication_ =
    objc.registerName("yieldActivationToApplication:");
final _objc_msgSend_301 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<objc.ObjCObject>)>();
late final _sel_yieldActivationToApplicationWithBundleIdentifier_ =
    objc.registerName("yieldActivationToApplicationWithBundleIdentifier:");
late final _sel_hideOtherApplications_ =
    objc.registerName("hideOtherApplications:");
late final _sel_unhideAllApplications_ =
    objc.registerName("unhideAllApplications:");
late final _sel_finishLaunching = objc.registerName("finishLaunching");
late final _sel_run = objc.registerName("run");
late final _sel_runModalForWindow_ = objc.registerName("runModalForWindow:");
final _objc_msgSend_302 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Long Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        int Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<objc.ObjCObject>)>();
late final _sel_stop_ = objc.registerName("stop:");
late final _sel_stopModal = objc.registerName("stopModal");
late final _sel_stopModalWithCode_ = objc.registerName("stopModalWithCode:");
late final _sel_abortModal = objc.registerName("abortModal");
late final _sel_modalWindow = objc.registerName("modalWindow");

final class _NSModalSession extends ffi.Opaque {}

late final _sel_beginModalSessionForWindow_ =
    objc.registerName("beginModalSessionForWindow:");
final _objc_msgSend_303 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<_NSModalSession> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        ffi.Pointer<_NSModalSession> Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<objc.ObjCObject>)>();
late final _sel_runModalSession_ = objc.registerName("runModalSession:");
final _objc_msgSend_304 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Long Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<_NSModalSession>)>>()
    .asFunction<
        int Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<_NSModalSession>)>();
late final _sel_endModalSession_ = objc.registerName("endModalSession:");
final _objc_msgSend_305 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<_NSModalSession>)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<_NSModalSession>)>();
late final _sel_terminate_ = objc.registerName("terminate:");

enum NSRequestUserAttentionType {
  NSCriticalRequest(0),
  NSInformationalRequest(10);

  final int value;
  const NSRequestUserAttentionType(this.value);

  static NSRequestUserAttentionType fromValue(int value) => switch (value) {
        0 => NSCriticalRequest,
        10 => NSInformationalRequest,
        _ => throw ArgumentError(
            "Unknown value for NSRequestUserAttentionType: $value"),
      };
}

late final _sel_requestUserAttention_ =
    objc.registerName("requestUserAttention:");
final _objc_msgSend_306 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Long Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, ffi.UnsignedLong)>>()
    .asFunction<
        int Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, int)>();
late final _sel_cancelUserAttentionRequest_ =
    objc.registerName("cancelUserAttentionRequest:");

enum NSWindowListOptions {
  /// Onscreen application windows in front to back order. By default, -[NSApp windows] is used.
  NSWindowListOrderedFrontToBack(1);

  final int value;
  const NSWindowListOptions(this.value);

  static NSWindowListOptions fromValue(int value) => switch (value) {
        1 => NSWindowListOrderedFrontToBack,
        _ =>
          throw ArgumentError("Unknown value for NSWindowListOptions: $value"),
      };
}

void _ObjCBlock_ffiVoid_NSWindow_bool_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlock> block,
        ffi.Pointer<objc.ObjCObject> arg0,
        ffi.Pointer<ffi.Bool> arg1) =>
    block.ref.target
        .cast<
            ffi.NativeFunction<
                ffi.Void Function(ffi.Pointer<objc.ObjCObject> arg0,
                    ffi.Pointer<ffi.Bool> arg1)>>()
        .asFunction<
            void Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<ffi.Bool>)>()(arg0, arg1);
void _ObjCBlock_ffiVoid_NSWindow_bool_closureTrampoline(
        ffi.Pointer<objc.ObjCBlock> block,
        ffi.Pointer<objc.ObjCObject> arg0,
        ffi.Pointer<ffi.Bool> arg1) =>
    (objc.getBlockClosure(block) as void Function(
        ffi.Pointer<objc.ObjCObject>, ffi.Pointer<ffi.Bool>))(arg0, arg1);

class ObjCBlock_ffiVoid_NSWindow_bool extends objc.ObjCBlockBase {
  ObjCBlock_ffiVoid_NSWindow_bool._(ffi.Pointer<objc.ObjCBlock> pointer,
      {bool retain = false, bool release = true})
      : super(pointer, retain: retain, release: release);

  /// Returns a block that wraps the given raw block pointer.
  static ObjCBlock_ffiVoid_NSWindow_bool castFromPointer(
      ffi.Pointer<objc.ObjCBlock> pointer,
      {bool retain = false,
      bool release = false}) {
    return ObjCBlock_ffiVoid_NSWindow_bool._(pointer,
        retain: retain, release: release);
  }

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ObjCBlock_ffiVoid_NSWindow_bool.fromFunctionPointer(
      ffi.Pointer<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<objc.ObjCObject> arg0,
                      ffi.Pointer<ffi.Bool> arg1)>>
          ptr)
      : this._(
            objc
                .newPointerBlock(
                    _cFuncTrampoline ??= ffi.Pointer.fromFunction<
                                ffi.Void Function(
                                    ffi.Pointer<objc.ObjCBlock>,
                                    ffi.Pointer<objc.ObjCObject>,
                                    ffi.Pointer<ffi.Bool>)>(
                            _ObjCBlock_ffiVoid_NSWindow_bool_fnPtrTrampoline)
                        .cast(),
                    ptr.cast()));
  static ffi.Pointer<ffi.Void>? _cFuncTrampoline;

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ObjCBlock_ffiVoid_NSWindow_bool.fromFunction(
      void Function(NSWindow, ffi.Pointer<ffi.Bool>) fn)
      : this._(objc.newClosureBlock(
            _dartFuncTrampoline ??= ffi.Pointer.fromFunction<
                        ffi.Void Function(
                            ffi.Pointer<objc.ObjCBlock>,
                            ffi.Pointer<objc.ObjCObject>,
                            ffi.Pointer<ffi.Bool>)>(
                    _ObjCBlock_ffiVoid_NSWindow_bool_closureTrampoline)
                .cast(),
            (ffi.Pointer<objc.ObjCObject> arg0, ffi.Pointer<ffi.Bool> arg1) =>
                fn(NSWindow.castFromPointer(arg0, retain: true, release: true),
                    arg1)));
  static ffi.Pointer<ffi.Void>? _dartFuncTrampoline;

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// Note that unlike the default behavior of NativeCallable.listener, listener
  /// blocks do not keep the isolate alive.
  ObjCBlock_ffiVoid_NSWindow_bool.listener(
      void Function(NSWindow, ffi.Pointer<ffi.Bool>) fn)
      : this._(wrapListenerBlock_ObjCBlock_ffiVoid_NSWindow_bool(objc.newClosureBlock(
            (_dartFuncListenerTrampoline ??= ffi.NativeCallable<
                        ffi.Void Function(
                            ffi.Pointer<objc.ObjCBlock>,
                            ffi.Pointer<objc.ObjCObject>,
                            ffi.Pointer<ffi.Bool>)>.listener(
                    _ObjCBlock_ffiVoid_NSWindow_bool_closureTrampoline)
                  ..keepIsolateAlive = false)
                .nativeFunction
                .cast(),
            (ffi.Pointer<objc.ObjCObject> arg0, ffi.Pointer<ffi.Bool> arg1) => fn(
                NSWindow.castFromPointer(arg0, retain: false, release: true),
                arg1))));
  static ffi.NativeCallable<
      ffi.Void Function(
          ffi.Pointer<objc.ObjCBlock>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<ffi.Bool>)>? _dartFuncListenerTrampoline;

  void call(NSWindow arg0, ffi.Pointer<ffi.Bool> arg1) => pointer.ref.invoke
      .cast<
          ffi.NativeFunction<
              ffi.Void Function(
                  ffi.Pointer<objc.ObjCBlock> block,
                  ffi.Pointer<objc.ObjCObject> arg0,
                  ffi.Pointer<ffi.Bool> arg1)>>()
      .asFunction<
          void Function(
              ffi.Pointer<objc.ObjCBlock>,
              ffi.Pointer<objc.ObjCObject>,
              ffi.Pointer<ffi.Bool>)>()(pointer, arg0.pointer, arg1);
}

late final _sel_enumerateWindowsWithOptions_usingBlock_ =
    objc.registerName("enumerateWindowsWithOptions:usingBlock:");
final _objc_msgSend_307 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.UnsignedLong,
                ffi.Pointer<objc.ObjCBlock>)>>()
    .asFunction<
        void Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            int,
            ffi.Pointer<objc.ObjCBlock>)>();
late final _sel_preventWindowOrdering =
    objc.registerName("preventWindowOrdering");
late final _sel_windows = objc.registerName("windows");
late final _sel_setWindowsNeedUpdate_ =
    objc.registerName("setWindowsNeedUpdate:");
late final _sel_updateWindows = objc.registerName("updateWindows");
late final _sel_mainMenu = objc.registerName("mainMenu");
late final _sel_setMainMenu_ = objc.registerName("setMainMenu:");
late final _sel_helpMenu = objc.registerName("helpMenu");
late final _sel_setHelpMenu_ = objc.registerName("setHelpMenu:");
late final _sel_applicationIconImage =
    objc.registerName("applicationIconImage");
late final _sel_setApplicationIconImage_ =
    objc.registerName("setApplicationIconImage:");
late final _sel_setActivationPolicy_ =
    objc.registerName("setActivationPolicy:");
final _objc_msgSend_308 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Bool Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, ffi.UnsignedLong)>>()
    .asFunction<
        bool Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, int)>();

/// NSException
class NSException extends objc.NSObject {
  NSException._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release);

  /// Constructs a [NSException] that points to the same underlying object as [other].
  NSException.castFrom(objc.ObjCObjectBase other)
      : this._(other.pointer, retain: true, release: true);

  /// Constructs a [NSException] that wraps the given raw object pointer.
  NSException.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [NSException].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_0(
        obj.pointer, _sel_isKindOfClass_, _class_NSException);
  }

  /// exceptionWithName:reason:userInfo:
  static NSException exceptionWithName_reason_userInfo_(
      objc.NSString name, objc.NSString? reason, objc.NSDictionary? userInfo) {
    final _ret = _objc_msgSend_309(
        _class_NSException,
        _sel_exceptionWithName_reason_userInfo_,
        name.pointer,
        reason?.pointer ?? ffi.nullptr,
        userInfo?.pointer ?? ffi.nullptr);
    return NSException.castFromPointer(_ret, retain: true, release: true);
  }

  /// initWithName:reason:userInfo:
  NSException initWithName_reason_userInfo_(objc.NSString aName,
      objc.NSString? aReason, objc.NSDictionary? aUserInfo) {
    final _ret = _objc_msgSend_310(
        this.pointer,
        _sel_initWithName_reason_userInfo_,
        aName.pointer,
        aReason?.pointer ?? ffi.nullptr,
        aUserInfo?.pointer ?? ffi.nullptr);
    return NSException.castFromPointer(_ret, retain: true, release: true);
  }

  /// name
  objc.NSString get name {
    final _ret = _objc_msgSend_3(this.pointer, _sel_name);
    return objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// reason
  objc.NSString? get reason {
    final _ret = _objc_msgSend_84(this.pointer, _sel_reason);
    return _ret.address == 0
        ? null
        : objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// userInfo
  objc.NSDictionary? get userInfo {
    final _ret = _objc_msgSend_311(this.pointer, _sel_userInfo);
    return _ret.address == 0
        ? null
        : objc.NSDictionary.castFromPointer(_ret, retain: true, release: true);
  }

  /// callStackReturnAddresses
  objc.ObjCObjectBase get callStackReturnAddresses {
    final _ret = _objc_msgSend_2(this.pointer, _sel_callStackReturnAddresses);
    return objc.ObjCObjectBase(_ret, retain: true, release: true);
  }

  /// callStackSymbols
  objc.ObjCObjectBase get callStackSymbols {
    final _ret = _objc_msgSend_2(this.pointer, _sel_callStackSymbols);
    return objc.ObjCObjectBase(_ret, retain: true, release: true);
  }

  /// raise
  void raise() {
    _objc_msgSend_11(this.pointer, _sel_raise);
  }

  /// init
  NSException init() {
    final _ret = _objc_msgSend_2(this.pointer, _sel_init);
    return NSException.castFromPointer(_ret, retain: true, release: true);
  }

  /// new
  static NSException new1() {
    final _ret = _objc_msgSend_2(_class_NSException, _sel_new);
    return NSException.castFromPointer(_ret, retain: false, release: true);
  }

  /// allocWithZone:
  static NSException allocWithZone_(ffi.Pointer<_NSZone> zone) {
    final _ret =
        _objc_msgSend_20(_class_NSException, _sel_allocWithZone_, zone);
    return NSException.castFromPointer(_ret, retain: false, release: true);
  }

  /// alloc
  static NSException alloc() {
    final _ret = _objc_msgSend_2(_class_NSException, _sel_alloc);
    return NSException.castFromPointer(_ret, retain: false, release: true);
  }
}

late final _class_NSException = objc.getClass("NSException");
late final _sel_exceptionWithName_reason_userInfo_ =
    objc.registerName("exceptionWithName:reason:userInfo:");
final _objc_msgSend_309 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>();
late final _sel_initWithName_reason_userInfo_ =
    objc.registerName("initWithName:reason:userInfo:");
final _objc_msgSend_310 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            instancetype Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        instancetype Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>();
late final _sel_reason = objc.registerName("reason");
late final _sel_userInfo = objc.registerName("userInfo");
final _objc_msgSend_311 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_callStackReturnAddresses =
    objc.registerName("callStackReturnAddresses");
late final _sel_callStackSymbols = objc.registerName("callStackSymbols");
late final _sel_raise = objc.registerName("raise");
late final _sel_reportException_ = objc.registerName("reportException:");
final _objc_msgSend_312 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<objc.ObjCObject>)>();
late final _sel_detachDrawingThread_toTarget_withObject_ =
    objc.registerName("detachDrawingThread:toTarget:withObject:");
final _objc_msgSend_313 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        void Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>();
late final _sel_replyToApplicationShouldTerminate_ =
    objc.registerName("replyToApplicationShouldTerminate:");

enum NSApplicationDelegateReply {
  NSApplicationDelegateReplySuccess(0),
  NSApplicationDelegateReplyCancel(1),
  NSApplicationDelegateReplyFailure(2);

  final int value;
  const NSApplicationDelegateReply(this.value);

  static NSApplicationDelegateReply fromValue(int value) => switch (value) {
        0 => NSApplicationDelegateReplySuccess,
        1 => NSApplicationDelegateReplyCancel,
        2 => NSApplicationDelegateReplyFailure,
        _ => throw ArgumentError(
            "Unknown value for NSApplicationDelegateReply: $value"),
      };
}

late final _sel_replyToOpenOrPrint_ = objc.registerName("replyToOpenOrPrint:");
final _objc_msgSend_314 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, ffi.UnsignedLong)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, int)>();
late final _sel_orderFrontCharacterPalette_ =
    objc.registerName("orderFrontCharacterPalette:");

/// Flags that comprise an application's @c presentationOptions.
enum NSApplicationPresentationOptions {
  NSApplicationPresentationDefault(0),

  /// Dock appears when moused to.
  NSApplicationPresentationAutoHideDock(1),

  /// Dock is entirely unavailable.
  NSApplicationPresentationHideDock(2),

  /// Menu Bar appears when moused to.
  NSApplicationPresentationAutoHideMenuBar(4),

  /// Menu Bar is entirely unavailable.
  NSApplicationPresentationHideMenuBar(8),

  /// All Apple menu items are disabled.
  NSApplicationPresentationDisableAppleMenu(16),

  /// Cmd+Tab UI is disabled.
  NSApplicationPresentationDisableProcessSwitching(32),

  /// Cmd+Opt+Esc panel is disabled.
  NSApplicationPresentationDisableForceQuit(64),

  /// PowerKey panel and Restart/Shut Down/Log Out disabled.
  NSApplicationPresentationDisableSessionTermination(128),

  /// Application "Hide" menu item is disabled.
  NSApplicationPresentationDisableHideApplication(256),

  /// Menu Bar's transparent appearance is disabled.
  NSApplicationPresentationDisableMenuBarTransparency(512),

  /// Application is in fullscreen mode.
  NSApplicationPresentationFullScreen(1024),

  /// Fullscreen window toolbar is detached from window and hides/shows on rollover.
  /// May be used only when both @c NSApplicationPresentationFullScreen is also set.
  NSApplicationPresentationAutoHideToolbar(2048),

  /// "Shake mouse pointer to locate" is disabled for this application.
  NSApplicationPresentationDisableCursorLocationAssistance(4096);

  final int value;
  const NSApplicationPresentationOptions(this.value);

  static NSApplicationPresentationOptions fromValue(int value) =>
      switch (value) {
        0 => NSApplicationPresentationDefault,
        1 => NSApplicationPresentationAutoHideDock,
        2 => NSApplicationPresentationHideDock,
        4 => NSApplicationPresentationAutoHideMenuBar,
        8 => NSApplicationPresentationHideMenuBar,
        16 => NSApplicationPresentationDisableAppleMenu,
        32 => NSApplicationPresentationDisableProcessSwitching,
        64 => NSApplicationPresentationDisableForceQuit,
        128 => NSApplicationPresentationDisableSessionTermination,
        256 => NSApplicationPresentationDisableHideApplication,
        512 => NSApplicationPresentationDisableMenuBarTransparency,
        1024 => NSApplicationPresentationFullScreen,
        2048 => NSApplicationPresentationAutoHideToolbar,
        4096 => NSApplicationPresentationDisableCursorLocationAssistance,
        _ => throw ArgumentError(
            "Unknown value for NSApplicationPresentationOptions: $value"),
      };
}

late final _sel_presentationOptions = objc.registerName("presentationOptions");
final _objc_msgSend_315 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.UnsignedLong Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        int Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_setPresentationOptions_ =
    objc.registerName("setPresentationOptions:");
final _objc_msgSend_316 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, ffi.UnsignedLong)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, int)>();
late final _sel_currentSystemPresentationOptions =
    objc.registerName("currentSystemPresentationOptions");

enum NSApplicationOcclusionState {
  /// If set, at least part of any window owned by this application is visible. If not set, all parts of all windows owned by this application are completely occluded. The menu bar does not count as a window owned by this application, so if only the menu bar is showing then the application is considered not visible. Status items, however, have windows owned by your application. If the status item is present in the menu bar, your application will be considered visible as long as the menu bar is visible.
  NSApplicationOcclusionStateVisible(2);

  final int value;
  const NSApplicationOcclusionState(this.value);

  static NSApplicationOcclusionState fromValue(int value) => switch (value) {
        2 => NSApplicationOcclusionStateVisible,
        _ => throw ArgumentError(
            "Unknown value for NSApplicationOcclusionState: $value"),
      };
}

final _objc_msgSend_317 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.UnsignedLong Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        int Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_isProtectedDataAvailable =
    objc.registerName("isProtectedDataAvailable");

/// NSAppearance
class NSAppearance extends objc.NSObject {
  NSAppearance._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release);

  /// Constructs a [NSAppearance] that points to the same underlying object as [other].
  NSAppearance.castFrom(objc.ObjCObjectBase other)
      : this._(other.pointer, retain: true, release: true);

  /// Constructs a [NSAppearance] that wraps the given raw object pointer.
  NSAppearance.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [NSAppearance].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_0(
        obj.pointer, _sel_isKindOfClass_, _class_NSAppearance);
  }

  /// name
  objc.NSString get name {
    final _ret = _objc_msgSend_3(this.pointer, _sel_name);
    return objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// currentAppearance
  static NSAppearance getCurrentAppearance() {
    final _ret = _objc_msgSend_318(_class_NSAppearance, _sel_currentAppearance);
    return NSAppearance.castFromPointer(_ret, retain: true, release: true);
  }

  /// setCurrentAppearance:
  static void setCurrentAppearance(NSAppearance value) {
    return _objc_msgSend_319(
        _class_NSAppearance, _sel_setCurrentAppearance_, value.pointer);
  }

  /// currentDrawingAppearance
  static NSAppearance getCurrentDrawingAppearance() {
    final _ret =
        _objc_msgSend_318(_class_NSAppearance, _sel_currentDrawingAppearance);
    return NSAppearance.castFromPointer(_ret, retain: true, release: true);
  }

  /// performAsCurrentDrawingAppearance:
  void performAsCurrentDrawingAppearance_(ObjCBlock_ffiVoid block) {
    _objc_msgSend_320(
        this.pointer, _sel_performAsCurrentDrawingAppearance_, block.pointer);
  }

  /// appearanceNamed:
  static NSAppearance? appearanceNamed_(objc.NSString name) {
    final _ret = _objc_msgSend_321(
        _class_NSAppearance, _sel_appearanceNamed_, name.pointer);
    return _ret.address == 0
        ? null
        : NSAppearance.castFromPointer(_ret, retain: true, release: true);
  }

  /// initWithAppearanceNamed:bundle:
  NSAppearance? initWithAppearanceNamed_bundle_(
      objc.NSString name, NSBundle? bundle) {
    final _ret = _objc_msgSend_344(
        this.pointer,
        _sel_initWithAppearanceNamed_bundle_,
        name.pointer,
        bundle?.pointer ?? ffi.nullptr);
    return _ret.address == 0
        ? null
        : NSAppearance.castFromPointer(_ret, retain: true, release: true);
  }

  /// initWithCoder:
  NSAppearance? initWithCoder_(objc.NSCoder coder) {
    final _ret =
        _objc_msgSend_45(this.pointer, _sel_initWithCoder_, coder.pointer);
    return _ret.address == 0
        ? null
        : NSAppearance.castFromPointer(_ret, retain: true, release: true);
  }

  /// allowsVibrancy
  bool get allowsVibrancy {
    return _objc_msgSend_13(this.pointer, _sel_allowsVibrancy);
  }

  /// bestMatchFromAppearancesWithNames:
  objc.NSString? bestMatchFromAppearancesWithNames_(
      objc.ObjCObjectBase appearances) {
    final _ret = _objc_msgSend_345(this.pointer,
        _sel_bestMatchFromAppearancesWithNames_, appearances.pointer);
    return _ret.address == 0
        ? null
        : objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// init
  NSAppearance init() {
    final _ret = _objc_msgSend_2(this.pointer, _sel_init);
    return NSAppearance.castFromPointer(_ret, retain: true, release: true);
  }

  /// new
  static NSAppearance new1() {
    final _ret = _objc_msgSend_2(_class_NSAppearance, _sel_new);
    return NSAppearance.castFromPointer(_ret, retain: false, release: true);
  }

  /// allocWithZone:
  static NSAppearance allocWithZone_(ffi.Pointer<_NSZone> zone) {
    final _ret =
        _objc_msgSend_20(_class_NSAppearance, _sel_allocWithZone_, zone);
    return NSAppearance.castFromPointer(_ret, retain: false, release: true);
  }

  /// alloc
  static NSAppearance alloc() {
    final _ret = _objc_msgSend_2(_class_NSAppearance, _sel_alloc);
    return NSAppearance.castFromPointer(_ret, retain: false, release: true);
  }
}

late final _class_NSAppearance = objc.getClass("NSAppearance");
late final _sel_currentAppearance = objc.registerName("currentAppearance");
final _objc_msgSend_318 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_setCurrentAppearance_ =
    objc.registerName("setCurrentAppearance:");
final _objc_msgSend_319 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<objc.ObjCObject>)>();
late final _sel_currentDrawingAppearance =
    objc.registerName("currentDrawingAppearance");
late final _sel_performAsCurrentDrawingAppearance_ =
    objc.registerName("performAsCurrentDrawingAppearance:");
final _objc_msgSend_320 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<objc.ObjCBlock>)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<objc.ObjCBlock>)>();
late final _sel_appearanceNamed_ = objc.registerName("appearanceNamed:");
final _objc_msgSend_321 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<objc.ObjCObject>)>();

/// NSBundle
class NSBundle extends objc.NSObject {
  NSBundle._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release);

  /// Constructs a [NSBundle] that points to the same underlying object as [other].
  NSBundle.castFrom(objc.ObjCObjectBase other)
      : this._(other.pointer, retain: true, release: true);

  /// Constructs a [NSBundle] that wraps the given raw object pointer.
  NSBundle.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [NSBundle].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_0(obj.pointer, _sel_isKindOfClass_, _class_NSBundle);
  }

  /// mainBundle
  static NSBundle getMainBundle() {
    final _ret = _objc_msgSend_322(_class_NSBundle, _sel_mainBundle);
    return NSBundle.castFromPointer(_ret, retain: true, release: true);
  }

  /// bundleWithPath:
  static NSBundle? bundleWithPath_(objc.NSString path) {
    final _ret =
        _objc_msgSend_285(_class_NSBundle, _sel_bundleWithPath_, path.pointer);
    return _ret.address == 0
        ? null
        : NSBundle.castFromPointer(_ret, retain: true, release: true);
  }

  /// initWithPath:
  NSBundle? initWithPath_(objc.NSString path) {
    final _ret =
        _objc_msgSend_285(this.pointer, _sel_initWithPath_, path.pointer);
    return _ret.address == 0
        ? null
        : NSBundle.castFromPointer(_ret, retain: true, release: true);
  }

  /// bundleWithURL:
  static NSBundle? bundleWithURL_(objc.NSURL url) {
    final _ret =
        _objc_msgSend_323(_class_NSBundle, _sel_bundleWithURL_, url.pointer);
    return _ret.address == 0
        ? null
        : NSBundle.castFromPointer(_ret, retain: true, release: true);
  }

  /// initWithURL:
  NSBundle? initWithURL_(objc.NSURL url) {
    final _ret =
        _objc_msgSend_323(this.pointer, _sel_initWithURL_, url.pointer);
    return _ret.address == 0
        ? null
        : NSBundle.castFromPointer(_ret, retain: true, release: true);
  }

  /// bundleForClass:
  static NSBundle bundleForClass_(objc.ObjCObjectBase aClass) {
    final _ret = _objc_msgSend_324(
        _class_NSBundle, _sel_bundleForClass_, aClass.pointer);
    return NSBundle.castFromPointer(_ret, retain: true, release: true);
  }

  /// bundleWithIdentifier:
  static NSBundle? bundleWithIdentifier_(objc.NSString identifier) {
    final _ret = _objc_msgSend_325(
        _class_NSBundle, _sel_bundleWithIdentifier_, identifier.pointer);
    return _ret.address == 0
        ? null
        : NSBundle.castFromPointer(_ret, retain: true, release: true);
  }

  /// allBundles
  static objc.ObjCObjectBase getAllBundles() {
    final _ret = _objc_msgSend_2(_class_NSBundle, _sel_allBundles);
    return objc.ObjCObjectBase(_ret, retain: true, release: true);
  }

  /// allFrameworks
  static objc.ObjCObjectBase getAllFrameworks() {
    final _ret = _objc_msgSend_2(_class_NSBundle, _sel_allFrameworks);
    return objc.ObjCObjectBase(_ret, retain: true, release: true);
  }

  /// load
  bool load() {
    return _objc_msgSend_13(this.pointer, _sel_load);
  }

  /// isLoaded
  bool get loaded {
    return _objc_msgSend_13(this.pointer, _sel_isLoaded);
  }

  /// unload
  bool unload() {
    return _objc_msgSend_13(this.pointer, _sel_unload);
  }

  /// preflightAndReturnError:
  bool preflightAndReturnError_(
      ffi.Pointer<ffi.Pointer<objc.ObjCObject>> error) {
    return _objc_msgSend_326(
        this.pointer, _sel_preflightAndReturnError_, error);
  }

  /// loadAndReturnError:
  bool loadAndReturnError_(ffi.Pointer<ffi.Pointer<objc.ObjCObject>> error) {
    return _objc_msgSend_326(this.pointer, _sel_loadAndReturnError_, error);
  }

  /// bundleURL
  objc.NSURL get bundleURL {
    final _ret = _objc_msgSend_327(this.pointer, _sel_bundleURL);
    return objc.NSURL.castFromPointer(_ret, retain: true, release: true);
  }

  /// resourceURL
  objc.NSURL? get resourceURL {
    final _ret = _objc_msgSend_42(this.pointer, _sel_resourceURL);
    return _ret.address == 0
        ? null
        : objc.NSURL.castFromPointer(_ret, retain: true, release: true);
  }

  /// executableURL
  objc.NSURL? get executableURL {
    final _ret = _objc_msgSend_42(this.pointer, _sel_executableURL);
    return _ret.address == 0
        ? null
        : objc.NSURL.castFromPointer(_ret, retain: true, release: true);
  }

  /// URLForAuxiliaryExecutable:
  objc.NSURL? URLForAuxiliaryExecutable_(objc.NSString executableName) {
    final _ret = _objc_msgSend_328(
        this.pointer, _sel_URLForAuxiliaryExecutable_, executableName.pointer);
    return _ret.address == 0
        ? null
        : objc.NSURL.castFromPointer(_ret, retain: true, release: true);
  }

  /// privateFrameworksURL
  objc.NSURL? get privateFrameworksURL {
    final _ret = _objc_msgSend_42(this.pointer, _sel_privateFrameworksURL);
    return _ret.address == 0
        ? null
        : objc.NSURL.castFromPointer(_ret, retain: true, release: true);
  }

  /// sharedFrameworksURL
  objc.NSURL? get sharedFrameworksURL {
    final _ret = _objc_msgSend_42(this.pointer, _sel_sharedFrameworksURL);
    return _ret.address == 0
        ? null
        : objc.NSURL.castFromPointer(_ret, retain: true, release: true);
  }

  /// sharedSupportURL
  objc.NSURL? get sharedSupportURL {
    final _ret = _objc_msgSend_42(this.pointer, _sel_sharedSupportURL);
    return _ret.address == 0
        ? null
        : objc.NSURL.castFromPointer(_ret, retain: true, release: true);
  }

  /// builtInPlugInsURL
  objc.NSURL? get builtInPlugInsURL {
    final _ret = _objc_msgSend_42(this.pointer, _sel_builtInPlugInsURL);
    return _ret.address == 0
        ? null
        : objc.NSURL.castFromPointer(_ret, retain: true, release: true);
  }

  /// appStoreReceiptURL
  objc.NSURL? get appStoreReceiptURL {
    final _ret = _objc_msgSend_42(this.pointer, _sel_appStoreReceiptURL);
    return _ret.address == 0
        ? null
        : objc.NSURL.castFromPointer(_ret, retain: true, release: true);
  }

  /// bundlePath
  objc.NSString get bundlePath {
    final _ret = _objc_msgSend_3(this.pointer, _sel_bundlePath);
    return objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// resourcePath
  objc.NSString? get resourcePath {
    final _ret = _objc_msgSend_84(this.pointer, _sel_resourcePath);
    return _ret.address == 0
        ? null
        : objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// executablePath
  objc.NSString? get executablePath {
    final _ret = _objc_msgSend_84(this.pointer, _sel_executablePath);
    return _ret.address == 0
        ? null
        : objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// pathForAuxiliaryExecutable:
  objc.NSString? pathForAuxiliaryExecutable_(objc.NSString executableName) {
    final _ret = _objc_msgSend_286(
        this.pointer, _sel_pathForAuxiliaryExecutable_, executableName.pointer);
    return _ret.address == 0
        ? null
        : objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// privateFrameworksPath
  objc.NSString? get privateFrameworksPath {
    final _ret = _objc_msgSend_84(this.pointer, _sel_privateFrameworksPath);
    return _ret.address == 0
        ? null
        : objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// sharedFrameworksPath
  objc.NSString? get sharedFrameworksPath {
    final _ret = _objc_msgSend_84(this.pointer, _sel_sharedFrameworksPath);
    return _ret.address == 0
        ? null
        : objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// sharedSupportPath
  objc.NSString? get sharedSupportPath {
    final _ret = _objc_msgSend_84(this.pointer, _sel_sharedSupportPath);
    return _ret.address == 0
        ? null
        : objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// builtInPlugInsPath
  objc.NSString? get builtInPlugInsPath {
    final _ret = _objc_msgSend_84(this.pointer, _sel_builtInPlugInsPath);
    return _ret.address == 0
        ? null
        : objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// URLForResource:withExtension:subdirectory:inBundleWithURL:
  static objc.NSURL? URLForResource_withExtension_subdirectory_inBundleWithURL_(
      objc.NSString? name,
      objc.NSString? ext,
      objc.NSString? subpath,
      objc.NSURL bundleURL) {
    final _ret = _objc_msgSend_329(
        _class_NSBundle,
        _sel_URLForResource_withExtension_subdirectory_inBundleWithURL_,
        name?.pointer ?? ffi.nullptr,
        ext?.pointer ?? ffi.nullptr,
        subpath?.pointer ?? ffi.nullptr,
        bundleURL.pointer);
    return _ret.address == 0
        ? null
        : objc.NSURL.castFromPointer(_ret, retain: true, release: true);
  }

  /// URLsForResourcesWithExtension:subdirectory:inBundleWithURL:
  static objc.ObjCObjectBase?
      URLsForResourcesWithExtension_subdirectory_inBundleWithURL_(
          objc.NSString? ext, objc.NSString? subpath, objc.NSURL bundleURL) {
    final _ret = _objc_msgSend_330(
        _class_NSBundle,
        _sel_URLsForResourcesWithExtension_subdirectory_inBundleWithURL_,
        ext?.pointer ?? ffi.nullptr,
        subpath?.pointer ?? ffi.nullptr,
        bundleURL.pointer);
    return _ret.address == 0
        ? null
        : objc.ObjCObjectBase(_ret, retain: true, release: true);
  }

  /// URLForResource:withExtension:
  objc.NSURL? URLForResource_withExtension_(
      objc.NSString? name, objc.NSString? ext) {
    final _ret = _objc_msgSend_331(
        this.pointer,
        _sel_URLForResource_withExtension_,
        name?.pointer ?? ffi.nullptr,
        ext?.pointer ?? ffi.nullptr);
    return _ret.address == 0
        ? null
        : objc.NSURL.castFromPointer(_ret, retain: true, release: true);
  }

  /// URLForResource:withExtension:subdirectory:
  objc.NSURL? URLForResource_withExtension_subdirectory_(
      objc.NSString? name, objc.NSString? ext, objc.NSString? subpath) {
    final _ret = _objc_msgSend_332(
        this.pointer,
        _sel_URLForResource_withExtension_subdirectory_,
        name?.pointer ?? ffi.nullptr,
        ext?.pointer ?? ffi.nullptr,
        subpath?.pointer ?? ffi.nullptr);
    return _ret.address == 0
        ? null
        : objc.NSURL.castFromPointer(_ret, retain: true, release: true);
  }

  /// URLForResource:withExtension:subdirectory:localization:
  objc.NSURL? URLForResource_withExtension_subdirectory_localization_(
      objc.NSString? name,
      objc.NSString? ext,
      objc.NSString? subpath,
      objc.NSString? localizationName) {
    final _ret = _objc_msgSend_333(
        this.pointer,
        _sel_URLForResource_withExtension_subdirectory_localization_,
        name?.pointer ?? ffi.nullptr,
        ext?.pointer ?? ffi.nullptr,
        subpath?.pointer ?? ffi.nullptr,
        localizationName?.pointer ?? ffi.nullptr);
    return _ret.address == 0
        ? null
        : objc.NSURL.castFromPointer(_ret, retain: true, release: true);
  }

  /// URLsForResourcesWithExtension:subdirectory:
  objc.ObjCObjectBase? URLsForResourcesWithExtension_subdirectory_(
      objc.NSString? ext, objc.NSString? subpath) {
    final _ret = _objc_msgSend_180(
        this.pointer,
        _sel_URLsForResourcesWithExtension_subdirectory_,
        ext?.pointer ?? ffi.nullptr,
        subpath?.pointer ?? ffi.nullptr);
    return _ret.address == 0
        ? null
        : objc.ObjCObjectBase(_ret, retain: true, release: true);
  }

  /// URLsForResourcesWithExtension:subdirectory:localization:
  objc.ObjCObjectBase? URLsForResourcesWithExtension_subdirectory_localization_(
      objc.NSString? ext,
      objc.NSString? subpath,
      objc.NSString? localizationName) {
    final _ret = _objc_msgSend_334(
        this.pointer,
        _sel_URLsForResourcesWithExtension_subdirectory_localization_,
        ext?.pointer ?? ffi.nullptr,
        subpath?.pointer ?? ffi.nullptr,
        localizationName?.pointer ?? ffi.nullptr);
    return _ret.address == 0
        ? null
        : objc.ObjCObjectBase(_ret, retain: true, release: true);
  }

  /// pathForResource:ofType:inDirectory:
  objc.NSString? pathForResource_ofType_inDirectory_(
      objc.NSString? name, objc.NSString? ext, objc.NSString? subpath) {
    final _ret = _objc_msgSend_335(
        this.pointer,
        _sel_pathForResource_ofType_inDirectory_,
        name?.pointer ?? ffi.nullptr,
        ext?.pointer ?? ffi.nullptr,
        subpath?.pointer ?? ffi.nullptr);
    return _ret.address == 0
        ? null
        : objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// pathsForResourcesOfType:inDirectory:
  objc.ObjCObjectBase pathsForResourcesOfType_inDirectory_(
      objc.NSString? ext, objc.NSString? subpath) {
    final _ret = _objc_msgSend_336(
        this.pointer,
        _sel_pathsForResourcesOfType_inDirectory_,
        ext?.pointer ?? ffi.nullptr,
        subpath?.pointer ?? ffi.nullptr);
    return objc.ObjCObjectBase(_ret, retain: true, release: true);
  }

  /// pathForResource:ofType:
  objc.NSString? pathForResource_ofType_(
      objc.NSString? name, objc.NSString? ext) {
    final _ret = _objc_msgSend_337(this.pointer, _sel_pathForResource_ofType_,
        name?.pointer ?? ffi.nullptr, ext?.pointer ?? ffi.nullptr);
    return _ret.address == 0
        ? null
        : objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// pathForResource:ofType:inDirectory:forLocalization:
  objc.NSString? pathForResource_ofType_inDirectory_forLocalization_(
      objc.NSString? name,
      objc.NSString? ext,
      objc.NSString? subpath,
      objc.NSString? localizationName) {
    final _ret = _objc_msgSend_338(
        this.pointer,
        _sel_pathForResource_ofType_inDirectory_forLocalization_,
        name?.pointer ?? ffi.nullptr,
        ext?.pointer ?? ffi.nullptr,
        subpath?.pointer ?? ffi.nullptr,
        localizationName?.pointer ?? ffi.nullptr);
    return _ret.address == 0
        ? null
        : objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// pathsForResourcesOfType:inDirectory:forLocalization:
  objc.ObjCObjectBase pathsForResourcesOfType_inDirectory_forLocalization_(
      objc.NSString? ext,
      objc.NSString? subpath,
      objc.NSString? localizationName) {
    final _ret = _objc_msgSend_339(
        this.pointer,
        _sel_pathsForResourcesOfType_inDirectory_forLocalization_,
        ext?.pointer ?? ffi.nullptr,
        subpath?.pointer ?? ffi.nullptr,
        localizationName?.pointer ?? ffi.nullptr);
    return objc.ObjCObjectBase(_ret, retain: true, release: true);
  }

  /// localizedStringForKey:value:table:
  objc.NSString localizedStringForKey_value_table_(
      objc.NSString key, objc.NSString? value, objc.NSString? tableName) {
    final _ret = _objc_msgSend_340(
        this.pointer,
        _sel_localizedStringForKey_value_table_,
        key.pointer,
        value?.pointer ?? ffi.nullptr,
        tableName?.pointer ?? ffi.nullptr);
    return objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// localizedAttributedStringForKey:value:table:
  NSAttributedString localizedAttributedStringForKey_value_table_(
      objc.NSString key, objc.NSString? value, objc.NSString? tableName) {
    final _ret = _objc_msgSend_341(
        this.pointer,
        _sel_localizedAttributedStringForKey_value_table_,
        key.pointer,
        value?.pointer ?? ffi.nullptr,
        tableName?.pointer ?? ffi.nullptr);
    return NSAttributedString.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// bundleIdentifier
  objc.NSString? get bundleIdentifier {
    final _ret = _objc_msgSend_84(this.pointer, _sel_bundleIdentifier);
    return _ret.address == 0
        ? null
        : objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// infoDictionary
  objc.NSDictionary? get infoDictionary {
    final _ret = _objc_msgSend_311(this.pointer, _sel_infoDictionary);
    return _ret.address == 0
        ? null
        : objc.NSDictionary.castFromPointer(_ret, retain: true, release: true);
  }

  /// localizedInfoDictionary
  objc.NSDictionary? get localizedInfoDictionary {
    final _ret = _objc_msgSend_311(this.pointer, _sel_localizedInfoDictionary);
    return _ret.address == 0
        ? null
        : objc.NSDictionary.castFromPointer(_ret, retain: true, release: true);
  }

  /// objectForInfoDictionaryKey:
  objc.ObjCObjectBase? objectForInfoDictionaryKey_(objc.NSString key) {
    final _ret = _objc_msgSend_285(
        this.pointer, _sel_objectForInfoDictionaryKey_, key.pointer);
    return _ret.address == 0
        ? null
        : objc.ObjCObjectBase(_ret, retain: true, release: true);
  }

  /// classNamed:
  objc.ObjCObjectBase? classNamed_(objc.NSString className) {
    final _ret =
        _objc_msgSend_285(this.pointer, _sel_classNamed_, className.pointer);
    return _ret.address == 0
        ? null
        : objc.ObjCObjectBase(_ret, retain: true, release: true);
  }

  /// principalClass
  objc.ObjCObjectBase? get principalClass {
    final _ret = _objc_msgSend_22(this.pointer, _sel_principalClass);
    return _ret.address == 0
        ? null
        : objc.ObjCObjectBase(_ret, retain: true, release: true);
  }

  /// preferredLocalizations
  objc.ObjCObjectBase get preferredLocalizations {
    final _ret = _objc_msgSend_2(this.pointer, _sel_preferredLocalizations);
    return objc.ObjCObjectBase(_ret, retain: true, release: true);
  }

  /// localizations
  objc.ObjCObjectBase get localizations {
    final _ret = _objc_msgSend_2(this.pointer, _sel_localizations);
    return objc.ObjCObjectBase(_ret, retain: true, release: true);
  }

  /// developmentLocalization
  objc.NSString? get developmentLocalization {
    final _ret = _objc_msgSend_84(this.pointer, _sel_developmentLocalization);
    return _ret.address == 0
        ? null
        : objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// preferredLocalizationsFromArray:
  static objc.ObjCObjectBase preferredLocalizationsFromArray_(
      objc.ObjCObjectBase localizationsArray) {
    final _ret = _objc_msgSend_342(_class_NSBundle,
        _sel_preferredLocalizationsFromArray_, localizationsArray.pointer);
    return objc.ObjCObjectBase(_ret, retain: true, release: true);
  }

  /// preferredLocalizationsFromArray:forPreferences:
  static objc.ObjCObjectBase preferredLocalizationsFromArray_forPreferences_(
      objc.ObjCObjectBase localizationsArray,
      objc.ObjCObjectBase? preferencesArray) {
    final _ret = _objc_msgSend_343(
        _class_NSBundle,
        _sel_preferredLocalizationsFromArray_forPreferences_,
        localizationsArray.pointer,
        preferencesArray?.pointer ?? ffi.nullptr);
    return objc.ObjCObjectBase(_ret, retain: true, release: true);
  }

  /// executableArchitectures
  objc.ObjCObjectBase? get executableArchitectures {
    final _ret = _objc_msgSend_22(this.pointer, _sel_executableArchitectures);
    return _ret.address == 0
        ? null
        : objc.ObjCObjectBase(_ret, retain: true, release: true);
  }

  /// init
  NSBundle init() {
    final _ret = _objc_msgSend_2(this.pointer, _sel_init);
    return NSBundle.castFromPointer(_ret, retain: true, release: true);
  }

  /// new
  static NSBundle new1() {
    final _ret = _objc_msgSend_2(_class_NSBundle, _sel_new);
    return NSBundle.castFromPointer(_ret, retain: false, release: true);
  }

  /// allocWithZone:
  static NSBundle allocWithZone_(ffi.Pointer<_NSZone> zone) {
    final _ret = _objc_msgSend_20(_class_NSBundle, _sel_allocWithZone_, zone);
    return NSBundle.castFromPointer(_ret, retain: false, release: true);
  }

  /// alloc
  static NSBundle alloc() {
    final _ret = _objc_msgSend_2(_class_NSBundle, _sel_alloc);
    return NSBundle.castFromPointer(_ret, retain: false, release: true);
  }
}

late final _class_NSBundle = objc.getClass("NSBundle");
late final _sel_mainBundle = objc.registerName("mainBundle");
final _objc_msgSend_322 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_bundleWithPath_ = objc.registerName("bundleWithPath:");
late final _sel_initWithPath_ = objc.registerName("initWithPath:");
late final _sel_bundleWithURL_ = objc.registerName("bundleWithURL:");
final _objc_msgSend_323 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            instancetype Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        instancetype Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<objc.ObjCObject>)>();
late final _sel_initWithURL_ = objc.registerName("initWithURL:");
late final _sel_bundleForClass_ = objc.registerName("bundleForClass:");
final _objc_msgSend_324 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<objc.ObjCObject>)>();
late final _sel_bundleWithIdentifier_ =
    objc.registerName("bundleWithIdentifier:");
final _objc_msgSend_325 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<objc.ObjCObject>)>();
late final _sel_allBundles = objc.registerName("allBundles");
late final _sel_allFrameworks = objc.registerName("allFrameworks");
late final _sel_load = objc.registerName("load");
late final _sel_isLoaded = objc.registerName("isLoaded");
late final _sel_unload = objc.registerName("unload");
late final _sel_preflightAndReturnError_ =
    objc.registerName("preflightAndReturnError:");
final _objc_msgSend_326 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Bool Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<ffi.Pointer<objc.ObjCObject>>)>>()
    .asFunction<
        bool Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<ffi.Pointer<objc.ObjCObject>>)>();
late final _sel_loadAndReturnError_ = objc.registerName("loadAndReturnError:");
final _objc_msgSend_327 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_resourceURL = objc.registerName("resourceURL");
late final _sel_URLForAuxiliaryExecutable_ =
    objc.registerName("URLForAuxiliaryExecutable:");
final _objc_msgSend_328 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<objc.ObjCObject>)>();
late final _sel_privateFrameworksURL =
    objc.registerName("privateFrameworksURL");
late final _sel_sharedFrameworksURL = objc.registerName("sharedFrameworksURL");
late final _sel_sharedSupportURL = objc.registerName("sharedSupportURL");
late final _sel_builtInPlugInsURL = objc.registerName("builtInPlugInsURL");
late final _sel_appStoreReceiptURL = objc.registerName("appStoreReceiptURL");
late final _sel_bundlePath = objc.registerName("bundlePath");
late final _sel_resourcePath = objc.registerName("resourcePath");
late final _sel_executablePath = objc.registerName("executablePath");
late final _sel_pathForAuxiliaryExecutable_ =
    objc.registerName("pathForAuxiliaryExecutable:");
late final _sel_privateFrameworksPath =
    objc.registerName("privateFrameworksPath");
late final _sel_sharedFrameworksPath =
    objc.registerName("sharedFrameworksPath");
late final _sel_sharedSupportPath = objc.registerName("sharedSupportPath");
late final _sel_builtInPlugInsPath = objc.registerName("builtInPlugInsPath");
late final _sel_URLForResource_withExtension_subdirectory_inBundleWithURL_ =
    objc.registerName(
        "URLForResource:withExtension:subdirectory:inBundleWithURL:");
final _objc_msgSend_329 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>();
late final _sel_URLsForResourcesWithExtension_subdirectory_inBundleWithURL_ =
    objc.registerName(
        "URLsForResourcesWithExtension:subdirectory:inBundleWithURL:");
final _objc_msgSend_330 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>();
late final _sel_URLForResource_withExtension_ =
    objc.registerName("URLForResource:withExtension:");
final _objc_msgSend_331 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>();
late final _sel_URLForResource_withExtension_subdirectory_ =
    objc.registerName("URLForResource:withExtension:subdirectory:");
final _objc_msgSend_332 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>();
late final _sel_URLForResource_withExtension_subdirectory_localization_ = objc
    .registerName("URLForResource:withExtension:subdirectory:localization:");
final _objc_msgSend_333 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>();
late final _sel_URLsForResourcesWithExtension_subdirectory_ =
    objc.registerName("URLsForResourcesWithExtension:subdirectory:");
late final _sel_URLsForResourcesWithExtension_subdirectory_localization_ = objc
    .registerName("URLsForResourcesWithExtension:subdirectory:localization:");
final _objc_msgSend_334 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>();
late final _sel_pathForResource_ofType_inDirectory_ =
    objc.registerName("pathForResource:ofType:inDirectory:");
final _objc_msgSend_335 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>();
late final _sel_pathsForResourcesOfType_inDirectory_ =
    objc.registerName("pathsForResourcesOfType:inDirectory:");
final _objc_msgSend_336 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>();
late final _sel_pathForResource_ofType_ =
    objc.registerName("pathForResource:ofType:");
final _objc_msgSend_337 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>();
late final _sel_pathForResource_ofType_inDirectory_forLocalization_ =
    objc.registerName("pathForResource:ofType:inDirectory:forLocalization:");
final _objc_msgSend_338 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>();
late final _sel_pathsForResourcesOfType_inDirectory_forLocalization_ =
    objc.registerName("pathsForResourcesOfType:inDirectory:forLocalization:");
final _objc_msgSend_339 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>();
late final _sel_localizedStringForKey_value_table_ =
    objc.registerName("localizedStringForKey:value:table:");
final _objc_msgSend_340 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>();
late final _sel_localizedAttributedStringForKey_value_table_ =
    objc.registerName("localizedAttributedStringForKey:value:table:");
final _objc_msgSend_341 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>();
late final _sel_infoDictionary = objc.registerName("infoDictionary");
late final _sel_localizedInfoDictionary =
    objc.registerName("localizedInfoDictionary");
late final _sel_objectForInfoDictionaryKey_ =
    objc.registerName("objectForInfoDictionaryKey:");
late final _sel_classNamed_ = objc.registerName("classNamed:");
late final _sel_principalClass = objc.registerName("principalClass");
late final _sel_preferredLocalizations =
    objc.registerName("preferredLocalizations");
late final _sel_localizations = objc.registerName("localizations");
late final _sel_developmentLocalization =
    objc.registerName("developmentLocalization");
late final _sel_preferredLocalizationsFromArray_ =
    objc.registerName("preferredLocalizationsFromArray:");
final _objc_msgSend_342 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<objc.ObjCObject>)>();
late final _sel_preferredLocalizationsFromArray_forPreferences_ =
    objc.registerName("preferredLocalizationsFromArray:forPreferences:");
final _objc_msgSend_343 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>();
late final _sel_executableArchitectures =
    objc.registerName("executableArchitectures");
late final _sel_initWithAppearanceNamed_bundle_ =
    objc.registerName("initWithAppearanceNamed:bundle:");
final _objc_msgSend_344 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            instancetype Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        instancetype Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>();
late final _sel_bestMatchFromAppearancesWithNames_ =
    objc.registerName("bestMatchFromAppearancesWithNames:");
final _objc_msgSend_345 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<objc.ObjCObject>)>();
late final _sel_appearance = objc.registerName("appearance");
final _objc_msgSend_346 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_setAppearance_ = objc.registerName("setAppearance:");
final _objc_msgSend_347 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<objc.ObjCObject>)>();
late final _sel_effectiveAppearance = objc.registerName("effectiveAppearance");
late final _sel_sendAction_to_from_ = objc.registerName("sendAction:to:from:");
final _objc_msgSend_348 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Bool Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        bool Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>();
late final _sel_targetForAction_ = objc.registerName("targetForAction:");
final _objc_msgSend_349 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_targetForAction_to_from_ =
    objc.registerName("targetForAction:to:from:");
final _objc_msgSend_350 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>();
late final _sel_windowsMenu = objc.registerName("windowsMenu");
late final _sel_setWindowsMenu_ = objc.registerName("setWindowsMenu:");
late final _sel_arrangeInFront_ = objc.registerName("arrangeInFront:");
late final _sel_removeWindowsItem_ = objc.registerName("removeWindowsItem:");
late final _sel_addWindowsItem_title_filename_ =
    objc.registerName("addWindowsItem:title:filename:");
final _objc_msgSend_351 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Bool)>>()
    .asFunction<
        void Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            bool)>();
late final _sel_changeWindowsItem_title_filename_ =
    objc.registerName("changeWindowsItem:title:filename:");
late final _sel_updateWindowsItem_ = objc.registerName("updateWindowsItem:");
late final _sel_miniaturizeAll_ = objc.registerName("miniaturizeAll:");
late final _sel_isFullKeyboardAccessEnabled =
    objc.registerName("isFullKeyboardAccessEnabled");
late final _sel_servicesMenu = objc.registerName("servicesMenu");
late final _sel_setServicesMenu_ = objc.registerName("setServicesMenu:");
late final _sel_registerServicesMenuSendTypes_returnTypes_ =
    objc.registerName("registerServicesMenuSendTypes:returnTypes:");
final _objc_msgSend_352 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        void Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>();
late final _sel_servicesProvider = objc.registerName("servicesProvider");
late final _sel_setServicesProvider_ =
    objc.registerName("setServicesProvider:");
late final _sel_orderFrontStandardAboutPanel_ =
    objc.registerName("orderFrontStandardAboutPanel:");
late final _sel_orderFrontStandardAboutPanelWithOptions_ =
    objc.registerName("orderFrontStandardAboutPanelWithOptions:");
final _objc_msgSend_353 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<objc.ObjCObject>)>();
late final _sel_disableRelaunchOnLogin =
    objc.registerName("disableRelaunchOnLogin");
late final _sel_enableRelaunchOnLogin =
    objc.registerName("enableRelaunchOnLogin");
late final _sel_registerForRemoteNotifications =
    objc.registerName("registerForRemoteNotifications");
late final _sel_unregisterForRemoteNotifications =
    objc.registerName("unregisterForRemoteNotifications");
late final _sel_isRegisteredForRemoteNotifications =
    objc.registerName("isRegisteredForRemoteNotifications");

/// Soft deprecated.
/// Please use `NSApplication`'s `-registerForRemoteNotifications` along with `-requestAuthorizationWithOptions:` from the `UserNotifications.framework` to specify allowable notification types.
enum NSRemoteNotificationType {
  NSRemoteNotificationTypeNone(0),
  NSRemoteNotificationTypeBadge(1),
  NSRemoteNotificationTypeSound(2),
  NSRemoteNotificationTypeAlert(4);

  final int value;
  const NSRemoteNotificationType(this.value);

  static NSRemoteNotificationType fromValue(int value) => switch (value) {
        0 => NSRemoteNotificationTypeNone,
        1 => NSRemoteNotificationTypeBadge,
        2 => NSRemoteNotificationTypeSound,
        4 => NSRemoteNotificationTypeAlert,
        _ => throw ArgumentError(
            "Unknown value for NSRemoteNotificationType: $value"),
      };
}

late final _sel_registerForRemoteNotificationTypes_ =
    objc.registerName("registerForRemoteNotificationTypes:");
final _objc_msgSend_354 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, ffi.UnsignedLong)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, int)>();
late final _sel_enabledRemoteNotificationTypes =
    objc.registerName("enabledRemoteNotificationTypes");
final _objc_msgSend_355 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.UnsignedLong Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        int Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_runModalForWindow_relativeToWindow_ =
    objc.registerName("runModalForWindow:relativeToWindow:");
final _objc_msgSend_356 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Long Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        int Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>();
late final _sel_beginModalSessionForWindow_relativeToWindow_ =
    objc.registerName("beginModalSessionForWindow:relativeToWindow:");
final _objc_msgSend_357 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<_NSModalSession> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        ffi.Pointer<_NSModalSession> Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>();
late final _sel_application_printFiles_ =
    objc.registerName("application:printFiles:");
final _objc_msgSend_358 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        void Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>();
late final _sel_beginSheet_modalForWindow_modalDelegate_didEndSelector_contextInfo_ =
    objc.registerName(
        "beginSheet:modalForWindow:modalDelegate:didEndSelector:contextInfo:");
final _objc_msgSend_359 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<ffi.Void>)>>()
    .asFunction<
        void Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<ffi.Void>)>();
late final _sel_makeWindowsPerform_inOrder_ =
    objc.registerName("makeWindowsPerform:inOrder:");
final _objc_msgSend_360 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Bool)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCSelector>,
            bool)>();

/// NSApplicationDelegate
abstract final class NSApplicationDelegate {
  /// Builds an object that implements the NSApplicationDelegate protocol. To implement
  /// multiple protocols, use [addToBuilder] or [objc.ObjCProtocolBuilder] directly.
  static objc.ObjCObjectBase implement(
      {NSApplicationTerminateReply Function(NSApplication)?
          applicationShouldTerminate_,
      void Function(NSApplication, objc.ObjCObjectBase)? application_openURLs_,
      bool Function(NSApplication, objc.NSString)? application_openFile_,
      void Function(NSApplication, objc.ObjCObjectBase)? application_openFiles_,
      bool Function(NSApplication, objc.NSString)? application_openTempFile_,
      bool Function(NSApplication)? applicationShouldOpenUntitledFile_,
      bool Function(NSApplication)? applicationOpenUntitledFile_,
      bool Function(objc.ObjCObjectBase, objc.NSString)?
          application_openFileWithoutUI_,
      bool Function(NSApplication, objc.NSString)? application_printFile_,
      NSApplicationPrintReply Function(
              NSApplication, objc.ObjCObjectBase, objc.NSDictionary, bool)?
          application_printFiles_withSettings_showPrintPanels_,
      bool Function(NSApplication)?
          applicationShouldTerminateAfterLastWindowClosed_,
      bool Function(NSApplication, bool)?
          applicationShouldHandleReopen_hasVisibleWindows_,
      NSMenu? Function(NSApplication)? applicationDockMenu_,
      objc.NSError Function(NSApplication, objc.NSError)?
          application_willPresentError_,
      void Function(NSApplication, objc.NSData)?
          application_didRegisterForRemoteNotificationsWithDeviceToken_,
      void Function(NSApplication, objc.NSError)?
          application_didFailToRegisterForRemoteNotificationsWithError_,
      void Function(NSApplication, objc.NSDictionary)?
          application_didReceiveRemoteNotification_,
      bool Function(NSApplication)? applicationSupportsSecureRestorableState_,
      objc.ObjCObjectBase? Function(NSApplication, INIntent)?
          application_handlerForIntent_,
      void Function(NSApplication, objc.NSCoder)?
          application_willEncodeRestorableState_,
      void Function(NSApplication, objc.NSCoder)?
          application_didDecodeRestorableState_,
      bool Function(NSApplication, objc.NSString)?
          application_willContinueUserActivityWithType_,
      bool Function(NSApplication, NSUserActivity, ObjCBlock_ffiVoid_NSArray)?
          application_continueUserActivity_restorationHandler_,
      void Function(NSApplication, objc.NSString, objc.NSError)?
          application_didFailToContinueUserActivityWithType_error_,
      void Function(NSApplication, NSUserActivity)?
          application_didUpdateUserActivity_,
      void Function(NSApplication, CKShareMetadata)?
          application_userDidAcceptCloudKitShareWithMetadata_,
      bool Function(NSApplication, objc.NSString)?
          application_delegateHandlesKey_,
      bool Function(NSApplication)?
          applicationShouldAutomaticallyLocalizeKeyEquivalents_,
      void Function(objc.NSNotification)? applicationWillFinishLaunching_,
      void Function(objc.NSNotification)? applicationDidFinishLaunching_,
      void Function(objc.NSNotification)? applicationWillHide_,
      void Function(objc.NSNotification)? applicationDidHide_,
      void Function(objc.NSNotification)? applicationWillUnhide_,
      void Function(objc.NSNotification)? applicationDidUnhide_,
      void Function(objc.NSNotification)? applicationWillBecomeActive_,
      void Function(objc.NSNotification)? applicationDidBecomeActive_,
      void Function(objc.NSNotification)? applicationWillResignActive_,
      void Function(objc.NSNotification)? applicationDidResignActive_,
      void Function(objc.NSNotification)? applicationWillUpdate_,
      void Function(objc.NSNotification)? applicationDidUpdate_,
      void Function(objc.NSNotification)? applicationWillTerminate_,
      void Function(objc.NSNotification)? applicationDidChangeScreenParameters_,
      void Function(objc.NSNotification)? applicationDidChangeOcclusionState_,
      void Function(objc.NSNotification)? applicationProtectedDataWillBecomeUnavailable_,
      void Function(objc.NSNotification)? applicationProtectedDataDidBecomeAvailable_}) {
    final builder = objc.ObjCProtocolBuilder();
    NSApplicationDelegate.applicationShouldTerminate_
        .implement(builder, applicationShouldTerminate_);
    NSApplicationDelegate.application_openURLs_
        .implement(builder, application_openURLs_);
    NSApplicationDelegate.application_openFile_
        .implement(builder, application_openFile_);
    NSApplicationDelegate.application_openFiles_
        .implement(builder, application_openFiles_);
    NSApplicationDelegate.application_openTempFile_
        .implement(builder, application_openTempFile_);
    NSApplicationDelegate.applicationShouldOpenUntitledFile_
        .implement(builder, applicationShouldOpenUntitledFile_);
    NSApplicationDelegate.applicationOpenUntitledFile_
        .implement(builder, applicationOpenUntitledFile_);
    NSApplicationDelegate.application_openFileWithoutUI_
        .implement(builder, application_openFileWithoutUI_);
    NSApplicationDelegate.application_printFile_
        .implement(builder, application_printFile_);
    NSApplicationDelegate.application_printFiles_withSettings_showPrintPanels_
        .implement(
            builder, application_printFiles_withSettings_showPrintPanels_);
    NSApplicationDelegate.applicationShouldTerminateAfterLastWindowClosed_
        .implement(builder, applicationShouldTerminateAfterLastWindowClosed_);
    NSApplicationDelegate.applicationShouldHandleReopen_hasVisibleWindows_
        .implement(builder, applicationShouldHandleReopen_hasVisibleWindows_);
    NSApplicationDelegate.applicationDockMenu_
        .implement(builder, applicationDockMenu_);
    NSApplicationDelegate.application_willPresentError_
        .implement(builder, application_willPresentError_);
    NSApplicationDelegate
        .application_didRegisterForRemoteNotificationsWithDeviceToken_
        .implement(builder,
            application_didRegisterForRemoteNotificationsWithDeviceToken_);
    NSApplicationDelegate
        .application_didFailToRegisterForRemoteNotificationsWithError_
        .implement(builder,
            application_didFailToRegisterForRemoteNotificationsWithError_);
    NSApplicationDelegate.application_didReceiveRemoteNotification_
        .implement(builder, application_didReceiveRemoteNotification_);
    NSApplicationDelegate.applicationSupportsSecureRestorableState_
        .implement(builder, applicationSupportsSecureRestorableState_);
    NSApplicationDelegate.application_handlerForIntent_
        .implement(builder, application_handlerForIntent_);
    NSApplicationDelegate.application_willEncodeRestorableState_
        .implement(builder, application_willEncodeRestorableState_);
    NSApplicationDelegate.application_didDecodeRestorableState_
        .implement(builder, application_didDecodeRestorableState_);
    NSApplicationDelegate.application_willContinueUserActivityWithType_
        .implement(builder, application_willContinueUserActivityWithType_);
    NSApplicationDelegate.application_continueUserActivity_restorationHandler_
        .implement(
            builder, application_continueUserActivity_restorationHandler_);
    NSApplicationDelegate
        .application_didFailToContinueUserActivityWithType_error_
        .implement(
            builder, application_didFailToContinueUserActivityWithType_error_);
    NSApplicationDelegate.application_didUpdateUserActivity_
        .implement(builder, application_didUpdateUserActivity_);
    NSApplicationDelegate.application_userDidAcceptCloudKitShareWithMetadata_
        .implement(
            builder, application_userDidAcceptCloudKitShareWithMetadata_);
    NSApplicationDelegate.application_delegateHandlesKey_
        .implement(builder, application_delegateHandlesKey_);
    NSApplicationDelegate.applicationShouldAutomaticallyLocalizeKeyEquivalents_
        .implement(
            builder, applicationShouldAutomaticallyLocalizeKeyEquivalents_);
    NSApplicationDelegate.applicationWillFinishLaunching_
        .implement(builder, applicationWillFinishLaunching_);
    NSApplicationDelegate.applicationDidFinishLaunching_
        .implement(builder, applicationDidFinishLaunching_);
    NSApplicationDelegate.applicationWillHide_
        .implement(builder, applicationWillHide_);
    NSApplicationDelegate.applicationDidHide_
        .implement(builder, applicationDidHide_);
    NSApplicationDelegate.applicationWillUnhide_
        .implement(builder, applicationWillUnhide_);
    NSApplicationDelegate.applicationDidUnhide_
        .implement(builder, applicationDidUnhide_);
    NSApplicationDelegate.applicationWillBecomeActive_
        .implement(builder, applicationWillBecomeActive_);
    NSApplicationDelegate.applicationDidBecomeActive_
        .implement(builder, applicationDidBecomeActive_);
    NSApplicationDelegate.applicationWillResignActive_
        .implement(builder, applicationWillResignActive_);
    NSApplicationDelegate.applicationDidResignActive_
        .implement(builder, applicationDidResignActive_);
    NSApplicationDelegate.applicationWillUpdate_
        .implement(builder, applicationWillUpdate_);
    NSApplicationDelegate.applicationDidUpdate_
        .implement(builder, applicationDidUpdate_);
    NSApplicationDelegate.applicationWillTerminate_
        .implement(builder, applicationWillTerminate_);
    NSApplicationDelegate.applicationDidChangeScreenParameters_
        .implement(builder, applicationDidChangeScreenParameters_);
    NSApplicationDelegate.applicationDidChangeOcclusionState_
        .implement(builder, applicationDidChangeOcclusionState_);
    NSApplicationDelegate.applicationProtectedDataWillBecomeUnavailable_
        .implement(builder, applicationProtectedDataWillBecomeUnavailable_);
    NSApplicationDelegate.applicationProtectedDataDidBecomeAvailable_
        .implement(builder, applicationProtectedDataDidBecomeAvailable_);
    return builder.build();
  }

  /// Adds the implementation of the NSApplicationDelegate protocol to an existing
  /// [objc.ObjCProtocolBuilder].
  static void addToBuilder(objc.ObjCProtocolBuilder builder,
      {NSApplicationTerminateReply Function(NSApplication)?
          applicationShouldTerminate_,
      void Function(NSApplication, objc.ObjCObjectBase)? application_openURLs_,
      bool Function(NSApplication, objc.NSString)? application_openFile_,
      void Function(NSApplication, objc.ObjCObjectBase)? application_openFiles_,
      bool Function(NSApplication, objc.NSString)? application_openTempFile_,
      bool Function(NSApplication)? applicationShouldOpenUntitledFile_,
      bool Function(NSApplication)? applicationOpenUntitledFile_,
      bool Function(objc.ObjCObjectBase, objc.NSString)?
          application_openFileWithoutUI_,
      bool Function(NSApplication, objc.NSString)? application_printFile_,
      NSApplicationPrintReply Function(
              NSApplication, objc.ObjCObjectBase, objc.NSDictionary, bool)?
          application_printFiles_withSettings_showPrintPanels_,
      bool Function(NSApplication)?
          applicationShouldTerminateAfterLastWindowClosed_,
      bool Function(NSApplication, bool)?
          applicationShouldHandleReopen_hasVisibleWindows_,
      NSMenu? Function(NSApplication)? applicationDockMenu_,
      objc.NSError Function(NSApplication, objc.NSError)?
          application_willPresentError_,
      void Function(NSApplication, objc.NSData)?
          application_didRegisterForRemoteNotificationsWithDeviceToken_,
      void Function(NSApplication, objc.NSError)?
          application_didFailToRegisterForRemoteNotificationsWithError_,
      void Function(NSApplication, objc.NSDictionary)?
          application_didReceiveRemoteNotification_,
      bool Function(NSApplication)? applicationSupportsSecureRestorableState_,
      objc.ObjCObjectBase? Function(NSApplication, INIntent)?
          application_handlerForIntent_,
      void Function(NSApplication, objc.NSCoder)?
          application_willEncodeRestorableState_,
      void Function(NSApplication, objc.NSCoder)?
          application_didDecodeRestorableState_,
      bool Function(NSApplication, objc.NSString)?
          application_willContinueUserActivityWithType_,
      bool Function(NSApplication, NSUserActivity, ObjCBlock_ffiVoid_NSArray)?
          application_continueUserActivity_restorationHandler_,
      void Function(NSApplication, objc.NSString, objc.NSError)?
          application_didFailToContinueUserActivityWithType_error_,
      void Function(NSApplication, NSUserActivity)?
          application_didUpdateUserActivity_,
      void Function(NSApplication, CKShareMetadata)?
          application_userDidAcceptCloudKitShareWithMetadata_,
      bool Function(NSApplication, objc.NSString)?
          application_delegateHandlesKey_,
      bool Function(NSApplication)?
          applicationShouldAutomaticallyLocalizeKeyEquivalents_,
      void Function(objc.NSNotification)? applicationWillFinishLaunching_,
      void Function(objc.NSNotification)? applicationDidFinishLaunching_,
      void Function(objc.NSNotification)? applicationWillHide_,
      void Function(objc.NSNotification)? applicationDidHide_,
      void Function(objc.NSNotification)? applicationWillUnhide_,
      void Function(objc.NSNotification)? applicationDidUnhide_,
      void Function(objc.NSNotification)? applicationWillBecomeActive_,
      void Function(objc.NSNotification)? applicationDidBecomeActive_,
      void Function(objc.NSNotification)? applicationWillResignActive_,
      void Function(objc.NSNotification)? applicationDidResignActive_,
      void Function(objc.NSNotification)? applicationWillUpdate_,
      void Function(objc.NSNotification)? applicationDidUpdate_,
      void Function(objc.NSNotification)? applicationWillTerminate_,
      void Function(objc.NSNotification)? applicationDidChangeScreenParameters_,
      void Function(objc.NSNotification)? applicationDidChangeOcclusionState_,
      void Function(objc.NSNotification)? applicationProtectedDataWillBecomeUnavailable_,
      void Function(objc.NSNotification)? applicationProtectedDataDidBecomeAvailable_}) {
    NSApplicationDelegate.applicationShouldTerminate_
        .implement(builder, applicationShouldTerminate_);
    NSApplicationDelegate.application_openURLs_
        .implement(builder, application_openURLs_);
    NSApplicationDelegate.application_openFile_
        .implement(builder, application_openFile_);
    NSApplicationDelegate.application_openFiles_
        .implement(builder, application_openFiles_);
    NSApplicationDelegate.application_openTempFile_
        .implement(builder, application_openTempFile_);
    NSApplicationDelegate.applicationShouldOpenUntitledFile_
        .implement(builder, applicationShouldOpenUntitledFile_);
    NSApplicationDelegate.applicationOpenUntitledFile_
        .implement(builder, applicationOpenUntitledFile_);
    NSApplicationDelegate.application_openFileWithoutUI_
        .implement(builder, application_openFileWithoutUI_);
    NSApplicationDelegate.application_printFile_
        .implement(builder, application_printFile_);
    NSApplicationDelegate.application_printFiles_withSettings_showPrintPanels_
        .implement(
            builder, application_printFiles_withSettings_showPrintPanels_);
    NSApplicationDelegate.applicationShouldTerminateAfterLastWindowClosed_
        .implement(builder, applicationShouldTerminateAfterLastWindowClosed_);
    NSApplicationDelegate.applicationShouldHandleReopen_hasVisibleWindows_
        .implement(builder, applicationShouldHandleReopen_hasVisibleWindows_);
    NSApplicationDelegate.applicationDockMenu_
        .implement(builder, applicationDockMenu_);
    NSApplicationDelegate.application_willPresentError_
        .implement(builder, application_willPresentError_);
    NSApplicationDelegate
        .application_didRegisterForRemoteNotificationsWithDeviceToken_
        .implement(builder,
            application_didRegisterForRemoteNotificationsWithDeviceToken_);
    NSApplicationDelegate
        .application_didFailToRegisterForRemoteNotificationsWithError_
        .implement(builder,
            application_didFailToRegisterForRemoteNotificationsWithError_);
    NSApplicationDelegate.application_didReceiveRemoteNotification_
        .implement(builder, application_didReceiveRemoteNotification_);
    NSApplicationDelegate.applicationSupportsSecureRestorableState_
        .implement(builder, applicationSupportsSecureRestorableState_);
    NSApplicationDelegate.application_handlerForIntent_
        .implement(builder, application_handlerForIntent_);
    NSApplicationDelegate.application_willEncodeRestorableState_
        .implement(builder, application_willEncodeRestorableState_);
    NSApplicationDelegate.application_didDecodeRestorableState_
        .implement(builder, application_didDecodeRestorableState_);
    NSApplicationDelegate.application_willContinueUserActivityWithType_
        .implement(builder, application_willContinueUserActivityWithType_);
    NSApplicationDelegate.application_continueUserActivity_restorationHandler_
        .implement(
            builder, application_continueUserActivity_restorationHandler_);
    NSApplicationDelegate
        .application_didFailToContinueUserActivityWithType_error_
        .implement(
            builder, application_didFailToContinueUserActivityWithType_error_);
    NSApplicationDelegate.application_didUpdateUserActivity_
        .implement(builder, application_didUpdateUserActivity_);
    NSApplicationDelegate.application_userDidAcceptCloudKitShareWithMetadata_
        .implement(
            builder, application_userDidAcceptCloudKitShareWithMetadata_);
    NSApplicationDelegate.application_delegateHandlesKey_
        .implement(builder, application_delegateHandlesKey_);
    NSApplicationDelegate.applicationShouldAutomaticallyLocalizeKeyEquivalents_
        .implement(
            builder, applicationShouldAutomaticallyLocalizeKeyEquivalents_);
    NSApplicationDelegate.applicationWillFinishLaunching_
        .implement(builder, applicationWillFinishLaunching_);
    NSApplicationDelegate.applicationDidFinishLaunching_
        .implement(builder, applicationDidFinishLaunching_);
    NSApplicationDelegate.applicationWillHide_
        .implement(builder, applicationWillHide_);
    NSApplicationDelegate.applicationDidHide_
        .implement(builder, applicationDidHide_);
    NSApplicationDelegate.applicationWillUnhide_
        .implement(builder, applicationWillUnhide_);
    NSApplicationDelegate.applicationDidUnhide_
        .implement(builder, applicationDidUnhide_);
    NSApplicationDelegate.applicationWillBecomeActive_
        .implement(builder, applicationWillBecomeActive_);
    NSApplicationDelegate.applicationDidBecomeActive_
        .implement(builder, applicationDidBecomeActive_);
    NSApplicationDelegate.applicationWillResignActive_
        .implement(builder, applicationWillResignActive_);
    NSApplicationDelegate.applicationDidResignActive_
        .implement(builder, applicationDidResignActive_);
    NSApplicationDelegate.applicationWillUpdate_
        .implement(builder, applicationWillUpdate_);
    NSApplicationDelegate.applicationDidUpdate_
        .implement(builder, applicationDidUpdate_);
    NSApplicationDelegate.applicationWillTerminate_
        .implement(builder, applicationWillTerminate_);
    NSApplicationDelegate.applicationDidChangeScreenParameters_
        .implement(builder, applicationDidChangeScreenParameters_);
    NSApplicationDelegate.applicationDidChangeOcclusionState_
        .implement(builder, applicationDidChangeOcclusionState_);
    NSApplicationDelegate.applicationProtectedDataWillBecomeUnavailable_
        .implement(builder, applicationProtectedDataWillBecomeUnavailable_);
    NSApplicationDelegate.applicationProtectedDataDidBecomeAvailable_
        .implement(builder, applicationProtectedDataDidBecomeAvailable_);
  }

  /// Builds an object that implements the NSApplicationDelegate protocol. To implement
  /// multiple protocols, use [addToBuilder] or [objc.ObjCProtocolBuilder] directly. All
  /// methods that can be implemented as listeners will be.
  static objc.ObjCObjectBase implementAsListener(
      {NSApplicationTerminateReply Function(NSApplication)?
          applicationShouldTerminate_,
      void Function(NSApplication, objc.ObjCObjectBase)? application_openURLs_,
      bool Function(NSApplication, objc.NSString)? application_openFile_,
      void Function(NSApplication, objc.ObjCObjectBase)? application_openFiles_,
      bool Function(NSApplication, objc.NSString)? application_openTempFile_,
      bool Function(NSApplication)? applicationShouldOpenUntitledFile_,
      bool Function(NSApplication)? applicationOpenUntitledFile_,
      bool Function(objc.ObjCObjectBase, objc.NSString)?
          application_openFileWithoutUI_,
      bool Function(NSApplication, objc.NSString)? application_printFile_,
      NSApplicationPrintReply Function(
              NSApplication, objc.ObjCObjectBase, objc.NSDictionary, bool)?
          application_printFiles_withSettings_showPrintPanels_,
      bool Function(NSApplication)?
          applicationShouldTerminateAfterLastWindowClosed_,
      bool Function(NSApplication, bool)?
          applicationShouldHandleReopen_hasVisibleWindows_,
      NSMenu? Function(NSApplication)? applicationDockMenu_,
      objc.NSError Function(NSApplication, objc.NSError)?
          application_willPresentError_,
      void Function(NSApplication, objc.NSData)?
          application_didRegisterForRemoteNotificationsWithDeviceToken_,
      void Function(NSApplication, objc.NSError)?
          application_didFailToRegisterForRemoteNotificationsWithError_,
      void Function(NSApplication, objc.NSDictionary)?
          application_didReceiveRemoteNotification_,
      bool Function(NSApplication)? applicationSupportsSecureRestorableState_,
      objc.ObjCObjectBase? Function(NSApplication, INIntent)?
          application_handlerForIntent_,
      void Function(NSApplication, objc.NSCoder)?
          application_willEncodeRestorableState_,
      void Function(NSApplication, objc.NSCoder)?
          application_didDecodeRestorableState_,
      bool Function(NSApplication, objc.NSString)?
          application_willContinueUserActivityWithType_,
      bool Function(NSApplication, NSUserActivity, ObjCBlock_ffiVoid_NSArray)?
          application_continueUserActivity_restorationHandler_,
      void Function(NSApplication, objc.NSString, objc.NSError)?
          application_didFailToContinueUserActivityWithType_error_,
      void Function(NSApplication, NSUserActivity)?
          application_didUpdateUserActivity_,
      void Function(NSApplication, CKShareMetadata)?
          application_userDidAcceptCloudKitShareWithMetadata_,
      bool Function(NSApplication, objc.NSString)?
          application_delegateHandlesKey_,
      bool Function(NSApplication)?
          applicationShouldAutomaticallyLocalizeKeyEquivalents_,
      void Function(objc.NSNotification)? applicationWillFinishLaunching_,
      void Function(objc.NSNotification)? applicationDidFinishLaunching_,
      void Function(objc.NSNotification)? applicationWillHide_,
      void Function(objc.NSNotification)? applicationDidHide_,
      void Function(objc.NSNotification)? applicationWillUnhide_,
      void Function(objc.NSNotification)? applicationDidUnhide_,
      void Function(objc.NSNotification)? applicationWillBecomeActive_,
      void Function(objc.NSNotification)? applicationDidBecomeActive_,
      void Function(objc.NSNotification)? applicationWillResignActive_,
      void Function(objc.NSNotification)? applicationDidResignActive_,
      void Function(objc.NSNotification)? applicationWillUpdate_,
      void Function(objc.NSNotification)? applicationDidUpdate_,
      void Function(objc.NSNotification)? applicationWillTerminate_,
      void Function(objc.NSNotification)? applicationDidChangeScreenParameters_,
      void Function(objc.NSNotification)? applicationDidChangeOcclusionState_,
      void Function(objc.NSNotification)? applicationProtectedDataWillBecomeUnavailable_,
      void Function(objc.NSNotification)? applicationProtectedDataDidBecomeAvailable_}) {
    final builder = objc.ObjCProtocolBuilder();
    NSApplicationDelegate.applicationShouldTerminate_
        .implement(builder, applicationShouldTerminate_);
    NSApplicationDelegate.application_openURLs_
        .implementAsListener(builder, application_openURLs_);
    NSApplicationDelegate.application_openFile_
        .implement(builder, application_openFile_);
    NSApplicationDelegate.application_openFiles_
        .implementAsListener(builder, application_openFiles_);
    NSApplicationDelegate.application_openTempFile_
        .implement(builder, application_openTempFile_);
    NSApplicationDelegate.applicationShouldOpenUntitledFile_
        .implement(builder, applicationShouldOpenUntitledFile_);
    NSApplicationDelegate.applicationOpenUntitledFile_
        .implement(builder, applicationOpenUntitledFile_);
    NSApplicationDelegate.application_openFileWithoutUI_
        .implement(builder, application_openFileWithoutUI_);
    NSApplicationDelegate.application_printFile_
        .implement(builder, application_printFile_);
    NSApplicationDelegate.application_printFiles_withSettings_showPrintPanels_
        .implement(
            builder, application_printFiles_withSettings_showPrintPanels_);
    NSApplicationDelegate.applicationShouldTerminateAfterLastWindowClosed_
        .implement(builder, applicationShouldTerminateAfterLastWindowClosed_);
    NSApplicationDelegate.applicationShouldHandleReopen_hasVisibleWindows_
        .implement(builder, applicationShouldHandleReopen_hasVisibleWindows_);
    NSApplicationDelegate.applicationDockMenu_
        .implement(builder, applicationDockMenu_);
    NSApplicationDelegate.application_willPresentError_
        .implement(builder, application_willPresentError_);
    NSApplicationDelegate
        .application_didRegisterForRemoteNotificationsWithDeviceToken_
        .implementAsListener(builder,
            application_didRegisterForRemoteNotificationsWithDeviceToken_);
    NSApplicationDelegate
        .application_didFailToRegisterForRemoteNotificationsWithError_
        .implementAsListener(builder,
            application_didFailToRegisterForRemoteNotificationsWithError_);
    NSApplicationDelegate.application_didReceiveRemoteNotification_
        .implementAsListener(
            builder, application_didReceiveRemoteNotification_);
    NSApplicationDelegate.applicationSupportsSecureRestorableState_
        .implement(builder, applicationSupportsSecureRestorableState_);
    NSApplicationDelegate.application_handlerForIntent_
        .implement(builder, application_handlerForIntent_);
    NSApplicationDelegate.application_willEncodeRestorableState_
        .implementAsListener(builder, application_willEncodeRestorableState_);
    NSApplicationDelegate.application_didDecodeRestorableState_
        .implementAsListener(builder, application_didDecodeRestorableState_);
    NSApplicationDelegate.application_willContinueUserActivityWithType_
        .implement(builder, application_willContinueUserActivityWithType_);
    NSApplicationDelegate.application_continueUserActivity_restorationHandler_
        .implement(
            builder, application_continueUserActivity_restorationHandler_);
    NSApplicationDelegate
        .application_didFailToContinueUserActivityWithType_error_
        .implementAsListener(
            builder, application_didFailToContinueUserActivityWithType_error_);
    NSApplicationDelegate.application_didUpdateUserActivity_
        .implementAsListener(builder, application_didUpdateUserActivity_);
    NSApplicationDelegate.application_userDidAcceptCloudKitShareWithMetadata_
        .implementAsListener(
            builder, application_userDidAcceptCloudKitShareWithMetadata_);
    NSApplicationDelegate.application_delegateHandlesKey_
        .implement(builder, application_delegateHandlesKey_);
    NSApplicationDelegate.applicationShouldAutomaticallyLocalizeKeyEquivalents_
        .implement(
            builder, applicationShouldAutomaticallyLocalizeKeyEquivalents_);
    NSApplicationDelegate.applicationWillFinishLaunching_
        .implementAsListener(builder, applicationWillFinishLaunching_);
    NSApplicationDelegate.applicationDidFinishLaunching_
        .implementAsListener(builder, applicationDidFinishLaunching_);
    NSApplicationDelegate.applicationWillHide_
        .implementAsListener(builder, applicationWillHide_);
    NSApplicationDelegate.applicationDidHide_
        .implementAsListener(builder, applicationDidHide_);
    NSApplicationDelegate.applicationWillUnhide_
        .implementAsListener(builder, applicationWillUnhide_);
    NSApplicationDelegate.applicationDidUnhide_
        .implementAsListener(builder, applicationDidUnhide_);
    NSApplicationDelegate.applicationWillBecomeActive_
        .implementAsListener(builder, applicationWillBecomeActive_);
    NSApplicationDelegate.applicationDidBecomeActive_
        .implementAsListener(builder, applicationDidBecomeActive_);
    NSApplicationDelegate.applicationWillResignActive_
        .implementAsListener(builder, applicationWillResignActive_);
    NSApplicationDelegate.applicationDidResignActive_
        .implementAsListener(builder, applicationDidResignActive_);
    NSApplicationDelegate.applicationWillUpdate_
        .implementAsListener(builder, applicationWillUpdate_);
    NSApplicationDelegate.applicationDidUpdate_
        .implementAsListener(builder, applicationDidUpdate_);
    NSApplicationDelegate.applicationWillTerminate_
        .implementAsListener(builder, applicationWillTerminate_);
    NSApplicationDelegate.applicationDidChangeScreenParameters_
        .implementAsListener(builder, applicationDidChangeScreenParameters_);
    NSApplicationDelegate.applicationDidChangeOcclusionState_
        .implementAsListener(builder, applicationDidChangeOcclusionState_);
    NSApplicationDelegate.applicationProtectedDataWillBecomeUnavailable_
        .implementAsListener(
            builder, applicationProtectedDataWillBecomeUnavailable_);
    NSApplicationDelegate.applicationProtectedDataDidBecomeAvailable_
        .implementAsListener(
            builder, applicationProtectedDataDidBecomeAvailable_);
    return builder.build();
  }

  /// Adds the implementation of the NSApplicationDelegate protocol to an existing
  /// [objc.ObjCProtocolBuilder]. All methods that can be implemented as listeners will
  /// be.
  static void addToBuilderAsListener(objc.ObjCProtocolBuilder builder,
      {NSApplicationTerminateReply Function(NSApplication)?
          applicationShouldTerminate_,
      void Function(NSApplication, objc.ObjCObjectBase)? application_openURLs_,
      bool Function(NSApplication, objc.NSString)? application_openFile_,
      void Function(NSApplication, objc.ObjCObjectBase)? application_openFiles_,
      bool Function(NSApplication, objc.NSString)? application_openTempFile_,
      bool Function(NSApplication)? applicationShouldOpenUntitledFile_,
      bool Function(NSApplication)? applicationOpenUntitledFile_,
      bool Function(objc.ObjCObjectBase, objc.NSString)?
          application_openFileWithoutUI_,
      bool Function(NSApplication, objc.NSString)? application_printFile_,
      NSApplicationPrintReply Function(
              NSApplication, objc.ObjCObjectBase, objc.NSDictionary, bool)?
          application_printFiles_withSettings_showPrintPanels_,
      bool Function(NSApplication)?
          applicationShouldTerminateAfterLastWindowClosed_,
      bool Function(NSApplication, bool)?
          applicationShouldHandleReopen_hasVisibleWindows_,
      NSMenu? Function(NSApplication)? applicationDockMenu_,
      objc.NSError Function(NSApplication, objc.NSError)?
          application_willPresentError_,
      void Function(NSApplication, objc.NSData)?
          application_didRegisterForRemoteNotificationsWithDeviceToken_,
      void Function(NSApplication, objc.NSError)?
          application_didFailToRegisterForRemoteNotificationsWithError_,
      void Function(NSApplication, objc.NSDictionary)?
          application_didReceiveRemoteNotification_,
      bool Function(NSApplication)? applicationSupportsSecureRestorableState_,
      objc.ObjCObjectBase? Function(NSApplication, INIntent)?
          application_handlerForIntent_,
      void Function(NSApplication, objc.NSCoder)?
          application_willEncodeRestorableState_,
      void Function(NSApplication, objc.NSCoder)?
          application_didDecodeRestorableState_,
      bool Function(NSApplication, objc.NSString)?
          application_willContinueUserActivityWithType_,
      bool Function(NSApplication, NSUserActivity, ObjCBlock_ffiVoid_NSArray)?
          application_continueUserActivity_restorationHandler_,
      void Function(NSApplication, objc.NSString, objc.NSError)?
          application_didFailToContinueUserActivityWithType_error_,
      void Function(NSApplication, NSUserActivity)?
          application_didUpdateUserActivity_,
      void Function(NSApplication, CKShareMetadata)?
          application_userDidAcceptCloudKitShareWithMetadata_,
      bool Function(NSApplication, objc.NSString)?
          application_delegateHandlesKey_,
      bool Function(NSApplication)?
          applicationShouldAutomaticallyLocalizeKeyEquivalents_,
      void Function(objc.NSNotification)? applicationWillFinishLaunching_,
      void Function(objc.NSNotification)? applicationDidFinishLaunching_,
      void Function(objc.NSNotification)? applicationWillHide_,
      void Function(objc.NSNotification)? applicationDidHide_,
      void Function(objc.NSNotification)? applicationWillUnhide_,
      void Function(objc.NSNotification)? applicationDidUnhide_,
      void Function(objc.NSNotification)? applicationWillBecomeActive_,
      void Function(objc.NSNotification)? applicationDidBecomeActive_,
      void Function(objc.NSNotification)? applicationWillResignActive_,
      void Function(objc.NSNotification)? applicationDidResignActive_,
      void Function(objc.NSNotification)? applicationWillUpdate_,
      void Function(objc.NSNotification)? applicationDidUpdate_,
      void Function(objc.NSNotification)? applicationWillTerminate_,
      void Function(objc.NSNotification)? applicationDidChangeScreenParameters_,
      void Function(objc.NSNotification)? applicationDidChangeOcclusionState_,
      void Function(objc.NSNotification)? applicationProtectedDataWillBecomeUnavailable_,
      void Function(objc.NSNotification)? applicationProtectedDataDidBecomeAvailable_}) {
    NSApplicationDelegate.applicationShouldTerminate_
        .implement(builder, applicationShouldTerminate_);
    NSApplicationDelegate.application_openURLs_
        .implementAsListener(builder, application_openURLs_);
    NSApplicationDelegate.application_openFile_
        .implement(builder, application_openFile_);
    NSApplicationDelegate.application_openFiles_
        .implementAsListener(builder, application_openFiles_);
    NSApplicationDelegate.application_openTempFile_
        .implement(builder, application_openTempFile_);
    NSApplicationDelegate.applicationShouldOpenUntitledFile_
        .implement(builder, applicationShouldOpenUntitledFile_);
    NSApplicationDelegate.applicationOpenUntitledFile_
        .implement(builder, applicationOpenUntitledFile_);
    NSApplicationDelegate.application_openFileWithoutUI_
        .implement(builder, application_openFileWithoutUI_);
    NSApplicationDelegate.application_printFile_
        .implement(builder, application_printFile_);
    NSApplicationDelegate.application_printFiles_withSettings_showPrintPanels_
        .implement(
            builder, application_printFiles_withSettings_showPrintPanels_);
    NSApplicationDelegate.applicationShouldTerminateAfterLastWindowClosed_
        .implement(builder, applicationShouldTerminateAfterLastWindowClosed_);
    NSApplicationDelegate.applicationShouldHandleReopen_hasVisibleWindows_
        .implement(builder, applicationShouldHandleReopen_hasVisibleWindows_);
    NSApplicationDelegate.applicationDockMenu_
        .implement(builder, applicationDockMenu_);
    NSApplicationDelegate.application_willPresentError_
        .implement(builder, application_willPresentError_);
    NSApplicationDelegate
        .application_didRegisterForRemoteNotificationsWithDeviceToken_
        .implementAsListener(builder,
            application_didRegisterForRemoteNotificationsWithDeviceToken_);
    NSApplicationDelegate
        .application_didFailToRegisterForRemoteNotificationsWithError_
        .implementAsListener(builder,
            application_didFailToRegisterForRemoteNotificationsWithError_);
    NSApplicationDelegate.application_didReceiveRemoteNotification_
        .implementAsListener(
            builder, application_didReceiveRemoteNotification_);
    NSApplicationDelegate.applicationSupportsSecureRestorableState_
        .implement(builder, applicationSupportsSecureRestorableState_);
    NSApplicationDelegate.application_handlerForIntent_
        .implement(builder, application_handlerForIntent_);
    NSApplicationDelegate.application_willEncodeRestorableState_
        .implementAsListener(builder, application_willEncodeRestorableState_);
    NSApplicationDelegate.application_didDecodeRestorableState_
        .implementAsListener(builder, application_didDecodeRestorableState_);
    NSApplicationDelegate.application_willContinueUserActivityWithType_
        .implement(builder, application_willContinueUserActivityWithType_);
    NSApplicationDelegate.application_continueUserActivity_restorationHandler_
        .implement(
            builder, application_continueUserActivity_restorationHandler_);
    NSApplicationDelegate
        .application_didFailToContinueUserActivityWithType_error_
        .implementAsListener(
            builder, application_didFailToContinueUserActivityWithType_error_);
    NSApplicationDelegate.application_didUpdateUserActivity_
        .implementAsListener(builder, application_didUpdateUserActivity_);
    NSApplicationDelegate.application_userDidAcceptCloudKitShareWithMetadata_
        .implementAsListener(
            builder, application_userDidAcceptCloudKitShareWithMetadata_);
    NSApplicationDelegate.application_delegateHandlesKey_
        .implement(builder, application_delegateHandlesKey_);
    NSApplicationDelegate.applicationShouldAutomaticallyLocalizeKeyEquivalents_
        .implement(
            builder, applicationShouldAutomaticallyLocalizeKeyEquivalents_);
    NSApplicationDelegate.applicationWillFinishLaunching_
        .implementAsListener(builder, applicationWillFinishLaunching_);
    NSApplicationDelegate.applicationDidFinishLaunching_
        .implementAsListener(builder, applicationDidFinishLaunching_);
    NSApplicationDelegate.applicationWillHide_
        .implementAsListener(builder, applicationWillHide_);
    NSApplicationDelegate.applicationDidHide_
        .implementAsListener(builder, applicationDidHide_);
    NSApplicationDelegate.applicationWillUnhide_
        .implementAsListener(builder, applicationWillUnhide_);
    NSApplicationDelegate.applicationDidUnhide_
        .implementAsListener(builder, applicationDidUnhide_);
    NSApplicationDelegate.applicationWillBecomeActive_
        .implementAsListener(builder, applicationWillBecomeActive_);
    NSApplicationDelegate.applicationDidBecomeActive_
        .implementAsListener(builder, applicationDidBecomeActive_);
    NSApplicationDelegate.applicationWillResignActive_
        .implementAsListener(builder, applicationWillResignActive_);
    NSApplicationDelegate.applicationDidResignActive_
        .implementAsListener(builder, applicationDidResignActive_);
    NSApplicationDelegate.applicationWillUpdate_
        .implementAsListener(builder, applicationWillUpdate_);
    NSApplicationDelegate.applicationDidUpdate_
        .implementAsListener(builder, applicationDidUpdate_);
    NSApplicationDelegate.applicationWillTerminate_
        .implementAsListener(builder, applicationWillTerminate_);
    NSApplicationDelegate.applicationDidChangeScreenParameters_
        .implementAsListener(builder, applicationDidChangeScreenParameters_);
    NSApplicationDelegate.applicationDidChangeOcclusionState_
        .implementAsListener(builder, applicationDidChangeOcclusionState_);
    NSApplicationDelegate.applicationProtectedDataWillBecomeUnavailable_
        .implementAsListener(
            builder, applicationProtectedDataWillBecomeUnavailable_);
    NSApplicationDelegate.applicationProtectedDataDidBecomeAvailable_
        .implementAsListener(
            builder, applicationProtectedDataDidBecomeAvailable_);
  }

  /// Allowable return values are:
  /// @c NSTerminateNow - it is ok to proceed with termination
  /// @c NSTerminateCancel - the application should not be terminated
  /// @c NSTerminateLater - it may be ok to proceed with termination later.  The application must call `-replyToApplicationShouldTerminate:` with @c YES or @c NO once the answer is known
  /// @note This return value is for delegates who need to provide document modal alerts (sheets) in order to decide whether to quit.
  static final applicationShouldTerminate_ = objc.ObjCProtocolMethod<
      NSApplicationTerminateReply Function(NSApplication)>(
    _sel_applicationShouldTerminate_,
    objc.getProtocolMethodSignature(
      _protocol_NSApplicationDelegate,
      _sel_applicationShouldTerminate_,
      isRequired: false,
      isInstanceMethod: true,
    ),
    (NSApplicationTerminateReply Function(NSApplication) func) =>
        ObjCBlock_NSApplicationTerminateReply_ffiVoid_NSApplication
            .fromFunction(
                (ffi.Pointer<ffi.Void> _, NSApplication arg1) => func(arg1)),
  );

  /// This will be called for any URLs your application is asked to open. This includes URL types (CFBundleURLTypes) defined in your Info.plist, and Document types (@c CFBundleDocumentTypes) that have no associated @c NSDocument class. Document URLs that have an associated @c NSDocument class will be opened through @c NSDocumentController. If this is implemented, `-application:openFiles:` and `-application:openFile:` will not be called.
  static final application_openURLs_ = objc.ObjCProtocolListenableMethod<
      void Function(NSApplication, objc.ObjCObjectBase)>(
    _sel_application_openURLs_,
    objc.getProtocolMethodSignature(
      _protocol_NSApplicationDelegate,
      _sel_application_openURLs_,
      isRequired: false,
      isInstanceMethod: true,
    ),
    (void Function(NSApplication, objc.ObjCObjectBase) func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSApplication_objcObjCObject.fromFunction(
            (ffi.Pointer<ffi.Void> _, NSApplication arg1,
                    objc.ObjCObjectBase arg2) =>
                func(arg1, arg2)),
    (void Function(NSApplication, objc.ObjCObjectBase) func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSApplication_objcObjCObject.listener(
            (ffi.Pointer<ffi.Void> _, NSApplication arg1,
                    objc.ObjCObjectBase arg2) =>
                func(arg1, arg2)),
  );

  /// application:openFile:
  static final application_openFile_ =
      objc.ObjCProtocolMethod<bool Function(NSApplication, objc.NSString)>(
    _sel_application_openFile_,
    objc.getProtocolMethodSignature(
      _protocol_NSApplicationDelegate,
      _sel_application_openFile_,
      isRequired: false,
      isInstanceMethod: true,
    ),
    (bool Function(NSApplication, objc.NSString) func) =>
        ObjCBlock_bool_ffiVoid_NSApplication_NSString.fromFunction(
            (ffi.Pointer<ffi.Void> _, NSApplication arg1, objc.NSString arg2) =>
                func(arg1, arg2)),
  );

  /// application:openFiles:
  static final application_openFiles_ = objc.ObjCProtocolListenableMethod<
      void Function(NSApplication, objc.ObjCObjectBase)>(
    _sel_application_openFiles_,
    objc.getProtocolMethodSignature(
      _protocol_NSApplicationDelegate,
      _sel_application_openFiles_,
      isRequired: false,
      isInstanceMethod: true,
    ),
    (void Function(NSApplication, objc.ObjCObjectBase) func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSApplication_objcObjCObject.fromFunction(
            (ffi.Pointer<ffi.Void> _, NSApplication arg1,
                    objc.ObjCObjectBase arg2) =>
                func(arg1, arg2)),
    (void Function(NSApplication, objc.ObjCObjectBase) func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSApplication_objcObjCObject.listener(
            (ffi.Pointer<ffi.Void> _, NSApplication arg1,
                    objc.ObjCObjectBase arg2) =>
                func(arg1, arg2)),
  );

  /// application:openTempFile:
  static final application_openTempFile_ =
      objc.ObjCProtocolMethod<bool Function(NSApplication, objc.NSString)>(
    _sel_application_openTempFile_,
    objc.getProtocolMethodSignature(
      _protocol_NSApplicationDelegate,
      _sel_application_openTempFile_,
      isRequired: false,
      isInstanceMethod: true,
    ),
    (bool Function(NSApplication, objc.NSString) func) =>
        ObjCBlock_bool_ffiVoid_NSApplication_NSString.fromFunction(
            (ffi.Pointer<ffi.Void> _, NSApplication arg1, objc.NSString arg2) =>
                func(arg1, arg2)),
  );

  /// applicationShouldOpenUntitledFile:
  static final applicationShouldOpenUntitledFile_ =
      objc.ObjCProtocolMethod<bool Function(NSApplication)>(
    _sel_applicationShouldOpenUntitledFile_,
    objc.getProtocolMethodSignature(
      _protocol_NSApplicationDelegate,
      _sel_applicationShouldOpenUntitledFile_,
      isRequired: false,
      isInstanceMethod: true,
    ),
    (bool Function(NSApplication) func) =>
        ObjCBlock_bool_ffiVoid_NSApplication.fromFunction(
            (ffi.Pointer<ffi.Void> _, NSApplication arg1) => func(arg1)),
  );

  /// applicationOpenUntitledFile:
  static final applicationOpenUntitledFile_ =
      objc.ObjCProtocolMethod<bool Function(NSApplication)>(
    _sel_applicationOpenUntitledFile_,
    objc.getProtocolMethodSignature(
      _protocol_NSApplicationDelegate,
      _sel_applicationOpenUntitledFile_,
      isRequired: false,
      isInstanceMethod: true,
    ),
    (bool Function(NSApplication) func) =>
        ObjCBlock_bool_ffiVoid_NSApplication.fromFunction(
            (ffi.Pointer<ffi.Void> _, NSApplication arg1) => func(arg1)),
  );

  /// application:openFileWithoutUI:
  static final application_openFileWithoutUI_ = objc.ObjCProtocolMethod<
      bool Function(objc.ObjCObjectBase, objc.NSString)>(
    _sel_application_openFileWithoutUI_,
    objc.getProtocolMethodSignature(
      _protocol_NSApplicationDelegate,
      _sel_application_openFileWithoutUI_,
      isRequired: false,
      isInstanceMethod: true,
    ),
    (bool Function(objc.ObjCObjectBase, objc.NSString) func) =>
        ObjCBlock_bool_ffiVoid_objcObjCObject_NSString.fromFunction(
            (ffi.Pointer<ffi.Void> _, objc.ObjCObjectBase arg1,
                    objc.NSString arg2) =>
                func(arg1, arg2)),
  );

  /// application:printFile:
  static final application_printFile_ =
      objc.ObjCProtocolMethod<bool Function(NSApplication, objc.NSString)>(
    _sel_application_printFile_,
    objc.getProtocolMethodSignature(
      _protocol_NSApplicationDelegate,
      _sel_application_printFile_,
      isRequired: false,
      isInstanceMethod: true,
    ),
    (bool Function(NSApplication, objc.NSString) func) =>
        ObjCBlock_bool_ffiVoid_NSApplication_NSString.fromFunction(
            (ffi.Pointer<ffi.Void> _, NSApplication arg1, objc.NSString arg2) =>
                func(arg1, arg2)),
  );

  /// application:printFiles:withSettings:showPrintPanels:
  static final application_printFiles_withSettings_showPrintPanels_ =
      objc.ObjCProtocolMethod<
          NSApplicationPrintReply Function(
              NSApplication, objc.ObjCObjectBase, objc.NSDictionary, bool)>(
    _sel_application_printFiles_withSettings_showPrintPanels_,
    objc.getProtocolMethodSignature(
      _protocol_NSApplicationDelegate,
      _sel_application_printFiles_withSettings_showPrintPanels_,
      isRequired: false,
      isInstanceMethod: true,
    ),
    (NSApplicationPrintReply Function(
                NSApplication, objc.ObjCObjectBase, objc.NSDictionary, bool)
            func) =>
        ObjCBlock_NSApplicationPrintReply_ffiVoid_NSApplication_objcObjCObject_NSDictionary_bool
            .fromFunction((ffi.Pointer<ffi.Void> _,
                    NSApplication arg1,
                    objc.ObjCObjectBase arg2,
                    objc.NSDictionary arg3,
                    bool arg4) =>
                func(arg1, arg2, arg3, arg4)),
  );

  /// applicationShouldTerminateAfterLastWindowClosed:
  static final applicationShouldTerminateAfterLastWindowClosed_ =
      objc.ObjCProtocolMethod<bool Function(NSApplication)>(
    _sel_applicationShouldTerminateAfterLastWindowClosed_,
    objc.getProtocolMethodSignature(
      _protocol_NSApplicationDelegate,
      _sel_applicationShouldTerminateAfterLastWindowClosed_,
      isRequired: false,
      isInstanceMethod: true,
    ),
    (bool Function(NSApplication) func) =>
        ObjCBlock_bool_ffiVoid_NSApplication.fromFunction(
            (ffi.Pointer<ffi.Void> _, NSApplication arg1) => func(arg1)),
  );

  /// applicationShouldHandleReopen:hasVisibleWindows:
  static final applicationShouldHandleReopen_hasVisibleWindows_ =
      objc.ObjCProtocolMethod<bool Function(NSApplication, bool)>(
    _sel_applicationShouldHandleReopen_hasVisibleWindows_,
    objc.getProtocolMethodSignature(
      _protocol_NSApplicationDelegate,
      _sel_applicationShouldHandleReopen_hasVisibleWindows_,
      isRequired: false,
      isInstanceMethod: true,
    ),
    (bool Function(NSApplication, bool) func) =>
        ObjCBlock_bool_ffiVoid_NSApplication_bool.fromFunction(
            (ffi.Pointer<ffi.Void> _, NSApplication arg1, bool arg2) =>
                func(arg1, arg2)),
  );

  /// applicationDockMenu:
  static final applicationDockMenu_ =
      objc.ObjCProtocolMethod<NSMenu? Function(NSApplication)>(
    _sel_applicationDockMenu_,
    objc.getProtocolMethodSignature(
      _protocol_NSApplicationDelegate,
      _sel_applicationDockMenu_,
      isRequired: false,
      isInstanceMethod: true,
    ),
    (NSMenu? Function(NSApplication) func) =>
        ObjCBlock_NSMenu_ffiVoid_NSApplication.fromFunction(
            (ffi.Pointer<ffi.Void> _, NSApplication arg1) => func(arg1)),
  );

  /// application:willPresentError:
  static final application_willPresentError_ = objc.ObjCProtocolMethod<
      objc.NSError Function(NSApplication, objc.NSError)>(
    _sel_application_willPresentError_,
    objc.getProtocolMethodSignature(
      _protocol_NSApplicationDelegate,
      _sel_application_willPresentError_,
      isRequired: false,
      isInstanceMethod: true,
    ),
    (objc.NSError Function(NSApplication, objc.NSError) func) =>
        ObjCBlock_NSError_ffiVoid_NSApplication_NSError.fromFunction(
            (ffi.Pointer<ffi.Void> _, NSApplication arg1, objc.NSError arg2) =>
                func(arg1, arg2)),
  );

  /// application:didRegisterForRemoteNotificationsWithDeviceToken:
  static final application_didRegisterForRemoteNotificationsWithDeviceToken_ =
      objc.ObjCProtocolListenableMethod<
          void Function(NSApplication, objc.NSData)>(
    _sel_application_didRegisterForRemoteNotificationsWithDeviceToken_,
    objc.getProtocolMethodSignature(
      _protocol_NSApplicationDelegate,
      _sel_application_didRegisterForRemoteNotificationsWithDeviceToken_,
      isRequired: false,
      isInstanceMethod: true,
    ),
    (void Function(NSApplication, objc.NSData) func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSApplication_NSData.fromFunction(
            (ffi.Pointer<ffi.Void> _, NSApplication arg1, objc.NSData arg2) =>
                func(arg1, arg2)),
    (void Function(NSApplication, objc.NSData) func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSApplication_NSData.listener(
            (ffi.Pointer<ffi.Void> _, NSApplication arg1, objc.NSData arg2) =>
                func(arg1, arg2)),
  );

  /// application:didFailToRegisterForRemoteNotificationsWithError:
  static final application_didFailToRegisterForRemoteNotificationsWithError_ =
      objc.ObjCProtocolListenableMethod<
          void Function(NSApplication, objc.NSError)>(
    _sel_application_didFailToRegisterForRemoteNotificationsWithError_,
    objc.getProtocolMethodSignature(
      _protocol_NSApplicationDelegate,
      _sel_application_didFailToRegisterForRemoteNotificationsWithError_,
      isRequired: false,
      isInstanceMethod: true,
    ),
    (void Function(NSApplication, objc.NSError) func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSApplication_NSError.fromFunction(
            (ffi.Pointer<ffi.Void> _, NSApplication arg1, objc.NSError arg2) =>
                func(arg1, arg2)),
    (void Function(NSApplication, objc.NSError) func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSApplication_NSError.listener(
            (ffi.Pointer<ffi.Void> _, NSApplication arg1, objc.NSError arg2) =>
                func(arg1, arg2)),
  );

  /// application:didReceiveRemoteNotification:
  static final application_didReceiveRemoteNotification_ =
      objc.ObjCProtocolListenableMethod<
          void Function(NSApplication, objc.NSDictionary)>(
    _sel_application_didReceiveRemoteNotification_,
    objc.getProtocolMethodSignature(
      _protocol_NSApplicationDelegate,
      _sel_application_didReceiveRemoteNotification_,
      isRequired: false,
      isInstanceMethod: true,
    ),
    (void Function(NSApplication, objc.NSDictionary) func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSApplication_NSDictionary.fromFunction(
            (ffi.Pointer<ffi.Void> _, NSApplication arg1,
                    objc.NSDictionary arg2) =>
                func(arg1, arg2)),
    (void Function(NSApplication, objc.NSDictionary) func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSApplication_NSDictionary.listener(
            (ffi.Pointer<ffi.Void> _, NSApplication arg1,
                    objc.NSDictionary arg2) =>
                func(arg1, arg2)),
  );

  /// Method to opt-in to secure restorable state.
  ///
  /// When this returns @c YES:
  /// NSCoders that are passed into the various @c NSWindowRestoration methods will @c requiresSecureCoding and have a @c decodingFailurePolicy of @c NSDecodingFailurePolicySetErrorAndReturn.
  /// Any @c restorationClass set on a window must explicitly conform to @c NSWindowRestoration.
  ///
  /// This method will be called prior to any state encoding or restoration.
  static final applicationSupportsSecureRestorableState_ =
      objc.ObjCProtocolMethod<bool Function(NSApplication)>(
    _sel_applicationSupportsSecureRestorableState_,
    objc.getProtocolMethodSignature(
      _protocol_NSApplicationDelegate,
      _sel_applicationSupportsSecureRestorableState_,
      isRequired: false,
      isInstanceMethod: true,
    ),
    (bool Function(NSApplication) func) =>
        ObjCBlock_bool_ffiVoid_NSApplication.fromFunction(
            (ffi.Pointer<ffi.Void> _, NSApplication arg1) => func(arg1)),
  );

  /// @return The object capable of handling the specified intent.
  static final application_handlerForIntent_ = objc.ObjCProtocolMethod<
      objc.ObjCObjectBase? Function(NSApplication, INIntent)>(
    _sel_application_handlerForIntent_,
    objc.getProtocolMethodSignature(
      _protocol_NSApplicationDelegate,
      _sel_application_handlerForIntent_,
      isRequired: false,
      isInstanceMethod: true,
    ),
    (objc.ObjCObjectBase? Function(NSApplication, INIntent) func) =>
        ObjCBlock_objcObjCObject_ffiVoid_NSApplication_INIntent.fromFunction(
            (ffi.Pointer<ffi.Void> _, NSApplication arg1, INIntent arg2) =>
                func(arg1, arg2)),
  );

  /// Method called by `-[NSApplication encodeRestorableStateWithCoder:]` to give the delegate a chance to encode any additional state into the @c NSCoder. If the restorable state managed by the delegate changes, you must call `-[NSApplication invalidateRestorableState]` so that it will be re-encoded. See the header `NSWindowRestoration.h` for more information.
  static final application_willEncodeRestorableState_ = objc
      .ObjCProtocolListenableMethod<void Function(NSApplication, objc.NSCoder)>(
    _sel_application_willEncodeRestorableState_,
    objc.getProtocolMethodSignature(
      _protocol_NSApplicationDelegate,
      _sel_application_willEncodeRestorableState_,
      isRequired: false,
      isInstanceMethod: true,
    ),
    (void Function(NSApplication, objc.NSCoder) func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSApplication_NSCoder.fromFunction(
            (ffi.Pointer<ffi.Void> _, NSApplication arg1, objc.NSCoder arg2) =>
                func(arg1, arg2)),
    (void Function(NSApplication, objc.NSCoder) func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSApplication_NSCoder.listener(
            (ffi.Pointer<ffi.Void> _, NSApplication arg1, objc.NSCoder arg2) =>
                func(arg1, arg2)),
  );

  /// Method called by `-[NSApplication restoreStateWithCoder:]` to give the delegate a chance to restore its own state, which it may decode from the @c NSCoder. See the header `NSWindowRestoration.h` for more information.
  static final application_didDecodeRestorableState_ = objc
      .ObjCProtocolListenableMethod<void Function(NSApplication, objc.NSCoder)>(
    _sel_application_didDecodeRestorableState_,
    objc.getProtocolMethodSignature(
      _protocol_NSApplicationDelegate,
      _sel_application_didDecodeRestorableState_,
      isRequired: false,
      isInstanceMethod: true,
    ),
    (void Function(NSApplication, objc.NSCoder) func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSApplication_NSCoder.fromFunction(
            (ffi.Pointer<ffi.Void> _, NSApplication arg1, objc.NSCoder arg2) =>
                func(arg1, arg2)),
    (void Function(NSApplication, objc.NSCoder) func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSApplication_NSCoder.listener(
            (ffi.Pointer<ffi.Void> _, NSApplication arg1, objc.NSCoder arg2) =>
                func(arg1, arg2)),
  );

  /// This will be called on the main thread as soon as the user indicates they want to continue an activity in your application. The @c NSUserActivity object may not be available instantly, so use this as an opportunity to show the user that an activity will be continued shortly. Return @c YES to indicate that you are doing so. Return @c NO (or leave it unimplemented) and AppKit/UIKit will put up a default UI.
  ///
  /// For each `-application:willContinueUserActivityWithType:` invocation, you are guaranteed to get exactly one invocation of `-application:continueUserActivity:restorationHandler:` on success, or `-application:didFailToContinueUserActivityWithType:error:` if an error was encountered.
  static final application_willContinueUserActivityWithType_ =
      objc.ObjCProtocolMethod<bool Function(NSApplication, objc.NSString)>(
    _sel_application_willContinueUserActivityWithType_,
    objc.getProtocolMethodSignature(
      _protocol_NSApplicationDelegate,
      _sel_application_willContinueUserActivityWithType_,
      isRequired: false,
      isInstanceMethod: true,
    ),
    (bool Function(NSApplication, objc.NSString) func) =>
        ObjCBlock_bool_ffiVoid_NSApplication_NSString.fromFunction(
            (ffi.Pointer<ffi.Void> _, NSApplication arg1, objc.NSString arg2) =>
                func(arg1, arg2)),
  );

  /// This will be called on the main thread after the @c NSUserActivity object is available. Use the data you stored in the NSUserActivity object to re-create what the user was doing.
  ///
  /// @return @c YES to indicate that the activity was handled. Return @c NO (or leave it unimplemented) and AppKit will attempt to continue the user activity.
  ///
  /// You should create/fetch any restorable objects associated with the user activity, and pass them to the restorationHandler. They will then get the above `-restoreUserActivityState:` method invoked with the user activity. Invoking the @c restorationHandler is optional. It may be copied and invoked later, but must be invoked on the main thread.
  ///
  /// If this user activity was created automatically by having @c NSUbiquitousDocumentUserActivityType in a @c CFBundleDocumentTypes entry, AppKit can automatically restore the NSUserActivity on OS X if NO is returned, or this method is unimplemented. It will do so by creating a document of the appropriate type using the URL stored in the userInfo under the @c NSUserActivityDocumentURLKey. The document will have `-restoreUserActivity:` called on it.
  static final application_continueUserActivity_restorationHandler_ =
      objc.ObjCProtocolMethod<
          bool Function(
              NSApplication, NSUserActivity, ObjCBlock_ffiVoid_NSArray)>(
    _sel_application_continueUserActivity_restorationHandler_,
    objc.getProtocolMethodSignature(
      _protocol_NSApplicationDelegate,
      _sel_application_continueUserActivity_restorationHandler_,
      isRequired: false,
      isInstanceMethod: true,
    ),
    (bool Function(NSApplication, NSUserActivity, ObjCBlock_ffiVoid_NSArray)
            func) =>
        ObjCBlock_bool_ffiVoid_NSApplication_NSUserActivity_ffiVoidNSArray
            .fromFunction((ffi.Pointer<ffi.Void> _, NSApplication arg1,
                    NSUserActivity arg2, ObjCBlock_ffiVoid_NSArray arg3) =>
                func(arg1, arg2, arg3)),
  );

  /// There are instances where continuing a @c NSUserActivity may fail. This will get called on the main thread if it does so. If it is unimplemented, AppKit will present the error.
  static final application_didFailToContinueUserActivityWithType_error_ =
      objc.ObjCProtocolListenableMethod<
          void Function(NSApplication, objc.NSString, objc.NSError)>(
    _sel_application_didFailToContinueUserActivityWithType_error_,
    objc.getProtocolMethodSignature(
      _protocol_NSApplicationDelegate,
      _sel_application_didFailToContinueUserActivityWithType_error_,
      isRequired: false,
      isInstanceMethod: true,
    ),
    (void Function(NSApplication, objc.NSString, objc.NSError) func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSApplication_NSString_NSError.fromFunction(
            (ffi.Pointer<ffi.Void> _, NSApplication arg1, objc.NSString arg2,
                    objc.NSError arg3) =>
                func(arg1, arg2, arg3)),
    (void Function(NSApplication, objc.NSString, objc.NSError) func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSApplication_NSString_NSError.listener(
            (ffi.Pointer<ffi.Void> _, NSApplication arg1, objc.NSString arg2,
                    objc.NSError arg3) =>
                func(arg1, arg2, arg3)),
  );

  /// This will be called on the main thread when a user activity managed by AppKit/UIKit has been updated. You should use this as a last chance to add additional data to the @c userActivity.
  static final application_didUpdateUserActivity_ =
      objc.ObjCProtocolListenableMethod<
          void Function(NSApplication, NSUserActivity)>(
    _sel_application_didUpdateUserActivity_,
    objc.getProtocolMethodSignature(
      _protocol_NSApplicationDelegate,
      _sel_application_didUpdateUserActivity_,
      isRequired: false,
      isInstanceMethod: true,
    ),
    (void Function(NSApplication, NSUserActivity) func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSApplication_NSUserActivity.fromFunction(
            (ffi.Pointer<ffi.Void> _, NSApplication arg1,
                    NSUserActivity arg2) =>
                func(arg1, arg2)),
    (void Function(NSApplication, NSUserActivity) func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSApplication_NSUserActivity.listener(
            (ffi.Pointer<ffi.Void> _, NSApplication arg1,
                    NSUserActivity arg2) =>
                func(arg1, arg2)),
  );

  /// This will be called on the main thread after the user indicates they want to accept a CloudKit sharing invitation in your application.
  ///
  /// You should use the @c CKShareMetadata object's @c shareURL and containerIdentifier to schedule a @c CKAcceptSharesOperation, then start using the resulting @c CKShare and its associated record(s), which will appear in the @c CKContainer's shared database in a zone matching that of the record's owner.
  static final application_userDidAcceptCloudKitShareWithMetadata_ =
      objc.ObjCProtocolListenableMethod<
          void Function(NSApplication, CKShareMetadata)>(
    _sel_application_userDidAcceptCloudKitShareWithMetadata_,
    objc.getProtocolMethodSignature(
      _protocol_NSApplicationDelegate,
      _sel_application_userDidAcceptCloudKitShareWithMetadata_,
      isRequired: false,
      isInstanceMethod: true,
    ),
    (void Function(NSApplication, CKShareMetadata) func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSApplication_CKShareMetadata.fromFunction(
            (ffi.Pointer<ffi.Void> _, NSApplication arg1,
                    CKShareMetadata arg2) =>
                func(arg1, arg2)),
    (void Function(NSApplication, CKShareMetadata) func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSApplication_CKShareMetadata.listener(
            (ffi.Pointer<ffi.Void> _, NSApplication arg1,
                    CKShareMetadata arg2) =>
                func(arg1, arg2)),
  );

  /// @return @c YES if the receiving delegate object can respond to key value coding messages for a specific keyed attribute, to-one relationship, or to-many relationship.  Return @c NO otherwise.
  static final application_delegateHandlesKey_ =
      objc.ObjCProtocolMethod<bool Function(NSApplication, objc.NSString)>(
    _sel_application_delegateHandlesKey_,
    objc.getProtocolMethodSignature(
      _protocol_NSApplicationDelegate,
      _sel_application_delegateHandlesKey_,
      isRequired: false,
      isInstanceMethod: true,
    ),
    (bool Function(NSApplication, objc.NSString) func) =>
        ObjCBlock_bool_ffiVoid_NSApplication_NSString.fromFunction(
            (ffi.Pointer<ffi.Void> _, NSApplication arg1, objc.NSString arg2) =>
                func(arg1, arg2)),
  );

  /// This method will be called once during application launch at `-[NSApplication finishLaunching]`.
  ///
  /// @return @c NO if the receiving delegate object wishes to opt-out of system-wide keyboard shortcut localization for all application-supplied menus. Return @c YES by default for apps linked against 12.0 and later SDK.
  static final applicationShouldAutomaticallyLocalizeKeyEquivalents_ =
      objc.ObjCProtocolMethod<bool Function(NSApplication)>(
    _sel_applicationShouldAutomaticallyLocalizeKeyEquivalents_,
    objc.getProtocolMethodSignature(
      _protocol_NSApplicationDelegate,
      _sel_applicationShouldAutomaticallyLocalizeKeyEquivalents_,
      isRequired: false,
      isInstanceMethod: true,
    ),
    (bool Function(NSApplication) func) =>
        ObjCBlock_bool_ffiVoid_NSApplication.fromFunction(
            (ffi.Pointer<ffi.Void> _, NSApplication arg1) => func(arg1)),
  );

  /// applicationWillFinishLaunching:
  static final applicationWillFinishLaunching_ =
      objc.ObjCProtocolListenableMethod<void Function(objc.NSNotification)>(
    _sel_applicationWillFinishLaunching_,
    objc.getProtocolMethodSignature(
      _protocol_NSApplicationDelegate,
      _sel_applicationWillFinishLaunching_,
      isRequired: false,
      isInstanceMethod: true,
    ),
    (void Function(objc.NSNotification) func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSNotification.fromFunction(
            (ffi.Pointer<ffi.Void> _, objc.NSNotification arg1) => func(arg1)),
    (void Function(objc.NSNotification) func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSNotification.listener(
            (ffi.Pointer<ffi.Void> _, objc.NSNotification arg1) => func(arg1)),
  );

  /// applicationDidFinishLaunching:
  static final applicationDidFinishLaunching_ =
      objc.ObjCProtocolListenableMethod<void Function(objc.NSNotification)>(
    _sel_applicationDidFinishLaunching_,
    objc.getProtocolMethodSignature(
      _protocol_NSApplicationDelegate,
      _sel_applicationDidFinishLaunching_,
      isRequired: false,
      isInstanceMethod: true,
    ),
    (void Function(objc.NSNotification) func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSNotification.fromFunction(
            (ffi.Pointer<ffi.Void> _, objc.NSNotification arg1) => func(arg1)),
    (void Function(objc.NSNotification) func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSNotification.listener(
            (ffi.Pointer<ffi.Void> _, objc.NSNotification arg1) => func(arg1)),
  );

  /// applicationWillHide:
  static final applicationWillHide_ =
      objc.ObjCProtocolListenableMethod<void Function(objc.NSNotification)>(
    _sel_applicationWillHide_,
    objc.getProtocolMethodSignature(
      _protocol_NSApplicationDelegate,
      _sel_applicationWillHide_,
      isRequired: false,
      isInstanceMethod: true,
    ),
    (void Function(objc.NSNotification) func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSNotification.fromFunction(
            (ffi.Pointer<ffi.Void> _, objc.NSNotification arg1) => func(arg1)),
    (void Function(objc.NSNotification) func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSNotification.listener(
            (ffi.Pointer<ffi.Void> _, objc.NSNotification arg1) => func(arg1)),
  );

  /// applicationDidHide:
  static final applicationDidHide_ =
      objc.ObjCProtocolListenableMethod<void Function(objc.NSNotification)>(
    _sel_applicationDidHide_,
    objc.getProtocolMethodSignature(
      _protocol_NSApplicationDelegate,
      _sel_applicationDidHide_,
      isRequired: false,
      isInstanceMethod: true,
    ),
    (void Function(objc.NSNotification) func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSNotification.fromFunction(
            (ffi.Pointer<ffi.Void> _, objc.NSNotification arg1) => func(arg1)),
    (void Function(objc.NSNotification) func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSNotification.listener(
            (ffi.Pointer<ffi.Void> _, objc.NSNotification arg1) => func(arg1)),
  );

  /// applicationWillUnhide:
  static final applicationWillUnhide_ =
      objc.ObjCProtocolListenableMethod<void Function(objc.NSNotification)>(
    _sel_applicationWillUnhide_,
    objc.getProtocolMethodSignature(
      _protocol_NSApplicationDelegate,
      _sel_applicationWillUnhide_,
      isRequired: false,
      isInstanceMethod: true,
    ),
    (void Function(objc.NSNotification) func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSNotification.fromFunction(
            (ffi.Pointer<ffi.Void> _, objc.NSNotification arg1) => func(arg1)),
    (void Function(objc.NSNotification) func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSNotification.listener(
            (ffi.Pointer<ffi.Void> _, objc.NSNotification arg1) => func(arg1)),
  );

  /// applicationDidUnhide:
  static final applicationDidUnhide_ =
      objc.ObjCProtocolListenableMethod<void Function(objc.NSNotification)>(
    _sel_applicationDidUnhide_,
    objc.getProtocolMethodSignature(
      _protocol_NSApplicationDelegate,
      _sel_applicationDidUnhide_,
      isRequired: false,
      isInstanceMethod: true,
    ),
    (void Function(objc.NSNotification) func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSNotification.fromFunction(
            (ffi.Pointer<ffi.Void> _, objc.NSNotification arg1) => func(arg1)),
    (void Function(objc.NSNotification) func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSNotification.listener(
            (ffi.Pointer<ffi.Void> _, objc.NSNotification arg1) => func(arg1)),
  );

  /// applicationWillBecomeActive:
  static final applicationWillBecomeActive_ =
      objc.ObjCProtocolListenableMethod<void Function(objc.NSNotification)>(
    _sel_applicationWillBecomeActive_,
    objc.getProtocolMethodSignature(
      _protocol_NSApplicationDelegate,
      _sel_applicationWillBecomeActive_,
      isRequired: false,
      isInstanceMethod: true,
    ),
    (void Function(objc.NSNotification) func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSNotification.fromFunction(
            (ffi.Pointer<ffi.Void> _, objc.NSNotification arg1) => func(arg1)),
    (void Function(objc.NSNotification) func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSNotification.listener(
            (ffi.Pointer<ffi.Void> _, objc.NSNotification arg1) => func(arg1)),
  );

  /// applicationDidBecomeActive:
  static final applicationDidBecomeActive_ =
      objc.ObjCProtocolListenableMethod<void Function(objc.NSNotification)>(
    _sel_applicationDidBecomeActive_,
    objc.getProtocolMethodSignature(
      _protocol_NSApplicationDelegate,
      _sel_applicationDidBecomeActive_,
      isRequired: false,
      isInstanceMethod: true,
    ),
    (void Function(objc.NSNotification) func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSNotification.fromFunction(
            (ffi.Pointer<ffi.Void> _, objc.NSNotification arg1) => func(arg1)),
    (void Function(objc.NSNotification) func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSNotification.listener(
            (ffi.Pointer<ffi.Void> _, objc.NSNotification arg1) => func(arg1)),
  );

  /// applicationWillResignActive:
  static final applicationWillResignActive_ =
      objc.ObjCProtocolListenableMethod<void Function(objc.NSNotification)>(
    _sel_applicationWillResignActive_,
    objc.getProtocolMethodSignature(
      _protocol_NSApplicationDelegate,
      _sel_applicationWillResignActive_,
      isRequired: false,
      isInstanceMethod: true,
    ),
    (void Function(objc.NSNotification) func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSNotification.fromFunction(
            (ffi.Pointer<ffi.Void> _, objc.NSNotification arg1) => func(arg1)),
    (void Function(objc.NSNotification) func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSNotification.listener(
            (ffi.Pointer<ffi.Void> _, objc.NSNotification arg1) => func(arg1)),
  );

  /// applicationDidResignActive:
  static final applicationDidResignActive_ =
      objc.ObjCProtocolListenableMethod<void Function(objc.NSNotification)>(
    _sel_applicationDidResignActive_,
    objc.getProtocolMethodSignature(
      _protocol_NSApplicationDelegate,
      _sel_applicationDidResignActive_,
      isRequired: false,
      isInstanceMethod: true,
    ),
    (void Function(objc.NSNotification) func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSNotification.fromFunction(
            (ffi.Pointer<ffi.Void> _, objc.NSNotification arg1) => func(arg1)),
    (void Function(objc.NSNotification) func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSNotification.listener(
            (ffi.Pointer<ffi.Void> _, objc.NSNotification arg1) => func(arg1)),
  );

  /// applicationWillUpdate:
  static final applicationWillUpdate_ =
      objc.ObjCProtocolListenableMethod<void Function(objc.NSNotification)>(
    _sel_applicationWillUpdate_,
    objc.getProtocolMethodSignature(
      _protocol_NSApplicationDelegate,
      _sel_applicationWillUpdate_,
      isRequired: false,
      isInstanceMethod: true,
    ),
    (void Function(objc.NSNotification) func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSNotification.fromFunction(
            (ffi.Pointer<ffi.Void> _, objc.NSNotification arg1) => func(arg1)),
    (void Function(objc.NSNotification) func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSNotification.listener(
            (ffi.Pointer<ffi.Void> _, objc.NSNotification arg1) => func(arg1)),
  );

  /// applicationDidUpdate:
  static final applicationDidUpdate_ =
      objc.ObjCProtocolListenableMethod<void Function(objc.NSNotification)>(
    _sel_applicationDidUpdate_,
    objc.getProtocolMethodSignature(
      _protocol_NSApplicationDelegate,
      _sel_applicationDidUpdate_,
      isRequired: false,
      isInstanceMethod: true,
    ),
    (void Function(objc.NSNotification) func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSNotification.fromFunction(
            (ffi.Pointer<ffi.Void> _, objc.NSNotification arg1) => func(arg1)),
    (void Function(objc.NSNotification) func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSNotification.listener(
            (ffi.Pointer<ffi.Void> _, objc.NSNotification arg1) => func(arg1)),
  );

  /// applicationWillTerminate:
  static final applicationWillTerminate_ =
      objc.ObjCProtocolListenableMethod<void Function(objc.NSNotification)>(
    _sel_applicationWillTerminate_,
    objc.getProtocolMethodSignature(
      _protocol_NSApplicationDelegate,
      _sel_applicationWillTerminate_,
      isRequired: false,
      isInstanceMethod: true,
    ),
    (void Function(objc.NSNotification) func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSNotification.fromFunction(
            (ffi.Pointer<ffi.Void> _, objc.NSNotification arg1) => func(arg1)),
    (void Function(objc.NSNotification) func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSNotification.listener(
            (ffi.Pointer<ffi.Void> _, objc.NSNotification arg1) => func(arg1)),
  );

  /// applicationDidChangeScreenParameters:
  static final applicationDidChangeScreenParameters_ =
      objc.ObjCProtocolListenableMethod<void Function(objc.NSNotification)>(
    _sel_applicationDidChangeScreenParameters_,
    objc.getProtocolMethodSignature(
      _protocol_NSApplicationDelegate,
      _sel_applicationDidChangeScreenParameters_,
      isRequired: false,
      isInstanceMethod: true,
    ),
    (void Function(objc.NSNotification) func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSNotification.fromFunction(
            (ffi.Pointer<ffi.Void> _, objc.NSNotification arg1) => func(arg1)),
    (void Function(objc.NSNotification) func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSNotification.listener(
            (ffi.Pointer<ffi.Void> _, objc.NSNotification arg1) => func(arg1)),
  );

  /// applicationDidChangeOcclusionState:
  static final applicationDidChangeOcclusionState_ =
      objc.ObjCProtocolListenableMethod<void Function(objc.NSNotification)>(
    _sel_applicationDidChangeOcclusionState_,
    objc.getProtocolMethodSignature(
      _protocol_NSApplicationDelegate,
      _sel_applicationDidChangeOcclusionState_,
      isRequired: false,
      isInstanceMethod: true,
    ),
    (void Function(objc.NSNotification) func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSNotification.fromFunction(
            (ffi.Pointer<ffi.Void> _, objc.NSNotification arg1) => func(arg1)),
    (void Function(objc.NSNotification) func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSNotification.listener(
            (ffi.Pointer<ffi.Void> _, objc.NSNotification arg1) => func(arg1)),
  );

  /// applicationProtectedDataWillBecomeUnavailable:
  static final applicationProtectedDataWillBecomeUnavailable_ =
      objc.ObjCProtocolListenableMethod<void Function(objc.NSNotification)>(
    _sel_applicationProtectedDataWillBecomeUnavailable_,
    objc.getProtocolMethodSignature(
      _protocol_NSApplicationDelegate,
      _sel_applicationProtectedDataWillBecomeUnavailable_,
      isRequired: false,
      isInstanceMethod: true,
    ),
    (void Function(objc.NSNotification) func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSNotification.fromFunction(
            (ffi.Pointer<ffi.Void> _, objc.NSNotification arg1) => func(arg1)),
    (void Function(objc.NSNotification) func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSNotification.listener(
            (ffi.Pointer<ffi.Void> _, objc.NSNotification arg1) => func(arg1)),
  );

  /// applicationProtectedDataDidBecomeAvailable:
  static final applicationProtectedDataDidBecomeAvailable_ =
      objc.ObjCProtocolListenableMethod<void Function(objc.NSNotification)>(
    _sel_applicationProtectedDataDidBecomeAvailable_,
    objc.getProtocolMethodSignature(
      _protocol_NSApplicationDelegate,
      _sel_applicationProtectedDataDidBecomeAvailable_,
      isRequired: false,
      isInstanceMethod: true,
    ),
    (void Function(objc.NSNotification) func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSNotification.fromFunction(
            (ffi.Pointer<ffi.Void> _, objc.NSNotification arg1) => func(arg1)),
    (void Function(objc.NSNotification) func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSNotification.listener(
            (ffi.Pointer<ffi.Void> _, objc.NSNotification arg1) => func(arg1)),
  );
}

late final _protocol_NSApplicationDelegate =
    objc.getProtocol("NSApplicationDelegate");

/// NSObject
abstract final class NSObject {
  /// Builds an object that implements the NSObject protocol. To implement
  /// multiple protocols, use [addToBuilder] or [objc.ObjCProtocolBuilder] directly.
  static objc.ObjCObjectBase implement(
      {required bool Function(objc.ObjCObjectBase) isEqual_,
      required objc.ObjCObjectBase Function() class1,
      required objc.ObjCObjectBase Function() self,
      required objc.ObjCObjectBase Function(ffi.Pointer<objc.ObjCSelector>)
          performSelector_,
      required objc.ObjCObjectBase Function(
              ffi.Pointer<objc.ObjCSelector>, objc.ObjCObjectBase)
          performSelector_withObject_,
      required objc.ObjCObjectBase Function(ffi.Pointer<objc.ObjCSelector>,
              objc.ObjCObjectBase, objc.ObjCObjectBase)
          performSelector_withObject_withObject_,
      required bool Function() isProxy,
      required bool Function(objc.ObjCObjectBase) isKindOfClass_,
      required bool Function(objc.ObjCObjectBase) isMemberOfClass_,
      required bool Function(objc.Protocol) conformsToProtocol_,
      required bool Function(ffi.Pointer<objc.ObjCSelector>)
          respondsToSelector_,
      required objc.ObjCObjectBase Function() retain,
      required void Function() release,
      required objc.ObjCObjectBase Function() autorelease,
      required int Function() retainCount,
      required ffi.Pointer<_NSZone> Function() zone,
      required int Function() hash,
      required objc.ObjCObjectBase Function() superclass,
      required objc.NSString Function() description,
      objc.NSString Function()? debugDescription}) {
    final builder = objc.ObjCProtocolBuilder();
    NSObject.isEqual_.implement(builder, isEqual_);
    NSObject.class1.implement(builder, class1);
    NSObject.self.implement(builder, self);
    NSObject.performSelector_.implement(builder, performSelector_);
    NSObject.performSelector_withObject_
        .implement(builder, performSelector_withObject_);
    NSObject.performSelector_withObject_withObject_
        .implement(builder, performSelector_withObject_withObject_);
    NSObject.isProxy.implement(builder, isProxy);
    NSObject.isKindOfClass_.implement(builder, isKindOfClass_);
    NSObject.isMemberOfClass_.implement(builder, isMemberOfClass_);
    NSObject.conformsToProtocol_.implement(builder, conformsToProtocol_);
    NSObject.respondsToSelector_.implement(builder, respondsToSelector_);
    NSObject.retain.implement(builder, retain);
    NSObject.release.implement(builder, release);
    NSObject.autorelease.implement(builder, autorelease);
    NSObject.retainCount.implement(builder, retainCount);
    NSObject.zone.implement(builder, zone);
    NSObject.hash.implement(builder, hash);
    NSObject.superclass.implement(builder, superclass);
    NSObject.description.implement(builder, description);
    NSObject.debugDescription.implement(builder, debugDescription);
    return builder.build();
  }

  /// Adds the implementation of the NSObject protocol to an existing
  /// [objc.ObjCProtocolBuilder].
  static void addToBuilder(objc.ObjCProtocolBuilder builder,
      {required bool Function(objc.ObjCObjectBase) isEqual_,
      required objc.ObjCObjectBase Function() class1,
      required objc.ObjCObjectBase Function() self,
      required objc.ObjCObjectBase Function(ffi.Pointer<objc.ObjCSelector>)
          performSelector_,
      required objc.ObjCObjectBase Function(
              ffi.Pointer<objc.ObjCSelector>, objc.ObjCObjectBase)
          performSelector_withObject_,
      required objc.ObjCObjectBase Function(ffi.Pointer<objc.ObjCSelector>,
              objc.ObjCObjectBase, objc.ObjCObjectBase)
          performSelector_withObject_withObject_,
      required bool Function() isProxy,
      required bool Function(objc.ObjCObjectBase) isKindOfClass_,
      required bool Function(objc.ObjCObjectBase) isMemberOfClass_,
      required bool Function(objc.Protocol) conformsToProtocol_,
      required bool Function(ffi.Pointer<objc.ObjCSelector>)
          respondsToSelector_,
      required objc.ObjCObjectBase Function() retain,
      required void Function() release,
      required objc.ObjCObjectBase Function() autorelease,
      required int Function() retainCount,
      required ffi.Pointer<_NSZone> Function() zone,
      required int Function() hash,
      required objc.ObjCObjectBase Function() superclass,
      required objc.NSString Function() description,
      objc.NSString Function()? debugDescription}) {
    NSObject.isEqual_.implement(builder, isEqual_);
    NSObject.class1.implement(builder, class1);
    NSObject.self.implement(builder, self);
    NSObject.performSelector_.implement(builder, performSelector_);
    NSObject.performSelector_withObject_
        .implement(builder, performSelector_withObject_);
    NSObject.performSelector_withObject_withObject_
        .implement(builder, performSelector_withObject_withObject_);
    NSObject.isProxy.implement(builder, isProxy);
    NSObject.isKindOfClass_.implement(builder, isKindOfClass_);
    NSObject.isMemberOfClass_.implement(builder, isMemberOfClass_);
    NSObject.conformsToProtocol_.implement(builder, conformsToProtocol_);
    NSObject.respondsToSelector_.implement(builder, respondsToSelector_);
    NSObject.retain.implement(builder, retain);
    NSObject.release.implement(builder, release);
    NSObject.autorelease.implement(builder, autorelease);
    NSObject.retainCount.implement(builder, retainCount);
    NSObject.zone.implement(builder, zone);
    NSObject.hash.implement(builder, hash);
    NSObject.superclass.implement(builder, superclass);
    NSObject.description.implement(builder, description);
    NSObject.debugDescription.implement(builder, debugDescription);
  }

  /// Builds an object that implements the NSObject protocol. To implement
  /// multiple protocols, use [addToBuilder] or [objc.ObjCProtocolBuilder] directly. All
  /// methods that can be implemented as listeners will be.
  static objc.ObjCObjectBase implementAsListener(
      {required bool Function(objc.ObjCObjectBase) isEqual_,
      required objc.ObjCObjectBase Function() class1,
      required objc.ObjCObjectBase Function() self,
      required objc.ObjCObjectBase Function(ffi.Pointer<objc.ObjCSelector>)
          performSelector_,
      required objc.ObjCObjectBase Function(
              ffi.Pointer<objc.ObjCSelector>, objc.ObjCObjectBase)
          performSelector_withObject_,
      required objc.ObjCObjectBase Function(ffi.Pointer<objc.ObjCSelector>,
              objc.ObjCObjectBase, objc.ObjCObjectBase)
          performSelector_withObject_withObject_,
      required bool Function() isProxy,
      required bool Function(objc.ObjCObjectBase) isKindOfClass_,
      required bool Function(objc.ObjCObjectBase) isMemberOfClass_,
      required bool Function(objc.Protocol) conformsToProtocol_,
      required bool Function(ffi.Pointer<objc.ObjCSelector>)
          respondsToSelector_,
      required objc.ObjCObjectBase Function() retain,
      required void Function() release,
      required objc.ObjCObjectBase Function() autorelease,
      required int Function() retainCount,
      required ffi.Pointer<_NSZone> Function() zone,
      required int Function() hash,
      required objc.ObjCObjectBase Function() superclass,
      required objc.NSString Function() description,
      objc.NSString Function()? debugDescription}) {
    final builder = objc.ObjCProtocolBuilder();
    NSObject.isEqual_.implement(builder, isEqual_);
    NSObject.class1.implement(builder, class1);
    NSObject.self.implement(builder, self);
    NSObject.performSelector_.implement(builder, performSelector_);
    NSObject.performSelector_withObject_
        .implement(builder, performSelector_withObject_);
    NSObject.performSelector_withObject_withObject_
        .implement(builder, performSelector_withObject_withObject_);
    NSObject.isProxy.implement(builder, isProxy);
    NSObject.isKindOfClass_.implement(builder, isKindOfClass_);
    NSObject.isMemberOfClass_.implement(builder, isMemberOfClass_);
    NSObject.conformsToProtocol_.implement(builder, conformsToProtocol_);
    NSObject.respondsToSelector_.implement(builder, respondsToSelector_);
    NSObject.retain.implement(builder, retain);
    NSObject.release.implementAsListener(builder, release);
    NSObject.autorelease.implement(builder, autorelease);
    NSObject.retainCount.implement(builder, retainCount);
    NSObject.zone.implement(builder, zone);
    NSObject.hash.implement(builder, hash);
    NSObject.superclass.implement(builder, superclass);
    NSObject.description.implement(builder, description);
    NSObject.debugDescription.implement(builder, debugDescription);
    return builder.build();
  }

  /// Adds the implementation of the NSObject protocol to an existing
  /// [objc.ObjCProtocolBuilder]. All methods that can be implemented as listeners will
  /// be.
  static void addToBuilderAsListener(objc.ObjCProtocolBuilder builder,
      {required bool Function(objc.ObjCObjectBase) isEqual_,
      required objc.ObjCObjectBase Function() class1,
      required objc.ObjCObjectBase Function() self,
      required objc.ObjCObjectBase Function(ffi.Pointer<objc.ObjCSelector>)
          performSelector_,
      required objc.ObjCObjectBase Function(
              ffi.Pointer<objc.ObjCSelector>, objc.ObjCObjectBase)
          performSelector_withObject_,
      required objc.ObjCObjectBase Function(ffi.Pointer<objc.ObjCSelector>,
              objc.ObjCObjectBase, objc.ObjCObjectBase)
          performSelector_withObject_withObject_,
      required bool Function() isProxy,
      required bool Function(objc.ObjCObjectBase) isKindOfClass_,
      required bool Function(objc.ObjCObjectBase) isMemberOfClass_,
      required bool Function(objc.Protocol) conformsToProtocol_,
      required bool Function(ffi.Pointer<objc.ObjCSelector>)
          respondsToSelector_,
      required objc.ObjCObjectBase Function() retain,
      required void Function() release,
      required objc.ObjCObjectBase Function() autorelease,
      required int Function() retainCount,
      required ffi.Pointer<_NSZone> Function() zone,
      required int Function() hash,
      required objc.ObjCObjectBase Function() superclass,
      required objc.NSString Function() description,
      objc.NSString Function()? debugDescription}) {
    NSObject.isEqual_.implement(builder, isEqual_);
    NSObject.class1.implement(builder, class1);
    NSObject.self.implement(builder, self);
    NSObject.performSelector_.implement(builder, performSelector_);
    NSObject.performSelector_withObject_
        .implement(builder, performSelector_withObject_);
    NSObject.performSelector_withObject_withObject_
        .implement(builder, performSelector_withObject_withObject_);
    NSObject.isProxy.implement(builder, isProxy);
    NSObject.isKindOfClass_.implement(builder, isKindOfClass_);
    NSObject.isMemberOfClass_.implement(builder, isMemberOfClass_);
    NSObject.conformsToProtocol_.implement(builder, conformsToProtocol_);
    NSObject.respondsToSelector_.implement(builder, respondsToSelector_);
    NSObject.retain.implement(builder, retain);
    NSObject.release.implementAsListener(builder, release);
    NSObject.autorelease.implement(builder, autorelease);
    NSObject.retainCount.implement(builder, retainCount);
    NSObject.zone.implement(builder, zone);
    NSObject.hash.implement(builder, hash);
    NSObject.superclass.implement(builder, superclass);
    NSObject.description.implement(builder, description);
    NSObject.debugDescription.implement(builder, debugDescription);
  }

  /// isEqual:
  static final isEqual_ =
      objc.ObjCProtocolMethod<bool Function(objc.ObjCObjectBase)>(
    _sel_isEqual_,
    objc.getProtocolMethodSignature(
      _protocol_NSObject,
      _sel_isEqual_,
      isRequired: true,
      isInstanceMethod: true,
    ),
    (bool Function(objc.ObjCObjectBase) func) =>
        ObjCBlock_bool_ffiVoid_objcObjCObject.fromFunction(
            (ffi.Pointer<ffi.Void> _, objc.ObjCObjectBase arg1) => func(arg1)),
  );

  /// class
  static final class1 = objc.ObjCProtocolMethod<objc.ObjCObjectBase Function()>(
    _sel_class,
    objc.getProtocolMethodSignature(
      _protocol_NSObject,
      _sel_class,
      isRequired: true,
      isInstanceMethod: true,
    ),
    (objc.ObjCObjectBase Function() func) =>
        ObjCBlock_objcObjCObject_ffiVoid.fromFunction((
      ffi.Pointer<ffi.Void> _,
    ) =>
            func()),
  );

  /// self
  static final self = objc.ObjCProtocolMethod<objc.ObjCObjectBase Function()>(
    _sel_self,
    objc.getProtocolMethodSignature(
      _protocol_NSObject,
      _sel_self,
      isRequired: true,
      isInstanceMethod: true,
    ),
    (objc.ObjCObjectBase Function() func) =>
        ObjCBlock_objcObjCObject_ffiVoid.fromFunction((
      ffi.Pointer<ffi.Void> _,
    ) =>
            func()),
  );

  /// performSelector:
  static final performSelector_ = objc.ObjCProtocolMethod<
      objc.ObjCObjectBase Function(ffi.Pointer<objc.ObjCSelector>)>(
    _sel_performSelector_,
    objc.getProtocolMethodSignature(
      _protocol_NSObject,
      _sel_performSelector_,
      isRequired: true,
      isInstanceMethod: true,
    ),
    (objc.ObjCObjectBase Function(ffi.Pointer<objc.ObjCSelector>) func) =>
        ObjCBlock_objcObjCObject_ffiVoid_objcObjCSelector.fromFunction(
            (ffi.Pointer<ffi.Void> _, ffi.Pointer<objc.ObjCSelector> arg1) =>
                func(arg1)),
  );

  /// performSelector:withObject:
  static final performSelector_withObject_ = objc.ObjCProtocolMethod<
      objc.ObjCObjectBase Function(
          ffi.Pointer<objc.ObjCSelector>, objc.ObjCObjectBase)>(
    _sel_performSelector_withObject_,
    objc.getProtocolMethodSignature(
      _protocol_NSObject,
      _sel_performSelector_withObject_,
      isRequired: true,
      isInstanceMethod: true,
    ),
    (objc.ObjCObjectBase Function(
                ffi.Pointer<objc.ObjCSelector>, objc.ObjCObjectBase)
            func) =>
        ObjCBlock_objcObjCObject_ffiVoid_objcObjCSelector_objcObjCObject
            .fromFunction((ffi.Pointer<ffi.Void> _,
                    ffi.Pointer<objc.ObjCSelector> arg1,
                    objc.ObjCObjectBase arg2) =>
                func(arg1, arg2)),
  );

  /// performSelector:withObject:withObject:
  static final performSelector_withObject_withObject_ = objc.ObjCProtocolMethod<
      objc.ObjCObjectBase Function(ffi.Pointer<objc.ObjCSelector>,
          objc.ObjCObjectBase, objc.ObjCObjectBase)>(
    _sel_performSelector_withObject_withObject_,
    objc.getProtocolMethodSignature(
      _protocol_NSObject,
      _sel_performSelector_withObject_withObject_,
      isRequired: true,
      isInstanceMethod: true,
    ),
    (objc.ObjCObjectBase Function(ffi.Pointer<objc.ObjCSelector>,
                objc.ObjCObjectBase, objc.ObjCObjectBase)
            func) =>
        ObjCBlock_objcObjCObject_ffiVoid_objcObjCSelector_objcObjCObject_objcObjCObject
            .fromFunction((ffi.Pointer<ffi.Void> _,
                    ffi.Pointer<objc.ObjCSelector> arg1,
                    objc.ObjCObjectBase arg2,
                    objc.ObjCObjectBase arg3) =>
                func(arg1, arg2, arg3)),
  );

  /// isProxy
  static final isProxy = objc.ObjCProtocolMethod<bool Function()>(
    _sel_isProxy,
    objc.getProtocolMethodSignature(
      _protocol_NSObject,
      _sel_isProxy,
      isRequired: true,
      isInstanceMethod: true,
    ),
    (bool Function() func) => ObjCBlock_bool_ffiVoid.fromFunction((
      ffi.Pointer<ffi.Void> _,
    ) =>
        func()),
  );

  /// isKindOfClass:
  static final isKindOfClass_ =
      objc.ObjCProtocolMethod<bool Function(objc.ObjCObjectBase)>(
    _sel_isKindOfClass_,
    objc.getProtocolMethodSignature(
      _protocol_NSObject,
      _sel_isKindOfClass_,
      isRequired: true,
      isInstanceMethod: true,
    ),
    (bool Function(objc.ObjCObjectBase) func) =>
        ObjCBlock_bool_ffiVoid_objcObjCObject.fromFunction(
            (ffi.Pointer<ffi.Void> _, objc.ObjCObjectBase arg1) => func(arg1)),
  );

  /// isMemberOfClass:
  static final isMemberOfClass_ =
      objc.ObjCProtocolMethod<bool Function(objc.ObjCObjectBase)>(
    _sel_isMemberOfClass_,
    objc.getProtocolMethodSignature(
      _protocol_NSObject,
      _sel_isMemberOfClass_,
      isRequired: true,
      isInstanceMethod: true,
    ),
    (bool Function(objc.ObjCObjectBase) func) =>
        ObjCBlock_bool_ffiVoid_objcObjCObject.fromFunction(
            (ffi.Pointer<ffi.Void> _, objc.ObjCObjectBase arg1) => func(arg1)),
  );

  /// conformsToProtocol:
  static final conformsToProtocol_ =
      objc.ObjCProtocolMethod<bool Function(objc.Protocol)>(
    _sel_conformsToProtocol_,
    objc.getProtocolMethodSignature(
      _protocol_NSObject,
      _sel_conformsToProtocol_,
      isRequired: true,
      isInstanceMethod: true,
    ),
    (bool Function(objc.Protocol) func) =>
        ObjCBlock_bool_ffiVoid_Protocol.fromFunction(
            (ffi.Pointer<ffi.Void> _, objc.Protocol arg1) => func(arg1)),
  );

  /// respondsToSelector:
  static final respondsToSelector_ =
      objc.ObjCProtocolMethod<bool Function(ffi.Pointer<objc.ObjCSelector>)>(
    _sel_respondsToSelector_,
    objc.getProtocolMethodSignature(
      _protocol_NSObject,
      _sel_respondsToSelector_,
      isRequired: true,
      isInstanceMethod: true,
    ),
    (bool Function(ffi.Pointer<objc.ObjCSelector>) func) =>
        ObjCBlock_bool_ffiVoid_objcObjCSelector.fromFunction(
            (ffi.Pointer<ffi.Void> _, ffi.Pointer<objc.ObjCSelector> arg1) =>
                func(arg1)),
  );

  /// retain
  static final retain = objc.ObjCProtocolMethod<objc.ObjCObjectBase Function()>(
    _sel_retain,
    objc.getProtocolMethodSignature(
      _protocol_NSObject,
      _sel_retain,
      isRequired: true,
      isInstanceMethod: true,
    ),
    (objc.ObjCObjectBase Function() func) =>
        ObjCBlock_objcObjCObject_ffiVoid.fromFunction((
      ffi.Pointer<ffi.Void> _,
    ) =>
            func()),
  );

  /// release
  static final release = objc.ObjCProtocolListenableMethod<void Function()>(
    _sel_release,
    objc.getProtocolMethodSignature(
      _protocol_NSObject,
      _sel_release,
      isRequired: true,
      isInstanceMethod: true,
    ),
    (void Function() func) => ObjCBlock_ffiVoid_ffiVoid.fromFunction((
      ffi.Pointer<ffi.Void> _,
    ) =>
        func()),
    (void Function() func) => ObjCBlock_ffiVoid_ffiVoid.listener((
      ffi.Pointer<ffi.Void> _,
    ) =>
        func()),
  );

  /// autorelease
  static final autorelease =
      objc.ObjCProtocolMethod<objc.ObjCObjectBase Function()>(
    _sel_autorelease,
    objc.getProtocolMethodSignature(
      _protocol_NSObject,
      _sel_autorelease,
      isRequired: true,
      isInstanceMethod: true,
    ),
    (objc.ObjCObjectBase Function() func) =>
        ObjCBlock_objcObjCObject_ffiVoid.fromFunction((
      ffi.Pointer<ffi.Void> _,
    ) =>
            func()),
  );

  /// retainCount
  static final retainCount = objc.ObjCProtocolMethod<int Function()>(
    _sel_retainCount,
    objc.getProtocolMethodSignature(
      _protocol_NSObject,
      _sel_retainCount,
      isRequired: true,
      isInstanceMethod: true,
    ),
    (int Function() func) => ObjCBlock_ffiUnsignedLong_ffiVoid.fromFunction((
      ffi.Pointer<ffi.Void> _,
    ) =>
        func()),
  );

  /// zone
  static final zone = objc.ObjCProtocolMethod<ffi.Pointer<_NSZone> Function()>(
    _sel_zone,
    objc.getProtocolMethodSignature(
      _protocol_NSObject,
      _sel_zone,
      isRequired: true,
      isInstanceMethod: true,
    ),
    (ffi.Pointer<_NSZone> Function() func) =>
        ObjCBlock_NSZone_ffiVoid.fromFunction((
      ffi.Pointer<ffi.Void> _,
    ) =>
            func()),
  );

  /// hash
  static final hash = objc.ObjCProtocolMethod<int Function()>(
    _sel_hash,
    objc.getProtocolMethodSignature(
      _protocol_NSObject,
      _sel_hash,
      isRequired: true,
      isInstanceMethod: true,
    ),
    (int Function() func) => ObjCBlock_ffiUnsignedLong_ffiVoid.fromFunction((
      ffi.Pointer<ffi.Void> _,
    ) =>
        func()),
  );

  /// superclass
  static final superclass =
      objc.ObjCProtocolMethod<objc.ObjCObjectBase Function()>(
    _sel_superclass,
    objc.getProtocolMethodSignature(
      _protocol_NSObject,
      _sel_superclass,
      isRequired: true,
      isInstanceMethod: true,
    ),
    (objc.ObjCObjectBase Function() func) =>
        ObjCBlock_objcObjCObject_ffiVoid.fromFunction((
      ffi.Pointer<ffi.Void> _,
    ) =>
            func()),
  );

  /// description
  static final description = objc.ObjCProtocolMethod<objc.NSString Function()>(
    _sel_description,
    objc.getProtocolMethodSignature(
      _protocol_NSObject,
      _sel_description,
      isRequired: true,
      isInstanceMethod: true,
    ),
    (objc.NSString Function() func) => ObjCBlock_NSString_ffiVoid.fromFunction((
      ffi.Pointer<ffi.Void> _,
    ) =>
        func()),
  );

  /// debugDescription
  static final debugDescription =
      objc.ObjCProtocolMethod<objc.NSString Function()>(
    _sel_debugDescription,
    objc.getProtocolMethodSignature(
      _protocol_NSObject,
      _sel_debugDescription,
      isRequired: false,
      isInstanceMethod: true,
    ),
    (objc.NSString Function() func) => ObjCBlock_NSString_ffiVoid.fromFunction((
      ffi.Pointer<ffi.Void> _,
    ) =>
        func()),
  );
}

late final _protocol_NSObject = objc.getProtocol("NSObject");
late final _sel_isEqual_ = objc.registerName("isEqual:");
bool _ObjCBlock_bool_ffiVoid_objcObjCObject_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlock> block,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1) =>
    block.ref.target
        .cast<
            ffi.NativeFunction<
                ffi.Bool Function(ffi.Pointer<ffi.Void> arg0,
                    ffi.Pointer<objc.ObjCObject> arg1)>>()
        .asFunction<
            bool Function(ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>)>()(arg0, arg1);
bool _ObjCBlock_bool_ffiVoid_objcObjCObject_closureTrampoline(
        ffi.Pointer<objc.ObjCBlock> block,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1) =>
    (objc.getBlockClosure(block) as bool Function(
        ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>))(arg0, arg1);

class ObjCBlock_bool_ffiVoid_objcObjCObject extends objc.ObjCBlockBase {
  ObjCBlock_bool_ffiVoid_objcObjCObject._(ffi.Pointer<objc.ObjCBlock> pointer,
      {bool retain = false, bool release = true})
      : super(pointer, retain: retain, release: release);

  /// Returns a block that wraps the given raw block pointer.
  static ObjCBlock_bool_ffiVoid_objcObjCObject castFromPointer(
      ffi.Pointer<objc.ObjCBlock> pointer,
      {bool retain = false,
      bool release = false}) {
    return ObjCBlock_bool_ffiVoid_objcObjCObject._(pointer,
        retain: retain, release: release);
  }

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ObjCBlock_bool_ffiVoid_objcObjCObject.fromFunctionPointer(
      ffi
          .Pointer<
              ffi
              .NativeFunction<
                  ffi.Bool Function(ffi.Pointer<ffi.Void> arg0,
                      ffi.Pointer<objc.ObjCObject> arg1)>>
          ptr)
      : this._(objc
            .newPointerBlock(
                _cFuncTrampoline ??= ffi.Pointer.fromFunction<
                            ffi.Bool Function(
                                ffi.Pointer<objc.ObjCBlock>,
                                ffi.Pointer<ffi.Void>,
                                ffi.Pointer<objc.ObjCObject>)>(
                        _ObjCBlock_bool_ffiVoid_objcObjCObject_fnPtrTrampoline,
                        false)
                    .cast(),
                ptr.cast()));
  static ffi.Pointer<ffi.Void>? _cFuncTrampoline;

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ObjCBlock_bool_ffiVoid_objcObjCObject.fromFunction(
      bool Function(ffi.Pointer<ffi.Void>, objc.ObjCObjectBase) fn)
      : this._(objc.newClosureBlock(
            _dartFuncTrampoline ??= ffi.Pointer.fromFunction<
                        ffi.Bool Function(
                            ffi.Pointer<objc.ObjCBlock>,
                            ffi.Pointer<ffi.Void>,
                            ffi.Pointer<objc.ObjCObject>)>(
                    _ObjCBlock_bool_ffiVoid_objcObjCObject_closureTrampoline,
                    false)
                .cast(),
            (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1) => fn(
                arg0, objc.ObjCObjectBase(arg1, retain: true, release: true))));
  static ffi.Pointer<ffi.Void>? _dartFuncTrampoline;

  bool call(ffi.Pointer<ffi.Void> arg0, objc.ObjCObjectBase arg1) =>
      pointer.ref.invoke
          .cast<
              ffi.NativeFunction<
                  ffi.Bool Function(
                      ffi.Pointer<objc.ObjCBlock> block,
                      ffi.Pointer<ffi.Void> arg0,
                      ffi.Pointer<objc.ObjCObject> arg1)>>()
          .asFunction<
              bool Function(ffi.Pointer<objc.ObjCBlock>, ffi.Pointer<ffi.Void>,
                  ffi.Pointer<objc.ObjCObject>)>()(pointer, arg0, arg1.pointer);
}

late final _sel_class = objc.registerName("class");
ffi.Pointer<objc.ObjCObject> _ObjCBlock_objcObjCObject_ffiVoid_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlock> block, ffi.Pointer<ffi.Void> arg0) =>
    block.ref.target
        .cast<
            ffi.NativeFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<ffi.Void> arg0)>>()
        .asFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<ffi.Void>)>()(arg0);
ffi.Pointer<objc.ObjCObject>
    _ObjCBlock_objcObjCObject_ffiVoid_closureTrampoline(
            ffi.Pointer<objc.ObjCBlock> block, ffi.Pointer<ffi.Void> arg0) =>
        (objc.getBlockClosure(block) as ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<ffi.Void>))(arg0);

class ObjCBlock_objcObjCObject_ffiVoid extends objc.ObjCBlockBase {
  ObjCBlock_objcObjCObject_ffiVoid._(ffi.Pointer<objc.ObjCBlock> pointer,
      {bool retain = false, bool release = true})
      : super(pointer, retain: retain, release: release);

  /// Returns a block that wraps the given raw block pointer.
  static ObjCBlock_objcObjCObject_ffiVoid castFromPointer(
      ffi.Pointer<objc.ObjCBlock> pointer,
      {bool retain = false,
      bool release = false}) {
    return ObjCBlock_objcObjCObject_ffiVoid._(pointer,
        retain: retain, release: release);
  }

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ObjCBlock_objcObjCObject_ffiVoid.fromFunctionPointer(
      ffi.Pointer<
              ffi.NativeFunction<
                  ffi.Pointer<objc.ObjCObject> Function(
                      ffi.Pointer<ffi.Void> arg0)>>
          ptr)
      : this._(objc.newPointerBlock(
            _cFuncTrampoline ??= ffi.Pointer.fromFunction<
                        ffi.Pointer<objc.ObjCObject> Function(
                            ffi.Pointer<objc.ObjCBlock>,
                            ffi.Pointer<ffi.Void>)>(
                    _ObjCBlock_objcObjCObject_ffiVoid_fnPtrTrampoline)
                .cast(),
            ptr.cast()));
  static ffi.Pointer<ffi.Void>? _cFuncTrampoline;

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ObjCBlock_objcObjCObject_ffiVoid.fromFunction(
      objc.ObjCObjectBase Function(ffi.Pointer<ffi.Void>) fn)
      : this._(objc.newClosureBlock(
            _dartFuncTrampoline ??= ffi.Pointer.fromFunction<
                        ffi.Pointer<objc.ObjCObject> Function(
                            ffi.Pointer<objc.ObjCBlock>,
                            ffi.Pointer<ffi.Void>)>(
                    _ObjCBlock_objcObjCObject_ffiVoid_closureTrampoline)
                .cast(),
            (ffi.Pointer<ffi.Void> arg0) => fn(arg0).retainAndReturnPointer()));
  static ffi.Pointer<ffi.Void>? _dartFuncTrampoline;

  objc.ObjCObjectBase call(ffi.Pointer<ffi.Void> arg0) => objc.ObjCObjectBase(
      pointer.ref.invoke
          .cast<
              ffi.NativeFunction<
                  ffi.Pointer<objc.ObjCObject> Function(
                      ffi.Pointer<objc.ObjCBlock> block,
                      ffi.Pointer<ffi.Void> arg0)>>()
          .asFunction<
              ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCBlock>,
                  ffi.Pointer<ffi.Void>)>()(pointer, arg0),
      retain: false,
      release: true);
}

late final _sel_self = objc.registerName("self");
late final _sel_performSelector_ = objc.registerName("performSelector:");
ffi.Pointer<objc.ObjCObject>
    _ObjCBlock_objcObjCObject_ffiVoid_objcObjCSelector_fnPtrTrampoline(
            ffi.Pointer<objc.ObjCBlock> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCSelector> arg1) =>
        block.ref.target
            .cast<
                ffi.NativeFunction<
                    ffi.Pointer<objc.ObjCObject> Function(
                        ffi.Pointer<ffi.Void> arg0,
                        ffi.Pointer<objc.ObjCSelector> arg1)>>()
            .asFunction<
                ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>,
                    ffi.Pointer<objc.ObjCSelector>)>()(arg0, arg1);
ffi.Pointer<objc.ObjCObject>
    _ObjCBlock_objcObjCObject_ffiVoid_objcObjCSelector_closureTrampoline(
            ffi.Pointer<objc.ObjCBlock> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCSelector> arg1) =>
        (objc.getBlockClosure(block) as ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCSelector>))(arg0, arg1);

class ObjCBlock_objcObjCObject_ffiVoid_objcObjCSelector
    extends objc.ObjCBlockBase {
  ObjCBlock_objcObjCObject_ffiVoid_objcObjCSelector._(
      ffi.Pointer<objc.ObjCBlock> pointer,
      {bool retain = false,
      bool release = true})
      : super(pointer, retain: retain, release: release);

  /// Returns a block that wraps the given raw block pointer.
  static ObjCBlock_objcObjCObject_ffiVoid_objcObjCSelector castFromPointer(
      ffi.Pointer<objc.ObjCBlock> pointer,
      {bool retain = false,
      bool release = false}) {
    return ObjCBlock_objcObjCObject_ffiVoid_objcObjCSelector._(pointer,
        retain: retain, release: release);
  }

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ObjCBlock_objcObjCObject_ffiVoid_objcObjCSelector.fromFunctionPointer(
      ffi.Pointer<
              ffi.NativeFunction<
                  ffi.Pointer<objc.ObjCObject> Function(
                      ffi.Pointer<ffi.Void> arg0,
                      ffi.Pointer<objc.ObjCSelector> arg1)>>
          ptr)
      : this._(objc.newPointerBlock(
            _cFuncTrampoline ??= ffi.Pointer.fromFunction<
                        ffi.Pointer<objc.ObjCObject> Function(
                            ffi.Pointer<objc.ObjCBlock>,
                            ffi.Pointer<ffi.Void>,
                            ffi.Pointer<objc.ObjCSelector>)>(
                    _ObjCBlock_objcObjCObject_ffiVoid_objcObjCSelector_fnPtrTrampoline)
                .cast(),
            ptr.cast()));
  static ffi.Pointer<ffi.Void>? _cFuncTrampoline;

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ObjCBlock_objcObjCObject_ffiVoid_objcObjCSelector.fromFunction(
      objc.ObjCObjectBase Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCSelector>)
          fn)
      : this._(objc.newClosureBlock(
            _dartFuncTrampoline ??= ffi.Pointer.fromFunction<
                        ffi.Pointer<objc.ObjCObject> Function(
                            ffi.Pointer<objc.ObjCBlock>,
                            ffi.Pointer<ffi.Void>,
                            ffi.Pointer<objc.ObjCSelector>)>(
                    _ObjCBlock_objcObjCObject_ffiVoid_objcObjCSelector_closureTrampoline)
                .cast(),
            (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCSelector> arg1) =>
                fn(arg0, arg1).retainAndReturnPointer()));
  static ffi.Pointer<ffi.Void>? _dartFuncTrampoline;

  objc.ObjCObjectBase call(
          ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCSelector> arg1) =>
      objc.ObjCObjectBase(
          pointer.ref.invoke
              .cast<
                  ffi.NativeFunction<
                      ffi.Pointer<objc.ObjCObject> Function(
                          ffi.Pointer<objc.ObjCBlock> block,
                          ffi.Pointer<ffi.Void> arg0,
                          ffi.Pointer<objc.ObjCSelector> arg1)>>()
              .asFunction<
                  ffi.Pointer<objc.ObjCObject> Function(
                      ffi.Pointer<objc.ObjCBlock>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<objc.ObjCSelector>)>()(pointer, arg0, arg1),
          retain: false,
          release: true);
}

late final _sel_performSelector_withObject_ =
    objc.registerName("performSelector:withObject:");
ffi.Pointer<objc.ObjCObject>
    _ObjCBlock_objcObjCObject_ffiVoid_objcObjCSelector_objcObjCObject_fnPtrTrampoline(
            ffi.Pointer<objc.ObjCBlock> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCSelector> arg1,
            ffi.Pointer<objc.ObjCObject> arg2) =>
        block.ref.target
            .cast<
                ffi.NativeFunction<
                    ffi.Pointer<objc.ObjCObject> Function(
                        ffi.Pointer<ffi.Void> arg0,
                        ffi.Pointer<objc.ObjCSelector> arg1,
                        ffi.Pointer<objc.ObjCObject> arg2)>>()
            .asFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<ffi.Void>,
                    ffi.Pointer<objc.ObjCSelector>,
                    ffi.Pointer<objc.ObjCObject>)>()(arg0, arg1, arg2);
ffi.Pointer<objc.ObjCObject>
    _ObjCBlock_objcObjCObject_ffiVoid_objcObjCSelector_objcObjCObject_closureTrampoline(
            ffi.Pointer<objc.ObjCBlock> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCSelector> arg1,
            ffi.Pointer<objc.ObjCObject> arg2) =>
        (objc.getBlockClosure(block) as ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>))(arg0, arg1, arg2);

class ObjCBlock_objcObjCObject_ffiVoid_objcObjCSelector_objcObjCObject
    extends objc.ObjCBlockBase {
  ObjCBlock_objcObjCObject_ffiVoid_objcObjCSelector_objcObjCObject._(
      ffi.Pointer<objc.ObjCBlock> pointer,
      {bool retain = false,
      bool release = true})
      : super(pointer, retain: retain, release: release);

  /// Returns a block that wraps the given raw block pointer.
  static ObjCBlock_objcObjCObject_ffiVoid_objcObjCSelector_objcObjCObject
      castFromPointer(ffi.Pointer<objc.ObjCBlock> pointer,
          {bool retain = false, bool release = false}) {
    return ObjCBlock_objcObjCObject_ffiVoid_objcObjCSelector_objcObjCObject._(
        pointer,
        retain: retain,
        release: release);
  }

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ObjCBlock_objcObjCObject_ffiVoid_objcObjCSelector_objcObjCObject.fromFunctionPointer(
      ffi.Pointer<
              ffi.NativeFunction<
                  ffi.Pointer<objc.ObjCObject> Function(
                      ffi.Pointer<ffi.Void> arg0,
                      ffi.Pointer<objc.ObjCSelector> arg1,
                      ffi.Pointer<objc.ObjCObject> arg2)>>
          ptr)
      : this._(objc.newPointerBlock(
            _cFuncTrampoline ??= ffi.Pointer.fromFunction<
                        ffi.Pointer<objc.ObjCObject> Function(
                            ffi.Pointer<objc.ObjCBlock>,
                            ffi.Pointer<ffi.Void>,
                            ffi.Pointer<objc.ObjCSelector>,
                            ffi.Pointer<objc.ObjCObject>)>(
                    _ObjCBlock_objcObjCObject_ffiVoid_objcObjCSelector_objcObjCObject_fnPtrTrampoline)
                .cast(),
            ptr.cast()));
  static ffi.Pointer<ffi.Void>? _cFuncTrampoline;

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ObjCBlock_objcObjCObject_ffiVoid_objcObjCSelector_objcObjCObject.fromFunction(
      objc.ObjCObjectBase Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCSelector>, objc.ObjCObjectBase)
          fn)
      : this._(objc.newClosureBlock(
            _dartFuncTrampoline ??= ffi.Pointer.fromFunction<
                        ffi.Pointer<objc.ObjCObject> Function(
                            ffi.Pointer<objc.ObjCBlock>,
                            ffi.Pointer<ffi.Void>,
                            ffi.Pointer<objc.ObjCSelector>,
                            ffi.Pointer<objc.ObjCObject>)>(
                    _ObjCBlock_objcObjCObject_ffiVoid_objcObjCSelector_objcObjCObject_closureTrampoline)
                .cast(),
            (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCSelector> arg1,
                    ffi.Pointer<objc.ObjCObject> arg2) =>
                fn(arg0, arg1, objc.ObjCObjectBase(arg2, retain: true, release: true)).retainAndReturnPointer()));
  static ffi.Pointer<ffi.Void>? _dartFuncTrampoline;

  objc.ObjCObjectBase call(ffi.Pointer<ffi.Void> arg0,
          ffi.Pointer<objc.ObjCSelector> arg1, objc.ObjCObjectBase arg2) =>
      objc.ObjCObjectBase(
          pointer.ref.invoke
                  .cast<
                      ffi.NativeFunction<
                          ffi.Pointer<objc.ObjCObject> Function(
                              ffi.Pointer<objc.ObjCBlock> block,
                              ffi.Pointer<ffi.Void> arg0,
                              ffi.Pointer<objc.ObjCSelector> arg1,
                              ffi.Pointer<objc.ObjCObject> arg2)>>()
                  .asFunction<
                      ffi.Pointer<objc.ObjCObject> Function(
                          ffi.Pointer<objc.ObjCBlock>,
                          ffi.Pointer<ffi.Void>,
                          ffi.Pointer<objc.ObjCSelector>,
                          ffi.Pointer<objc.ObjCObject>)>()(
              pointer, arg0, arg1, arg2.pointer),
          retain: false,
          release: true);
}

late final _sel_performSelector_withObject_withObject_ =
    objc.registerName("performSelector:withObject:withObject:");
ffi.Pointer<objc.ObjCObject>
    _ObjCBlock_objcObjCObject_ffiVoid_objcObjCSelector_objcObjCObject_objcObjCObject_fnPtrTrampoline(
            ffi.Pointer<objc.ObjCBlock> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCSelector> arg1,
            ffi.Pointer<objc.ObjCObject> arg2,
            ffi.Pointer<objc.ObjCObject> arg3) =>
        block.ref.target
            .cast<
                ffi.NativeFunction<
                    ffi.Pointer<objc.ObjCObject> Function(
                        ffi.Pointer<ffi.Void> arg0,
                        ffi.Pointer<objc.ObjCSelector> arg1,
                        ffi.Pointer<objc.ObjCObject> arg2,
                        ffi.Pointer<objc.ObjCObject> arg3)>>()
            .asFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<ffi.Void>,
                    ffi.Pointer<objc.ObjCSelector>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>)>()(arg0, arg1, arg2, arg3);
ffi.Pointer<objc.ObjCObject>
    _ObjCBlock_objcObjCObject_ffiVoid_objcObjCSelector_objcObjCObject_objcObjCObject_closureTrampoline(
            ffi.Pointer<objc.ObjCBlock> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCSelector> arg1,
            ffi.Pointer<objc.ObjCObject> arg2,
            ffi.Pointer<objc.ObjCObject> arg3) =>
        (objc.getBlockClosure(block) as ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>))(arg0, arg1, arg2, arg3);

class ObjCBlock_objcObjCObject_ffiVoid_objcObjCSelector_objcObjCObject_objcObjCObject
    extends objc.ObjCBlockBase {
  ObjCBlock_objcObjCObject_ffiVoid_objcObjCSelector_objcObjCObject_objcObjCObject._(
      ffi.Pointer<objc.ObjCBlock> pointer,
      {bool retain = false,
      bool release = true})
      : super(pointer, retain: retain, release: release);

  /// Returns a block that wraps the given raw block pointer.
  static ObjCBlock_objcObjCObject_ffiVoid_objcObjCSelector_objcObjCObject_objcObjCObject
      castFromPointer(ffi.Pointer<objc.ObjCBlock> pointer,
          {bool retain = false, bool release = false}) {
    return ObjCBlock_objcObjCObject_ffiVoid_objcObjCSelector_objcObjCObject_objcObjCObject
        ._(pointer, retain: retain, release: release);
  }

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ObjCBlock_objcObjCObject_ffiVoid_objcObjCSelector_objcObjCObject_objcObjCObject.fromFunctionPointer(
      ffi.Pointer<
              ffi.NativeFunction<
                  ffi.Pointer<objc.ObjCObject> Function(
                      ffi.Pointer<ffi.Void> arg0,
                      ffi.Pointer<objc.ObjCSelector> arg1,
                      ffi.Pointer<objc.ObjCObject> arg2,
                      ffi.Pointer<objc.ObjCObject> arg3)>>
          ptr)
      : this._(objc.newPointerBlock(
            _cFuncTrampoline ??= ffi.Pointer.fromFunction<
                        ffi.Pointer<objc.ObjCObject> Function(
                            ffi.Pointer<objc.ObjCBlock>,
                            ffi.Pointer<ffi.Void>,
                            ffi.Pointer<objc.ObjCSelector>,
                            ffi.Pointer<objc.ObjCObject>,
                            ffi.Pointer<objc.ObjCObject>)>(
                    _ObjCBlock_objcObjCObject_ffiVoid_objcObjCSelector_objcObjCObject_objcObjCObject_fnPtrTrampoline)
                .cast(),
            ptr.cast()));
  static ffi.Pointer<ffi.Void>? _cFuncTrampoline;

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ObjCBlock_objcObjCObject_ffiVoid_objcObjCSelector_objcObjCObject_objcObjCObject.fromFunction(
      objc.ObjCObjectBase Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCSelector>, objc.ObjCObjectBase, objc.ObjCObjectBase)
          fn)
      : this._(objc.newClosureBlock(
            _dartFuncTrampoline ??= ffi.Pointer.fromFunction<
                        ffi.Pointer<objc.ObjCObject> Function(
                            ffi.Pointer<objc.ObjCBlock>,
                            ffi.Pointer<ffi.Void>,
                            ffi.Pointer<objc.ObjCSelector>,
                            ffi.Pointer<objc.ObjCObject>,
                            ffi.Pointer<objc.ObjCObject>)>(
                    _ObjCBlock_objcObjCObject_ffiVoid_objcObjCSelector_objcObjCObject_objcObjCObject_closureTrampoline)
                .cast(),
            (ffi.Pointer<ffi.Void> arg0,
                    ffi.Pointer<objc.ObjCSelector> arg1,
                    ffi.Pointer<objc.ObjCObject> arg2,
                    ffi.Pointer<objc.ObjCObject> arg3) =>
                fn(arg0, arg1, objc.ObjCObjectBase(arg2, retain: true, release: true), objc.ObjCObjectBase(arg3, retain: true, release: true)).retainAndReturnPointer()));
  static ffi.Pointer<ffi.Void>? _dartFuncTrampoline;

  objc.ObjCObjectBase call(
          ffi.Pointer<ffi.Void> arg0,
          ffi.Pointer<objc.ObjCSelector> arg1,
          objc.ObjCObjectBase arg2,
          objc.ObjCObjectBase arg3) =>
      objc.ObjCObjectBase(
          pointer.ref.invoke
              .cast<
                  ffi.NativeFunction<
                      ffi.Pointer<objc.ObjCObject> Function(
                          ffi.Pointer<objc.ObjCBlock> block,
                          ffi.Pointer<ffi.Void> arg0,
                          ffi.Pointer<objc.ObjCSelector> arg1,
                          ffi.Pointer<objc.ObjCObject> arg2,
                          ffi.Pointer<objc.ObjCObject> arg3)>>()
              .asFunction<
                  ffi.Pointer<objc.ObjCObject> Function(
                      ffi.Pointer<objc.ObjCBlock>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<objc.ObjCSelector>,
                      ffi.Pointer<objc.ObjCObject>,
                      ffi.Pointer<objc.ObjCObject>)>()(pointer, arg0, arg1, arg2.pointer, arg3.pointer),
          retain: false,
          release: true);
}

late final _sel_isProxy = objc.registerName("isProxy");
bool _ObjCBlock_bool_ffiVoid_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlock> block, ffi.Pointer<ffi.Void> arg0) =>
    block.ref.target
        .cast<
            ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<ffi.Void> arg0)>>()
        .asFunction<bool Function(ffi.Pointer<ffi.Void>)>()(arg0);
bool _ObjCBlock_bool_ffiVoid_closureTrampoline(
        ffi.Pointer<objc.ObjCBlock> block, ffi.Pointer<ffi.Void> arg0) =>
    (objc.getBlockClosure(block) as bool Function(ffi.Pointer<ffi.Void>))(arg0);

class ObjCBlock_bool_ffiVoid extends objc.ObjCBlockBase {
  ObjCBlock_bool_ffiVoid._(ffi.Pointer<objc.ObjCBlock> pointer,
      {bool retain = false, bool release = true})
      : super(pointer, retain: retain, release: release);

  /// Returns a block that wraps the given raw block pointer.
  static ObjCBlock_bool_ffiVoid castFromPointer(
      ffi.Pointer<objc.ObjCBlock> pointer,
      {bool retain = false,
      bool release = false}) {
    return ObjCBlock_bool_ffiVoid._(pointer, retain: retain, release: release);
  }

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ObjCBlock_bool_ffiVoid.fromFunctionPointer(
      ffi.Pointer<
              ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<ffi.Void> arg0)>>
          ptr)
      : this._(objc
            .newPointerBlock(
                _cFuncTrampoline ??= ffi.Pointer.fromFunction<
                            ffi.Bool Function(ffi.Pointer<objc.ObjCBlock>,
                                ffi.Pointer<ffi.Void>)>(
                        _ObjCBlock_bool_ffiVoid_fnPtrTrampoline, false)
                    .cast(),
                ptr.cast()));
  static ffi.Pointer<ffi.Void>? _cFuncTrampoline;

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ObjCBlock_bool_ffiVoid.fromFunction(bool Function(ffi.Pointer<ffi.Void>) fn)
      : this._(objc.newClosureBlock(
            _dartFuncTrampoline ??= ffi.Pointer.fromFunction<
                        ffi.Bool Function(ffi.Pointer<objc.ObjCBlock>,
                            ffi.Pointer<ffi.Void>)>(
                    _ObjCBlock_bool_ffiVoid_closureTrampoline, false)
                .cast(),
            (ffi.Pointer<ffi.Void> arg0) => fn(arg0)));
  static ffi.Pointer<ffi.Void>? _dartFuncTrampoline;

  bool call(ffi.Pointer<ffi.Void> arg0) => pointer.ref.invoke
      .cast<
          ffi.NativeFunction<
              ffi.Bool Function(ffi.Pointer<objc.ObjCBlock> block,
                  ffi.Pointer<ffi.Void> arg0)>>()
      .asFunction<
          bool Function(ffi.Pointer<objc.ObjCBlock>,
              ffi.Pointer<ffi.Void>)>()(pointer, arg0);
}

late final _sel_isMemberOfClass_ = objc.registerName("isMemberOfClass:");
late final _sel_conformsToProtocol_ = objc.registerName("conformsToProtocol:");
bool _ObjCBlock_bool_ffiVoid_Protocol_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlock> block,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1) =>
    block.ref.target
        .cast<
            ffi.NativeFunction<
                ffi.Bool Function(ffi.Pointer<ffi.Void> arg0,
                    ffi.Pointer<objc.ObjCObject> arg1)>>()
        .asFunction<
            bool Function(ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>)>()(arg0, arg1);
bool _ObjCBlock_bool_ffiVoid_Protocol_closureTrampoline(
        ffi.Pointer<objc.ObjCBlock> block,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1) =>
    (objc.getBlockClosure(block) as bool Function(
        ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>))(arg0, arg1);

class ObjCBlock_bool_ffiVoid_Protocol extends objc.ObjCBlockBase {
  ObjCBlock_bool_ffiVoid_Protocol._(ffi.Pointer<objc.ObjCBlock> pointer,
      {bool retain = false, bool release = true})
      : super(pointer, retain: retain, release: release);

  /// Returns a block that wraps the given raw block pointer.
  static ObjCBlock_bool_ffiVoid_Protocol castFromPointer(
      ffi.Pointer<objc.ObjCBlock> pointer,
      {bool retain = false,
      bool release = false}) {
    return ObjCBlock_bool_ffiVoid_Protocol._(pointer,
        retain: retain, release: release);
  }

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ObjCBlock_bool_ffiVoid_Protocol.fromFunctionPointer(
      ffi.Pointer<
              ffi.NativeFunction<
                  ffi.Bool Function(ffi.Pointer<ffi.Void> arg0,
                      ffi.Pointer<objc.ObjCObject> arg1)>>
          ptr)
      : this._(objc.newPointerBlock(
            _cFuncTrampoline ??= ffi.Pointer.fromFunction<
                        ffi.Bool Function(
                            ffi.Pointer<objc.ObjCBlock>,
                            ffi.Pointer<ffi.Void>,
                            ffi.Pointer<objc.ObjCObject>)>(
                    _ObjCBlock_bool_ffiVoid_Protocol_fnPtrTrampoline, false)
                .cast(),
            ptr.cast()));
  static ffi.Pointer<ffi.Void>? _cFuncTrampoline;

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ObjCBlock_bool_ffiVoid_Protocol.fromFunction(
      bool Function(ffi.Pointer<ffi.Void>, objc.Protocol) fn)
      : this._(objc.newClosureBlock(
            _dartFuncTrampoline ??= ffi.Pointer.fromFunction<
                        ffi.Bool Function(
                            ffi.Pointer<objc.ObjCBlock>,
                            ffi.Pointer<ffi.Void>,
                            ffi.Pointer<objc.ObjCObject>)>(
                    _ObjCBlock_bool_ffiVoid_Protocol_closureTrampoline, false)
                .cast(),
            (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1) => fn(
                arg0,
                objc.Protocol.castFromPointer(arg1, retain: true, release: true))));
  static ffi.Pointer<ffi.Void>? _dartFuncTrampoline;

  bool call(ffi.Pointer<ffi.Void> arg0, objc.Protocol arg1) =>
      pointer.ref.invoke
          .cast<
              ffi.NativeFunction<
                  ffi.Bool Function(
                      ffi.Pointer<objc.ObjCBlock> block,
                      ffi.Pointer<ffi.Void> arg0,
                      ffi.Pointer<objc.ObjCObject> arg1)>>()
          .asFunction<
              bool Function(ffi.Pointer<objc.ObjCBlock>, ffi.Pointer<ffi.Void>,
                  ffi.Pointer<objc.ObjCObject>)>()(pointer, arg0, arg1.pointer);
}

late final _sel_respondsToSelector_ = objc.registerName("respondsToSelector:");
bool _ObjCBlock_bool_ffiVoid_objcObjCSelector_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlock> block,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCSelector> arg1) =>
    block.ref.target
        .cast<
            ffi.NativeFunction<
                ffi.Bool Function(ffi.Pointer<ffi.Void> arg0,
                    ffi.Pointer<objc.ObjCSelector> arg1)>>()
        .asFunction<
            bool Function(ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCSelector>)>()(arg0, arg1);
bool _ObjCBlock_bool_ffiVoid_objcObjCSelector_closureTrampoline(
        ffi.Pointer<objc.ObjCBlock> block,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCSelector> arg1) =>
    (objc.getBlockClosure(block) as bool Function(
        ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCSelector>))(arg0, arg1);

class ObjCBlock_bool_ffiVoid_objcObjCSelector extends objc.ObjCBlockBase {
  ObjCBlock_bool_ffiVoid_objcObjCSelector._(ffi.Pointer<objc.ObjCBlock> pointer,
      {bool retain = false, bool release = true})
      : super(pointer, retain: retain, release: release);

  /// Returns a block that wraps the given raw block pointer.
  static ObjCBlock_bool_ffiVoid_objcObjCSelector castFromPointer(
      ffi.Pointer<objc.ObjCBlock> pointer,
      {bool retain = false,
      bool release = false}) {
    return ObjCBlock_bool_ffiVoid_objcObjCSelector._(pointer,
        retain: retain, release: release);
  }

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ObjCBlock_bool_ffiVoid_objcObjCSelector.fromFunctionPointer(
      ffi.Pointer<
              ffi.NativeFunction<
                  ffi.Bool Function(ffi.Pointer<ffi.Void> arg0,
                      ffi.Pointer<objc.ObjCSelector> arg1)>>
          ptr)
      : this._(objc.newPointerBlock(
            _cFuncTrampoline ??= ffi.Pointer.fromFunction<
                        ffi.Bool Function(
                            ffi.Pointer<objc.ObjCBlock>,
                            ffi.Pointer<ffi.Void>,
                            ffi.Pointer<objc.ObjCSelector>)>(
                    _ObjCBlock_bool_ffiVoid_objcObjCSelector_fnPtrTrampoline,
                    false)
                .cast(),
            ptr.cast()));
  static ffi.Pointer<ffi.Void>? _cFuncTrampoline;

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ObjCBlock_bool_ffiVoid_objcObjCSelector.fromFunction(
      bool Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCSelector>) fn)
      : this._(objc.newClosureBlock(
            _dartFuncTrampoline ??= ffi.Pointer.fromFunction<
                        ffi.Bool Function(
                            ffi.Pointer<objc.ObjCBlock>,
                            ffi.Pointer<ffi.Void>,
                            ffi.Pointer<objc.ObjCSelector>)>(
                    _ObjCBlock_bool_ffiVoid_objcObjCSelector_closureTrampoline,
                    false)
                .cast(),
            (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCSelector> arg1) =>
                fn(arg0, arg1)));
  static ffi.Pointer<ffi.Void>? _dartFuncTrampoline;

  bool call(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCSelector> arg1) =>
      pointer.ref.invoke
          .cast<
              ffi.NativeFunction<
                  ffi.Bool Function(
                      ffi.Pointer<objc.ObjCBlock> block,
                      ffi.Pointer<ffi.Void> arg0,
                      ffi.Pointer<objc.ObjCSelector> arg1)>>()
          .asFunction<
              bool Function(ffi.Pointer<objc.ObjCBlock>, ffi.Pointer<ffi.Void>,
                  ffi.Pointer<objc.ObjCSelector>)>()(pointer, arg0, arg1);
}

late final _sel_retain = objc.registerName("retain");
late final _sel_release = objc.registerName("release");
void _ObjCBlock_ffiVoid_ffiVoid_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlock> block, ffi.Pointer<ffi.Void> arg0) =>
    block.ref.target
        .cast<
            ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void> arg0)>>()
        .asFunction<void Function(ffi.Pointer<ffi.Void>)>()(arg0);
void _ObjCBlock_ffiVoid_ffiVoid_closureTrampoline(
        ffi.Pointer<objc.ObjCBlock> block, ffi.Pointer<ffi.Void> arg0) =>
    (objc.getBlockClosure(block) as void Function(ffi.Pointer<ffi.Void>))(arg0);

class ObjCBlock_ffiVoid_ffiVoid extends objc.ObjCBlockBase {
  ObjCBlock_ffiVoid_ffiVoid._(ffi.Pointer<objc.ObjCBlock> pointer,
      {bool retain = false, bool release = true})
      : super(pointer, retain: retain, release: release);

  /// Returns a block that wraps the given raw block pointer.
  static ObjCBlock_ffiVoid_ffiVoid castFromPointer(
      ffi.Pointer<objc.ObjCBlock> pointer,
      {bool retain = false,
      bool release = false}) {
    return ObjCBlock_ffiVoid_ffiVoid._(pointer,
        retain: retain, release: release);
  }

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ObjCBlock_ffiVoid_ffiVoid.fromFunctionPointer(
      ffi.Pointer<
              ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void> arg0)>>
          ptr)
      : this._(objc
            .newPointerBlock(
                _cFuncTrampoline ??= ffi.Pointer.fromFunction<
                            ffi.Void Function(ffi.Pointer<objc.ObjCBlock>,
                                ffi.Pointer<ffi.Void>)>(
                        _ObjCBlock_ffiVoid_ffiVoid_fnPtrTrampoline)
                    .cast(),
                ptr.cast()));
  static ffi.Pointer<ffi.Void>? _cFuncTrampoline;

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ObjCBlock_ffiVoid_ffiVoid.fromFunction(
      void Function(ffi.Pointer<ffi.Void>) fn)
      : this._(objc.newClosureBlock(
            _dartFuncTrampoline ??= ffi.Pointer.fromFunction<
                        ffi.Void Function(ffi.Pointer<objc.ObjCBlock>,
                            ffi.Pointer<ffi.Void>)>(
                    _ObjCBlock_ffiVoid_ffiVoid_closureTrampoline)
                .cast(),
            (ffi.Pointer<ffi.Void> arg0) => fn(arg0)));
  static ffi.Pointer<ffi.Void>? _dartFuncTrampoline;

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// Note that unlike the default behavior of NativeCallable.listener, listener
  /// blocks do not keep the isolate alive.
  ObjCBlock_ffiVoid_ffiVoid.listener(void Function(ffi.Pointer<ffi.Void>) fn)
      : this._((objc.newClosureBlock(
            (_dartFuncListenerTrampoline ??= ffi.NativeCallable<
                        ffi.Void Function(ffi.Pointer<objc.ObjCBlock>,
                            ffi.Pointer<ffi.Void>)>.listener(
                    _ObjCBlock_ffiVoid_ffiVoid_closureTrampoline)
                  ..keepIsolateAlive = false)
                .nativeFunction
                .cast(),
            (ffi.Pointer<ffi.Void> arg0) => fn(arg0))));
  static ffi.NativeCallable<
          ffi.Void Function(
              ffi.Pointer<objc.ObjCBlock>, ffi.Pointer<ffi.Void>)>?
      _dartFuncListenerTrampoline;

  void call(ffi.Pointer<ffi.Void> arg0) => pointer.ref.invoke
      .cast<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<objc.ObjCBlock> block,
                  ffi.Pointer<ffi.Void> arg0)>>()
      .asFunction<
          void Function(ffi.Pointer<objc.ObjCBlock>,
              ffi.Pointer<ffi.Void>)>()(pointer, arg0);
}

late final _sel_autorelease = objc.registerName("autorelease");
late final _sel_retainCount = objc.registerName("retainCount");
int _ObjCBlock_ffiUnsignedLong_ffiVoid_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlock> block, ffi.Pointer<ffi.Void> arg0) =>
    block.ref.target
        .cast<
            ffi.NativeFunction<
                ffi.UnsignedLong Function(ffi.Pointer<ffi.Void> arg0)>>()
        .asFunction<int Function(ffi.Pointer<ffi.Void>)>()(arg0);
int _ObjCBlock_ffiUnsignedLong_ffiVoid_closureTrampoline(
        ffi.Pointer<objc.ObjCBlock> block, ffi.Pointer<ffi.Void> arg0) =>
    (objc.getBlockClosure(block) as int Function(ffi.Pointer<ffi.Void>))(arg0);

class ObjCBlock_ffiUnsignedLong_ffiVoid extends objc.ObjCBlockBase {
  ObjCBlock_ffiUnsignedLong_ffiVoid._(ffi.Pointer<objc.ObjCBlock> pointer,
      {bool retain = false, bool release = true})
      : super(pointer, retain: retain, release: release);

  /// Returns a block that wraps the given raw block pointer.
  static ObjCBlock_ffiUnsignedLong_ffiVoid castFromPointer(
      ffi.Pointer<objc.ObjCBlock> pointer,
      {bool retain = false,
      bool release = false}) {
    return ObjCBlock_ffiUnsignedLong_ffiVoid._(pointer,
        retain: retain, release: release);
  }

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ObjCBlock_ffiUnsignedLong_ffiVoid.fromFunctionPointer(
      ffi.Pointer<
              ffi.NativeFunction<
                  ffi.UnsignedLong Function(ffi.Pointer<ffi.Void> arg0)>>
          ptr)
      : this._(objc.newPointerBlock(
            _cFuncTrampoline ??= ffi.Pointer.fromFunction<
                        ffi.UnsignedLong Function(ffi.Pointer<objc.ObjCBlock>,
                            ffi.Pointer<ffi.Void>)>(
                    _ObjCBlock_ffiUnsignedLong_ffiVoid_fnPtrTrampoline, 0)
                .cast(),
            ptr.cast()));
  static ffi.Pointer<ffi.Void>? _cFuncTrampoline;

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ObjCBlock_ffiUnsignedLong_ffiVoid.fromFunction(
      int Function(ffi.Pointer<ffi.Void>) fn)
      : this._(objc.newClosureBlock(
            _dartFuncTrampoline ??= ffi.Pointer.fromFunction<
                        ffi.UnsignedLong Function(ffi.Pointer<objc.ObjCBlock>,
                            ffi.Pointer<ffi.Void>)>(
                    _ObjCBlock_ffiUnsignedLong_ffiVoid_closureTrampoline, 0)
                .cast(),
            (ffi.Pointer<ffi.Void> arg0) => fn(arg0)));
  static ffi.Pointer<ffi.Void>? _dartFuncTrampoline;

  int call(ffi.Pointer<ffi.Void> arg0) => pointer.ref.invoke
      .cast<
          ffi.NativeFunction<
              ffi.UnsignedLong Function(ffi.Pointer<objc.ObjCBlock> block,
                  ffi.Pointer<ffi.Void> arg0)>>()
      .asFunction<
          int Function(ffi.Pointer<objc.ObjCBlock>,
              ffi.Pointer<ffi.Void>)>()(pointer, arg0);
}

late final _sel_zone = objc.registerName("zone");
ffi.Pointer<_NSZone> _ObjCBlock_NSZone_ffiVoid_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlock> block, ffi.Pointer<ffi.Void> arg0) =>
    block.ref.target
        .cast<
            ffi.NativeFunction<
                ffi.Pointer<_NSZone> Function(ffi.Pointer<ffi.Void> arg0)>>()
        .asFunction<
            ffi.Pointer<_NSZone> Function(ffi.Pointer<ffi.Void>)>()(arg0);
ffi.Pointer<_NSZone> _ObjCBlock_NSZone_ffiVoid_closureTrampoline(
        ffi.Pointer<objc.ObjCBlock> block, ffi.Pointer<ffi.Void> arg0) =>
    (objc.getBlockClosure(block) as ffi.Pointer<_NSZone> Function(
        ffi.Pointer<ffi.Void>))(arg0);

class ObjCBlock_NSZone_ffiVoid extends objc.ObjCBlockBase {
  ObjCBlock_NSZone_ffiVoid._(ffi.Pointer<objc.ObjCBlock> pointer,
      {bool retain = false, bool release = true})
      : super(pointer, retain: retain, release: release);

  /// Returns a block that wraps the given raw block pointer.
  static ObjCBlock_NSZone_ffiVoid castFromPointer(
      ffi.Pointer<objc.ObjCBlock> pointer,
      {bool retain = false,
      bool release = false}) {
    return ObjCBlock_NSZone_ffiVoid._(pointer,
        retain: retain, release: release);
  }

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ObjCBlock_NSZone_ffiVoid.fromFunctionPointer(
      ffi.Pointer<
              ffi.NativeFunction<
                  ffi.Pointer<_NSZone> Function(ffi.Pointer<ffi.Void> arg0)>>
          ptr)
      : this._(
            objc.newPointerBlock(
                _cFuncTrampoline ??= ffi.Pointer.fromFunction<
                            ffi.Pointer<_NSZone> Function(
                                ffi.Pointer<objc.ObjCBlock>,
                                ffi.Pointer<ffi.Void>)>(
                        _ObjCBlock_NSZone_ffiVoid_fnPtrTrampoline)
                    .cast(),
                ptr.cast()));
  static ffi.Pointer<ffi.Void>? _cFuncTrampoline;

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ObjCBlock_NSZone_ffiVoid.fromFunction(
      ffi.Pointer<_NSZone> Function(ffi.Pointer<ffi.Void>) fn)
      : this._(objc.newClosureBlock(
            _dartFuncTrampoline ??= ffi.Pointer.fromFunction<
                        ffi.Pointer<_NSZone> Function(
                            ffi.Pointer<objc.ObjCBlock>,
                            ffi.Pointer<ffi.Void>)>(
                    _ObjCBlock_NSZone_ffiVoid_closureTrampoline)
                .cast(),
            (ffi.Pointer<ffi.Void> arg0) => fn(arg0)));
  static ffi.Pointer<ffi.Void>? _dartFuncTrampoline;

  ffi.Pointer<_NSZone> call(ffi.Pointer<ffi.Void> arg0) => pointer.ref.invoke
      .cast<
          ffi.NativeFunction<
              ffi.Pointer<_NSZone> Function(ffi.Pointer<objc.ObjCBlock> block,
                  ffi.Pointer<ffi.Void> arg0)>>()
      .asFunction<
          ffi.Pointer<_NSZone> Function(ffi.Pointer<objc.ObjCBlock>,
              ffi.Pointer<ffi.Void>)>()(pointer, arg0);
}

late final _sel_hash = objc.registerName("hash");
late final _sel_superclass = objc.registerName("superclass");
late final _sel_description = objc.registerName("description");
ffi.Pointer<objc.ObjCObject> _ObjCBlock_NSString_ffiVoid_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlock> block, ffi.Pointer<ffi.Void> arg0) =>
    block.ref.target
        .cast<
            ffi.NativeFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<ffi.Void> arg0)>>()
        .asFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<ffi.Void>)>()(arg0);
ffi.Pointer<objc.ObjCObject> _ObjCBlock_NSString_ffiVoid_closureTrampoline(
        ffi.Pointer<objc.ObjCBlock> block, ffi.Pointer<ffi.Void> arg0) =>
    (objc.getBlockClosure(block) as ffi.Pointer<objc.ObjCObject> Function(
        ffi.Pointer<ffi.Void>))(arg0);

class ObjCBlock_NSString_ffiVoid extends objc.ObjCBlockBase {
  ObjCBlock_NSString_ffiVoid._(ffi.Pointer<objc.ObjCBlock> pointer,
      {bool retain = false, bool release = true})
      : super(pointer, retain: retain, release: release);

  /// Returns a block that wraps the given raw block pointer.
  static ObjCBlock_NSString_ffiVoid castFromPointer(
      ffi.Pointer<objc.ObjCBlock> pointer,
      {bool retain = false,
      bool release = false}) {
    return ObjCBlock_NSString_ffiVoid._(pointer,
        retain: retain, release: release);
  }

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ObjCBlock_NSString_ffiVoid.fromFunctionPointer(
      ffi.Pointer<
              ffi.NativeFunction<
                  ffi.Pointer<objc.ObjCObject> Function(
                      ffi.Pointer<ffi.Void> arg0)>>
          ptr)
      : this._(objc.newPointerBlock(
            _cFuncTrampoline ??= ffi.Pointer.fromFunction<
                        ffi.Pointer<objc.ObjCObject> Function(
                            ffi.Pointer<objc.ObjCBlock>,
                            ffi.Pointer<ffi.Void>)>(
                    _ObjCBlock_NSString_ffiVoid_fnPtrTrampoline)
                .cast(),
            ptr.cast()));
  static ffi.Pointer<ffi.Void>? _cFuncTrampoline;

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ObjCBlock_NSString_ffiVoid.fromFunction(
      objc.NSString Function(ffi.Pointer<ffi.Void>) fn)
      : this._(objc.newClosureBlock(
            _dartFuncTrampoline ??= ffi.Pointer.fromFunction<
                        ffi.Pointer<objc.ObjCObject> Function(
                            ffi.Pointer<objc.ObjCBlock>,
                            ffi.Pointer<ffi.Void>)>(
                    _ObjCBlock_NSString_ffiVoid_closureTrampoline)
                .cast(),
            (ffi.Pointer<ffi.Void> arg0) => fn(arg0).retainAndReturnPointer()));
  static ffi.Pointer<ffi.Void>? _dartFuncTrampoline;

  objc.NSString call(ffi.Pointer<ffi.Void> arg0) =>
      objc.NSString.castFromPointer(
          pointer.ref.invoke
              .cast<
                  ffi.NativeFunction<
                      ffi.Pointer<objc.ObjCObject> Function(
                          ffi.Pointer<objc.ObjCBlock> block,
                          ffi.Pointer<ffi.Void> arg0)>>()
              .asFunction<
                  ffi.Pointer<objc.ObjCObject> Function(
                      ffi.Pointer<objc.ObjCBlock>,
                      ffi.Pointer<ffi.Void>)>()(pointer, arg0),
          retain: false,
          release: true);
}

late final _sel_debugDescription = objc.registerName("debugDescription");

/// Return values for `-applicationShouldTerminate:`.
enum NSApplicationTerminateReply {
  NSTerminateCancel(0),
  NSTerminateNow(1),
  NSTerminateLater(2);

  final int value;
  const NSApplicationTerminateReply(this.value);

  static NSApplicationTerminateReply fromValue(int value) => switch (value) {
        0 => NSTerminateCancel,
        1 => NSTerminateNow,
        2 => NSTerminateLater,
        _ => throw ArgumentError(
            "Unknown value for NSApplicationTerminateReply: $value"),
      };
}

late final _sel_applicationShouldTerminate_ =
    objc.registerName("applicationShouldTerminate:");
int _ObjCBlock_NSApplicationTerminateReply_ffiVoid_NSApplication_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlock> block,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1) =>
    block.ref.target
        .cast<
            ffi.NativeFunction<
                ffi.UnsignedLong Function(ffi.Pointer<ffi.Void> arg0,
                    ffi.Pointer<objc.ObjCObject> arg1)>>()
        .asFunction<
            int Function(ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>)>()(arg0, arg1);
int _ObjCBlock_NSApplicationTerminateReply_ffiVoid_NSApplication_closureTrampoline(
        ffi.Pointer<objc.ObjCBlock> block,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1) =>
    (objc.getBlockClosure(block) as int Function(
        ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>))(arg0, arg1);

class ObjCBlock_NSApplicationTerminateReply_ffiVoid_NSApplication
    extends objc.ObjCBlockBase {
  ObjCBlock_NSApplicationTerminateReply_ffiVoid_NSApplication._(
      ffi.Pointer<objc.ObjCBlock> pointer,
      {bool retain = false,
      bool release = true})
      : super(pointer, retain: retain, release: release);

  /// Returns a block that wraps the given raw block pointer.
  static ObjCBlock_NSApplicationTerminateReply_ffiVoid_NSApplication
      castFromPointer(ffi.Pointer<objc.ObjCBlock> pointer,
          {bool retain = false, bool release = false}) {
    return ObjCBlock_NSApplicationTerminateReply_ffiVoid_NSApplication._(
        pointer,
        retain: retain,
        release: release);
  }

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ObjCBlock_NSApplicationTerminateReply_ffiVoid_NSApplication.fromFunctionPointer(
      ffi.Pointer<
              ffi.NativeFunction<
                  ffi.UnsignedLong Function(ffi.Pointer<ffi.Void> arg0,
                      ffi.Pointer<objc.ObjCObject> arg1)>>
          ptr)
      : this._(objc.newPointerBlock(
            _cFuncTrampoline ??= ffi.Pointer.fromFunction<
                        ffi.UnsignedLong Function(
                            ffi.Pointer<objc.ObjCBlock>,
                            ffi.Pointer<ffi.Void>,
                            ffi.Pointer<objc.ObjCObject>)>(
                    _ObjCBlock_NSApplicationTerminateReply_ffiVoid_NSApplication_fnPtrTrampoline,
                    0)
                .cast(),
            ptr.cast()));
  static ffi.Pointer<ffi.Void>? _cFuncTrampoline;

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ObjCBlock_NSApplicationTerminateReply_ffiVoid_NSApplication.fromFunction(
      NSApplicationTerminateReply Function(ffi.Pointer<ffi.Void>, NSApplication)
          fn)
      : this._(objc.newClosureBlock(
            _dartFuncTrampoline ??= ffi.Pointer.fromFunction<
                        ffi.UnsignedLong Function(
                            ffi.Pointer<objc.ObjCBlock>,
                            ffi.Pointer<ffi.Void>,
                            ffi.Pointer<objc.ObjCObject>)>(
                    _ObjCBlock_NSApplicationTerminateReply_ffiVoid_NSApplication_closureTrampoline, 0)
                .cast(),
            (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1) =>
                fn(arg0, NSApplication.castFromPointer(arg1, retain: true, release: true)).value));
  static ffi.Pointer<ffi.Void>? _dartFuncTrampoline;

  NSApplicationTerminateReply call(
          ffi.Pointer<ffi.Void> arg0, NSApplication arg1) =>
      NSApplicationTerminateReply.fromValue(pointer.ref.invoke
              .cast<
                  ffi.NativeFunction<
                      ffi.UnsignedLong Function(
                          ffi.Pointer<objc.ObjCBlock> block,
                          ffi.Pointer<ffi.Void> arg0,
                          ffi.Pointer<objc.ObjCObject> arg1)>>()
              .asFunction<
                  int Function(ffi.Pointer<objc.ObjCBlock>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>()(
          pointer, arg0, arg1.pointer));
}

late final _sel_application_openURLs_ =
    objc.registerName("application:openURLs:");
void _ObjCBlock_ffiVoid_ffiVoid_NSApplication_objcObjCObject_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlock> block,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1,
        ffi.Pointer<objc.ObjCObject> arg2) =>
    block.ref.target
        .cast<
            ffi.NativeFunction<
                ffi.Void Function(
                    ffi.Pointer<ffi.Void> arg0,
                    ffi.Pointer<objc.ObjCObject> arg1,
                    ffi.Pointer<objc.ObjCObject> arg2)>>()
        .asFunction<
            void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>()(arg0, arg1, arg2);
void _ObjCBlock_ffiVoid_ffiVoid_NSApplication_objcObjCObject_closureTrampoline(
        ffi.Pointer<objc.ObjCBlock> block,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1,
        ffi.Pointer<objc.ObjCObject> arg2) =>
    (objc.getBlockClosure(block) as void Function(
        ffi.Pointer<ffi.Void>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>))(arg0, arg1, arg2);

class ObjCBlock_ffiVoid_ffiVoid_NSApplication_objcObjCObject
    extends objc.ObjCBlockBase {
  ObjCBlock_ffiVoid_ffiVoid_NSApplication_objcObjCObject._(
      ffi.Pointer<objc.ObjCBlock> pointer,
      {bool retain = false,
      bool release = true})
      : super(pointer, retain: retain, release: release);

  /// Returns a block that wraps the given raw block pointer.
  static ObjCBlock_ffiVoid_ffiVoid_NSApplication_objcObjCObject castFromPointer(
      ffi.Pointer<objc.ObjCBlock> pointer,
      {bool retain = false,
      bool release = false}) {
    return ObjCBlock_ffiVoid_ffiVoid_NSApplication_objcObjCObject._(pointer,
        retain: retain, release: release);
  }

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ObjCBlock_ffiVoid_ffiVoid_NSApplication_objcObjCObject.fromFunctionPointer(
      ffi.Pointer<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void> arg0,
                      ffi.Pointer<objc.ObjCObject> arg1,
                      ffi.Pointer<objc.ObjCObject> arg2)>>
          ptr)
      : this._(objc.newPointerBlock(
            _cFuncTrampoline ??= ffi.Pointer.fromFunction<
                        ffi.Void Function(
                            ffi.Pointer<objc.ObjCBlock>,
                            ffi.Pointer<ffi.Void>,
                            ffi.Pointer<objc.ObjCObject>,
                            ffi.Pointer<objc.ObjCObject>)>(
                    _ObjCBlock_ffiVoid_ffiVoid_NSApplication_objcObjCObject_fnPtrTrampoline)
                .cast(),
            ptr.cast()));
  static ffi.Pointer<ffi.Void>? _cFuncTrampoline;

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ObjCBlock_ffiVoid_ffiVoid_NSApplication_objcObjCObject.fromFunction(
      void Function(ffi.Pointer<ffi.Void>, NSApplication, objc.ObjCObjectBase)
          fn)
      : this._(objc.newClosureBlock(
            _dartFuncTrampoline ??= ffi.Pointer.fromFunction<
                        ffi.Void Function(
                            ffi.Pointer<objc.ObjCBlock>,
                            ffi.Pointer<ffi.Void>,
                            ffi.Pointer<objc.ObjCObject>,
                            ffi.Pointer<objc.ObjCObject>)>(
                    _ObjCBlock_ffiVoid_ffiVoid_NSApplication_objcObjCObject_closureTrampoline)
                .cast(),
            (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1,
                    ffi.Pointer<objc.ObjCObject> arg2) =>
                fn(arg0, NSApplication.castFromPointer(arg1, retain: true, release: true), objc.ObjCObjectBase(arg2, retain: true, release: true))));
  static ffi.Pointer<ffi.Void>? _dartFuncTrampoline;

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// Note that unlike the default behavior of NativeCallable.listener, listener
  /// blocks do not keep the isolate alive.
  ObjCBlock_ffiVoid_ffiVoid_NSApplication_objcObjCObject.listener(void Function(ffi.Pointer<ffi.Void>, NSApplication, objc.ObjCObjectBase) fn)
      : this._(wrapListenerBlock_ObjCBlock_ffiVoid_ffiVoid_NSApplication_objcObjCObject(
            objc.newClosureBlock(
                (_dartFuncListenerTrampoline ??= ffi.NativeCallable<
                            ffi.Void Function(
                                ffi.Pointer<objc.ObjCBlock>,
                                ffi.Pointer<ffi.Void>,
                                ffi.Pointer<objc.ObjCObject>,
                                ffi.Pointer<objc.ObjCObject>)>.listener(
                        _ObjCBlock_ffiVoid_ffiVoid_NSApplication_objcObjCObject_closureTrampoline)
                      ..keepIsolateAlive = false)
                    .nativeFunction
                    .cast(),
                (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1,
                        ffi.Pointer<objc.ObjCObject> arg2) =>
                    fn(arg0, NSApplication.castFromPointer(arg1, retain: false, release: true), objc.ObjCObjectBase(arg2, retain: false, release: true)))));
  static ffi.NativeCallable<
      ffi.Void Function(
          ffi.Pointer<objc.ObjCBlock>,
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCObject>)>? _dartFuncListenerTrampoline;

  void call(ffi.Pointer<ffi.Void> arg0, NSApplication arg1,
          objc.ObjCObjectBase arg2) =>
      pointer.ref.invoke
              .cast<
                  ffi.NativeFunction<
                      ffi.Void Function(
                          ffi.Pointer<objc.ObjCBlock> block,
                          ffi.Pointer<ffi.Void> arg0,
                          ffi.Pointer<objc.ObjCObject> arg1,
                          ffi.Pointer<objc.ObjCObject> arg2)>>()
              .asFunction<
                  void Function(
                      ffi.Pointer<objc.ObjCBlock>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<objc.ObjCObject>,
                      ffi.Pointer<objc.ObjCObject>)>()(
          pointer, arg0, arg1.pointer, arg2.pointer);
}

late final _sel_application_openFile_ =
    objc.registerName("application:openFile:");
bool _ObjCBlock_bool_ffiVoid_NSApplication_NSString_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlock> block,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1,
        ffi.Pointer<objc.ObjCObject> arg2) =>
    block.ref.target
        .cast<
            ffi.NativeFunction<
                ffi.Bool Function(
                    ffi.Pointer<ffi.Void> arg0,
                    ffi.Pointer<objc.ObjCObject> arg1,
                    ffi.Pointer<objc.ObjCObject> arg2)>>()
        .asFunction<
            bool Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>()(arg0, arg1, arg2);
bool _ObjCBlock_bool_ffiVoid_NSApplication_NSString_closureTrampoline(
        ffi.Pointer<objc.ObjCBlock> block,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1,
        ffi.Pointer<objc.ObjCObject> arg2) =>
    (objc.getBlockClosure(block) as bool Function(
        ffi.Pointer<ffi.Void>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>))(arg0, arg1, arg2);

class ObjCBlock_bool_ffiVoid_NSApplication_NSString extends objc.ObjCBlockBase {
  ObjCBlock_bool_ffiVoid_NSApplication_NSString._(
      ffi.Pointer<objc.ObjCBlock> pointer,
      {bool retain = false,
      bool release = true})
      : super(pointer, retain: retain, release: release);

  /// Returns a block that wraps the given raw block pointer.
  static ObjCBlock_bool_ffiVoid_NSApplication_NSString castFromPointer(
      ffi.Pointer<objc.ObjCBlock> pointer,
      {bool retain = false,
      bool release = false}) {
    return ObjCBlock_bool_ffiVoid_NSApplication_NSString._(pointer,
        retain: retain, release: release);
  }

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ObjCBlock_bool_ffiVoid_NSApplication_NSString.fromFunctionPointer(
      ffi.Pointer<
              ffi.NativeFunction<
                  ffi.Bool Function(
                      ffi.Pointer<ffi.Void> arg0,
                      ffi.Pointer<objc.ObjCObject> arg1,
                      ffi.Pointer<objc.ObjCObject> arg2)>>
          ptr)
      : this._(objc.newPointerBlock(
            _cFuncTrampoline ??= ffi.Pointer.fromFunction<
                        ffi.Bool Function(
                            ffi.Pointer<objc.ObjCBlock>,
                            ffi.Pointer<ffi.Void>,
                            ffi.Pointer<objc.ObjCObject>,
                            ffi.Pointer<objc.ObjCObject>)>(
                    _ObjCBlock_bool_ffiVoid_NSApplication_NSString_fnPtrTrampoline,
                    false)
                .cast(),
            ptr.cast()));
  static ffi.Pointer<ffi.Void>? _cFuncTrampoline;

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ObjCBlock_bool_ffiVoid_NSApplication_NSString.fromFunction(
      bool Function(ffi.Pointer<ffi.Void>, NSApplication, objc.NSString) fn)
      : this._(objc.newClosureBlock(
            _dartFuncTrampoline ??= ffi.Pointer.fromFunction<
                        ffi.Bool Function(
                            ffi.Pointer<objc.ObjCBlock>,
                            ffi.Pointer<ffi.Void>,
                            ffi.Pointer<objc.ObjCObject>,
                            ffi.Pointer<objc.ObjCObject>)>(
                    _ObjCBlock_bool_ffiVoid_NSApplication_NSString_closureTrampoline, false)
                .cast(),
            (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1, ffi.Pointer<objc.ObjCObject> arg2) => fn(
                arg0,
                NSApplication.castFromPointer(arg1, retain: true, release: true),
                objc.NSString.castFromPointer(arg2, retain: true, release: true))));
  static ffi.Pointer<ffi.Void>? _dartFuncTrampoline;

  bool call(
          ffi.Pointer<ffi.Void> arg0, NSApplication arg1, objc.NSString arg2) =>
      pointer.ref.invoke
              .cast<
                  ffi.NativeFunction<
                      ffi.Bool Function(
                          ffi.Pointer<objc.ObjCBlock> block,
                          ffi.Pointer<ffi.Void> arg0,
                          ffi.Pointer<objc.ObjCObject> arg1,
                          ffi.Pointer<objc.ObjCObject> arg2)>>()
              .asFunction<
                  bool Function(
                      ffi.Pointer<objc.ObjCBlock>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<objc.ObjCObject>,
                      ffi.Pointer<objc.ObjCObject>)>()(
          pointer, arg0, arg1.pointer, arg2.pointer);
}

late final _sel_application_openFiles_ =
    objc.registerName("application:openFiles:");
late final _sel_application_openTempFile_ =
    objc.registerName("application:openTempFile:");
late final _sel_applicationShouldOpenUntitledFile_ =
    objc.registerName("applicationShouldOpenUntitledFile:");
bool _ObjCBlock_bool_ffiVoid_NSApplication_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlock> block,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1) =>
    block.ref.target
        .cast<
            ffi.NativeFunction<
                ffi.Bool Function(ffi.Pointer<ffi.Void> arg0,
                    ffi.Pointer<objc.ObjCObject> arg1)>>()
        .asFunction<
            bool Function(ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>)>()(arg0, arg1);
bool _ObjCBlock_bool_ffiVoid_NSApplication_closureTrampoline(
        ffi.Pointer<objc.ObjCBlock> block,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1) =>
    (objc.getBlockClosure(block) as bool Function(
        ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>))(arg0, arg1);

class ObjCBlock_bool_ffiVoid_NSApplication extends objc.ObjCBlockBase {
  ObjCBlock_bool_ffiVoid_NSApplication._(ffi.Pointer<objc.ObjCBlock> pointer,
      {bool retain = false, bool release = true})
      : super(pointer, retain: retain, release: release);

  /// Returns a block that wraps the given raw block pointer.
  static ObjCBlock_bool_ffiVoid_NSApplication castFromPointer(
      ffi.Pointer<objc.ObjCBlock> pointer,
      {bool retain = false,
      bool release = false}) {
    return ObjCBlock_bool_ffiVoid_NSApplication._(pointer,
        retain: retain, release: release);
  }

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ObjCBlock_bool_ffiVoid_NSApplication.fromFunctionPointer(
      ffi.Pointer<
              ffi.NativeFunction<
                  ffi.Bool Function(ffi.Pointer<ffi.Void> arg0,
                      ffi.Pointer<objc.ObjCObject> arg1)>>
          ptr)
      : this._(objc.newPointerBlock(
            _cFuncTrampoline ??= ffi.Pointer.fromFunction<
                        ffi.Bool Function(
                            ffi.Pointer<objc.ObjCBlock>,
                            ffi.Pointer<ffi.Void>,
                            ffi.Pointer<objc.ObjCObject>)>(
                    _ObjCBlock_bool_ffiVoid_NSApplication_fnPtrTrampoline,
                    false)
                .cast(),
            ptr.cast()));
  static ffi.Pointer<ffi.Void>? _cFuncTrampoline;

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ObjCBlock_bool_ffiVoid_NSApplication.fromFunction(
      bool Function(ffi.Pointer<ffi.Void>, NSApplication) fn)
      : this._(objc.newClosureBlock(
            _dartFuncTrampoline ??= ffi.Pointer.fromFunction<
                        ffi.Bool Function(
                            ffi.Pointer<objc.ObjCBlock>,
                            ffi.Pointer<ffi.Void>,
                            ffi.Pointer<objc.ObjCObject>)>(
                    _ObjCBlock_bool_ffiVoid_NSApplication_closureTrampoline, false)
                .cast(),
            (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1) => fn(
                arg0,
                NSApplication.castFromPointer(arg1, retain: true, release: true))));
  static ffi.Pointer<ffi.Void>? _dartFuncTrampoline;

  bool call(ffi.Pointer<ffi.Void> arg0, NSApplication arg1) =>
      pointer.ref.invoke
          .cast<
              ffi.NativeFunction<
                  ffi.Bool Function(
                      ffi.Pointer<objc.ObjCBlock> block,
                      ffi.Pointer<ffi.Void> arg0,
                      ffi.Pointer<objc.ObjCObject> arg1)>>()
          .asFunction<
              bool Function(ffi.Pointer<objc.ObjCBlock>, ffi.Pointer<ffi.Void>,
                  ffi.Pointer<objc.ObjCObject>)>()(pointer, arg0, arg1.pointer);
}

late final _sel_applicationOpenUntitledFile_ =
    objc.registerName("applicationOpenUntitledFile:");
late final _sel_application_openFileWithoutUI_ =
    objc.registerName("application:openFileWithoutUI:");
bool _ObjCBlock_bool_ffiVoid_objcObjCObject_NSString_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlock> block,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1,
        ffi.Pointer<objc.ObjCObject> arg2) =>
    block.ref.target
        .cast<
            ffi.NativeFunction<
                ffi.Bool Function(
                    ffi.Pointer<ffi.Void> arg0,
                    ffi.Pointer<objc.ObjCObject> arg1,
                    ffi.Pointer<objc.ObjCObject> arg2)>>()
        .asFunction<
            bool Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>()(arg0, arg1, arg2);
bool _ObjCBlock_bool_ffiVoid_objcObjCObject_NSString_closureTrampoline(
        ffi.Pointer<objc.ObjCBlock> block,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1,
        ffi.Pointer<objc.ObjCObject> arg2) =>
    (objc.getBlockClosure(block) as bool Function(
        ffi.Pointer<ffi.Void>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>))(arg0, arg1, arg2);

class ObjCBlock_bool_ffiVoid_objcObjCObject_NSString
    extends objc.ObjCBlockBase {
  ObjCBlock_bool_ffiVoid_objcObjCObject_NSString._(
      ffi.Pointer<objc.ObjCBlock> pointer,
      {bool retain = false,
      bool release = true})
      : super(pointer, retain: retain, release: release);

  /// Returns a block that wraps the given raw block pointer.
  static ObjCBlock_bool_ffiVoid_objcObjCObject_NSString castFromPointer(
      ffi.Pointer<objc.ObjCBlock> pointer,
      {bool retain = false,
      bool release = false}) {
    return ObjCBlock_bool_ffiVoid_objcObjCObject_NSString._(pointer,
        retain: retain, release: release);
  }

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ObjCBlock_bool_ffiVoid_objcObjCObject_NSString.fromFunctionPointer(
      ffi.Pointer<
              ffi.NativeFunction<
                  ffi.Bool Function(
                      ffi.Pointer<ffi.Void> arg0,
                      ffi.Pointer<objc.ObjCObject> arg1,
                      ffi.Pointer<objc.ObjCObject> arg2)>>
          ptr)
      : this._(objc.newPointerBlock(
            _cFuncTrampoline ??= ffi.Pointer.fromFunction<
                        ffi.Bool Function(
                            ffi.Pointer<objc.ObjCBlock>,
                            ffi.Pointer<ffi.Void>,
                            ffi.Pointer<objc.ObjCObject>,
                            ffi.Pointer<objc.ObjCObject>)>(
                    _ObjCBlock_bool_ffiVoid_objcObjCObject_NSString_fnPtrTrampoline,
                    false)
                .cast(),
            ptr.cast()));
  static ffi.Pointer<ffi.Void>? _cFuncTrampoline;

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ObjCBlock_bool_ffiVoid_objcObjCObject_NSString.fromFunction(bool Function(ffi.Pointer<ffi.Void>, objc.ObjCObjectBase, objc.NSString) fn)
      : this._(objc.newClosureBlock(
            _dartFuncTrampoline ??= ffi.Pointer.fromFunction<
                        ffi.Bool Function(
                            ffi.Pointer<objc.ObjCBlock>,
                            ffi.Pointer<ffi.Void>,
                            ffi.Pointer<objc.ObjCObject>,
                            ffi.Pointer<objc.ObjCObject>)>(
                    _ObjCBlock_bool_ffiVoid_objcObjCObject_NSString_closureTrampoline, false)
                .cast(),
            (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1, ffi.Pointer<objc.ObjCObject> arg2) => fn(
                arg0,
                objc.ObjCObjectBase(arg1, retain: true, release: true),
                objc.NSString.castFromPointer(arg2, retain: true, release: true))));
  static ffi.Pointer<ffi.Void>? _dartFuncTrampoline;

  bool call(ffi.Pointer<ffi.Void> arg0, objc.ObjCObjectBase arg1,
          objc.NSString arg2) =>
      pointer.ref.invoke
              .cast<
                  ffi.NativeFunction<
                      ffi.Bool Function(
                          ffi.Pointer<objc.ObjCBlock> block,
                          ffi.Pointer<ffi.Void> arg0,
                          ffi.Pointer<objc.ObjCObject> arg1,
                          ffi.Pointer<objc.ObjCObject> arg2)>>()
              .asFunction<
                  bool Function(
                      ffi.Pointer<objc.ObjCBlock>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<objc.ObjCObject>,
                      ffi.Pointer<objc.ObjCObject>)>()(
          pointer, arg0, arg1.pointer, arg2.pointer);
}

late final _sel_application_printFile_ =
    objc.registerName("application:printFile:");

/// Return values for `-application:printFiles:withSettings:showPrintPanels:`.
enum NSApplicationPrintReply {
  NSPrintingCancelled(0),
  NSPrintingSuccess(1),
  NSPrintingReplyLater(2),
  NSPrintingFailure(3);

  final int value;
  const NSApplicationPrintReply(this.value);

  static NSApplicationPrintReply fromValue(int value) => switch (value) {
        0 => NSPrintingCancelled,
        1 => NSPrintingSuccess,
        2 => NSPrintingReplyLater,
        3 => NSPrintingFailure,
        _ => throw ArgumentError(
            "Unknown value for NSApplicationPrintReply: $value"),
      };
}

late final _sel_application_printFiles_withSettings_showPrintPanels_ =
    objc.registerName("application:printFiles:withSettings:showPrintPanels:");
int _ObjCBlock_NSApplicationPrintReply_ffiVoid_NSApplication_objcObjCObject_NSDictionary_bool_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlock> block,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1,
        ffi.Pointer<objc.ObjCObject> arg2,
        ffi.Pointer<objc.ObjCObject> arg3,
        bool arg4) =>
    block.ref.target
        .cast<
            ffi.NativeFunction<
                ffi.UnsignedLong Function(
                    ffi.Pointer<ffi.Void> arg0,
                    ffi.Pointer<objc.ObjCObject> arg1,
                    ffi.Pointer<objc.ObjCObject> arg2,
                    ffi.Pointer<objc.ObjCObject> arg3,
                    ffi.Bool arg4)>>()
        .asFunction<
            int Function(
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                bool)>()(arg0, arg1, arg2, arg3, arg4);
int _ObjCBlock_NSApplicationPrintReply_ffiVoid_NSApplication_objcObjCObject_NSDictionary_bool_closureTrampoline(
        ffi.Pointer<objc.ObjCBlock> block,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1,
        ffi.Pointer<objc.ObjCObject> arg2,
        ffi.Pointer<objc.ObjCObject> arg3,
        bool arg4) =>
    (objc.getBlockClosure(block) as int Function(
        ffi.Pointer<ffi.Void>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>,
        bool))(arg0, arg1, arg2, arg3, arg4);

class ObjCBlock_NSApplicationPrintReply_ffiVoid_NSApplication_objcObjCObject_NSDictionary_bool
    extends objc.ObjCBlockBase {
  ObjCBlock_NSApplicationPrintReply_ffiVoid_NSApplication_objcObjCObject_NSDictionary_bool._(
      ffi.Pointer<objc.ObjCBlock> pointer,
      {bool retain = false,
      bool release = true})
      : super(pointer, retain: retain, release: release);

  /// Returns a block that wraps the given raw block pointer.
  static ObjCBlock_NSApplicationPrintReply_ffiVoid_NSApplication_objcObjCObject_NSDictionary_bool
      castFromPointer(ffi.Pointer<objc.ObjCBlock> pointer,
          {bool retain = false, bool release = false}) {
    return ObjCBlock_NSApplicationPrintReply_ffiVoid_NSApplication_objcObjCObject_NSDictionary_bool
        ._(pointer, retain: retain, release: release);
  }

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ObjCBlock_NSApplicationPrintReply_ffiVoid_NSApplication_objcObjCObject_NSDictionary_bool.fromFunctionPointer(
      ffi.Pointer<
              ffi.NativeFunction<
                  ffi.UnsignedLong Function(
                      ffi.Pointer<ffi.Void> arg0,
                      ffi.Pointer<objc.ObjCObject> arg1,
                      ffi.Pointer<objc.ObjCObject> arg2,
                      ffi.Pointer<objc.ObjCObject> arg3,
                      ffi.Bool arg4)>>
          ptr)
      : this._(objc.newPointerBlock(
            _cFuncTrampoline ??= ffi.Pointer.fromFunction<
                        ffi.UnsignedLong Function(
                            ffi.Pointer<objc.ObjCBlock>,
                            ffi.Pointer<ffi.Void>,
                            ffi.Pointer<objc.ObjCObject>,
                            ffi.Pointer<objc.ObjCObject>,
                            ffi.Pointer<objc.ObjCObject>,
                            ffi.Bool)>(
                    _ObjCBlock_NSApplicationPrintReply_ffiVoid_NSApplication_objcObjCObject_NSDictionary_bool_fnPtrTrampoline,
                    0)
                .cast(),
            ptr.cast()));
  static ffi.Pointer<ffi.Void>? _cFuncTrampoline;

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ObjCBlock_NSApplicationPrintReply_ffiVoid_NSApplication_objcObjCObject_NSDictionary_bool.fromFunction(NSApplicationPrintReply Function(ffi.Pointer<ffi.Void>, NSApplication, objc.ObjCObjectBase, objc.NSDictionary, bool) fn)
      : this._(objc.newClosureBlock(
            _dartFuncTrampoline ??= ffi.Pointer.fromFunction<
                        ffi.UnsignedLong Function(
                            ffi.Pointer<objc.ObjCBlock>,
                            ffi.Pointer<ffi.Void>,
                            ffi.Pointer<objc.ObjCObject>,
                            ffi.Pointer<objc.ObjCObject>,
                            ffi.Pointer<objc.ObjCObject>,
                            ffi.Bool)>(
                    _ObjCBlock_NSApplicationPrintReply_ffiVoid_NSApplication_objcObjCObject_NSDictionary_bool_closureTrampoline, 0)
                .cast(),
            (ffi.Pointer<ffi.Void> arg0,
                    ffi.Pointer<objc.ObjCObject> arg1,
                    ffi.Pointer<objc.ObjCObject> arg2,
                    ffi.Pointer<objc.ObjCObject> arg3,
                    bool arg4) =>
                fn(arg0, NSApplication.castFromPointer(arg1, retain: true, release: true), objc.ObjCObjectBase(arg2, retain: true, release: true), objc.NSDictionary.castFromPointer(arg3, retain: true, release: true), arg4)
                    .value));
  static ffi.Pointer<ffi.Void>? _dartFuncTrampoline;

  NSApplicationPrintReply call(ffi.Pointer<ffi.Void> arg0, NSApplication arg1,
          objc.ObjCObjectBase arg2, objc.NSDictionary arg3, bool arg4) =>
      NSApplicationPrintReply.fromValue(pointer.ref.invoke
          .cast<
              ffi.NativeFunction<
                  ffi.UnsignedLong Function(
                      ffi.Pointer<objc.ObjCBlock> block,
                      ffi.Pointer<ffi.Void> arg0,
                      ffi.Pointer<objc.ObjCObject> arg1,
                      ffi.Pointer<objc.ObjCObject> arg2,
                      ffi.Pointer<objc.ObjCObject> arg3,
                      ffi.Bool arg4)>>()
          .asFunction<
              int Function(
                  ffi.Pointer<objc.ObjCBlock>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<objc.ObjCObject>,
                  ffi.Pointer<objc.ObjCObject>,
                  ffi.Pointer<objc.ObjCObject>,
                  bool)>()(pointer, arg0, arg1.pointer, arg2.pointer, arg3.pointer, arg4));
}

late final _sel_applicationShouldTerminateAfterLastWindowClosed_ =
    objc.registerName("applicationShouldTerminateAfterLastWindowClosed:");
late final _sel_applicationShouldHandleReopen_hasVisibleWindows_ =
    objc.registerName("applicationShouldHandleReopen:hasVisibleWindows:");
bool _ObjCBlock_bool_ffiVoid_NSApplication_bool_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlock> block,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1,
        bool arg2) =>
    block.ref.target
        .cast<
            ffi.NativeFunction<
                ffi.Bool Function(ffi.Pointer<ffi.Void> arg0,
                    ffi.Pointer<objc.ObjCObject> arg1, ffi.Bool arg2)>>()
        .asFunction<
            bool Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>,
                bool)>()(arg0, arg1, arg2);
bool _ObjCBlock_bool_ffiVoid_NSApplication_bool_closureTrampoline(
        ffi.Pointer<objc.ObjCBlock> block,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1,
        bool arg2) =>
    (objc.getBlockClosure(block) as bool Function(ffi.Pointer<ffi.Void>,
        ffi.Pointer<objc.ObjCObject>, bool))(arg0, arg1, arg2);

class ObjCBlock_bool_ffiVoid_NSApplication_bool extends objc.ObjCBlockBase {
  ObjCBlock_bool_ffiVoid_NSApplication_bool._(
      ffi.Pointer<objc.ObjCBlock> pointer,
      {bool retain = false,
      bool release = true})
      : super(pointer, retain: retain, release: release);

  /// Returns a block that wraps the given raw block pointer.
  static ObjCBlock_bool_ffiVoid_NSApplication_bool castFromPointer(
      ffi.Pointer<objc.ObjCBlock> pointer,
      {bool retain = false,
      bool release = false}) {
    return ObjCBlock_bool_ffiVoid_NSApplication_bool._(pointer,
        retain: retain, release: release);
  }

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ObjCBlock_bool_ffiVoid_NSApplication_bool.fromFunctionPointer(
      ffi.Pointer<
              ffi.NativeFunction<
                  ffi.Bool Function(ffi.Pointer<ffi.Void> arg0,
                      ffi.Pointer<objc.ObjCObject> arg1, ffi.Bool arg2)>>
          ptr)
      : this._(objc.newPointerBlock(
            _cFuncTrampoline ??= ffi.Pointer.fromFunction<
                        ffi.Bool Function(
                            ffi.Pointer<objc.ObjCBlock>,
                            ffi.Pointer<ffi.Void>,
                            ffi.Pointer<objc.ObjCObject>,
                            ffi.Bool)>(
                    _ObjCBlock_bool_ffiVoid_NSApplication_bool_fnPtrTrampoline,
                    false)
                .cast(),
            ptr.cast()));
  static ffi.Pointer<ffi.Void>? _cFuncTrampoline;

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ObjCBlock_bool_ffiVoid_NSApplication_bool.fromFunction(
      bool Function(ffi.Pointer<ffi.Void>, NSApplication, bool) fn)
      : this._(objc.newClosureBlock(
            _dartFuncTrampoline ??= ffi.Pointer.fromFunction<
                        ffi.Bool Function(
                            ffi.Pointer<objc.ObjCBlock>,
                            ffi.Pointer<ffi.Void>,
                            ffi.Pointer<objc.ObjCObject>,
                            ffi.Bool)>(
                    _ObjCBlock_bool_ffiVoid_NSApplication_bool_closureTrampoline,
                    false)
                .cast(),
            (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1,
                    bool arg2) =>
                fn(arg0, NSApplication.castFromPointer(arg1, retain: true, release: true), arg2)));
  static ffi.Pointer<ffi.Void>? _dartFuncTrampoline;

  bool call(ffi.Pointer<ffi.Void> arg0, NSApplication arg1, bool arg2) =>
      pointer.ref.invoke
          .cast<
              ffi.NativeFunction<
                  ffi.Bool Function(
                      ffi.Pointer<objc.ObjCBlock> block,
                      ffi.Pointer<ffi.Void> arg0,
                      ffi.Pointer<objc.ObjCObject> arg1,
                      ffi.Bool arg2)>>()
          .asFunction<
              bool Function(
                  ffi.Pointer<objc.ObjCBlock>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<objc.ObjCObject>,
                  bool)>()(pointer, arg0, arg1.pointer, arg2);
}

late final _sel_applicationDockMenu_ =
    objc.registerName("applicationDockMenu:");
ffi.Pointer<objc.ObjCObject>
    _ObjCBlock_NSMenu_ffiVoid_NSApplication_fnPtrTrampoline(
            ffi.Pointer<objc.ObjCBlock> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObject> arg1) =>
        block.ref.target
            .cast<
                ffi.NativeFunction<
                    ffi.Pointer<objc.ObjCObject> Function(
                        ffi.Pointer<ffi.Void> arg0,
                        ffi.Pointer<objc.ObjCObject> arg1)>>()
            .asFunction<
                ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>,
                    ffi.Pointer<objc.ObjCObject>)>()(arg0, arg1);
ffi.Pointer<objc.ObjCObject>
    _ObjCBlock_NSMenu_ffiVoid_NSApplication_closureTrampoline(
            ffi.Pointer<objc.ObjCBlock> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObject> arg1) =>
        (objc.getBlockClosure(block) as ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>))(arg0, arg1);

class ObjCBlock_NSMenu_ffiVoid_NSApplication extends objc.ObjCBlockBase {
  ObjCBlock_NSMenu_ffiVoid_NSApplication._(ffi.Pointer<objc.ObjCBlock> pointer,
      {bool retain = false, bool release = true})
      : super(pointer, retain: retain, release: release);

  /// Returns a block that wraps the given raw block pointer.
  static ObjCBlock_NSMenu_ffiVoid_NSApplication castFromPointer(
      ffi.Pointer<objc.ObjCBlock> pointer,
      {bool retain = false,
      bool release = false}) {
    return ObjCBlock_NSMenu_ffiVoid_NSApplication._(pointer,
        retain: retain, release: release);
  }

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ObjCBlock_NSMenu_ffiVoid_NSApplication.fromFunctionPointer(
      ffi.Pointer<
              ffi.NativeFunction<
                  ffi.Pointer<objc.ObjCObject> Function(
                      ffi.Pointer<ffi.Void> arg0,
                      ffi.Pointer<objc.ObjCObject> arg1)>>
          ptr)
      : this._(
            objc.newPointerBlock(
                _cFuncTrampoline ??= ffi.Pointer.fromFunction<
                            ffi.Pointer<objc.ObjCObject> Function(
                                ffi.Pointer<objc.ObjCBlock>,
                                ffi.Pointer<ffi.Void>,
                                ffi.Pointer<objc.ObjCObject>)>(
                        _ObjCBlock_NSMenu_ffiVoid_NSApplication_fnPtrTrampoline)
                    .cast(),
                ptr.cast()));
  static ffi.Pointer<ffi.Void>? _cFuncTrampoline;

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ObjCBlock_NSMenu_ffiVoid_NSApplication.fromFunction(
      NSMenu? Function(ffi.Pointer<ffi.Void>, NSApplication) fn)
      : this._(objc.newClosureBlock(
            _dartFuncTrampoline ??= ffi.Pointer.fromFunction<
                        ffi.Pointer<objc.ObjCObject> Function(
                            ffi.Pointer<objc.ObjCBlock>,
                            ffi.Pointer<ffi.Void>,
                            ffi.Pointer<objc.ObjCObject>)>(
                    _ObjCBlock_NSMenu_ffiVoid_NSApplication_closureTrampoline)
                .cast(),
            (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1) =>
                fn(arg0, NSApplication.castFromPointer(arg1, retain: true, release: true))
                    ?.retainAndReturnPointer() ??
                ffi.nullptr));
  static ffi.Pointer<ffi.Void>? _dartFuncTrampoline;

  NSMenu? call(ffi.Pointer<ffi.Void> arg0, NSApplication arg1) => pointer
              .ref.invoke
              .cast<
                  ffi.NativeFunction<
                      ffi.Pointer<objc.ObjCObject> Function(
                          ffi.Pointer<objc.ObjCBlock> block,
                          ffi.Pointer<ffi.Void> arg0,
                          ffi.Pointer<objc.ObjCObject> arg1)>>()
              .asFunction<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCBlock>, ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>()
              (pointer, arg0, arg1.pointer)
              .address ==
          0
      ? null
      : NSMenu.castFromPointer(
          pointer.ref.invoke
              .cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCBlock> block, ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1)>>()
              .asFunction<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCBlock>, ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>()(pointer, arg0, arg1.pointer),
          retain: false,
          release: true);
}

late final _sel_application_willPresentError_ =
    objc.registerName("application:willPresentError:");
ffi.Pointer<objc.ObjCObject>
    _ObjCBlock_NSError_ffiVoid_NSApplication_NSError_fnPtrTrampoline(
            ffi.Pointer<objc.ObjCBlock> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObject> arg1,
            ffi.Pointer<objc.ObjCObject> arg2) =>
        block.ref.target
            .cast<
                ffi.NativeFunction<
                    ffi.Pointer<objc.ObjCObject> Function(
                        ffi.Pointer<ffi.Void> arg0,
                        ffi.Pointer<objc.ObjCObject> arg1,
                        ffi.Pointer<objc.ObjCObject> arg2)>>()
            .asFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<ffi.Void>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>)>()(arg0, arg1, arg2);
ffi.Pointer<objc.ObjCObject>
    _ObjCBlock_NSError_ffiVoid_NSApplication_NSError_closureTrampoline(
            ffi.Pointer<objc.ObjCBlock> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObject> arg1,
            ffi.Pointer<objc.ObjCObject> arg2) =>
        (objc.getBlockClosure(block) as ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>))(arg0, arg1, arg2);

class ObjCBlock_NSError_ffiVoid_NSApplication_NSError
    extends objc.ObjCBlockBase {
  ObjCBlock_NSError_ffiVoid_NSApplication_NSError._(
      ffi.Pointer<objc.ObjCBlock> pointer,
      {bool retain = false,
      bool release = true})
      : super(pointer, retain: retain, release: release);

  /// Returns a block that wraps the given raw block pointer.
  static ObjCBlock_NSError_ffiVoid_NSApplication_NSError castFromPointer(
      ffi.Pointer<objc.ObjCBlock> pointer,
      {bool retain = false,
      bool release = false}) {
    return ObjCBlock_NSError_ffiVoid_NSApplication_NSError._(pointer,
        retain: retain, release: release);
  }

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ObjCBlock_NSError_ffiVoid_NSApplication_NSError.fromFunctionPointer(
      ffi.Pointer<
              ffi.NativeFunction<
                  ffi.Pointer<objc.ObjCObject> Function(
                      ffi.Pointer<ffi.Void> arg0,
                      ffi.Pointer<objc.ObjCObject> arg1,
                      ffi.Pointer<objc.ObjCObject> arg2)>>
          ptr)
      : this._(objc.newPointerBlock(
            _cFuncTrampoline ??= ffi.Pointer.fromFunction<
                        ffi.Pointer<objc.ObjCObject> Function(
                            ffi.Pointer<objc.ObjCBlock>,
                            ffi.Pointer<ffi.Void>,
                            ffi.Pointer<objc.ObjCObject>,
                            ffi.Pointer<objc.ObjCObject>)>(
                    _ObjCBlock_NSError_ffiVoid_NSApplication_NSError_fnPtrTrampoline)
                .cast(),
            ptr.cast()));
  static ffi.Pointer<ffi.Void>? _cFuncTrampoline;

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ObjCBlock_NSError_ffiVoid_NSApplication_NSError.fromFunction(
      objc.NSError Function(ffi.Pointer<ffi.Void>, NSApplication, objc.NSError)
          fn)
      : this._(objc.newClosureBlock(
            _dartFuncTrampoline ??= ffi.Pointer.fromFunction<
                        ffi.Pointer<objc.ObjCObject> Function(
                            ffi.Pointer<objc.ObjCBlock>,
                            ffi.Pointer<ffi.Void>,
                            ffi.Pointer<objc.ObjCObject>,
                            ffi.Pointer<objc.ObjCObject>)>(
                    _ObjCBlock_NSError_ffiVoid_NSApplication_NSError_closureTrampoline)
                .cast(),
            (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1,
                    ffi.Pointer<objc.ObjCObject> arg2) =>
                fn(arg0, NSApplication.castFromPointer(arg1, retain: true, release: true), objc.NSError.castFromPointer(arg2, retain: true, release: true)).retainAndReturnPointer()));
  static ffi.Pointer<ffi.Void>? _dartFuncTrampoline;

  objc.NSError call(
          ffi.Pointer<ffi.Void> arg0, NSApplication arg1, objc.NSError arg2) =>
      objc.NSError.castFromPointer(
          pointer.ref.invoke
              .cast<
                  ffi.NativeFunction<
                      ffi.Pointer<objc.ObjCObject> Function(
                          ffi.Pointer<objc.ObjCBlock> block,
                          ffi.Pointer<ffi.Void> arg0,
                          ffi.Pointer<objc.ObjCObject> arg1,
                          ffi.Pointer<objc.ObjCObject> arg2)>>()
              .asFunction<
                  ffi.Pointer<objc.ObjCObject> Function(
                      ffi.Pointer<objc.ObjCBlock>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<objc.ObjCObject>,
                      ffi.Pointer<objc.ObjCObject>)>()(pointer, arg0, arg1.pointer, arg2.pointer),
          retain: false,
          release: true);
}

late final _sel_application_didRegisterForRemoteNotificationsWithDeviceToken_ =
    objc.registerName(
        "application:didRegisterForRemoteNotificationsWithDeviceToken:");
void _ObjCBlock_ffiVoid_ffiVoid_NSApplication_NSData_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlock> block,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1,
        ffi.Pointer<objc.ObjCObject> arg2) =>
    block.ref.target
        .cast<
            ffi.NativeFunction<
                ffi.Void Function(
                    ffi.Pointer<ffi.Void> arg0,
                    ffi.Pointer<objc.ObjCObject> arg1,
                    ffi.Pointer<objc.ObjCObject> arg2)>>()
        .asFunction<
            void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>()(arg0, arg1, arg2);
void _ObjCBlock_ffiVoid_ffiVoid_NSApplication_NSData_closureTrampoline(
        ffi.Pointer<objc.ObjCBlock> block,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1,
        ffi.Pointer<objc.ObjCObject> arg2) =>
    (objc.getBlockClosure(block) as void Function(
        ffi.Pointer<ffi.Void>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>))(arg0, arg1, arg2);

class ObjCBlock_ffiVoid_ffiVoid_NSApplication_NSData
    extends objc.ObjCBlockBase {
  ObjCBlock_ffiVoid_ffiVoid_NSApplication_NSData._(
      ffi.Pointer<objc.ObjCBlock> pointer,
      {bool retain = false,
      bool release = true})
      : super(pointer, retain: retain, release: release);

  /// Returns a block that wraps the given raw block pointer.
  static ObjCBlock_ffiVoid_ffiVoid_NSApplication_NSData castFromPointer(
      ffi.Pointer<objc.ObjCBlock> pointer,
      {bool retain = false,
      bool release = false}) {
    return ObjCBlock_ffiVoid_ffiVoid_NSApplication_NSData._(pointer,
        retain: retain, release: release);
  }

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ObjCBlock_ffiVoid_ffiVoid_NSApplication_NSData.fromFunctionPointer(
      ffi.Pointer<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void> arg0,
                      ffi.Pointer<objc.ObjCObject> arg1,
                      ffi.Pointer<objc.ObjCObject> arg2)>>
          ptr)
      : this._(objc.newPointerBlock(
            _cFuncTrampoline ??= ffi.Pointer.fromFunction<
                        ffi.Void Function(
                            ffi.Pointer<objc.ObjCBlock>,
                            ffi.Pointer<ffi.Void>,
                            ffi.Pointer<objc.ObjCObject>,
                            ffi.Pointer<objc.ObjCObject>)>(
                    _ObjCBlock_ffiVoid_ffiVoid_NSApplication_NSData_fnPtrTrampoline)
                .cast(),
            ptr.cast()));
  static ffi.Pointer<ffi.Void>? _cFuncTrampoline;

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ObjCBlock_ffiVoid_ffiVoid_NSApplication_NSData.fromFunction(
      void Function(ffi.Pointer<ffi.Void>, NSApplication, objc.NSData) fn)
      : this._(objc.newClosureBlock(
            _dartFuncTrampoline ??= ffi.Pointer.fromFunction<
                        ffi.Void Function(
                            ffi.Pointer<objc.ObjCBlock>,
                            ffi.Pointer<ffi.Void>,
                            ffi.Pointer<objc.ObjCObject>,
                            ffi.Pointer<objc.ObjCObject>)>(
                    _ObjCBlock_ffiVoid_ffiVoid_NSApplication_NSData_closureTrampoline)
                .cast(),
            (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1, ffi.Pointer<objc.ObjCObject> arg2) => fn(
                arg0,
                NSApplication.castFromPointer(arg1, retain: true, release: true),
                objc.NSData.castFromPointer(arg2, retain: true, release: true))));
  static ffi.Pointer<ffi.Void>? _dartFuncTrampoline;

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// Note that unlike the default behavior of NativeCallable.listener, listener
  /// blocks do not keep the isolate alive.
  ObjCBlock_ffiVoid_ffiVoid_NSApplication_NSData.listener(
      void Function(ffi.Pointer<ffi.Void>, NSApplication, objc.NSData) fn)
      : this._(wrapListenerBlock_ObjCBlock_ffiVoid_ffiVoid_NSApplication_NSData(objc.newClosureBlock(
            (_dartFuncListenerTrampoline ??= ffi.NativeCallable<
                        ffi.Void Function(
                            ffi.Pointer<objc.ObjCBlock>,
                            ffi.Pointer<ffi.Void>,
                            ffi.Pointer<objc.ObjCObject>,
                            ffi.Pointer<objc.ObjCObject>)>.listener(
                    _ObjCBlock_ffiVoid_ffiVoid_NSApplication_NSData_closureTrampoline)
                  ..keepIsolateAlive = false)
                .nativeFunction
                .cast(),
            (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1,
                    ffi.Pointer<objc.ObjCObject> arg2) =>
                fn(arg0, NSApplication.castFromPointer(arg1, retain: false, release: true), objc.NSData.castFromPointer(arg2, retain: false, release: true)))));
  static ffi.NativeCallable<
      ffi.Void Function(
          ffi.Pointer<objc.ObjCBlock>,
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCObject>)>? _dartFuncListenerTrampoline;

  void call(ffi.Pointer<ffi.Void> arg0, NSApplication arg1, objc.NSData arg2) =>
      pointer.ref.invoke
              .cast<
                  ffi.NativeFunction<
                      ffi.Void Function(
                          ffi.Pointer<objc.ObjCBlock> block,
                          ffi.Pointer<ffi.Void> arg0,
                          ffi.Pointer<objc.ObjCObject> arg1,
                          ffi.Pointer<objc.ObjCObject> arg2)>>()
              .asFunction<
                  void Function(
                      ffi.Pointer<objc.ObjCBlock>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<objc.ObjCObject>,
                      ffi.Pointer<objc.ObjCObject>)>()(
          pointer, arg0, arg1.pointer, arg2.pointer);
}

late final _sel_application_didFailToRegisterForRemoteNotificationsWithError_ =
    objc.registerName(
        "application:didFailToRegisterForRemoteNotificationsWithError:");
void _ObjCBlock_ffiVoid_ffiVoid_NSApplication_NSError_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlock> block,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1,
        ffi.Pointer<objc.ObjCObject> arg2) =>
    block.ref.target
        .cast<
            ffi.NativeFunction<
                ffi.Void Function(
                    ffi.Pointer<ffi.Void> arg0,
                    ffi.Pointer<objc.ObjCObject> arg1,
                    ffi.Pointer<objc.ObjCObject> arg2)>>()
        .asFunction<
            void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>()(arg0, arg1, arg2);
void _ObjCBlock_ffiVoid_ffiVoid_NSApplication_NSError_closureTrampoline(
        ffi.Pointer<objc.ObjCBlock> block,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1,
        ffi.Pointer<objc.ObjCObject> arg2) =>
    (objc.getBlockClosure(block) as void Function(
        ffi.Pointer<ffi.Void>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>))(arg0, arg1, arg2);

class ObjCBlock_ffiVoid_ffiVoid_NSApplication_NSError
    extends objc.ObjCBlockBase {
  ObjCBlock_ffiVoid_ffiVoid_NSApplication_NSError._(
      ffi.Pointer<objc.ObjCBlock> pointer,
      {bool retain = false,
      bool release = true})
      : super(pointer, retain: retain, release: release);

  /// Returns a block that wraps the given raw block pointer.
  static ObjCBlock_ffiVoid_ffiVoid_NSApplication_NSError castFromPointer(
      ffi.Pointer<objc.ObjCBlock> pointer,
      {bool retain = false,
      bool release = false}) {
    return ObjCBlock_ffiVoid_ffiVoid_NSApplication_NSError._(pointer,
        retain: retain, release: release);
  }

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ObjCBlock_ffiVoid_ffiVoid_NSApplication_NSError.fromFunctionPointer(
      ffi.Pointer<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void> arg0,
                      ffi.Pointer<objc.ObjCObject> arg1,
                      ffi.Pointer<objc.ObjCObject> arg2)>>
          ptr)
      : this._(objc.newPointerBlock(
            _cFuncTrampoline ??= ffi.Pointer.fromFunction<
                        ffi.Void Function(
                            ffi.Pointer<objc.ObjCBlock>,
                            ffi.Pointer<ffi.Void>,
                            ffi.Pointer<objc.ObjCObject>,
                            ffi.Pointer<objc.ObjCObject>)>(
                    _ObjCBlock_ffiVoid_ffiVoid_NSApplication_NSError_fnPtrTrampoline)
                .cast(),
            ptr.cast()));
  static ffi.Pointer<ffi.Void>? _cFuncTrampoline;

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ObjCBlock_ffiVoid_ffiVoid_NSApplication_NSError.fromFunction(
      void Function(ffi.Pointer<ffi.Void>, NSApplication, objc.NSError) fn)
      : this._(objc.newClosureBlock(
            _dartFuncTrampoline ??= ffi.Pointer.fromFunction<
                        ffi.Void Function(
                            ffi.Pointer<objc.ObjCBlock>,
                            ffi.Pointer<ffi.Void>,
                            ffi.Pointer<objc.ObjCObject>,
                            ffi.Pointer<objc.ObjCObject>)>(
                    _ObjCBlock_ffiVoid_ffiVoid_NSApplication_NSError_closureTrampoline)
                .cast(),
            (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1, ffi.Pointer<objc.ObjCObject> arg2) => fn(
                arg0,
                NSApplication.castFromPointer(arg1, retain: true, release: true),
                objc.NSError.castFromPointer(arg2, retain: true, release: true))));
  static ffi.Pointer<ffi.Void>? _dartFuncTrampoline;

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// Note that unlike the default behavior of NativeCallable.listener, listener
  /// blocks do not keep the isolate alive.
  ObjCBlock_ffiVoid_ffiVoid_NSApplication_NSError.listener(
      void Function(ffi.Pointer<ffi.Void>, NSApplication, objc.NSError) fn)
      : this._(wrapListenerBlock_ObjCBlock_ffiVoid_ffiVoid_NSApplication_NSError(objc.newClosureBlock(
            (_dartFuncListenerTrampoline ??= ffi.NativeCallable<
                        ffi.Void Function(
                            ffi.Pointer<objc.ObjCBlock>,
                            ffi.Pointer<ffi.Void>,
                            ffi.Pointer<objc.ObjCObject>,
                            ffi.Pointer<objc.ObjCObject>)>.listener(
                    _ObjCBlock_ffiVoid_ffiVoid_NSApplication_NSError_closureTrampoline)
                  ..keepIsolateAlive = false)
                .nativeFunction
                .cast(),
            (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1,
                    ffi.Pointer<objc.ObjCObject> arg2) =>
                fn(arg0, NSApplication.castFromPointer(arg1, retain: false, release: true), objc.NSError.castFromPointer(arg2, retain: false, release: true)))));
  static ffi.NativeCallable<
      ffi.Void Function(
          ffi.Pointer<objc.ObjCBlock>,
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCObject>)>? _dartFuncListenerTrampoline;

  void call(
          ffi.Pointer<ffi.Void> arg0, NSApplication arg1, objc.NSError arg2) =>
      pointer.ref.invoke
              .cast<
                  ffi.NativeFunction<
                      ffi.Void Function(
                          ffi.Pointer<objc.ObjCBlock> block,
                          ffi.Pointer<ffi.Void> arg0,
                          ffi.Pointer<objc.ObjCObject> arg1,
                          ffi.Pointer<objc.ObjCObject> arg2)>>()
              .asFunction<
                  void Function(
                      ffi.Pointer<objc.ObjCBlock>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<objc.ObjCObject>,
                      ffi.Pointer<objc.ObjCObject>)>()(
          pointer, arg0, arg1.pointer, arg2.pointer);
}

late final _sel_application_didReceiveRemoteNotification_ =
    objc.registerName("application:didReceiveRemoteNotification:");
void _ObjCBlock_ffiVoid_ffiVoid_NSApplication_NSDictionary_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlock> block,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1,
        ffi.Pointer<objc.ObjCObject> arg2) =>
    block.ref.target
        .cast<
            ffi.NativeFunction<
                ffi.Void Function(
                    ffi.Pointer<ffi.Void> arg0,
                    ffi.Pointer<objc.ObjCObject> arg1,
                    ffi.Pointer<objc.ObjCObject> arg2)>>()
        .asFunction<
            void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>()(arg0, arg1, arg2);
void _ObjCBlock_ffiVoid_ffiVoid_NSApplication_NSDictionary_closureTrampoline(
        ffi.Pointer<objc.ObjCBlock> block,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1,
        ffi.Pointer<objc.ObjCObject> arg2) =>
    (objc.getBlockClosure(block) as void Function(
        ffi.Pointer<ffi.Void>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>))(arg0, arg1, arg2);

class ObjCBlock_ffiVoid_ffiVoid_NSApplication_NSDictionary
    extends objc.ObjCBlockBase {
  ObjCBlock_ffiVoid_ffiVoid_NSApplication_NSDictionary._(
      ffi.Pointer<objc.ObjCBlock> pointer,
      {bool retain = false,
      bool release = true})
      : super(pointer, retain: retain, release: release);

  /// Returns a block that wraps the given raw block pointer.
  static ObjCBlock_ffiVoid_ffiVoid_NSApplication_NSDictionary castFromPointer(
      ffi.Pointer<objc.ObjCBlock> pointer,
      {bool retain = false,
      bool release = false}) {
    return ObjCBlock_ffiVoid_ffiVoid_NSApplication_NSDictionary._(pointer,
        retain: retain, release: release);
  }

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ObjCBlock_ffiVoid_ffiVoid_NSApplication_NSDictionary.fromFunctionPointer(
      ffi.Pointer<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void> arg0,
                      ffi.Pointer<objc.ObjCObject> arg1,
                      ffi.Pointer<objc.ObjCObject> arg2)>>
          ptr)
      : this._(objc.newPointerBlock(
            _cFuncTrampoline ??= ffi.Pointer.fromFunction<
                        ffi.Void Function(
                            ffi.Pointer<objc.ObjCBlock>,
                            ffi.Pointer<ffi.Void>,
                            ffi.Pointer<objc.ObjCObject>,
                            ffi.Pointer<objc.ObjCObject>)>(
                    _ObjCBlock_ffiVoid_ffiVoid_NSApplication_NSDictionary_fnPtrTrampoline)
                .cast(),
            ptr.cast()));
  static ffi.Pointer<ffi.Void>? _cFuncTrampoline;

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ObjCBlock_ffiVoid_ffiVoid_NSApplication_NSDictionary.fromFunction(
      void Function(ffi.Pointer<ffi.Void>, NSApplication, objc.NSDictionary) fn)
      : this._(objc.newClosureBlock(
            _dartFuncTrampoline ??= ffi.Pointer.fromFunction<
                        ffi.Void Function(
                            ffi.Pointer<objc.ObjCBlock>,
                            ffi.Pointer<ffi.Void>,
                            ffi.Pointer<objc.ObjCObject>,
                            ffi.Pointer<objc.ObjCObject>)>(
                    _ObjCBlock_ffiVoid_ffiVoid_NSApplication_NSDictionary_closureTrampoline)
                .cast(),
            (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1, ffi.Pointer<objc.ObjCObject> arg2) => fn(
                arg0,
                NSApplication.castFromPointer(arg1, retain: true, release: true),
                objc.NSDictionary.castFromPointer(arg2, retain: true, release: true))));
  static ffi.Pointer<ffi.Void>? _dartFuncTrampoline;

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// Note that unlike the default behavior of NativeCallable.listener, listener
  /// blocks do not keep the isolate alive.
  ObjCBlock_ffiVoid_ffiVoid_NSApplication_NSDictionary.listener(
      void Function(ffi.Pointer<ffi.Void>, NSApplication, objc.NSDictionary) fn)
      : this._(wrapListenerBlock_ObjCBlock_ffiVoid_ffiVoid_NSApplication_NSDictionary(objc.newClosureBlock(
            (_dartFuncListenerTrampoline ??= ffi.NativeCallable<
                        ffi.Void Function(
                            ffi.Pointer<objc.ObjCBlock>,
                            ffi.Pointer<ffi.Void>,
                            ffi.Pointer<objc.ObjCObject>,
                            ffi.Pointer<objc.ObjCObject>)>.listener(
                    _ObjCBlock_ffiVoid_ffiVoid_NSApplication_NSDictionary_closureTrampoline)
                  ..keepIsolateAlive = false)
                .nativeFunction
                .cast(),
            (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1,
                    ffi.Pointer<objc.ObjCObject> arg2) =>
                fn(arg0, NSApplication.castFromPointer(arg1, retain: false, release: true), objc.NSDictionary.castFromPointer(arg2, retain: false, release: true)))));
  static ffi.NativeCallable<
      ffi.Void Function(
          ffi.Pointer<objc.ObjCBlock>,
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCObject>)>? _dartFuncListenerTrampoline;

  void call(ffi.Pointer<ffi.Void> arg0, NSApplication arg1,
          objc.NSDictionary arg2) =>
      pointer.ref.invoke
              .cast<
                  ffi.NativeFunction<
                      ffi.Void Function(
                          ffi.Pointer<objc.ObjCBlock> block,
                          ffi.Pointer<ffi.Void> arg0,
                          ffi.Pointer<objc.ObjCObject> arg1,
                          ffi.Pointer<objc.ObjCObject> arg2)>>()
              .asFunction<
                  void Function(
                      ffi.Pointer<objc.ObjCBlock>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<objc.ObjCObject>,
                      ffi.Pointer<objc.ObjCObject>)>()(
          pointer, arg0, arg1.pointer, arg2.pointer);
}

late final _sel_applicationSupportsSecureRestorableState_ =
    objc.registerName("applicationSupportsSecureRestorableState:");

/// INIntent
class INIntent extends objc.ObjCObjectBase {
  INIntent._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super(pointer, retain: retain, release: release);

  /// Constructs a [INIntent] that points to the same underlying object as [other].
  INIntent.castFrom(objc.ObjCObjectBase other)
      : this._(other.pointer, retain: true, release: true);

  /// Constructs a [INIntent] that wraps the given raw object pointer.
  INIntent.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [INIntent].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_0(obj.pointer, _sel_isKindOfClass_, _class_INIntent);
  }
}

late final _class_INIntent = objc.getClass("INIntent");
late final _sel_application_handlerForIntent_ =
    objc.registerName("application:handlerForIntent:");
ffi.Pointer<objc.ObjCObject>
    _ObjCBlock_objcObjCObject_ffiVoid_NSApplication_INIntent_fnPtrTrampoline(
            ffi.Pointer<objc.ObjCBlock> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObject> arg1,
            ffi.Pointer<objc.ObjCObject> arg2) =>
        block.ref.target
            .cast<
                ffi.NativeFunction<
                    ffi.Pointer<objc.ObjCObject> Function(
                        ffi.Pointer<ffi.Void> arg0,
                        ffi.Pointer<objc.ObjCObject> arg1,
                        ffi.Pointer<objc.ObjCObject> arg2)>>()
            .asFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<ffi.Void>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>)>()(arg0, arg1, arg2);
ffi.Pointer<objc.ObjCObject>
    _ObjCBlock_objcObjCObject_ffiVoid_NSApplication_INIntent_closureTrampoline(
            ffi.Pointer<objc.ObjCBlock> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObject> arg1,
            ffi.Pointer<objc.ObjCObject> arg2) =>
        (objc.getBlockClosure(block) as ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>))(arg0, arg1, arg2);

class ObjCBlock_objcObjCObject_ffiVoid_NSApplication_INIntent
    extends objc.ObjCBlockBase {
  ObjCBlock_objcObjCObject_ffiVoid_NSApplication_INIntent._(
      ffi.Pointer<objc.ObjCBlock> pointer,
      {bool retain = false,
      bool release = true})
      : super(pointer, retain: retain, release: release);

  /// Returns a block that wraps the given raw block pointer.
  static ObjCBlock_objcObjCObject_ffiVoid_NSApplication_INIntent
      castFromPointer(ffi.Pointer<objc.ObjCBlock> pointer,
          {bool retain = false, bool release = false}) {
    return ObjCBlock_objcObjCObject_ffiVoid_NSApplication_INIntent._(pointer,
        retain: retain, release: release);
  }

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ObjCBlock_objcObjCObject_ffiVoid_NSApplication_INIntent.fromFunctionPointer(
      ffi.Pointer<
              ffi.NativeFunction<
                  ffi.Pointer<objc.ObjCObject> Function(
                      ffi.Pointer<ffi.Void> arg0,
                      ffi.Pointer<objc.ObjCObject> arg1,
                      ffi.Pointer<objc.ObjCObject> arg2)>>
          ptr)
      : this._(objc.newPointerBlock(
            _cFuncTrampoline ??= ffi.Pointer.fromFunction<
                        ffi.Pointer<objc.ObjCObject> Function(
                            ffi.Pointer<objc.ObjCBlock>,
                            ffi.Pointer<ffi.Void>,
                            ffi.Pointer<objc.ObjCObject>,
                            ffi.Pointer<objc.ObjCObject>)>(
                    _ObjCBlock_objcObjCObject_ffiVoid_NSApplication_INIntent_fnPtrTrampoline)
                .cast(),
            ptr.cast()));
  static ffi.Pointer<ffi.Void>? _cFuncTrampoline;

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ObjCBlock_objcObjCObject_ffiVoid_NSApplication_INIntent.fromFunction(
      objc.ObjCObjectBase? Function(
              ffi.Pointer<ffi.Void>, NSApplication, INIntent)
          fn)
      : this._(objc.newClosureBlock(
            _dartFuncTrampoline ??= ffi.Pointer.fromFunction<
                        ffi.Pointer<objc.ObjCObject> Function(
                            ffi.Pointer<objc.ObjCBlock>,
                            ffi.Pointer<ffi.Void>,
                            ffi.Pointer<objc.ObjCObject>,
                            ffi.Pointer<objc.ObjCObject>)>(
                    _ObjCBlock_objcObjCObject_ffiVoid_NSApplication_INIntent_closureTrampoline)
                .cast(),
            (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1,
                    ffi.Pointer<objc.ObjCObject> arg2) =>
                fn(arg0, NSApplication.castFromPointer(arg1, retain: true, release: true), INIntent.castFromPointer(arg2, retain: true, release: true))?.retainAndReturnPointer() ?? ffi.nullptr));
  static ffi.Pointer<ffi.Void>? _dartFuncTrampoline;

  objc.ObjCObjectBase? call(
          ffi.Pointer<ffi.Void> arg0, NSApplication arg1, INIntent arg2) =>
      pointer.ref.invoke
                  .cast<
                      ffi.NativeFunction<
                          ffi.Pointer<objc.ObjCObject> Function(
                              ffi.Pointer<objc.ObjCBlock> block,
                              ffi.Pointer<ffi.Void> arg0,
                              ffi.Pointer<objc.ObjCObject> arg1,
                              ffi.Pointer<objc.ObjCObject> arg2)>>()
                  .asFunction<
                      ffi.Pointer<objc.ObjCObject> Function(
                          ffi.Pointer<objc.ObjCBlock>,
                          ffi.Pointer<ffi.Void>,
                          ffi.Pointer<objc.ObjCObject>,
                          ffi.Pointer<objc.ObjCObject>)>()
                  (pointer, arg0, arg1.pointer, arg2.pointer)
                  .address ==
              0
          ? null
          : objc.ObjCObjectBase(pointer.ref.invoke.cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCBlock> block, ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1, ffi.Pointer<objc.ObjCObject> arg2)>>().asFunction<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCBlock>, ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCObject>)>()(pointer, arg0, arg1.pointer, arg2.pointer), retain: false, release: true);
}

late final _sel_application_willEncodeRestorableState_ =
    objc.registerName("application:willEncodeRestorableState:");
void _ObjCBlock_ffiVoid_ffiVoid_NSApplication_NSCoder_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlock> block,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1,
        ffi.Pointer<objc.ObjCObject> arg2) =>
    block.ref.target
        .cast<
            ffi.NativeFunction<
                ffi.Void Function(
                    ffi.Pointer<ffi.Void> arg0,
                    ffi.Pointer<objc.ObjCObject> arg1,
                    ffi.Pointer<objc.ObjCObject> arg2)>>()
        .asFunction<
            void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>()(arg0, arg1, arg2);
void _ObjCBlock_ffiVoid_ffiVoid_NSApplication_NSCoder_closureTrampoline(
        ffi.Pointer<objc.ObjCBlock> block,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1,
        ffi.Pointer<objc.ObjCObject> arg2) =>
    (objc.getBlockClosure(block) as void Function(
        ffi.Pointer<ffi.Void>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>))(arg0, arg1, arg2);

class ObjCBlock_ffiVoid_ffiVoid_NSApplication_NSCoder
    extends objc.ObjCBlockBase {
  ObjCBlock_ffiVoid_ffiVoid_NSApplication_NSCoder._(
      ffi.Pointer<objc.ObjCBlock> pointer,
      {bool retain = false,
      bool release = true})
      : super(pointer, retain: retain, release: release);

  /// Returns a block that wraps the given raw block pointer.
  static ObjCBlock_ffiVoid_ffiVoid_NSApplication_NSCoder castFromPointer(
      ffi.Pointer<objc.ObjCBlock> pointer,
      {bool retain = false,
      bool release = false}) {
    return ObjCBlock_ffiVoid_ffiVoid_NSApplication_NSCoder._(pointer,
        retain: retain, release: release);
  }

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ObjCBlock_ffiVoid_ffiVoid_NSApplication_NSCoder.fromFunctionPointer(
      ffi.Pointer<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void> arg0,
                      ffi.Pointer<objc.ObjCObject> arg1,
                      ffi.Pointer<objc.ObjCObject> arg2)>>
          ptr)
      : this._(objc.newPointerBlock(
            _cFuncTrampoline ??= ffi.Pointer.fromFunction<
                        ffi.Void Function(
                            ffi.Pointer<objc.ObjCBlock>,
                            ffi.Pointer<ffi.Void>,
                            ffi.Pointer<objc.ObjCObject>,
                            ffi.Pointer<objc.ObjCObject>)>(
                    _ObjCBlock_ffiVoid_ffiVoid_NSApplication_NSCoder_fnPtrTrampoline)
                .cast(),
            ptr.cast()));
  static ffi.Pointer<ffi.Void>? _cFuncTrampoline;

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ObjCBlock_ffiVoid_ffiVoid_NSApplication_NSCoder.fromFunction(
      void Function(ffi.Pointer<ffi.Void>, NSApplication, objc.NSCoder) fn)
      : this._(objc.newClosureBlock(
            _dartFuncTrampoline ??= ffi.Pointer.fromFunction<
                        ffi.Void Function(
                            ffi.Pointer<objc.ObjCBlock>,
                            ffi.Pointer<ffi.Void>,
                            ffi.Pointer<objc.ObjCObject>,
                            ffi.Pointer<objc.ObjCObject>)>(
                    _ObjCBlock_ffiVoid_ffiVoid_NSApplication_NSCoder_closureTrampoline)
                .cast(),
            (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1, ffi.Pointer<objc.ObjCObject> arg2) => fn(
                arg0,
                NSApplication.castFromPointer(arg1, retain: true, release: true),
                objc.NSCoder.castFromPointer(arg2, retain: true, release: true))));
  static ffi.Pointer<ffi.Void>? _dartFuncTrampoline;

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// Note that unlike the default behavior of NativeCallable.listener, listener
  /// blocks do not keep the isolate alive.
  ObjCBlock_ffiVoid_ffiVoid_NSApplication_NSCoder.listener(
      void Function(ffi.Pointer<ffi.Void>, NSApplication, objc.NSCoder) fn)
      : this._(wrapListenerBlock_ObjCBlock_ffiVoid_ffiVoid_NSApplication_NSCoder(objc.newClosureBlock(
            (_dartFuncListenerTrampoline ??= ffi.NativeCallable<
                        ffi.Void Function(
                            ffi.Pointer<objc.ObjCBlock>,
                            ffi.Pointer<ffi.Void>,
                            ffi.Pointer<objc.ObjCObject>,
                            ffi.Pointer<objc.ObjCObject>)>.listener(
                    _ObjCBlock_ffiVoid_ffiVoid_NSApplication_NSCoder_closureTrampoline)
                  ..keepIsolateAlive = false)
                .nativeFunction
                .cast(),
            (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1,
                    ffi.Pointer<objc.ObjCObject> arg2) =>
                fn(arg0, NSApplication.castFromPointer(arg1, retain: false, release: true), objc.NSCoder.castFromPointer(arg2, retain: false, release: true)))));
  static ffi.NativeCallable<
      ffi.Void Function(
          ffi.Pointer<objc.ObjCBlock>,
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCObject>)>? _dartFuncListenerTrampoline;

  void call(
          ffi.Pointer<ffi.Void> arg0, NSApplication arg1, objc.NSCoder arg2) =>
      pointer.ref.invoke
              .cast<
                  ffi.NativeFunction<
                      ffi.Void Function(
                          ffi.Pointer<objc.ObjCBlock> block,
                          ffi.Pointer<ffi.Void> arg0,
                          ffi.Pointer<objc.ObjCObject> arg1,
                          ffi.Pointer<objc.ObjCObject> arg2)>>()
              .asFunction<
                  void Function(
                      ffi.Pointer<objc.ObjCBlock>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<objc.ObjCObject>,
                      ffi.Pointer<objc.ObjCObject>)>()(
          pointer, arg0, arg1.pointer, arg2.pointer);
}

late final _sel_application_didDecodeRestorableState_ =
    objc.registerName("application:didDecodeRestorableState:");
late final _sel_application_willContinueUserActivityWithType_ =
    objc.registerName("application:willContinueUserActivityWithType:");

/// NSUserActivity
class NSUserActivity extends objc.NSObject {
  NSUserActivity._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release);

  /// Constructs a [NSUserActivity] that points to the same underlying object as [other].
  NSUserActivity.castFrom(objc.ObjCObjectBase other)
      : this._(other.pointer, retain: true, release: true);

  /// Constructs a [NSUserActivity] that wraps the given raw object pointer.
  NSUserActivity.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [NSUserActivity].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_0(
        obj.pointer, _sel_isKindOfClass_, _class_NSUserActivity);
  }

  /// initWithActivityType:
  NSUserActivity initWithActivityType_(objc.NSString activityType) {
    final _ret = _objc_msgSend_128(
        this.pointer, _sel_initWithActivityType_, activityType.pointer);
    return NSUserActivity.castFromPointer(_ret, retain: true, release: true);
  }

  /// init
  NSUserActivity init() {
    final _ret = _objc_msgSend_2(this.pointer, _sel_init);
    return NSUserActivity.castFromPointer(_ret, retain: true, release: true);
  }

  /// activityType
  objc.NSString get activityType {
    final _ret = _objc_msgSend_3(this.pointer, _sel_activityType);
    return objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// title
  objc.NSString? get title {
    final _ret = _objc_msgSend_84(this.pointer, _sel_title);
    return _ret.address == 0
        ? null
        : objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// setTitle:
  set title(objc.NSString? value) {
    return _objc_msgSend_148(
        this.pointer, _sel_setTitle_, value?.pointer ?? ffi.nullptr);
  }

  /// userInfo
  objc.NSDictionary? get userInfo {
    final _ret = _objc_msgSend_311(this.pointer, _sel_userInfo);
    return _ret.address == 0
        ? null
        : objc.NSDictionary.castFromPointer(_ret, retain: true, release: true);
  }

  /// setUserInfo:
  set userInfo(objc.NSDictionary? value) {
    return _objc_msgSend_361(
        this.pointer, _sel_setUserInfo_, value?.pointer ?? ffi.nullptr);
  }

  /// addUserInfoEntriesFromDictionary:
  void addUserInfoEntriesFromDictionary_(objc.NSDictionary otherDictionary) {
    _objc_msgSend_353(this.pointer, _sel_addUserInfoEntriesFromDictionary_,
        otherDictionary.pointer);
  }

  /// requiredUserInfoKeys
  objc.ObjCObjectBase? get requiredUserInfoKeys {
    final _ret = _objc_msgSend_22(this.pointer, _sel_requiredUserInfoKeys);
    return _ret.address == 0
        ? null
        : objc.ObjCObjectBase(_ret, retain: true, release: true);
  }

  /// setRequiredUserInfoKeys:
  set requiredUserInfoKeys(objc.ObjCObjectBase? value) {
    return _objc_msgSend_23(this.pointer, _sel_setRequiredUserInfoKeys_,
        value?.pointer ?? ffi.nullptr);
  }

  /// needsSave
  bool get needsSave {
    return _objc_msgSend_13(this.pointer, _sel_needsSave);
  }

  /// setNeedsSave:
  set needsSave(bool value) {
    return _objc_msgSend_14(this.pointer, _sel_setNeedsSave_, value);
  }

  /// webpageURL
  objc.NSURL? get webpageURL {
    final _ret = _objc_msgSend_42(this.pointer, _sel_webpageURL);
    return _ret.address == 0
        ? null
        : objc.NSURL.castFromPointer(_ret, retain: true, release: true);
  }

  /// setWebpageURL:
  set webpageURL(objc.NSURL? value) {
    return _objc_msgSend_43(
        this.pointer, _sel_setWebpageURL_, value?.pointer ?? ffi.nullptr);
  }

  /// referrerURL
  objc.NSURL? get referrerURL {
    final _ret = _objc_msgSend_42(this.pointer, _sel_referrerURL);
    return _ret.address == 0
        ? null
        : objc.NSURL.castFromPointer(_ret, retain: true, release: true);
  }

  /// setReferrerURL:
  set referrerURL(objc.NSURL? value) {
    return _objc_msgSend_43(
        this.pointer, _sel_setReferrerURL_, value?.pointer ?? ffi.nullptr);
  }

  /// expirationDate
  objc.NSDate? get expirationDate {
    final _ret = _objc_msgSend_296(this.pointer, _sel_expirationDate);
    return _ret.address == 0
        ? null
        : objc.NSDate.castFromPointer(_ret, retain: true, release: true);
  }

  /// setExpirationDate:
  set expirationDate(objc.NSDate? value) {
    return _objc_msgSend_362(
        this.pointer, _sel_setExpirationDate_, value?.pointer ?? ffi.nullptr);
  }

  /// keywords
  objc.ObjCObjectBase get keywords {
    final _ret = _objc_msgSend_2(this.pointer, _sel_keywords);
    return objc.ObjCObjectBase(_ret, retain: true, release: true);
  }

  /// setKeywords:
  set keywords(objc.ObjCObjectBase value) {
    return _objc_msgSend_48(this.pointer, _sel_setKeywords_, value.pointer);
  }

  /// supportsContinuationStreams
  bool get supportsContinuationStreams {
    return _objc_msgSend_13(this.pointer, _sel_supportsContinuationStreams);
  }

  /// setSupportsContinuationStreams:
  set supportsContinuationStreams(bool value) {
    return _objc_msgSend_14(
        this.pointer, _sel_setSupportsContinuationStreams_, value);
  }

  /// delegate
  objc.ObjCObjectBase? get delegate {
    final _ret = _objc_msgSend_22(this.pointer, _sel_delegate);
    return _ret.address == 0
        ? null
        : objc.ObjCObjectBase(_ret, retain: true, release: true);
  }

  /// setDelegate:
  set delegate(objc.ObjCObjectBase? value) {
    return _objc_msgSend_23(
        this.pointer, _sel_setDelegate_, value?.pointer ?? ffi.nullptr);
  }

  /// targetContentIdentifier
  objc.NSString? get targetContentIdentifier {
    final _ret = _objc_msgSend_84(this.pointer, _sel_targetContentIdentifier);
    return _ret.address == 0
        ? null
        : objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// setTargetContentIdentifier:
  set targetContentIdentifier(objc.NSString? value) {
    return _objc_msgSend_148(this.pointer, _sel_setTargetContentIdentifier_,
        value?.pointer ?? ffi.nullptr);
  }

  /// becomeCurrent
  void becomeCurrent() {
    _objc_msgSend_11(this.pointer, _sel_becomeCurrent);
  }

  /// resignCurrent
  void resignCurrent() {
    _objc_msgSend_11(this.pointer, _sel_resignCurrent);
  }

  /// invalidate
  void invalidate() {
    _objc_msgSend_11(this.pointer, _sel_invalidate);
  }

  /// getContinuationStreamsWithCompletionHandler:
  void getContinuationStreamsWithCompletionHandler_(
      ObjCBlock_ffiVoid_NSInputStream_NSOutputStream_NSError
          completionHandler) {
    _objc_msgSend_409(
        this.pointer,
        _sel_getContinuationStreamsWithCompletionHandler_,
        completionHandler.pointer);
  }

  /// isEligibleForHandoff
  bool get eligibleForHandoff {
    return _objc_msgSend_13(this.pointer, _sel_isEligibleForHandoff);
  }

  /// setEligibleForHandoff:
  set eligibleForHandoff(bool value) {
    return _objc_msgSend_14(this.pointer, _sel_setEligibleForHandoff_, value);
  }

  /// isEligibleForSearch
  bool get eligibleForSearch {
    return _objc_msgSend_13(this.pointer, _sel_isEligibleForSearch);
  }

  /// setEligibleForSearch:
  set eligibleForSearch(bool value) {
    return _objc_msgSend_14(this.pointer, _sel_setEligibleForSearch_, value);
  }

  /// isEligibleForPublicIndexing
  bool get eligibleForPublicIndexing {
    return _objc_msgSend_13(this.pointer, _sel_isEligibleForPublicIndexing);
  }

  /// setEligibleForPublicIndexing:
  set eligibleForPublicIndexing(bool value) {
    return _objc_msgSend_14(
        this.pointer, _sel_setEligibleForPublicIndexing_, value);
  }

  /// isEligibleForPrediction
  bool get eligibleForPrediction {
    return _objc_msgSend_13(this.pointer, _sel_isEligibleForPrediction);
  }

  /// setEligibleForPrediction:
  set eligibleForPrediction(bool value) {
    return _objc_msgSend_14(
        this.pointer, _sel_setEligibleForPrediction_, value);
  }

  /// persistentIdentifier
  objc.NSString? get persistentIdentifier {
    final _ret = _objc_msgSend_84(this.pointer, _sel_persistentIdentifier);
    return _ret.address == 0
        ? null
        : objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// setPersistentIdentifier:
  set persistentIdentifier(objc.NSString? value) {
    return _objc_msgSend_148(this.pointer, _sel_setPersistentIdentifier_,
        value?.pointer ?? ffi.nullptr);
  }

  /// deleteSavedUserActivitiesWithPersistentIdentifiers:completionHandler:
  static void
      deleteSavedUserActivitiesWithPersistentIdentifiers_completionHandler_(
          objc.NSArray persistentIdentifiers, ObjCBlock_ffiVoid handler) {
    _objc_msgSend_410(
        _class_NSUserActivity,
        _sel_deleteSavedUserActivitiesWithPersistentIdentifiers_completionHandler_,
        persistentIdentifiers.pointer,
        handler.pointer);
  }

  /// deleteAllSavedUserActivitiesWithCompletionHandler:
  static void deleteAllSavedUserActivitiesWithCompletionHandler_(
      ObjCBlock_ffiVoid handler) {
    _objc_msgSend_320(
        _class_NSUserActivity,
        _sel_deleteAllSavedUserActivitiesWithCompletionHandler_,
        handler.pointer);
  }

  /// new
  static NSUserActivity new1() {
    final _ret = _objc_msgSend_2(_class_NSUserActivity, _sel_new);
    return NSUserActivity.castFromPointer(_ret, retain: false, release: true);
  }

  /// allocWithZone:
  static NSUserActivity allocWithZone_(ffi.Pointer<_NSZone> zone) {
    final _ret =
        _objc_msgSend_20(_class_NSUserActivity, _sel_allocWithZone_, zone);
    return NSUserActivity.castFromPointer(_ret, retain: false, release: true);
  }

  /// alloc
  static NSUserActivity alloc() {
    final _ret = _objc_msgSend_2(_class_NSUserActivity, _sel_alloc);
    return NSUserActivity.castFromPointer(_ret, retain: false, release: true);
  }
}

late final _class_NSUserActivity = objc.getClass("NSUserActivity");
late final _sel_initWithActivityType_ =
    objc.registerName("initWithActivityType:");
late final _sel_activityType = objc.registerName("activityType");
late final _sel_setUserInfo_ = objc.registerName("setUserInfo:");
final _objc_msgSend_361 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<objc.ObjCObject>)>();
late final _sel_addUserInfoEntriesFromDictionary_ =
    objc.registerName("addUserInfoEntriesFromDictionary:");
late final _sel_requiredUserInfoKeys =
    objc.registerName("requiredUserInfoKeys");
late final _sel_setRequiredUserInfoKeys_ =
    objc.registerName("setRequiredUserInfoKeys:");
late final _sel_needsSave = objc.registerName("needsSave");
late final _sel_setNeedsSave_ = objc.registerName("setNeedsSave:");
late final _sel_webpageURL = objc.registerName("webpageURL");
late final _sel_setWebpageURL_ = objc.registerName("setWebpageURL:");
late final _sel_referrerURL = objc.registerName("referrerURL");
late final _sel_setReferrerURL_ = objc.registerName("setReferrerURL:");
late final _sel_expirationDate = objc.registerName("expirationDate");
late final _sel_setExpirationDate_ = objc.registerName("setExpirationDate:");
final _objc_msgSend_362 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<objc.ObjCObject>)>();
late final _sel_keywords = objc.registerName("keywords");
late final _sel_setKeywords_ = objc.registerName("setKeywords:");
late final _sel_supportsContinuationStreams =
    objc.registerName("supportsContinuationStreams");
late final _sel_setSupportsContinuationStreams_ =
    objc.registerName("setSupportsContinuationStreams:");
late final _sel_targetContentIdentifier =
    objc.registerName("targetContentIdentifier");
late final _sel_setTargetContentIdentifier_ =
    objc.registerName("setTargetContentIdentifier:");
late final _sel_becomeCurrent = objc.registerName("becomeCurrent");
late final _sel_resignCurrent = objc.registerName("resignCurrent");
late final _sel_invalidate = objc.registerName("invalidate");
void _ObjCBlock_ffiVoid_NSInputStream_NSOutputStream_NSError_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlock> block,
        ffi.Pointer<objc.ObjCObject> arg0,
        ffi.Pointer<objc.ObjCObject> arg1,
        ffi.Pointer<objc.ObjCObject> arg2) =>
    block.ref.target
        .cast<
            ffi.NativeFunction<
                ffi.Void Function(
                    ffi.Pointer<objc.ObjCObject> arg0,
                    ffi.Pointer<objc.ObjCObject> arg1,
                    ffi.Pointer<objc.ObjCObject> arg2)>>()
        .asFunction<
            void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>()(arg0, arg1, arg2);
void _ObjCBlock_ffiVoid_NSInputStream_NSOutputStream_NSError_closureTrampoline(
        ffi.Pointer<objc.ObjCBlock> block,
        ffi.Pointer<objc.ObjCObject> arg0,
        ffi.Pointer<objc.ObjCObject> arg1,
        ffi.Pointer<objc.ObjCObject> arg2) =>
    (objc.getBlockClosure(block) as void Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>))(arg0, arg1, arg2);

class ObjCBlock_ffiVoid_NSInputStream_NSOutputStream_NSError
    extends objc.ObjCBlockBase {
  ObjCBlock_ffiVoid_NSInputStream_NSOutputStream_NSError._(
      ffi.Pointer<objc.ObjCBlock> pointer,
      {bool retain = false,
      bool release = true})
      : super(pointer, retain: retain, release: release);

  /// Returns a block that wraps the given raw block pointer.
  static ObjCBlock_ffiVoid_NSInputStream_NSOutputStream_NSError castFromPointer(
      ffi.Pointer<objc.ObjCBlock> pointer,
      {bool retain = false,
      bool release = false}) {
    return ObjCBlock_ffiVoid_NSInputStream_NSOutputStream_NSError._(pointer,
        retain: retain, release: release);
  }

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ObjCBlock_ffiVoid_NSInputStream_NSOutputStream_NSError.fromFunctionPointer(
      ffi.Pointer<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<objc.ObjCObject> arg0,
                      ffi.Pointer<objc.ObjCObject> arg1,
                      ffi.Pointer<objc.ObjCObject> arg2)>>
          ptr)
      : this._(objc.newPointerBlock(
            _cFuncTrampoline ??= ffi.Pointer.fromFunction<
                        ffi.Void Function(
                            ffi.Pointer<objc.ObjCBlock>,
                            ffi.Pointer<objc.ObjCObject>,
                            ffi.Pointer<objc.ObjCObject>,
                            ffi.Pointer<objc.ObjCObject>)>(
                    _ObjCBlock_ffiVoid_NSInputStream_NSOutputStream_NSError_fnPtrTrampoline)
                .cast(),
            ptr.cast()));
  static ffi.Pointer<ffi.Void>? _cFuncTrampoline;

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ObjCBlock_ffiVoid_NSInputStream_NSOutputStream_NSError.fromFunction(
      void Function(NSInputStream?, NSOutputStream?, objc.NSError?) fn)
      : this._(objc.newClosureBlock(
            _dartFuncTrampoline ??= ffi.Pointer.fromFunction<
                        ffi.Void Function(
                            ffi.Pointer<objc.ObjCBlock>,
                            ffi.Pointer<objc.ObjCObject>,
                            ffi.Pointer<objc.ObjCObject>,
                            ffi.Pointer<objc.ObjCObject>)>(
                    _ObjCBlock_ffiVoid_NSInputStream_NSOutputStream_NSError_closureTrampoline)
                .cast(),
            (ffi.Pointer<objc.ObjCObject> arg0, ffi.Pointer<objc.ObjCObject> arg1, ffi.Pointer<objc.ObjCObject> arg2) => fn(
                arg0.address == 0 ? null : NSInputStream.castFromPointer(arg0, retain: true, release: true),
                arg1.address == 0 ? null : NSOutputStream.castFromPointer(arg1, retain: true, release: true),
                arg2.address == 0 ? null : objc.NSError.castFromPointer(arg2, retain: true, release: true))));
  static ffi.Pointer<ffi.Void>? _dartFuncTrampoline;

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// Note that unlike the default behavior of NativeCallable.listener, listener
  /// blocks do not keep the isolate alive.
  ObjCBlock_ffiVoid_NSInputStream_NSOutputStream_NSError.listener(
      void Function(NSInputStream?, NSOutputStream?, objc.NSError?) fn)
      : this._(wrapListenerBlock_ObjCBlock_ffiVoid_NSInputStream_NSOutputStream_NSError(
            objc.newClosureBlock(
                (_dartFuncListenerTrampoline ??=
                        ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlock>, ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCObject>)>.listener(
                            _ObjCBlock_ffiVoid_NSInputStream_NSOutputStream_NSError_closureTrampoline)
                          ..keepIsolateAlive = false)
                    .nativeFunction
                    .cast(),
                (ffi.Pointer<objc.ObjCObject> arg0,
                        ffi.Pointer<objc.ObjCObject> arg1,
                        ffi.Pointer<objc.ObjCObject> arg2) =>
                    fn(
                        arg0.address == 0
                            ? null
                            : NSInputStream.castFromPointer(arg0, retain: false, release: true),
                        arg1.address == 0 ? null : NSOutputStream.castFromPointer(arg1, retain: false, release: true),
                        arg2.address == 0 ? null : objc.NSError.castFromPointer(arg2, retain: false, release: true)))));
  static ffi.NativeCallable<
      ffi.Void Function(
          ffi.Pointer<objc.ObjCBlock>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCObject>)>? _dartFuncListenerTrampoline;

  void call(NSInputStream? arg0, NSOutputStream? arg1, objc.NSError? arg2) =>
      pointer.ref.invoke
              .cast<
                  ffi.NativeFunction<
                      ffi.Void Function(
                          ffi.Pointer<objc.ObjCBlock> block,
                          ffi.Pointer<objc.ObjCObject> arg0,
                          ffi.Pointer<objc.ObjCObject> arg1,
                          ffi.Pointer<objc.ObjCObject> arg2)>>()
              .asFunction<
                  void Function(
                      ffi.Pointer<objc.ObjCBlock>,
                      ffi.Pointer<objc.ObjCObject>,
                      ffi.Pointer<objc.ObjCObject>,
                      ffi.Pointer<objc.ObjCObject>)>()(
          pointer,
          arg0?.pointer ?? ffi.nullptr,
          arg1?.pointer ?? ffi.nullptr,
          arg2?.pointer ?? ffi.nullptr);
}

/// NSInputStream
class NSInputStream extends NSStream {
  NSInputStream._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release);

  /// Constructs a [NSInputStream] that points to the same underlying object as [other].
  NSInputStream.castFrom(objc.ObjCObjectBase other)
      : this._(other.pointer, retain: true, release: true);

  /// Constructs a [NSInputStream] that wraps the given raw object pointer.
  NSInputStream.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [NSInputStream].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_0(
        obj.pointer, _sel_isKindOfClass_, _class_NSInputStream);
  }

  /// read:maxLength:
  int read_maxLength_(ffi.Pointer<ffi.Uint8> buffer, int len) {
    return _objc_msgSend_363(this.pointer, _sel_read_maxLength_, buffer, len);
  }

  /// getBuffer:length:
  bool getBuffer_length_(ffi.Pointer<ffi.Pointer<ffi.Uint8>> buffer,
      ffi.Pointer<ffi.UnsignedLong> len) {
    return _objc_msgSend_364(this.pointer, _sel_getBuffer_length_, buffer, len);
  }

  /// hasBytesAvailable
  bool get hasBytesAvailable {
    return _objc_msgSend_13(this.pointer, _sel_hasBytesAvailable);
  }

  /// initWithData:
  NSInputStream initWithData_(objc.NSData data) {
    final _ret =
        _objc_msgSend_365(this.pointer, _sel_initWithData_, data.pointer);
    return NSInputStream.castFromPointer(_ret, retain: true, release: true);
  }

  /// initWithURL:
  NSInputStream? initWithURL_(objc.NSURL url) {
    final _ret =
        _objc_msgSend_323(this.pointer, _sel_initWithURL_, url.pointer);
    return _ret.address == 0
        ? null
        : NSInputStream.castFromPointer(_ret, retain: true, release: true);
  }

  /// init
  NSInputStream init() {
    final _ret = _objc_msgSend_2(this.pointer, _sel_init);
    return NSInputStream.castFromPointer(_ret, retain: true, release: true);
  }

  /// new
  static NSInputStream new1() {
    final _ret = _objc_msgSend_2(_class_NSInputStream, _sel_new);
    return NSInputStream.castFromPointer(_ret, retain: false, release: true);
  }

  /// allocWithZone:
  static NSInputStream allocWithZone_(ffi.Pointer<_NSZone> zone) {
    final _ret =
        _objc_msgSend_20(_class_NSInputStream, _sel_allocWithZone_, zone);
    return NSInputStream.castFromPointer(_ret, retain: false, release: true);
  }

  /// alloc
  static NSInputStream alloc() {
    final _ret = _objc_msgSend_2(_class_NSInputStream, _sel_alloc);
    return NSInputStream.castFromPointer(_ret, retain: false, release: true);
  }
}

late final _class_NSInputStream = objc.getClass("NSInputStream");
late final _sel_read_maxLength_ = objc.registerName("read:maxLength:");
final _objc_msgSend_363 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Long Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<ffi.Uint8>,
                ffi.UnsignedLong)>>()
    .asFunction<
        int Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<ffi.Uint8>, int)>();
late final _sel_getBuffer_length_ = objc.registerName("getBuffer:length:");
final _objc_msgSend_364 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Bool Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<ffi.Pointer<ffi.Uint8>>,
                ffi.Pointer<ffi.UnsignedLong>)>>()
    .asFunction<
        bool Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<ffi.Pointer<ffi.Uint8>>,
            ffi.Pointer<ffi.UnsignedLong>)>();
late final _sel_hasBytesAvailable = objc.registerName("hasBytesAvailable");
late final _sel_initWithData_ = objc.registerName("initWithData:");
final _objc_msgSend_365 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            instancetype Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        instancetype Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<objc.ObjCObject>)>();

/// NSStream
class NSStream extends objc.NSObject {
  NSStream._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release);

  /// Constructs a [NSStream] that points to the same underlying object as [other].
  NSStream.castFrom(objc.ObjCObjectBase other)
      : this._(other.pointer, retain: true, release: true);

  /// Constructs a [NSStream] that wraps the given raw object pointer.
  NSStream.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [NSStream].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_0(obj.pointer, _sel_isKindOfClass_, _class_NSStream);
  }

  /// open
  void open() {
    _objc_msgSend_11(this.pointer, _sel_open);
  }

  /// close
  void close() {
    _objc_msgSend_11(this.pointer, _sel_close);
  }

  /// delegate
  objc.ObjCObjectBase? get delegate {
    final _ret = _objc_msgSend_22(this.pointer, _sel_delegate);
    return _ret.address == 0
        ? null
        : objc.ObjCObjectBase(_ret, retain: true, release: true);
  }

  /// setDelegate:
  set delegate(objc.ObjCObjectBase? value) {
    return _objc_msgSend_23(
        this.pointer, _sel_setDelegate_, value?.pointer ?? ffi.nullptr);
  }

  /// propertyForKey:
  objc.ObjCObjectBase? propertyForKey_(objc.NSString key) {
    final _ret =
        _objc_msgSend_285(this.pointer, _sel_propertyForKey_, key.pointer);
    return _ret.address == 0
        ? null
        : objc.ObjCObjectBase(_ret, retain: true, release: true);
  }

  /// setProperty:forKey:
  bool setProperty_forKey_(objc.ObjCObjectBase? property, objc.NSString key) {
    return _objc_msgSend_366(this.pointer, _sel_setProperty_forKey_,
        property?.pointer ?? ffi.nullptr, key.pointer);
  }

  /// scheduleInRunLoop:forMode:
  void scheduleInRunLoop_forMode_(NSRunLoop aRunLoop, objc.NSString mode) {
    _objc_msgSend_378(this.pointer, _sel_scheduleInRunLoop_forMode_,
        aRunLoop.pointer, mode.pointer);
  }

  /// removeFromRunLoop:forMode:
  void removeFromRunLoop_forMode_(NSRunLoop aRunLoop, objc.NSString mode) {
    _objc_msgSend_378(this.pointer, _sel_removeFromRunLoop_forMode_,
        aRunLoop.pointer, mode.pointer);
  }

  /// streamStatus
  NSStreamStatus get streamStatus {
    final _ret = _objc_msgSend_405(this.pointer, _sel_streamStatus);
    return NSStreamStatus.fromValue(_ret);
  }

  /// streamError
  objc.NSError? get streamError {
    final _ret = _objc_msgSend_406(this.pointer, _sel_streamError);
    return _ret.address == 0
        ? null
        : objc.NSError.castFromPointer(_ret, retain: true, release: true);
  }

  /// init
  NSStream init() {
    final _ret = _objc_msgSend_2(this.pointer, _sel_init);
    return NSStream.castFromPointer(_ret, retain: true, release: true);
  }

  /// new
  static NSStream new1() {
    final _ret = _objc_msgSend_2(_class_NSStream, _sel_new);
    return NSStream.castFromPointer(_ret, retain: false, release: true);
  }

  /// allocWithZone:
  static NSStream allocWithZone_(ffi.Pointer<_NSZone> zone) {
    final _ret = _objc_msgSend_20(_class_NSStream, _sel_allocWithZone_, zone);
    return NSStream.castFromPointer(_ret, retain: false, release: true);
  }

  /// alloc
  static NSStream alloc() {
    final _ret = _objc_msgSend_2(_class_NSStream, _sel_alloc);
    return NSStream.castFromPointer(_ret, retain: false, release: true);
  }
}

late final _class_NSStream = objc.getClass("NSStream");
late final _sel_open = objc.registerName("open");
late final _sel_propertyForKey_ = objc.registerName("propertyForKey:");
late final _sel_setProperty_forKey_ = objc.registerName("setProperty:forKey:");
final _objc_msgSend_366 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Bool Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        bool Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>();

/// NSRunLoop
class NSRunLoop extends objc.NSObject {
  NSRunLoop._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release);

  /// Constructs a [NSRunLoop] that points to the same underlying object as [other].
  NSRunLoop.castFrom(objc.ObjCObjectBase other)
      : this._(other.pointer, retain: true, release: true);

  /// Constructs a [NSRunLoop] that wraps the given raw object pointer.
  NSRunLoop.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [NSRunLoop].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_0(obj.pointer, _sel_isKindOfClass_, _class_NSRunLoop);
  }

  /// currentRunLoop
  static NSRunLoop getCurrentRunLoop() {
    final _ret = _objc_msgSend_367(_class_NSRunLoop, _sel_currentRunLoop);
    return NSRunLoop.castFromPointer(_ret, retain: true, release: true);
  }

  /// mainRunLoop
  static NSRunLoop getMainRunLoop() {
    final _ret = _objc_msgSend_367(_class_NSRunLoop, _sel_mainRunLoop);
    return NSRunLoop.castFromPointer(_ret, retain: true, release: true);
  }

  /// currentMode
  objc.NSString? get currentMode {
    final _ret = _objc_msgSend_84(this.pointer, _sel_currentMode);
    return _ret.address == 0
        ? null
        : objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// getCFRunLoop
  ffi.Pointer<__CFRunLoop> getCFRunLoop() {
    return _objc_msgSend_368(this.pointer, _sel_getCFRunLoop);
  }

  /// addTimer:forMode:
  void addTimer_forMode_(NSTimer timer, objc.NSString mode) {
    _objc_msgSend_376(
        this.pointer, _sel_addTimer_forMode_, timer.pointer, mode.pointer);
  }

  /// addPort:forMode:
  void addPort_forMode_(NSPort aPort, objc.NSString mode) {
    _objc_msgSend_402(
        this.pointer, _sel_addPort_forMode_, aPort.pointer, mode.pointer);
  }

  /// removePort:forMode:
  void removePort_forMode_(NSPort aPort, objc.NSString mode) {
    _objc_msgSend_402(
        this.pointer, _sel_removePort_forMode_, aPort.pointer, mode.pointer);
  }

  /// limitDateForMode:
  objc.NSDate? limitDateForMode_(objc.NSString mode) {
    final _ret =
        _objc_msgSend_403(this.pointer, _sel_limitDateForMode_, mode.pointer);
    return _ret.address == 0
        ? null
        : objc.NSDate.castFromPointer(_ret, retain: true, release: true);
  }

  /// acceptInputForMode:beforeDate:
  void acceptInputForMode_beforeDate_(
      objc.NSString mode, objc.NSDate limitDate) {
    _objc_msgSend_404(this.pointer, _sel_acceptInputForMode_beforeDate_,
        mode.pointer, limitDate.pointer);
  }

  /// init
  NSRunLoop init() {
    final _ret = _objc_msgSend_2(this.pointer, _sel_init);
    return NSRunLoop.castFromPointer(_ret, retain: true, release: true);
  }

  /// new
  static NSRunLoop new1() {
    final _ret = _objc_msgSend_2(_class_NSRunLoop, _sel_new);
    return NSRunLoop.castFromPointer(_ret, retain: false, release: true);
  }

  /// allocWithZone:
  static NSRunLoop allocWithZone_(ffi.Pointer<_NSZone> zone) {
    final _ret = _objc_msgSend_20(_class_NSRunLoop, _sel_allocWithZone_, zone);
    return NSRunLoop.castFromPointer(_ret, retain: false, release: true);
  }

  /// alloc
  static NSRunLoop alloc() {
    final _ret = _objc_msgSend_2(_class_NSRunLoop, _sel_alloc);
    return NSRunLoop.castFromPointer(_ret, retain: false, release: true);
  }
}

late final _class_NSRunLoop = objc.getClass("NSRunLoop");
late final _sel_currentRunLoop = objc.registerName("currentRunLoop");
final _objc_msgSend_367 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_mainRunLoop = objc.registerName("mainRunLoop");
late final _sel_currentMode = objc.registerName("currentMode");

final class __CFRunLoop extends ffi.Opaque {}

late final _sel_getCFRunLoop = objc.registerName("getCFRunLoop");
final _objc_msgSend_368 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<__CFRunLoop> Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        ffi.Pointer<__CFRunLoop> Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();

/// NSTimer
class NSTimer extends objc.NSObject {
  NSTimer._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release);

  /// Constructs a [NSTimer] that points to the same underlying object as [other].
  NSTimer.castFrom(objc.ObjCObjectBase other)
      : this._(other.pointer, retain: true, release: true);

  /// Constructs a [NSTimer] that wraps the given raw object pointer.
  NSTimer.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [NSTimer].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_0(obj.pointer, _sel_isKindOfClass_, _class_NSTimer);
  }

  /// timerWithTimeInterval:invocation:repeats:
  static NSTimer timerWithTimeInterval_invocation_repeats_(
      double ti, objc.NSInvocation invocation, bool yesOrNo) {
    final _ret = _objc_msgSend_369(
        _class_NSTimer,
        _sel_timerWithTimeInterval_invocation_repeats_,
        ti,
        invocation.pointer,
        yesOrNo);
    return NSTimer.castFromPointer(_ret, retain: true, release: true);
  }

  /// scheduledTimerWithTimeInterval:invocation:repeats:
  static NSTimer scheduledTimerWithTimeInterval_invocation_repeats_(
      double ti, objc.NSInvocation invocation, bool yesOrNo) {
    final _ret = _objc_msgSend_369(
        _class_NSTimer,
        _sel_scheduledTimerWithTimeInterval_invocation_repeats_,
        ti,
        invocation.pointer,
        yesOrNo);
    return NSTimer.castFromPointer(_ret, retain: true, release: true);
  }

  /// timerWithTimeInterval:target:selector:userInfo:repeats:
  static NSTimer timerWithTimeInterval_target_selector_userInfo_repeats_(
      double ti,
      objc.ObjCObjectBase aTarget,
      ffi.Pointer<objc.ObjCSelector> aSelector,
      objc.ObjCObjectBase? userInfo,
      bool yesOrNo) {
    final _ret = _objc_msgSend_370(
        _class_NSTimer,
        _sel_timerWithTimeInterval_target_selector_userInfo_repeats_,
        ti,
        aTarget.pointer,
        aSelector,
        userInfo?.pointer ?? ffi.nullptr,
        yesOrNo);
    return NSTimer.castFromPointer(_ret, retain: true, release: true);
  }

  /// scheduledTimerWithTimeInterval:target:selector:userInfo:repeats:
  static NSTimer
      scheduledTimerWithTimeInterval_target_selector_userInfo_repeats_(
          double ti,
          objc.ObjCObjectBase aTarget,
          ffi.Pointer<objc.ObjCSelector> aSelector,
          objc.ObjCObjectBase? userInfo,
          bool yesOrNo) {
    final _ret = _objc_msgSend_370(
        _class_NSTimer,
        _sel_scheduledTimerWithTimeInterval_target_selector_userInfo_repeats_,
        ti,
        aTarget.pointer,
        aSelector,
        userInfo?.pointer ?? ffi.nullptr,
        yesOrNo);
    return NSTimer.castFromPointer(_ret, retain: true, release: true);
  }

  /// timerWithTimeInterval:repeats:block:
  static NSTimer timerWithTimeInterval_repeats_block_(
      double interval, bool repeats, ObjCBlock_ffiVoid_NSTimer block) {
    final _ret = _objc_msgSend_371(
        _class_NSTimer,
        _sel_timerWithTimeInterval_repeats_block_,
        interval,
        repeats,
        block.pointer);
    return NSTimer.castFromPointer(_ret, retain: true, release: true);
  }

  /// scheduledTimerWithTimeInterval:repeats:block:
  static NSTimer scheduledTimerWithTimeInterval_repeats_block_(
      double interval, bool repeats, ObjCBlock_ffiVoid_NSTimer block) {
    final _ret = _objc_msgSend_371(
        _class_NSTimer,
        _sel_scheduledTimerWithTimeInterval_repeats_block_,
        interval,
        repeats,
        block.pointer);
    return NSTimer.castFromPointer(_ret, retain: true, release: true);
  }

  /// initWithFireDate:interval:repeats:block:
  NSTimer initWithFireDate_interval_repeats_block_(objc.NSDate date,
      double interval, bool repeats, ObjCBlock_ffiVoid_NSTimer block) {
    final _ret = _objc_msgSend_372(
        this.pointer,
        _sel_initWithFireDate_interval_repeats_block_,
        date.pointer,
        interval,
        repeats,
        block.pointer);
    return NSTimer.castFromPointer(_ret, retain: true, release: true);
  }

  /// initWithFireDate:interval:target:selector:userInfo:repeats:
  NSTimer initWithFireDate_interval_target_selector_userInfo_repeats_(
      objc.NSDate date,
      double ti,
      objc.ObjCObjectBase t,
      ffi.Pointer<objc.ObjCSelector> s,
      objc.ObjCObjectBase? ui,
      bool rep) {
    final _ret = _objc_msgSend_373(
        this.pointer,
        _sel_initWithFireDate_interval_target_selector_userInfo_repeats_,
        date.pointer,
        ti,
        t.pointer,
        s,
        ui?.pointer ?? ffi.nullptr,
        rep);
    return NSTimer.castFromPointer(_ret, retain: true, release: true);
  }

  /// fire
  void fire() {
    _objc_msgSend_11(this.pointer, _sel_fire);
  }

  /// fireDate
  objc.NSDate get fireDate {
    final _ret = _objc_msgSend_374(this.pointer, _sel_fireDate);
    return objc.NSDate.castFromPointer(_ret, retain: true, release: true);
  }

  /// setFireDate:
  set fireDate(objc.NSDate value) {
    return _objc_msgSend_375(this.pointer, _sel_setFireDate_, value.pointer);
  }

  /// timeInterval
  double get timeInterval {
    return objc.useMsgSendVariants
        ? _objc_msgSend_10Fpret(this.pointer, _sel_timeInterval)
        : _objc_msgSend_10(this.pointer, _sel_timeInterval);
  }

  /// tolerance
  double get tolerance {
    return objc.useMsgSendVariants
        ? _objc_msgSend_10Fpret(this.pointer, _sel_tolerance)
        : _objc_msgSend_10(this.pointer, _sel_tolerance);
  }

  /// setTolerance:
  set tolerance(double value) {
    return _objc_msgSend_64(this.pointer, _sel_setTolerance_, value);
  }

  /// invalidate
  void invalidate() {
    _objc_msgSend_11(this.pointer, _sel_invalidate);
  }

  /// isValid
  bool get valid {
    return _objc_msgSend_13(this.pointer, _sel_isValid);
  }

  /// userInfo
  objc.ObjCObjectBase? get userInfo {
    final _ret = _objc_msgSend_22(this.pointer, _sel_userInfo);
    return _ret.address == 0
        ? null
        : objc.ObjCObjectBase(_ret, retain: true, release: true);
  }

  /// init
  NSTimer init() {
    final _ret = _objc_msgSend_2(this.pointer, _sel_init);
    return NSTimer.castFromPointer(_ret, retain: true, release: true);
  }

  /// new
  static NSTimer new1() {
    final _ret = _objc_msgSend_2(_class_NSTimer, _sel_new);
    return NSTimer.castFromPointer(_ret, retain: false, release: true);
  }

  /// allocWithZone:
  static NSTimer allocWithZone_(ffi.Pointer<_NSZone> zone) {
    final _ret = _objc_msgSend_20(_class_NSTimer, _sel_allocWithZone_, zone);
    return NSTimer.castFromPointer(_ret, retain: false, release: true);
  }

  /// alloc
  static NSTimer alloc() {
    final _ret = _objc_msgSend_2(_class_NSTimer, _sel_alloc);
    return NSTimer.castFromPointer(_ret, retain: false, release: true);
  }
}

late final _class_NSTimer = objc.getClass("NSTimer");
late final _sel_timerWithTimeInterval_invocation_repeats_ =
    objc.registerName("timerWithTimeInterval:invocation:repeats:");
final _objc_msgSend_369 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Double,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Bool)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            double,
            ffi.Pointer<objc.ObjCObject>,
            bool)>();
late final _sel_scheduledTimerWithTimeInterval_invocation_repeats_ =
    objc.registerName("scheduledTimerWithTimeInterval:invocation:repeats:");
late final _sel_timerWithTimeInterval_target_selector_userInfo_repeats_ = objc
    .registerName("timerWithTimeInterval:target:selector:userInfo:repeats:");
final _objc_msgSend_370 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Double,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Bool)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            double,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            bool)>();
late final _sel_scheduledTimerWithTimeInterval_target_selector_userInfo_repeats_ =
    objc.registerName(
        "scheduledTimerWithTimeInterval:target:selector:userInfo:repeats:");
void _ObjCBlock_ffiVoid_NSTimer_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlock> block, ffi.Pointer<objc.ObjCObject> arg0) =>
    block.ref.target
        .cast<
            ffi.NativeFunction<
                ffi.Void Function(ffi.Pointer<objc.ObjCObject> arg0)>>()
        .asFunction<void Function(ffi.Pointer<objc.ObjCObject>)>()(arg0);
void _ObjCBlock_ffiVoid_NSTimer_closureTrampoline(
        ffi.Pointer<objc.ObjCBlock> block, ffi.Pointer<objc.ObjCObject> arg0) =>
    (objc.getBlockClosure(block) as void Function(
        ffi.Pointer<objc.ObjCObject>))(arg0);

class ObjCBlock_ffiVoid_NSTimer extends objc.ObjCBlockBase {
  ObjCBlock_ffiVoid_NSTimer._(ffi.Pointer<objc.ObjCBlock> pointer,
      {bool retain = false, bool release = true})
      : super(pointer, retain: retain, release: release);

  /// Returns a block that wraps the given raw block pointer.
  static ObjCBlock_ffiVoid_NSTimer castFromPointer(
      ffi.Pointer<objc.ObjCBlock> pointer,
      {bool retain = false,
      bool release = false}) {
    return ObjCBlock_ffiVoid_NSTimer._(pointer,
        retain: retain, release: release);
  }

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ObjCBlock_ffiVoid_NSTimer.fromFunctionPointer(
      ffi.Pointer<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<objc.ObjCObject> arg0)>>
          ptr)
      : this._(objc.newPointerBlock(
            _cFuncTrampoline ??= ffi.Pointer.fromFunction<
                        ffi.Void Function(ffi.Pointer<objc.ObjCBlock>,
                            ffi.Pointer<objc.ObjCObject>)>(
                    _ObjCBlock_ffiVoid_NSTimer_fnPtrTrampoline)
                .cast(),
            ptr.cast()));
  static ffi.Pointer<ffi.Void>? _cFuncTrampoline;

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ObjCBlock_ffiVoid_NSTimer.fromFunction(void Function(NSTimer) fn)
      : this._(objc.newClosureBlock(
            _dartFuncTrampoline ??= ffi.Pointer.fromFunction<
                        ffi.Void Function(ffi.Pointer<objc.ObjCBlock>,
                            ffi.Pointer<objc.ObjCObject>)>(
                    _ObjCBlock_ffiVoid_NSTimer_closureTrampoline)
                .cast(),
            (ffi.Pointer<objc.ObjCObject> arg0) => fn(
                NSTimer.castFromPointer(arg0, retain: true, release: true))));
  static ffi.Pointer<ffi.Void>? _dartFuncTrampoline;

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// Note that unlike the default behavior of NativeCallable.listener, listener
  /// blocks do not keep the isolate alive.
  ObjCBlock_ffiVoid_NSTimer.listener(void Function(NSTimer) fn)
      : this._(wrapListenerBlock_ObjCBlock_ffiVoid_NSTimer(objc.newClosureBlock(
            (_dartFuncListenerTrampoline ??= ffi.NativeCallable<
                        ffi.Void Function(ffi.Pointer<objc.ObjCBlock>,
                            ffi.Pointer<objc.ObjCObject>)>.listener(
                    _ObjCBlock_ffiVoid_NSTimer_closureTrampoline)
                  ..keepIsolateAlive = false)
                .nativeFunction
                .cast(),
            (ffi.Pointer<objc.ObjCObject> arg0) => fn(
                NSTimer.castFromPointer(arg0, retain: false, release: true)))));
  static ffi.NativeCallable<
          ffi.Void Function(
              ffi.Pointer<objc.ObjCBlock>, ffi.Pointer<objc.ObjCObject>)>?
      _dartFuncListenerTrampoline;

  void call(NSTimer arg0) => pointer.ref.invoke
      .cast<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<objc.ObjCBlock> block,
                  ffi.Pointer<objc.ObjCObject> arg0)>>()
      .asFunction<
          void Function(ffi.Pointer<objc.ObjCBlock>,
              ffi.Pointer<objc.ObjCObject>)>()(pointer, arg0.pointer);
}

late final _sel_timerWithTimeInterval_repeats_block_ =
    objc.registerName("timerWithTimeInterval:repeats:block:");
final _objc_msgSend_371 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Double,
                ffi.Bool,
                ffi.Pointer<objc.ObjCBlock>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            double,
            bool,
            ffi.Pointer<objc.ObjCBlock>)>();
late final _sel_scheduledTimerWithTimeInterval_repeats_block_ =
    objc.registerName("scheduledTimerWithTimeInterval:repeats:block:");
late final _sel_initWithFireDate_interval_repeats_block_ =
    objc.registerName("initWithFireDate:interval:repeats:block:");
final _objc_msgSend_372 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            instancetype Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Double,
                ffi.Bool,
                ffi.Pointer<objc.ObjCBlock>)>>()
    .asFunction<
        instancetype Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            double,
            bool,
            ffi.Pointer<objc.ObjCBlock>)>();
late final _sel_initWithFireDate_interval_target_selector_userInfo_repeats_ =
    objc.registerName(
        "initWithFireDate:interval:target:selector:userInfo:repeats:");
final _objc_msgSend_373 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            instancetype Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Double,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Bool)>>()
    .asFunction<
        instancetype Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            double,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            bool)>();
late final _sel_fire = objc.registerName("fire");
late final _sel_fireDate = objc.registerName("fireDate");
final _objc_msgSend_374 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_setFireDate_ = objc.registerName("setFireDate:");
final _objc_msgSend_375 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<objc.ObjCObject>)>();
late final _sel_timeInterval = objc.registerName("timeInterval");
late final _sel_tolerance = objc.registerName("tolerance");
late final _sel_setTolerance_ = objc.registerName("setTolerance:");
late final _sel_isValid = objc.registerName("isValid");
late final _sel_addTimer_forMode_ = objc.registerName("addTimer:forMode:");
final _objc_msgSend_376 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        void Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>();

/// NSPort
class NSPort extends objc.NSObject {
  NSPort._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release);

  /// Constructs a [NSPort] that points to the same underlying object as [other].
  NSPort.castFrom(objc.ObjCObjectBase other)
      : this._(other.pointer, retain: true, release: true);

  /// Constructs a [NSPort] that wraps the given raw object pointer.
  NSPort.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [NSPort].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_0(obj.pointer, _sel_isKindOfClass_, _class_NSPort);
  }

  /// port
  static NSPort port() {
    final _ret = _objc_msgSend_377(_class_NSPort, _sel_port);
    return NSPort.castFromPointer(_ret, retain: true, release: true);
  }

  /// invalidate
  void invalidate() {
    _objc_msgSend_11(this.pointer, _sel_invalidate);
  }

  /// isValid
  bool get valid {
    return _objc_msgSend_13(this.pointer, _sel_isValid);
  }

  /// setDelegate:
  void setDelegate_(objc.ObjCObjectBase? anObject) {
    _objc_msgSend_24(
        this.pointer, _sel_setDelegate_, anObject?.pointer ?? ffi.nullptr);
  }

  /// delegate
  objc.ObjCObjectBase? delegate() {
    final _ret = _objc_msgSend_22(this.pointer, _sel_delegate);
    return _ret.address == 0
        ? null
        : objc.ObjCObjectBase(_ret, retain: true, release: true);
  }

  /// scheduleInRunLoop:forMode:
  void scheduleInRunLoop_forMode_(NSRunLoop runLoop, objc.NSString mode) {
    _objc_msgSend_378(this.pointer, _sel_scheduleInRunLoop_forMode_,
        runLoop.pointer, mode.pointer);
  }

  /// removeFromRunLoop:forMode:
  void removeFromRunLoop_forMode_(NSRunLoop runLoop, objc.NSString mode) {
    _objc_msgSend_378(this.pointer, _sel_removeFromRunLoop_forMode_,
        runLoop.pointer, mode.pointer);
  }

  /// reservedSpaceLength
  int get reservedSpaceLength {
    return _objc_msgSend_6(this.pointer, _sel_reservedSpaceLength);
  }

  /// sendBeforeDate:components:from:reserved:
  bool sendBeforeDate_components_from_reserved_(
      objc.NSDate limitDate,
      objc.NSMutableArray? components,
      NSPort? receivePort,
      int headerSpaceReserved) {
    return _objc_msgSend_379(
        this.pointer,
        _sel_sendBeforeDate_components_from_reserved_,
        limitDate.pointer,
        components?.pointer ?? ffi.nullptr,
        receivePort?.pointer ?? ffi.nullptr,
        headerSpaceReserved);
  }

  /// sendBeforeDate:msgid:components:from:reserved:
  bool sendBeforeDate_msgid_components_from_reserved_(
      objc.NSDate limitDate,
      int msgID,
      objc.NSMutableArray? components,
      NSPort? receivePort,
      int headerSpaceReserved) {
    return _objc_msgSend_380(
        this.pointer,
        _sel_sendBeforeDate_msgid_components_from_reserved_,
        limitDate.pointer,
        msgID,
        components?.pointer ?? ffi.nullptr,
        receivePort?.pointer ?? ffi.nullptr,
        headerSpaceReserved);
  }

  /// addConnection:toRunLoop:forMode:
  void addConnection_toRunLoop_forMode_(
      NSConnection conn, NSRunLoop runLoop, objc.NSString mode) {
    _objc_msgSend_401(this.pointer, _sel_addConnection_toRunLoop_forMode_,
        conn.pointer, runLoop.pointer, mode.pointer);
  }

  /// removeConnection:fromRunLoop:forMode:
  void removeConnection_fromRunLoop_forMode_(
      NSConnection conn, NSRunLoop runLoop, objc.NSString mode) {
    _objc_msgSend_401(this.pointer, _sel_removeConnection_fromRunLoop_forMode_,
        conn.pointer, runLoop.pointer, mode.pointer);
  }

  /// init
  NSPort init() {
    final _ret = _objc_msgSend_2(this.pointer, _sel_init);
    return NSPort.castFromPointer(_ret, retain: true, release: true);
  }

  /// new
  static NSPort new1() {
    final _ret = _objc_msgSend_2(_class_NSPort, _sel_new);
    return NSPort.castFromPointer(_ret, retain: false, release: true);
  }

  /// allocWithZone:
  static NSPort allocWithZone_(ffi.Pointer<_NSZone> zone) {
    final _ret = _objc_msgSend_20(_class_NSPort, _sel_allocWithZone_, zone);
    return NSPort.castFromPointer(_ret, retain: false, release: true);
  }

  /// alloc
  static NSPort alloc() {
    final _ret = _objc_msgSend_2(_class_NSPort, _sel_alloc);
    return NSPort.castFromPointer(_ret, retain: false, release: true);
  }
}

late final _class_NSPort = objc.getClass("NSPort");
late final _sel_port = objc.registerName("port");
final _objc_msgSend_377 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_scheduleInRunLoop_forMode_ =
    objc.registerName("scheduleInRunLoop:forMode:");
final _objc_msgSend_378 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        void Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>();
late final _sel_removeFromRunLoop_forMode_ =
    objc.registerName("removeFromRunLoop:forMode:");
late final _sel_reservedSpaceLength = objc.registerName("reservedSpaceLength");
late final _sel_sendBeforeDate_components_from_reserved_ =
    objc.registerName("sendBeforeDate:components:from:reserved:");
final _objc_msgSend_379 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Bool Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.UnsignedLong)>>()
    .asFunction<
        bool Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            int)>();
late final _sel_sendBeforeDate_msgid_components_from_reserved_ =
    objc.registerName("sendBeforeDate:msgid:components:from:reserved:");
final _objc_msgSend_380 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Bool Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.UnsignedLong,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.UnsignedLong)>>()
    .asFunction<
        bool Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            int,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            int)>();

/// NSConnection
class NSConnection extends objc.NSObject {
  NSConnection._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release);

  /// Constructs a [NSConnection] that points to the same underlying object as [other].
  NSConnection.castFrom(objc.ObjCObjectBase other)
      : this._(other.pointer, retain: true, release: true);

  /// Constructs a [NSConnection] that wraps the given raw object pointer.
  NSConnection.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [NSConnection].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_0(
        obj.pointer, _sel_isKindOfClass_, _class_NSConnection);
  }

  /// statistics
  objc.NSDictionary get statistics {
    final _ret = _objc_msgSend_231(this.pointer, _sel_statistics);
    return objc.NSDictionary.castFromPointer(_ret, retain: true, release: true);
  }

  /// allConnections
  static objc.NSArray allConnections() {
    final _ret = _objc_msgSend_37(_class_NSConnection, _sel_allConnections);
    return objc.NSArray.castFromPointer(_ret, retain: true, release: true);
  }

  /// defaultConnection
  static NSConnection defaultConnection() {
    final _ret = _objc_msgSend_381(_class_NSConnection, _sel_defaultConnection);
    return NSConnection.castFromPointer(_ret, retain: true, release: true);
  }

  /// connectionWithRegisteredName:host:
  static NSConnection? connectionWithRegisteredName_host_(
      objc.NSString name, objc.NSString? hostName) {
    final _ret = _objc_msgSend_382(
        _class_NSConnection,
        _sel_connectionWithRegisteredName_host_,
        name.pointer,
        hostName?.pointer ?? ffi.nullptr);
    return _ret.address == 0
        ? null
        : NSConnection.castFromPointer(_ret, retain: true, release: true);
  }

  /// connectionWithRegisteredName:host:usingNameServer:
  static NSConnection? connectionWithRegisteredName_host_usingNameServer_(
      objc.NSString name, objc.NSString? hostName, NSPortNameServer server) {
    final _ret = _objc_msgSend_387(
        _class_NSConnection,
        _sel_connectionWithRegisteredName_host_usingNameServer_,
        name.pointer,
        hostName?.pointer ?? ffi.nullptr,
        server.pointer);
    return _ret.address == 0
        ? null
        : NSConnection.castFromPointer(_ret, retain: true, release: true);
  }

  /// rootProxyForConnectionWithRegisteredName:host:
  static NSDistantObject? rootProxyForConnectionWithRegisteredName_host_(
      objc.NSString name, objc.NSString? hostName) {
    final _ret = _objc_msgSend_392(
        _class_NSConnection,
        _sel_rootProxyForConnectionWithRegisteredName_host_,
        name.pointer,
        hostName?.pointer ?? ffi.nullptr);
    return _ret.address == 0
        ? null
        : NSDistantObject.castFromPointer(_ret, retain: true, release: true);
  }

  /// rootProxyForConnectionWithRegisteredName:host:usingNameServer:
  static NSDistantObject?
      rootProxyForConnectionWithRegisteredName_host_usingNameServer_(
          objc.NSString name,
          objc.NSString? hostName,
          NSPortNameServer server) {
    final _ret = _objc_msgSend_393(
        _class_NSConnection,
        _sel_rootProxyForConnectionWithRegisteredName_host_usingNameServer_,
        name.pointer,
        hostName?.pointer ?? ffi.nullptr,
        server.pointer);
    return _ret.address == 0
        ? null
        : NSDistantObject.castFromPointer(_ret, retain: true, release: true);
  }

  /// serviceConnectionWithName:rootObject:usingNameServer:
  static NSConnection? serviceConnectionWithName_rootObject_usingNameServer_(
      objc.NSString name, objc.ObjCObjectBase root, NSPortNameServer server) {
    final _ret = _objc_msgSend_394(
        _class_NSConnection,
        _sel_serviceConnectionWithName_rootObject_usingNameServer_,
        name.pointer,
        root.pointer,
        server.pointer);
    return _ret.address == 0
        ? null
        : NSConnection.castFromPointer(_ret, retain: true, release: true);
  }

  /// serviceConnectionWithName:rootObject:
  static NSConnection? serviceConnectionWithName_rootObject_(
      objc.NSString name, objc.ObjCObjectBase root) {
    final _ret = _objc_msgSend_395(_class_NSConnection,
        _sel_serviceConnectionWithName_rootObject_, name.pointer, root.pointer);
    return _ret.address == 0
        ? null
        : NSConnection.castFromPointer(_ret, retain: true, release: true);
  }

  /// requestTimeout
  double get requestTimeout {
    return objc.useMsgSendVariants
        ? _objc_msgSend_10Fpret(this.pointer, _sel_requestTimeout)
        : _objc_msgSend_10(this.pointer, _sel_requestTimeout);
  }

  /// setRequestTimeout:
  set requestTimeout(double value) {
    return _objc_msgSend_64(this.pointer, _sel_setRequestTimeout_, value);
  }

  /// replyTimeout
  double get replyTimeout {
    return objc.useMsgSendVariants
        ? _objc_msgSend_10Fpret(this.pointer, _sel_replyTimeout)
        : _objc_msgSend_10(this.pointer, _sel_replyTimeout);
  }

  /// setReplyTimeout:
  set replyTimeout(double value) {
    return _objc_msgSend_64(this.pointer, _sel_setReplyTimeout_, value);
  }

  /// rootObject
  objc.ObjCObjectBase? get rootObject {
    final _ret = _objc_msgSend_22(this.pointer, _sel_rootObject);
    return _ret.address == 0
        ? null
        : objc.ObjCObjectBase(_ret, retain: true, release: true);
  }

  /// setRootObject:
  set rootObject(objc.ObjCObjectBase? value) {
    return _objc_msgSend_23(
        this.pointer, _sel_setRootObject_, value?.pointer ?? ffi.nullptr);
  }

  /// delegate
  objc.ObjCObjectBase? get delegate {
    final _ret = _objc_msgSend_22(this.pointer, _sel_delegate);
    return _ret.address == 0
        ? null
        : objc.ObjCObjectBase(_ret, retain: true, release: true);
  }

  /// setDelegate:
  set delegate(objc.ObjCObjectBase? value) {
    return _objc_msgSend_23(
        this.pointer, _sel_setDelegate_, value?.pointer ?? ffi.nullptr);
  }

  /// independentConversationQueueing
  bool get independentConversationQueueing {
    return _objc_msgSend_13(this.pointer, _sel_independentConversationQueueing);
  }

  /// setIndependentConversationQueueing:
  set independentConversationQueueing(bool value) {
    return _objc_msgSend_14(
        this.pointer, _sel_setIndependentConversationQueueing_, value);
  }

  /// isValid
  bool get valid {
    return _objc_msgSend_13(this.pointer, _sel_isValid);
  }

  /// rootProxy
  NSDistantObject get rootProxy {
    final _ret = _objc_msgSend_396(this.pointer, _sel_rootProxy);
    return NSDistantObject.castFromPointer(_ret, retain: true, release: true);
  }

  /// invalidate
  void invalidate() {
    _objc_msgSend_11(this.pointer, _sel_invalidate);
  }

  /// addRequestMode:
  void addRequestMode_(objc.NSString rmode) {
    _objc_msgSend_12(this.pointer, _sel_addRequestMode_, rmode.pointer);
  }

  /// removeRequestMode:
  void removeRequestMode_(objc.NSString rmode) {
    _objc_msgSend_12(this.pointer, _sel_removeRequestMode_, rmode.pointer);
  }

  /// requestModes
  objc.NSArray get requestModes {
    final _ret = _objc_msgSend_37(this.pointer, _sel_requestModes);
    return objc.NSArray.castFromPointer(_ret, retain: true, release: true);
  }

  /// registerName:
  bool registerName_(objc.NSString? name) {
    return _objc_msgSend_397(
        this.pointer, _sel_registerName_, name?.pointer ?? ffi.nullptr);
  }

  /// registerName:withNameServer:
  bool registerName_withNameServer_(
      objc.NSString? name, NSPortNameServer server) {
    return _objc_msgSend_398(this.pointer, _sel_registerName_withNameServer_,
        name?.pointer ?? ffi.nullptr, server.pointer);
  }

  /// connectionWithReceivePort:sendPort:
  static NSConnection? connectionWithReceivePort_sendPort_(
      NSPort? receivePort, NSPort? sendPort) {
    final _ret = _objc_msgSend_399(
        _class_NSConnection,
        _sel_connectionWithReceivePort_sendPort_,
        receivePort?.pointer ?? ffi.nullptr,
        sendPort?.pointer ?? ffi.nullptr);
    return _ret.address == 0
        ? null
        : NSConnection.castFromPointer(_ret, retain: true, release: true);
  }

  /// currentConversation
  static objc.ObjCObjectBase? currentConversation() {
    final _ret =
        _objc_msgSend_22(_class_NSConnection, _sel_currentConversation);
    return _ret.address == 0
        ? null
        : objc.ObjCObjectBase(_ret, retain: true, release: true);
  }

  /// initWithReceivePort:sendPort:
  NSConnection? initWithReceivePort_sendPort_(
      NSPort? receivePort, NSPort? sendPort) {
    final _ret = _objc_msgSend_399(
        this.pointer,
        _sel_initWithReceivePort_sendPort_,
        receivePort?.pointer ?? ffi.nullptr,
        sendPort?.pointer ?? ffi.nullptr);
    return _ret.address == 0
        ? null
        : NSConnection.castFromPointer(_ret, retain: true, release: true);
  }

  /// sendPort
  NSPort get sendPort {
    final _ret = _objc_msgSend_377(this.pointer, _sel_sendPort);
    return NSPort.castFromPointer(_ret, retain: true, release: true);
  }

  /// receivePort
  NSPort get receivePort {
    final _ret = _objc_msgSend_377(this.pointer, _sel_receivePort);
    return NSPort.castFromPointer(_ret, retain: true, release: true);
  }

  /// enableMultipleThreads
  void enableMultipleThreads() {
    _objc_msgSend_11(this.pointer, _sel_enableMultipleThreads);
  }

  /// multipleThreadsEnabled
  bool get multipleThreadsEnabled {
    return _objc_msgSend_13(this.pointer, _sel_multipleThreadsEnabled);
  }

  /// addRunLoop:
  void addRunLoop_(NSRunLoop runloop) {
    _objc_msgSend_400(this.pointer, _sel_addRunLoop_, runloop.pointer);
  }

  /// removeRunLoop:
  void removeRunLoop_(NSRunLoop runloop) {
    _objc_msgSend_400(this.pointer, _sel_removeRunLoop_, runloop.pointer);
  }

  /// runInNewThread
  void runInNewThread() {
    _objc_msgSend_11(this.pointer, _sel_runInNewThread);
  }

  /// remoteObjects
  objc.NSArray get remoteObjects {
    final _ret = _objc_msgSend_37(this.pointer, _sel_remoteObjects);
    return objc.NSArray.castFromPointer(_ret, retain: true, release: true);
  }

  /// localObjects
  objc.NSArray get localObjects {
    final _ret = _objc_msgSend_37(this.pointer, _sel_localObjects);
    return objc.NSArray.castFromPointer(_ret, retain: true, release: true);
  }

  /// dispatchWithComponents:
  void dispatchWithComponents_(objc.NSArray components) {
    _objc_msgSend_288(
        this.pointer, _sel_dispatchWithComponents_, components.pointer);
  }

  /// init
  NSConnection init() {
    final _ret = _objc_msgSend_2(this.pointer, _sel_init);
    return NSConnection.castFromPointer(_ret, retain: true, release: true);
  }

  /// new
  static NSConnection new1() {
    final _ret = _objc_msgSend_2(_class_NSConnection, _sel_new);
    return NSConnection.castFromPointer(_ret, retain: false, release: true);
  }

  /// allocWithZone:
  static NSConnection allocWithZone_(ffi.Pointer<_NSZone> zone) {
    final _ret =
        _objc_msgSend_20(_class_NSConnection, _sel_allocWithZone_, zone);
    return NSConnection.castFromPointer(_ret, retain: false, release: true);
  }

  /// alloc
  static NSConnection alloc() {
    final _ret = _objc_msgSend_2(_class_NSConnection, _sel_alloc);
    return NSConnection.castFromPointer(_ret, retain: false, release: true);
  }
}

late final _class_NSConnection = objc.getClass("NSConnection");
late final _sel_statistics = objc.registerName("statistics");
late final _sel_allConnections = objc.registerName("allConnections");
late final _sel_defaultConnection = objc.registerName("defaultConnection");
final _objc_msgSend_381 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_connectionWithRegisteredName_host_ =
    objc.registerName("connectionWithRegisteredName:host:");
final _objc_msgSend_382 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            instancetype Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        instancetype Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>();

/// NSPortNameServer
class NSPortNameServer extends objc.NSObject {
  NSPortNameServer._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release);

  /// Constructs a [NSPortNameServer] that points to the same underlying object as [other].
  NSPortNameServer.castFrom(objc.ObjCObjectBase other)
      : this._(other.pointer, retain: true, release: true);

  /// Constructs a [NSPortNameServer] that wraps the given raw object pointer.
  NSPortNameServer.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [NSPortNameServer].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_0(
        obj.pointer, _sel_isKindOfClass_, _class_NSPortNameServer);
  }

  /// systemDefaultPortNameServer
  static NSPortNameServer systemDefaultPortNameServer() {
    final _ret = _objc_msgSend_383(
        _class_NSPortNameServer, _sel_systemDefaultPortNameServer);
    return NSPortNameServer.castFromPointer(_ret, retain: true, release: true);
  }

  /// portForName:
  NSPort? portForName_(objc.NSString name) {
    final _ret =
        _objc_msgSend_384(this.pointer, _sel_portForName_, name.pointer);
    return _ret.address == 0
        ? null
        : NSPort.castFromPointer(_ret, retain: true, release: true);
  }

  /// portForName:host:
  NSPort? portForName_host_(objc.NSString name, objc.NSString? host) {
    final _ret = _objc_msgSend_385(this.pointer, _sel_portForName_host_,
        name.pointer, host?.pointer ?? ffi.nullptr);
    return _ret.address == 0
        ? null
        : NSPort.castFromPointer(_ret, retain: true, release: true);
  }

  /// registerPort:name:
  bool registerPort_name_(NSPort port, objc.NSString name) {
    return _objc_msgSend_386(
        this.pointer, _sel_registerPort_name_, port.pointer, name.pointer);
  }

  /// removePortForName:
  bool removePortForName_(objc.NSString name) {
    return _objc_msgSend_191(
        this.pointer, _sel_removePortForName_, name.pointer);
  }

  /// init
  NSPortNameServer init() {
    final _ret = _objc_msgSend_2(this.pointer, _sel_init);
    return NSPortNameServer.castFromPointer(_ret, retain: true, release: true);
  }

  /// new
  static NSPortNameServer new1() {
    final _ret = _objc_msgSend_2(_class_NSPortNameServer, _sel_new);
    return NSPortNameServer.castFromPointer(_ret, retain: false, release: true);
  }

  /// allocWithZone:
  static NSPortNameServer allocWithZone_(ffi.Pointer<_NSZone> zone) {
    final _ret =
        _objc_msgSend_20(_class_NSPortNameServer, _sel_allocWithZone_, zone);
    return NSPortNameServer.castFromPointer(_ret, retain: false, release: true);
  }

  /// alloc
  static NSPortNameServer alloc() {
    final _ret = _objc_msgSend_2(_class_NSPortNameServer, _sel_alloc);
    return NSPortNameServer.castFromPointer(_ret, retain: false, release: true);
  }
}

late final _class_NSPortNameServer = objc.getClass("NSPortNameServer");
late final _sel_systemDefaultPortNameServer =
    objc.registerName("systemDefaultPortNameServer");
final _objc_msgSend_383 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_portForName_ = objc.registerName("portForName:");
final _objc_msgSend_384 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<objc.ObjCObject>)>();
late final _sel_portForName_host_ = objc.registerName("portForName:host:");
final _objc_msgSend_385 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>();
late final _sel_registerPort_name_ = objc.registerName("registerPort:name:");
final _objc_msgSend_386 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Bool Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        bool Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>();
late final _sel_removePortForName_ = objc.registerName("removePortForName:");
late final _sel_connectionWithRegisteredName_host_usingNameServer_ =
    objc.registerName("connectionWithRegisteredName:host:usingNameServer:");
final _objc_msgSend_387 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            instancetype Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        instancetype Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>();

/// NSDistantObject
class NSDistantObject extends objc.NSProxy {
  NSDistantObject._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release);

  /// Constructs a [NSDistantObject] that points to the same underlying object as [other].
  NSDistantObject.castFrom(objc.ObjCObjectBase other)
      : this._(other.pointer, retain: true, release: true);

  /// Constructs a [NSDistantObject] that wraps the given raw object pointer.
  NSDistantObject.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [NSDistantObject].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_0(
        obj.pointer, _sel_isKindOfClass_, _class_NSDistantObject);
  }

  /// proxyWithTarget:connection:
  static objc.ObjCObjectBase? proxyWithTarget_connection_(
      objc.ObjCObjectBase target, NSConnection connection) {
    final _ret = _objc_msgSend_388(_class_NSDistantObject,
        _sel_proxyWithTarget_connection_, target.pointer, connection.pointer);
    return _ret.address == 0
        ? null
        : objc.ObjCObjectBase(_ret, retain: true, release: true);
  }

  /// initWithTarget:connection:
  NSDistantObject? initWithTarget_connection_(
      objc.ObjCObjectBase target, NSConnection connection) {
    final _ret = _objc_msgSend_388(this.pointer,
        _sel_initWithTarget_connection_, target.pointer, connection.pointer);
    return _ret.address == 0
        ? null
        : NSDistantObject.castFromPointer(_ret, retain: true, release: true);
  }

  /// proxyWithLocal:connection:
  static objc.ObjCObjectBase proxyWithLocal_connection_(
      objc.ObjCObjectBase target, NSConnection connection) {
    final _ret = _objc_msgSend_389(_class_NSDistantObject,
        _sel_proxyWithLocal_connection_, target.pointer, connection.pointer);
    return objc.ObjCObjectBase(_ret, retain: true, release: true);
  }

  /// initWithLocal:connection:
  NSDistantObject initWithLocal_connection_(
      objc.ObjCObjectBase target, NSConnection connection) {
    final _ret = _objc_msgSend_389(this.pointer, _sel_initWithLocal_connection_,
        target.pointer, connection.pointer);
    return NSDistantObject.castFromPointer(_ret, retain: true, release: true);
  }

  /// initWithCoder:
  NSDistantObject? initWithCoder_(objc.NSCoder inCoder) {
    final _ret =
        _objc_msgSend_45(this.pointer, _sel_initWithCoder_, inCoder.pointer);
    return _ret.address == 0
        ? null
        : NSDistantObject.castFromPointer(_ret, retain: true, release: true);
  }

  /// setProtocolForProxy:
  void setProtocolForProxy_(objc.Protocol? proto) {
    _objc_msgSend_390(
        this.pointer, _sel_setProtocolForProxy_, proto?.pointer ?? ffi.nullptr);
  }

  /// connectionForProxy
  NSConnection get connectionForProxy {
    final _ret = _objc_msgSend_381(this.pointer, _sel_connectionForProxy);
    return NSConnection.castFromPointer(_ret, retain: true, release: true);
  }

  /// alloc
  static objc.ObjCObjectBase alloc() {
    final _ret = _objc_msgSend_2(_class_NSDistantObject, _sel_alloc);
    return objc.ObjCObjectBase(_ret, retain: false, release: true);
  }

  /// respondsToSelector:
  static bool respondsToSelector_(ffi.Pointer<objc.ObjCSelector> aSelector) {
    return _objc_msgSend_391(
        _class_NSDistantObject, _sel_respondsToSelector_, aSelector);
  }
}

late final _class_NSDistantObject = objc.getClass("NSDistantObject");
late final _sel_proxyWithTarget_connection_ =
    objc.registerName("proxyWithTarget:connection:");
final _objc_msgSend_388 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>();
late final _sel_initWithTarget_connection_ =
    objc.registerName("initWithTarget:connection:");
late final _sel_proxyWithLocal_connection_ =
    objc.registerName("proxyWithLocal:connection:");
final _objc_msgSend_389 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>();
late final _sel_initWithLocal_connection_ =
    objc.registerName("initWithLocal:connection:");
late final _sel_setProtocolForProxy_ =
    objc.registerName("setProtocolForProxy:");
final _objc_msgSend_390 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<objc.ObjCObject>)>();
late final _sel_connectionForProxy = objc.registerName("connectionForProxy");
final _objc_msgSend_391 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Bool Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        bool Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_rootProxyForConnectionWithRegisteredName_host_ =
    objc.registerName("rootProxyForConnectionWithRegisteredName:host:");
final _objc_msgSend_392 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>();
late final _sel_rootProxyForConnectionWithRegisteredName_host_usingNameServer_ =
    objc.registerName(
        "rootProxyForConnectionWithRegisteredName:host:usingNameServer:");
final _objc_msgSend_393 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>();
late final _sel_serviceConnectionWithName_rootObject_usingNameServer_ =
    objc.registerName("serviceConnectionWithName:rootObject:usingNameServer:");
final _objc_msgSend_394 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            instancetype Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        instancetype Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>();
late final _sel_serviceConnectionWithName_rootObject_ =
    objc.registerName("serviceConnectionWithName:rootObject:");
final _objc_msgSend_395 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            instancetype Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        instancetype Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>();
late final _sel_requestTimeout = objc.registerName("requestTimeout");
late final _sel_setRequestTimeout_ = objc.registerName("setRequestTimeout:");
late final _sel_replyTimeout = objc.registerName("replyTimeout");
late final _sel_setReplyTimeout_ = objc.registerName("setReplyTimeout:");
late final _sel_rootObject = objc.registerName("rootObject");
late final _sel_setRootObject_ = objc.registerName("setRootObject:");
late final _sel_independentConversationQueueing =
    objc.registerName("independentConversationQueueing");
late final _sel_setIndependentConversationQueueing_ =
    objc.registerName("setIndependentConversationQueueing:");
late final _sel_rootProxy = objc.registerName("rootProxy");
final _objc_msgSend_396 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_addRequestMode_ = objc.registerName("addRequestMode:");
late final _sel_removeRequestMode_ = objc.registerName("removeRequestMode:");
late final _sel_requestModes = objc.registerName("requestModes");
late final _sel_registerName_ = objc.registerName("registerName:");
final _objc_msgSend_397 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Bool Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        bool Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<objc.ObjCObject>)>();
late final _sel_registerName_withNameServer_ =
    objc.registerName("registerName:withNameServer:");
final _objc_msgSend_398 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Bool Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        bool Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>();
late final _sel_connectionWithReceivePort_sendPort_ =
    objc.registerName("connectionWithReceivePort:sendPort:");
final _objc_msgSend_399 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            instancetype Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        instancetype Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>();
late final _sel_currentConversation = objc.registerName("currentConversation");
late final _sel_initWithReceivePort_sendPort_ =
    objc.registerName("initWithReceivePort:sendPort:");
late final _sel_sendPort = objc.registerName("sendPort");
late final _sel_receivePort = objc.registerName("receivePort");
late final _sel_enableMultipleThreads =
    objc.registerName("enableMultipleThreads");
late final _sel_multipleThreadsEnabled =
    objc.registerName("multipleThreadsEnabled");
late final _sel_addRunLoop_ = objc.registerName("addRunLoop:");
final _objc_msgSend_400 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<objc.ObjCObject>)>();
late final _sel_removeRunLoop_ = objc.registerName("removeRunLoop:");
late final _sel_runInNewThread = objc.registerName("runInNewThread");
late final _sel_remoteObjects = objc.registerName("remoteObjects");
late final _sel_localObjects = objc.registerName("localObjects");
late final _sel_dispatchWithComponents_ =
    objc.registerName("dispatchWithComponents:");
late final _sel_addConnection_toRunLoop_forMode_ =
    objc.registerName("addConnection:toRunLoop:forMode:");
final _objc_msgSend_401 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        void Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>();
late final _sel_removeConnection_fromRunLoop_forMode_ =
    objc.registerName("removeConnection:fromRunLoop:forMode:");
late final _sel_addPort_forMode_ = objc.registerName("addPort:forMode:");
final _objc_msgSend_402 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        void Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>();
late final _sel_removePort_forMode_ = objc.registerName("removePort:forMode:");
late final _sel_limitDateForMode_ = objc.registerName("limitDateForMode:");
final _objc_msgSend_403 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<objc.ObjCObject>)>();
late final _sel_acceptInputForMode_beforeDate_ =
    objc.registerName("acceptInputForMode:beforeDate:");
final _objc_msgSend_404 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        void Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>();

enum NSStreamStatus {
  NSStreamStatusNotOpen(0),
  NSStreamStatusOpening(1),
  NSStreamStatusOpen(2),
  NSStreamStatusReading(3),
  NSStreamStatusWriting(4),
  NSStreamStatusAtEnd(5),
  NSStreamStatusClosed(6),
  NSStreamStatusError(7);

  final int value;
  const NSStreamStatus(this.value);

  static NSStreamStatus fromValue(int value) => switch (value) {
        0 => NSStreamStatusNotOpen,
        1 => NSStreamStatusOpening,
        2 => NSStreamStatusOpen,
        3 => NSStreamStatusReading,
        4 => NSStreamStatusWriting,
        5 => NSStreamStatusAtEnd,
        6 => NSStreamStatusClosed,
        7 => NSStreamStatusError,
        _ => throw ArgumentError("Unknown value for NSStreamStatus: $value"),
      };
}

late final _sel_streamStatus = objc.registerName("streamStatus");
final _objc_msgSend_405 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.UnsignedLong Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        int Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_streamError = objc.registerName("streamError");
final _objc_msgSend_406 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();

/// NSOutputStream
class NSOutputStream extends NSStream {
  NSOutputStream._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release);

  /// Constructs a [NSOutputStream] that points to the same underlying object as [other].
  NSOutputStream.castFrom(objc.ObjCObjectBase other)
      : this._(other.pointer, retain: true, release: true);

  /// Constructs a [NSOutputStream] that wraps the given raw object pointer.
  NSOutputStream.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [NSOutputStream].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_0(
        obj.pointer, _sel_isKindOfClass_, _class_NSOutputStream);
  }

  /// write:maxLength:
  int write_maxLength_(ffi.Pointer<ffi.Uint8> buffer, int len) {
    return _objc_msgSend_363(this.pointer, _sel_write_maxLength_, buffer, len);
  }

  /// hasSpaceAvailable
  bool get hasSpaceAvailable {
    return _objc_msgSend_13(this.pointer, _sel_hasSpaceAvailable);
  }

  /// initToMemory
  NSOutputStream initToMemory() {
    final _ret = _objc_msgSend_2(this.pointer, _sel_initToMemory);
    return NSOutputStream.castFromPointer(_ret, retain: true, release: true);
  }

  /// initToBuffer:capacity:
  NSOutputStream initToBuffer_capacity_(
      ffi.Pointer<ffi.Uint8> buffer, int capacity) {
    final _ret = _objc_msgSend_407(
        this.pointer, _sel_initToBuffer_capacity_, buffer, capacity);
    return NSOutputStream.castFromPointer(_ret, retain: true, release: true);
  }

  /// initWithURL:append:
  NSOutputStream? initWithURL_append_(objc.NSURL url, bool shouldAppend) {
    final _ret = _objc_msgSend_408(
        this.pointer, _sel_initWithURL_append_, url.pointer, shouldAppend);
    return _ret.address == 0
        ? null
        : NSOutputStream.castFromPointer(_ret, retain: true, release: true);
  }

  /// init
  NSOutputStream init() {
    final _ret = _objc_msgSend_2(this.pointer, _sel_init);
    return NSOutputStream.castFromPointer(_ret, retain: true, release: true);
  }

  /// new
  static NSOutputStream new1() {
    final _ret = _objc_msgSend_2(_class_NSOutputStream, _sel_new);
    return NSOutputStream.castFromPointer(_ret, retain: false, release: true);
  }

  /// allocWithZone:
  static NSOutputStream allocWithZone_(ffi.Pointer<_NSZone> zone) {
    final _ret =
        _objc_msgSend_20(_class_NSOutputStream, _sel_allocWithZone_, zone);
    return NSOutputStream.castFromPointer(_ret, retain: false, release: true);
  }

  /// alloc
  static NSOutputStream alloc() {
    final _ret = _objc_msgSend_2(_class_NSOutputStream, _sel_alloc);
    return NSOutputStream.castFromPointer(_ret, retain: false, release: true);
  }
}

late final _class_NSOutputStream = objc.getClass("NSOutputStream");
late final _sel_write_maxLength_ = objc.registerName("write:maxLength:");
late final _sel_hasSpaceAvailable = objc.registerName("hasSpaceAvailable");
late final _sel_initToMemory = objc.registerName("initToMemory");
late final _sel_initToBuffer_capacity_ =
    objc.registerName("initToBuffer:capacity:");
final _objc_msgSend_407 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            instancetype Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<ffi.Uint8>,
                ffi.UnsignedLong)>>()
    .asFunction<
        instancetype Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<ffi.Uint8>, int)>();
late final _sel_initWithURL_append_ = objc.registerName("initWithURL:append:");
final _objc_msgSend_408 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            instancetype Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Bool)>>()
    .asFunction<
        instancetype Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            bool)>();
late final _sel_getContinuationStreamsWithCompletionHandler_ =
    objc.registerName("getContinuationStreamsWithCompletionHandler:");
final _objc_msgSend_409 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<objc.ObjCBlock>)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<objc.ObjCBlock>)>();
late final _sel_isEligibleForHandoff =
    objc.registerName("isEligibleForHandoff");
late final _sel_setEligibleForHandoff_ =
    objc.registerName("setEligibleForHandoff:");
late final _sel_isEligibleForSearch = objc.registerName("isEligibleForSearch");
late final _sel_setEligibleForSearch_ =
    objc.registerName("setEligibleForSearch:");
late final _sel_isEligibleForPublicIndexing =
    objc.registerName("isEligibleForPublicIndexing");
late final _sel_setEligibleForPublicIndexing_ =
    objc.registerName("setEligibleForPublicIndexing:");
late final _sel_isEligibleForPrediction =
    objc.registerName("isEligibleForPrediction");
late final _sel_setEligibleForPrediction_ =
    objc.registerName("setEligibleForPrediction:");
late final _sel_persistentIdentifier =
    objc.registerName("persistentIdentifier");
late final _sel_setPersistentIdentifier_ =
    objc.registerName("setPersistentIdentifier:");
late final _sel_deleteSavedUserActivitiesWithPersistentIdentifiers_completionHandler_ =
    objc.registerName(
        "deleteSavedUserActivitiesWithPersistentIdentifiers:completionHandler:");
final _objc_msgSend_410 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCBlock>)>>()
    .asFunction<
        void Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCBlock>)>();
late final _sel_deleteAllSavedUserActivitiesWithCompletionHandler_ =
    objc.registerName("deleteAllSavedUserActivitiesWithCompletionHandler:");
void _ObjCBlock_ffiVoid_NSArray_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlock> block, ffi.Pointer<objc.ObjCObject> arg0) =>
    block.ref.target
        .cast<
            ffi.NativeFunction<
                ffi.Void Function(ffi.Pointer<objc.ObjCObject> arg0)>>()
        .asFunction<void Function(ffi.Pointer<objc.ObjCObject>)>()(arg0);
void _ObjCBlock_ffiVoid_NSArray_closureTrampoline(
        ffi.Pointer<objc.ObjCBlock> block, ffi.Pointer<objc.ObjCObject> arg0) =>
    (objc.getBlockClosure(block) as void Function(
        ffi.Pointer<objc.ObjCObject>))(arg0);

class ObjCBlock_ffiVoid_NSArray extends objc.ObjCBlockBase {
  ObjCBlock_ffiVoid_NSArray._(ffi.Pointer<objc.ObjCBlock> pointer,
      {bool retain = false, bool release = true})
      : super(pointer, retain: retain, release: release);

  /// Returns a block that wraps the given raw block pointer.
  static ObjCBlock_ffiVoid_NSArray castFromPointer(
      ffi.Pointer<objc.ObjCBlock> pointer,
      {bool retain = false,
      bool release = false}) {
    return ObjCBlock_ffiVoid_NSArray._(pointer,
        retain: retain, release: release);
  }

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ObjCBlock_ffiVoid_NSArray.fromFunctionPointer(
      ffi.Pointer<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<objc.ObjCObject> arg0)>>
          ptr)
      : this._(objc.newPointerBlock(
            _cFuncTrampoline ??= ffi.Pointer.fromFunction<
                        ffi.Void Function(ffi.Pointer<objc.ObjCBlock>,
                            ffi.Pointer<objc.ObjCObject>)>(
                    _ObjCBlock_ffiVoid_NSArray_fnPtrTrampoline)
                .cast(),
            ptr.cast()));
  static ffi.Pointer<ffi.Void>? _cFuncTrampoline;

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ObjCBlock_ffiVoid_NSArray.fromFunction(void Function(objc.NSArray) fn)
      : this._(objc.newClosureBlock(
            _dartFuncTrampoline ??= ffi.Pointer.fromFunction<
                        ffi.Void Function(ffi.Pointer<objc.ObjCBlock>,
                            ffi.Pointer<objc.ObjCObject>)>(
                    _ObjCBlock_ffiVoid_NSArray_closureTrampoline)
                .cast(),
            (ffi.Pointer<objc.ObjCObject> arg0) => fn(
                objc.NSArray.castFromPointer(arg0,
                    retain: true, release: true))));
  static ffi.Pointer<ffi.Void>? _dartFuncTrampoline;

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// Note that unlike the default behavior of NativeCallable.listener, listener
  /// blocks do not keep the isolate alive.
  ObjCBlock_ffiVoid_NSArray.listener(void Function(objc.NSArray) fn)
      : this._(wrapListenerBlock_ObjCBlock_ffiVoid_NSArray(objc.newClosureBlock(
            (_dartFuncListenerTrampoline ??= ffi.NativeCallable<
                        ffi.Void Function(ffi.Pointer<objc.ObjCBlock>,
                            ffi.Pointer<objc.ObjCObject>)>.listener(
                    _ObjCBlock_ffiVoid_NSArray_closureTrampoline)
                  ..keepIsolateAlive = false)
                .nativeFunction
                .cast(),
            (ffi.Pointer<objc.ObjCObject> arg0) => fn(
                objc.NSArray.castFromPointer(arg0,
                    retain: false, release: true)))));
  static ffi.NativeCallable<
          ffi.Void Function(
              ffi.Pointer<objc.ObjCBlock>, ffi.Pointer<objc.ObjCObject>)>?
      _dartFuncListenerTrampoline;

  void call(objc.NSArray arg0) => pointer.ref.invoke
      .cast<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<objc.ObjCBlock> block,
                  ffi.Pointer<objc.ObjCObject> arg0)>>()
      .asFunction<
          void Function(ffi.Pointer<objc.ObjCBlock>,
              ffi.Pointer<objc.ObjCObject>)>()(pointer, arg0.pointer);
}

late final _sel_application_continueUserActivity_restorationHandler_ =
    objc.registerName("application:continueUserActivity:restorationHandler:");
bool
    _ObjCBlock_bool_ffiVoid_NSApplication_NSUserActivity_ffiVoidNSArray_fnPtrTrampoline(
            ffi.Pointer<objc.ObjCBlock> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObject> arg1,
            ffi.Pointer<objc.ObjCObject> arg2,
            ffi.Pointer<objc.ObjCBlock> arg3) =>
        block.ref.target
            .cast<
                ffi.NativeFunction<
                    ffi.Bool Function(
                        ffi.Pointer<ffi.Void> arg0,
                        ffi.Pointer<objc.ObjCObject> arg1,
                        ffi.Pointer<objc.ObjCObject> arg2,
                        ffi.Pointer<objc.ObjCBlock> arg3)>>()
            .asFunction<
                bool Function(
                    ffi.Pointer<ffi.Void>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCBlock>)>()(arg0, arg1, arg2, arg3);
bool
    _ObjCBlock_bool_ffiVoid_NSApplication_NSUserActivity_ffiVoidNSArray_closureTrampoline(
            ffi.Pointer<objc.ObjCBlock> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObject> arg1,
            ffi.Pointer<objc.ObjCObject> arg2,
            ffi.Pointer<objc.ObjCBlock> arg3) =>
        (objc.getBlockClosure(block) as bool Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCBlock>))(arg0, arg1, arg2, arg3);

class ObjCBlock_bool_ffiVoid_NSApplication_NSUserActivity_ffiVoidNSArray
    extends objc.ObjCBlockBase {
  ObjCBlock_bool_ffiVoid_NSApplication_NSUserActivity_ffiVoidNSArray._(
      ffi.Pointer<objc.ObjCBlock> pointer,
      {bool retain = false,
      bool release = true})
      : super(pointer, retain: retain, release: release);

  /// Returns a block that wraps the given raw block pointer.
  static ObjCBlock_bool_ffiVoid_NSApplication_NSUserActivity_ffiVoidNSArray
      castFromPointer(ffi.Pointer<objc.ObjCBlock> pointer,
          {bool retain = false, bool release = false}) {
    return ObjCBlock_bool_ffiVoid_NSApplication_NSUserActivity_ffiVoidNSArray._(
        pointer,
        retain: retain,
        release: release);
  }

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ObjCBlock_bool_ffiVoid_NSApplication_NSUserActivity_ffiVoidNSArray.fromFunctionPointer(
      ffi.Pointer<
              ffi.NativeFunction<
                  ffi.Bool Function(
                      ffi.Pointer<ffi.Void> arg0,
                      ffi.Pointer<objc.ObjCObject> arg1,
                      ffi.Pointer<objc.ObjCObject> arg2,
                      ffi.Pointer<objc.ObjCBlock> arg3)>>
          ptr)
      : this._(objc.newPointerBlock(
            _cFuncTrampoline ??= ffi.Pointer.fromFunction<
                        ffi.Bool Function(
                            ffi.Pointer<objc.ObjCBlock>,
                            ffi.Pointer<ffi.Void>,
                            ffi.Pointer<objc.ObjCObject>,
                            ffi.Pointer<objc.ObjCObject>,
                            ffi.Pointer<objc.ObjCBlock>)>(
                    _ObjCBlock_bool_ffiVoid_NSApplication_NSUserActivity_ffiVoidNSArray_fnPtrTrampoline,
                    false)
                .cast(),
            ptr.cast()));
  static ffi.Pointer<ffi.Void>? _cFuncTrampoline;

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ObjCBlock_bool_ffiVoid_NSApplication_NSUserActivity_ffiVoidNSArray.fromFunction(bool Function(ffi.Pointer<ffi.Void>, NSApplication, NSUserActivity, ObjCBlock_ffiVoid_NSArray) fn)
      : this._(objc.newClosureBlock(
            _dartFuncTrampoline ??= ffi.Pointer.fromFunction<
                        ffi.Bool Function(
                            ffi.Pointer<objc.ObjCBlock>,
                            ffi.Pointer<ffi.Void>,
                            ffi.Pointer<objc.ObjCObject>,
                            ffi.Pointer<objc.ObjCObject>,
                            ffi.Pointer<objc.ObjCBlock>)>(
                    _ObjCBlock_bool_ffiVoid_NSApplication_NSUserActivity_ffiVoidNSArray_closureTrampoline, false)
                .cast(),
            (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1, ffi.Pointer<objc.ObjCObject> arg2, ffi.Pointer<objc.ObjCBlock> arg3) => fn(
                arg0,
                NSApplication.castFromPointer(arg1, retain: true, release: true),
                NSUserActivity.castFromPointer(arg2, retain: true, release: true),
                ObjCBlock_ffiVoid_NSArray.castFromPointer(arg3, retain: true, release: true))));
  static ffi.Pointer<ffi.Void>? _dartFuncTrampoline;

  bool call(ffi.Pointer<ffi.Void> arg0, NSApplication arg1, NSUserActivity arg2,
          ObjCBlock_ffiVoid_NSArray arg3) =>
      pointer.ref.invoke
              .cast<
                  ffi.NativeFunction<
                      ffi.Bool Function(
                          ffi.Pointer<objc.ObjCBlock> block,
                          ffi.Pointer<ffi.Void> arg0,
                          ffi.Pointer<objc.ObjCObject> arg1,
                          ffi.Pointer<objc.ObjCObject> arg2,
                          ffi.Pointer<objc.ObjCBlock> arg3)>>()
              .asFunction<
                  bool Function(
                      ffi.Pointer<objc.ObjCBlock>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<objc.ObjCObject>,
                      ffi.Pointer<objc.ObjCObject>,
                      ffi.Pointer<objc.ObjCBlock>)>()(
          pointer, arg0, arg1.pointer, arg2.pointer, arg3.pointer);
}

late final _sel_application_didFailToContinueUserActivityWithType_error_ = objc
    .registerName("application:didFailToContinueUserActivityWithType:error:");
void _ObjCBlock_ffiVoid_ffiVoid_NSApplication_NSString_NSError_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlock> block,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1,
        ffi.Pointer<objc.ObjCObject> arg2,
        ffi.Pointer<objc.ObjCObject> arg3) =>
    block.ref.target
        .cast<
            ffi.NativeFunction<
                ffi.Void Function(
                    ffi.Pointer<ffi.Void> arg0,
                    ffi.Pointer<objc.ObjCObject> arg1,
                    ffi.Pointer<objc.ObjCObject> arg2,
                    ffi.Pointer<objc.ObjCObject> arg3)>>()
        .asFunction<
            void Function(
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>()(arg0, arg1, arg2, arg3);
void
    _ObjCBlock_ffiVoid_ffiVoid_NSApplication_NSString_NSError_closureTrampoline(
            ffi.Pointer<objc.ObjCBlock> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObject> arg1,
            ffi.Pointer<objc.ObjCObject> arg2,
            ffi.Pointer<objc.ObjCObject> arg3) =>
        (objc.getBlockClosure(block) as void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>))(arg0, arg1, arg2, arg3);

class ObjCBlock_ffiVoid_ffiVoid_NSApplication_NSString_NSError
    extends objc.ObjCBlockBase {
  ObjCBlock_ffiVoid_ffiVoid_NSApplication_NSString_NSError._(
      ffi.Pointer<objc.ObjCBlock> pointer,
      {bool retain = false,
      bool release = true})
      : super(pointer, retain: retain, release: release);

  /// Returns a block that wraps the given raw block pointer.
  static ObjCBlock_ffiVoid_ffiVoid_NSApplication_NSString_NSError
      castFromPointer(ffi.Pointer<objc.ObjCBlock> pointer,
          {bool retain = false, bool release = false}) {
    return ObjCBlock_ffiVoid_ffiVoid_NSApplication_NSString_NSError._(pointer,
        retain: retain, release: release);
  }

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ObjCBlock_ffiVoid_ffiVoid_NSApplication_NSString_NSError.fromFunctionPointer(
      ffi.Pointer<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void> arg0,
                      ffi.Pointer<objc.ObjCObject> arg1,
                      ffi.Pointer<objc.ObjCObject> arg2,
                      ffi.Pointer<objc.ObjCObject> arg3)>>
          ptr)
      : this._(objc.newPointerBlock(
            _cFuncTrampoline ??= ffi.Pointer.fromFunction<
                        ffi.Void Function(
                            ffi.Pointer<objc.ObjCBlock>,
                            ffi.Pointer<ffi.Void>,
                            ffi.Pointer<objc.ObjCObject>,
                            ffi.Pointer<objc.ObjCObject>,
                            ffi.Pointer<objc.ObjCObject>)>(
                    _ObjCBlock_ffiVoid_ffiVoid_NSApplication_NSString_NSError_fnPtrTrampoline)
                .cast(),
            ptr.cast()));
  static ffi.Pointer<ffi.Void>? _cFuncTrampoline;

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ObjCBlock_ffiVoid_ffiVoid_NSApplication_NSString_NSError.fromFunction(void Function(ffi.Pointer<ffi.Void>, NSApplication, objc.NSString, objc.NSError) fn)
      : this._(objc.newClosureBlock(
            _dartFuncTrampoline ??= ffi.Pointer.fromFunction<
                        ffi.Void Function(
                            ffi.Pointer<objc.ObjCBlock>,
                            ffi.Pointer<ffi.Void>,
                            ffi.Pointer<objc.ObjCObject>,
                            ffi.Pointer<objc.ObjCObject>,
                            ffi.Pointer<objc.ObjCObject>)>(
                    _ObjCBlock_ffiVoid_ffiVoid_NSApplication_NSString_NSError_closureTrampoline)
                .cast(),
            (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1, ffi.Pointer<objc.ObjCObject> arg2, ffi.Pointer<objc.ObjCObject> arg3) => fn(
                arg0,
                NSApplication.castFromPointer(arg1, retain: true, release: true),
                objc.NSString.castFromPointer(arg2, retain: true, release: true),
                objc.NSError.castFromPointer(arg3, retain: true, release: true))));
  static ffi.Pointer<ffi.Void>? _dartFuncTrampoline;

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// Note that unlike the default behavior of NativeCallable.listener, listener
  /// blocks do not keep the isolate alive.
  ObjCBlock_ffiVoid_ffiVoid_NSApplication_NSString_NSError.listener(
      void Function(
              ffi.Pointer<ffi.Void>, NSApplication, objc.NSString, objc.NSError)
          fn)
      : this._(wrapListenerBlock_ObjCBlock_ffiVoid_ffiVoid_NSApplication_NSString_NSError(objc.newClosureBlock(
            (_dartFuncListenerTrampoline ??=
                    ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlock>, ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCObject>)>.listener(_ObjCBlock_ffiVoid_ffiVoid_NSApplication_NSString_NSError_closureTrampoline)
                      ..keepIsolateAlive = false)
                .nativeFunction
                .cast(),
            (ffi.Pointer<ffi.Void> arg0,
                    ffi.Pointer<objc.ObjCObject> arg1,
                    ffi.Pointer<objc.ObjCObject> arg2,
                    ffi.Pointer<objc.ObjCObject> arg3) =>
                fn(
                    arg0,
                    NSApplication.castFromPointer(arg1, retain: false, release: true),
                    objc.NSString.castFromPointer(arg2, retain: false, release: true),
                    objc.NSError.castFromPointer(arg3, retain: false, release: true)))));
  static ffi.NativeCallable<
      ffi.Void Function(
          ffi.Pointer<objc.ObjCBlock>,
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCObject>)>? _dartFuncListenerTrampoline;

  void call(ffi.Pointer<ffi.Void> arg0, NSApplication arg1, objc.NSString arg2,
          objc.NSError arg3) =>
      pointer.ref.invoke
              .cast<
                  ffi.NativeFunction<
                      ffi.Void Function(
                          ffi.Pointer<objc.ObjCBlock> block,
                          ffi.Pointer<ffi.Void> arg0,
                          ffi.Pointer<objc.ObjCObject> arg1,
                          ffi.Pointer<objc.ObjCObject> arg2,
                          ffi.Pointer<objc.ObjCObject> arg3)>>()
              .asFunction<
                  void Function(
                      ffi.Pointer<objc.ObjCBlock>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<objc.ObjCObject>,
                      ffi.Pointer<objc.ObjCObject>,
                      ffi.Pointer<objc.ObjCObject>)>()(
          pointer, arg0, arg1.pointer, arg2.pointer, arg3.pointer);
}

late final _sel_application_didUpdateUserActivity_ =
    objc.registerName("application:didUpdateUserActivity:");
void _ObjCBlock_ffiVoid_ffiVoid_NSApplication_NSUserActivity_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlock> block,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1,
        ffi.Pointer<objc.ObjCObject> arg2) =>
    block.ref.target
        .cast<
            ffi.NativeFunction<
                ffi.Void Function(
                    ffi.Pointer<ffi.Void> arg0,
                    ffi.Pointer<objc.ObjCObject> arg1,
                    ffi.Pointer<objc.ObjCObject> arg2)>>()
        .asFunction<
            void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>()(arg0, arg1, arg2);
void _ObjCBlock_ffiVoid_ffiVoid_NSApplication_NSUserActivity_closureTrampoline(
        ffi.Pointer<objc.ObjCBlock> block,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1,
        ffi.Pointer<objc.ObjCObject> arg2) =>
    (objc.getBlockClosure(block) as void Function(
        ffi.Pointer<ffi.Void>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>))(arg0, arg1, arg2);

class ObjCBlock_ffiVoid_ffiVoid_NSApplication_NSUserActivity
    extends objc.ObjCBlockBase {
  ObjCBlock_ffiVoid_ffiVoid_NSApplication_NSUserActivity._(
      ffi.Pointer<objc.ObjCBlock> pointer,
      {bool retain = false,
      bool release = true})
      : super(pointer, retain: retain, release: release);

  /// Returns a block that wraps the given raw block pointer.
  static ObjCBlock_ffiVoid_ffiVoid_NSApplication_NSUserActivity castFromPointer(
      ffi.Pointer<objc.ObjCBlock> pointer,
      {bool retain = false,
      bool release = false}) {
    return ObjCBlock_ffiVoid_ffiVoid_NSApplication_NSUserActivity._(pointer,
        retain: retain, release: release);
  }

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ObjCBlock_ffiVoid_ffiVoid_NSApplication_NSUserActivity.fromFunctionPointer(
      ffi.Pointer<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void> arg0,
                      ffi.Pointer<objc.ObjCObject> arg1,
                      ffi.Pointer<objc.ObjCObject> arg2)>>
          ptr)
      : this._(objc.newPointerBlock(
            _cFuncTrampoline ??= ffi.Pointer.fromFunction<
                        ffi.Void Function(
                            ffi.Pointer<objc.ObjCBlock>,
                            ffi.Pointer<ffi.Void>,
                            ffi.Pointer<objc.ObjCObject>,
                            ffi.Pointer<objc.ObjCObject>)>(
                    _ObjCBlock_ffiVoid_ffiVoid_NSApplication_NSUserActivity_fnPtrTrampoline)
                .cast(),
            ptr.cast()));
  static ffi.Pointer<ffi.Void>? _cFuncTrampoline;

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ObjCBlock_ffiVoid_ffiVoid_NSApplication_NSUserActivity.fromFunction(
      void Function(ffi.Pointer<ffi.Void>, NSApplication, NSUserActivity) fn)
      : this._(objc.newClosureBlock(
            _dartFuncTrampoline ??= ffi.Pointer.fromFunction<
                        ffi.Void Function(
                            ffi.Pointer<objc.ObjCBlock>,
                            ffi.Pointer<ffi.Void>,
                            ffi.Pointer<objc.ObjCObject>,
                            ffi.Pointer<objc.ObjCObject>)>(
                    _ObjCBlock_ffiVoid_ffiVoid_NSApplication_NSUserActivity_closureTrampoline)
                .cast(),
            (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1, ffi.Pointer<objc.ObjCObject> arg2) => fn(
                arg0,
                NSApplication.castFromPointer(arg1, retain: true, release: true),
                NSUserActivity.castFromPointer(arg2, retain: true, release: true))));
  static ffi.Pointer<ffi.Void>? _dartFuncTrampoline;

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// Note that unlike the default behavior of NativeCallable.listener, listener
  /// blocks do not keep the isolate alive.
  ObjCBlock_ffiVoid_ffiVoid_NSApplication_NSUserActivity.listener(
      void Function(ffi.Pointer<ffi.Void>, NSApplication, NSUserActivity) fn)
      : this._(wrapListenerBlock_ObjCBlock_ffiVoid_ffiVoid_NSApplication_NSUserActivity(objc.newClosureBlock(
            (_dartFuncListenerTrampoline ??= ffi.NativeCallable<
                        ffi.Void Function(
                            ffi.Pointer<objc.ObjCBlock>,
                            ffi.Pointer<ffi.Void>,
                            ffi.Pointer<objc.ObjCObject>,
                            ffi.Pointer<objc.ObjCObject>)>.listener(
                    _ObjCBlock_ffiVoid_ffiVoid_NSApplication_NSUserActivity_closureTrampoline)
                  ..keepIsolateAlive = false)
                .nativeFunction
                .cast(),
            (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1,
                    ffi.Pointer<objc.ObjCObject> arg2) =>
                fn(arg0, NSApplication.castFromPointer(arg1, retain: false, release: true), NSUserActivity.castFromPointer(arg2, retain: false, release: true)))));
  static ffi.NativeCallable<
      ffi.Void Function(
          ffi.Pointer<objc.ObjCBlock>,
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCObject>)>? _dartFuncListenerTrampoline;

  void call(ffi.Pointer<ffi.Void> arg0, NSApplication arg1,
          NSUserActivity arg2) =>
      pointer.ref.invoke
              .cast<
                  ffi.NativeFunction<
                      ffi.Void Function(
                          ffi.Pointer<objc.ObjCBlock> block,
                          ffi.Pointer<ffi.Void> arg0,
                          ffi.Pointer<objc.ObjCObject> arg1,
                          ffi.Pointer<objc.ObjCObject> arg2)>>()
              .asFunction<
                  void Function(
                      ffi.Pointer<objc.ObjCBlock>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<objc.ObjCObject>,
                      ffi.Pointer<objc.ObjCObject>)>()(
          pointer, arg0, arg1.pointer, arg2.pointer);
}

/// CKShareMetadata
class CKShareMetadata extends objc.ObjCObjectBase {
  CKShareMetadata._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super(pointer, retain: retain, release: release);

  /// Constructs a [CKShareMetadata] that points to the same underlying object as [other].
  CKShareMetadata.castFrom(objc.ObjCObjectBase other)
      : this._(other.pointer, retain: true, release: true);

  /// Constructs a [CKShareMetadata] that wraps the given raw object pointer.
  CKShareMetadata.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [CKShareMetadata].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_0(
        obj.pointer, _sel_isKindOfClass_, _class_CKShareMetadata);
  }
}

late final _class_CKShareMetadata = objc.getClass("CKShareMetadata");
late final _sel_application_userDidAcceptCloudKitShareWithMetadata_ =
    objc.registerName("application:userDidAcceptCloudKitShareWithMetadata:");
void _ObjCBlock_ffiVoid_ffiVoid_NSApplication_CKShareMetadata_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlock> block,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1,
        ffi.Pointer<objc.ObjCObject> arg2) =>
    block.ref.target
        .cast<
            ffi.NativeFunction<
                ffi.Void Function(
                    ffi.Pointer<ffi.Void> arg0,
                    ffi.Pointer<objc.ObjCObject> arg1,
                    ffi.Pointer<objc.ObjCObject> arg2)>>()
        .asFunction<
            void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>()(arg0, arg1, arg2);
void _ObjCBlock_ffiVoid_ffiVoid_NSApplication_CKShareMetadata_closureTrampoline(
        ffi.Pointer<objc.ObjCBlock> block,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1,
        ffi.Pointer<objc.ObjCObject> arg2) =>
    (objc.getBlockClosure(block) as void Function(
        ffi.Pointer<ffi.Void>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>))(arg0, arg1, arg2);

class ObjCBlock_ffiVoid_ffiVoid_NSApplication_CKShareMetadata
    extends objc.ObjCBlockBase {
  ObjCBlock_ffiVoid_ffiVoid_NSApplication_CKShareMetadata._(
      ffi.Pointer<objc.ObjCBlock> pointer,
      {bool retain = false,
      bool release = true})
      : super(pointer, retain: retain, release: release);

  /// Returns a block that wraps the given raw block pointer.
  static ObjCBlock_ffiVoid_ffiVoid_NSApplication_CKShareMetadata
      castFromPointer(ffi.Pointer<objc.ObjCBlock> pointer,
          {bool retain = false, bool release = false}) {
    return ObjCBlock_ffiVoid_ffiVoid_NSApplication_CKShareMetadata._(pointer,
        retain: retain, release: release);
  }

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ObjCBlock_ffiVoid_ffiVoid_NSApplication_CKShareMetadata.fromFunctionPointer(
      ffi.Pointer<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void> arg0,
                      ffi.Pointer<objc.ObjCObject> arg1,
                      ffi.Pointer<objc.ObjCObject> arg2)>>
          ptr)
      : this._(objc.newPointerBlock(
            _cFuncTrampoline ??= ffi.Pointer.fromFunction<
                        ffi.Void Function(
                            ffi.Pointer<objc.ObjCBlock>,
                            ffi.Pointer<ffi.Void>,
                            ffi.Pointer<objc.ObjCObject>,
                            ffi.Pointer<objc.ObjCObject>)>(
                    _ObjCBlock_ffiVoid_ffiVoid_NSApplication_CKShareMetadata_fnPtrTrampoline)
                .cast(),
            ptr.cast()));
  static ffi.Pointer<ffi.Void>? _cFuncTrampoline;

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ObjCBlock_ffiVoid_ffiVoid_NSApplication_CKShareMetadata.fromFunction(
      void Function(ffi.Pointer<ffi.Void>, NSApplication, CKShareMetadata) fn)
      : this._(objc.newClosureBlock(
            _dartFuncTrampoline ??= ffi.Pointer.fromFunction<
                        ffi.Void Function(
                            ffi.Pointer<objc.ObjCBlock>,
                            ffi.Pointer<ffi.Void>,
                            ffi.Pointer<objc.ObjCObject>,
                            ffi.Pointer<objc.ObjCObject>)>(
                    _ObjCBlock_ffiVoid_ffiVoid_NSApplication_CKShareMetadata_closureTrampoline)
                .cast(),
            (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1, ffi.Pointer<objc.ObjCObject> arg2) => fn(
                arg0,
                NSApplication.castFromPointer(arg1, retain: true, release: true),
                CKShareMetadata.castFromPointer(arg2, retain: true, release: true))));
  static ffi.Pointer<ffi.Void>? _dartFuncTrampoline;

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// Note that unlike the default behavior of NativeCallable.listener, listener
  /// blocks do not keep the isolate alive.
  ObjCBlock_ffiVoid_ffiVoid_NSApplication_CKShareMetadata.listener(
      void Function(ffi.Pointer<ffi.Void>, NSApplication, CKShareMetadata) fn)
      : this._(wrapListenerBlock_ObjCBlock_ffiVoid_ffiVoid_NSApplication_CKShareMetadata(objc.newClosureBlock(
            (_dartFuncListenerTrampoline ??= ffi.NativeCallable<
                        ffi.Void Function(
                            ffi.Pointer<objc.ObjCBlock>,
                            ffi.Pointer<ffi.Void>,
                            ffi.Pointer<objc.ObjCObject>,
                            ffi.Pointer<objc.ObjCObject>)>.listener(
                    _ObjCBlock_ffiVoid_ffiVoid_NSApplication_CKShareMetadata_closureTrampoline)
                  ..keepIsolateAlive = false)
                .nativeFunction
                .cast(),
            (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1,
                    ffi.Pointer<objc.ObjCObject> arg2) =>
                fn(arg0, NSApplication.castFromPointer(arg1, retain: false, release: true), CKShareMetadata.castFromPointer(arg2, retain: false, release: true)))));
  static ffi.NativeCallable<
      ffi.Void Function(
          ffi.Pointer<objc.ObjCBlock>,
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCObject>)>? _dartFuncListenerTrampoline;

  void call(ffi.Pointer<ffi.Void> arg0, NSApplication arg1,
          CKShareMetadata arg2) =>
      pointer.ref.invoke
              .cast<
                  ffi.NativeFunction<
                      ffi.Void Function(
                          ffi.Pointer<objc.ObjCBlock> block,
                          ffi.Pointer<ffi.Void> arg0,
                          ffi.Pointer<objc.ObjCObject> arg1,
                          ffi.Pointer<objc.ObjCObject> arg2)>>()
              .asFunction<
                  void Function(
                      ffi.Pointer<objc.ObjCBlock>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<objc.ObjCObject>,
                      ffi.Pointer<objc.ObjCObject>)>()(
          pointer, arg0, arg1.pointer, arg2.pointer);
}

late final _sel_application_delegateHandlesKey_ =
    objc.registerName("application:delegateHandlesKey:");
late final _sel_applicationShouldAutomaticallyLocalizeKeyEquivalents_ =
    objc.registerName("applicationShouldAutomaticallyLocalizeKeyEquivalents:");
late final _sel_applicationWillFinishLaunching_ =
    objc.registerName("applicationWillFinishLaunching:");
void _ObjCBlock_ffiVoid_ffiVoid_NSNotification_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlock> block,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1) =>
    block.ref.target
        .cast<
            ffi.NativeFunction<
                ffi.Void Function(ffi.Pointer<ffi.Void> arg0,
                    ffi.Pointer<objc.ObjCObject> arg1)>>()
        .asFunction<
            void Function(ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>)>()(arg0, arg1);
void _ObjCBlock_ffiVoid_ffiVoid_NSNotification_closureTrampoline(
        ffi.Pointer<objc.ObjCBlock> block,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1) =>
    (objc.getBlockClosure(block) as void Function(
        ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>))(arg0, arg1);

class ObjCBlock_ffiVoid_ffiVoid_NSNotification extends objc.ObjCBlockBase {
  ObjCBlock_ffiVoid_ffiVoid_NSNotification._(
      ffi.Pointer<objc.ObjCBlock> pointer,
      {bool retain = false,
      bool release = true})
      : super(pointer, retain: retain, release: release);

  /// Returns a block that wraps the given raw block pointer.
  static ObjCBlock_ffiVoid_ffiVoid_NSNotification castFromPointer(
      ffi.Pointer<objc.ObjCBlock> pointer,
      {bool retain = false,
      bool release = false}) {
    return ObjCBlock_ffiVoid_ffiVoid_NSNotification._(pointer,
        retain: retain, release: release);
  }

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ObjCBlock_ffiVoid_ffiVoid_NSNotification.fromFunctionPointer(
      ffi.Pointer<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void> arg0,
                      ffi.Pointer<objc.ObjCObject> arg1)>>
          ptr)
      : this._(objc.newPointerBlock(
            _cFuncTrampoline ??= ffi.Pointer.fromFunction<
                        ffi.Void Function(
                            ffi.Pointer<objc.ObjCBlock>,
                            ffi.Pointer<ffi.Void>,
                            ffi.Pointer<objc.ObjCObject>)>(
                    _ObjCBlock_ffiVoid_ffiVoid_NSNotification_fnPtrTrampoline)
                .cast(),
            ptr.cast()));
  static ffi.Pointer<ffi.Void>? _cFuncTrampoline;

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ObjCBlock_ffiVoid_ffiVoid_NSNotification.fromFunction(
      void Function(ffi.Pointer<ffi.Void>, objc.NSNotification) fn)
      : this._(objc.newClosureBlock(
            _dartFuncTrampoline ??= ffi.Pointer.fromFunction<
                        ffi.Void Function(
                            ffi.Pointer<objc.ObjCBlock>,
                            ffi.Pointer<ffi.Void>,
                            ffi.Pointer<objc.ObjCObject>)>(
                    _ObjCBlock_ffiVoid_ffiVoid_NSNotification_closureTrampoline)
                .cast(),
            (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1) => fn(
                arg0,
                objc.NSNotification.castFromPointer(arg1, retain: true, release: true))));
  static ffi.Pointer<ffi.Void>? _dartFuncTrampoline;

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// Note that unlike the default behavior of NativeCallable.listener, listener
  /// blocks do not keep the isolate alive.
  ObjCBlock_ffiVoid_ffiVoid_NSNotification.listener(
      void Function(ffi.Pointer<ffi.Void>, objc.NSNotification) fn)
      : this._(wrapListenerBlock_ObjCBlock_ffiVoid_ffiVoid_NSNotification(
            objc.newClosureBlock(
                (_dartFuncListenerTrampoline ??= ffi.NativeCallable<
                            ffi.Void Function(
                                ffi.Pointer<objc.ObjCBlock>,
                                ffi.Pointer<ffi.Void>,
                                ffi.Pointer<objc.ObjCObject>)>.listener(
                        _ObjCBlock_ffiVoid_ffiVoid_NSNotification_closureTrampoline)
                      ..keepIsolateAlive = false)
                    .nativeFunction
                    .cast(),
                (ffi.Pointer<ffi.Void> arg0,
                        ffi.Pointer<objc.ObjCObject> arg1) =>
                    fn(arg0, objc.NSNotification.castFromPointer(arg1, retain: false, release: true)))));
  static ffi.NativeCallable<
      ffi.Void Function(ffi.Pointer<objc.ObjCBlock>, ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObject>)>? _dartFuncListenerTrampoline;

  void call(ffi.Pointer<ffi.Void> arg0, objc.NSNotification arg1) =>
      pointer.ref.invoke
          .cast<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<objc.ObjCBlock> block,
                      ffi.Pointer<ffi.Void> arg0,
                      ffi.Pointer<objc.ObjCObject> arg1)>>()
          .asFunction<
              void Function(ffi.Pointer<objc.ObjCBlock>, ffi.Pointer<ffi.Void>,
                  ffi.Pointer<objc.ObjCObject>)>()(pointer, arg0, arg1.pointer);
}

late final _sel_applicationDidFinishLaunching_ =
    objc.registerName("applicationDidFinishLaunching:");
late final _sel_applicationWillHide_ =
    objc.registerName("applicationWillHide:");
late final _sel_applicationDidHide_ = objc.registerName("applicationDidHide:");
late final _sel_applicationWillUnhide_ =
    objc.registerName("applicationWillUnhide:");
late final _sel_applicationDidUnhide_ =
    objc.registerName("applicationDidUnhide:");
late final _sel_applicationWillBecomeActive_ =
    objc.registerName("applicationWillBecomeActive:");
late final _sel_applicationDidBecomeActive_ =
    objc.registerName("applicationDidBecomeActive:");
late final _sel_applicationWillResignActive_ =
    objc.registerName("applicationWillResignActive:");
late final _sel_applicationDidResignActive_ =
    objc.registerName("applicationDidResignActive:");
late final _sel_applicationWillUpdate_ =
    objc.registerName("applicationWillUpdate:");
late final _sel_applicationDidUpdate_ =
    objc.registerName("applicationDidUpdate:");
late final _sel_applicationWillTerminate_ =
    objc.registerName("applicationWillTerminate:");
late final _sel_applicationDidChangeScreenParameters_ =
    objc.registerName("applicationDidChangeScreenParameters:");
late final _sel_applicationDidChangeOcclusionState_ =
    objc.registerName("applicationDidChangeOcclusionState:");
late final _sel_applicationProtectedDataWillBecomeUnavailable_ =
    objc.registerName("applicationProtectedDataWillBecomeUnavailable:");
late final _sel_applicationProtectedDataDidBecomeAvailable_ =
    objc.registerName("applicationProtectedDataDidBecomeAvailable:");

/// ! @enum ASWebAuthenticationSessionErrorCode
/// @abstract Error code of the NSError object passed in by ASWebAuthenticationSessionCompletionHandler.
/// @constant ASWebAuthenticationSessionErrorCodeCanceledLogin The user has canceled login by cancelling the
/// alert asking for permission to log in to this app, or by dismissing the view controller for loading the
/// authentication webpage.
/// @constant ASWebAuthenticationSessionErrorCodePresentationContextNotProvided A valid presentationContextProvider
/// was not found when -start was called. Ensure this property was not nil when -start was called.
/// @constant ASWebAuthenticationSessionErrorCodePresentationContextInvalid The presentation context returned
/// was not elligible to show the authentication UI. For iOS, validate that the UIWindow is in a foreground scene.
enum ASWebAuthenticationSessionErrorCode {
  ASWebAuthenticationSessionErrorCodeCanceledLogin(1),
  ASWebAuthenticationSessionErrorCodePresentationContextNotProvided(2),
  ASWebAuthenticationSessionErrorCodePresentationContextInvalid(3);

  final int value;
  const ASWebAuthenticationSessionErrorCode(this.value);

  static ASWebAuthenticationSessionErrorCode fromValue(int value) =>
      switch (value) {
        1 => ASWebAuthenticationSessionErrorCodeCanceledLogin,
        2 => ASWebAuthenticationSessionErrorCodePresentationContextNotProvided,
        3 => ASWebAuthenticationSessionErrorCodePresentationContextInvalid,
        _ => throw ArgumentError(
            "Unknown value for ASWebAuthenticationSessionErrorCode: $value"),
      };
}

/// !
/// @class ASWebAuthenticationSession
/// An ASWebAuthenticationSession object can be used to authenticate a user with a web service, even if the web service is run
/// by a third party. ASWebAuthenticationSession puts the user in control of whether they want to use their existing logged-in
/// session from Safari. The app provides a URL that points to the authentication webpage. The page will be loaded in a secure
/// view controller. From the webpage, the user can authenticate herself and grant access to the app.
/// On completion, the service will send a callback URL with an authentication token, and this URL will be passed to the app by
/// ASWebAuthenticationSessionCompletionHandler.
///
/// The callback URL usually has a custom URL scheme. For the app to receive the callback URL, it needs to either register the
/// custom URL scheme in its Info.plist, or set the scheme to callbackURLScheme argument in the initializer.
///
/// If the user has already logged into the web service in Safari or other apps via ASWebAuthenticationSession, it is possible to
/// share the existing login information. An alert will be presented to get the user's consent for sharing their existing login
/// information. If the user cancels the alert, the session will be canceled, and the completion handler will be called with
/// the error code ASWebAuthenticationSessionErrorCodeCanceledLogin.
///
/// If the user taps Cancel when showing the login webpage for the web service, the session will be canceled, and the completion
/// handler will be called with the error code ASWebAuthenticationSessionErrorCodeCanceledLogin.
///
/// The app can cancel the session by calling -[ASWebAuthenticationSession cancel]. This will also dismiss the view controller that
/// is showing the web service's login page.
class ASWebAuthenticationSession extends objc.NSObject {
  ASWebAuthenticationSession._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release);

  /// Constructs a [ASWebAuthenticationSession] that points to the same underlying object as [other].
  ASWebAuthenticationSession.castFrom(objc.ObjCObjectBase other)
      : this._(other.pointer, retain: true, release: true);

  /// Constructs a [ASWebAuthenticationSession] that wraps the given raw object pointer.
  ASWebAuthenticationSession.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [ASWebAuthenticationSession].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_0(
        obj.pointer, _sel_isKindOfClass_, _class_ASWebAuthenticationSession);
  }

  /// ! @abstract Returns an ASWebAuthenticationSession object.
  /// @param URL the initial URL pointing to the authentication webpage. Only supports URLs with http:// or https:// schemes.
  /// @param callbackURLScheme the custom URL scheme that the app expects in the callback URL.
  /// @param completionHandler the completion handler which is called when the session is completed successfully or canceled by user.
  ASWebAuthenticationSession initWithURL_callbackURLScheme_completionHandler_(
      objc.NSURL URL,
      objc.NSString? callbackURLScheme,
      ObjCBlock_ffiVoid_NSURL_NSError completionHandler) {
    final _ret = _objc_msgSend_411(
        this.pointer,
        _sel_initWithURL_callbackURLScheme_completionHandler_,
        URL.pointer,
        callbackURLScheme?.pointer ?? ffi.nullptr,
        completionHandler.pointer);
    return ASWebAuthenticationSession.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// initWithURL:callback:completionHandler:
  ASWebAuthenticationSession initWithURL_callback_completionHandler_(
      objc.NSURL URL,
      ASWebAuthenticationSessionCallback callback,
      ObjCBlock_ffiVoid_NSURL_NSError completionHandler) {
    final _ret = _objc_msgSend_414(
        this.pointer,
        _sel_initWithURL_callback_completionHandler_,
        URL.pointer,
        callback.pointer,
        completionHandler.pointer);
    return ASWebAuthenticationSession.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// ! @abstract Provides context to target where in an application's UI the authorization view should be shown. A provider
  /// must be set prior to calling -start, otherwise the authorization view cannot be displayed. If deploying to iOS prior to
  /// 13.0, the desired window is inferred by the application's key window.
  objc.ObjCObjectBase? get presentationContextProvider {
    final _ret =
        _objc_msgSend_22(this.pointer, _sel_presentationContextProvider);
    return _ret.address == 0
        ? null
        : objc.ObjCObjectBase(_ret, retain: true, release: true);
  }

  /// ! @abstract Provides context to target where in an application's UI the authorization view should be shown. A provider
  /// must be set prior to calling -start, otherwise the authorization view cannot be displayed. If deploying to iOS prior to
  /// 13.0, the desired window is inferred by the application's key window.
  set presentationContextProvider(objc.ObjCObjectBase? value) {
    return _objc_msgSend_23(this.pointer, _sel_setPresentationContextProvider_,
        value?.pointer ?? ffi.nullptr);
  }

  /// ! @abstract Indicates whether this session should ask the browser for an ephemeral session.
  /// @discussion Ephemeral web browser sessions do not not share cookies or other browsing data with a user's normal browser session.
  /// This value is NO by default. Setting this property after calling -[ASWebAuthenticationSession start] has no effect.
  bool get prefersEphemeralWebBrowserSession {
    return _objc_msgSend_13(
        this.pointer, _sel_prefersEphemeralWebBrowserSession);
  }

  /// ! @abstract Indicates whether this session should ask the browser for an ephemeral session.
  /// @discussion Ephemeral web browser sessions do not not share cookies or other browsing data with a user's normal browser session.
  /// This value is NO by default. Setting this property after calling -[ASWebAuthenticationSession start] has no effect.
  set prefersEphemeralWebBrowserSession(bool value) {
    return _objc_msgSend_14(
        this.pointer, _sel_setPrefersEphemeralWebBrowserSession_, value);
  }

  /// Any additional header fields to be set when loading the initial URL.
  /// All header field names must start with the "X-" prefix.
  objc.NSDictionary? get additionalHeaderFields {
    final _ret = _objc_msgSend_311(this.pointer, _sel_additionalHeaderFields);
    return _ret.address == 0
        ? null
        : objc.NSDictionary.castFromPointer(_ret, retain: true, release: true);
  }

  /// Any additional header fields to be set when loading the initial URL.
  /// All header field names must start with the "X-" prefix.
  set additionalHeaderFields(objc.NSDictionary? value) {
    return _objc_msgSend_361(this.pointer, _sel_setAdditionalHeaderFields_,
        value?.pointer ?? ffi.nullptr);
  }

  /// ! @abstract Returns whether the session can be successfully started. This property returns the same value as calling -start,
  /// but without the side effect of actually starting the session.
  bool get canStart {
    return _objc_msgSend_13(this.pointer, _sel_canStart);
  }

  /// ! @abstract Starts the ASWebAuthenticationSession instance after it is instantiated.
  /// @discussion start can only be called once for an ASWebAuthenticationSession instance. This also means calling start on a
  /// canceled session will fail.
  /// @result Returns YES if the session starts successfully.
  bool start() {
    return _objc_msgSend_13(this.pointer, _sel_start);
  }

  /// ! @abstract Cancel an ASWebAuthenticationSession. If the view controller is already presented to load the webpage for
  /// authentication, it will be dismissed. Calling cancel on an already canceled session will have no effect.
  void cancel() {
    _objc_msgSend_11(this.pointer, _sel_cancel);
  }

  /// new
  static ASWebAuthenticationSession new1() {
    final _ret = _objc_msgSend_2(_class_ASWebAuthenticationSession, _sel_new);
    return ASWebAuthenticationSession.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// init
  ASWebAuthenticationSession init() {
    final _ret = _objc_msgSend_2(this.pointer, _sel_init);
    return ASWebAuthenticationSession.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// allocWithZone:
  static ASWebAuthenticationSession allocWithZone_(ffi.Pointer<_NSZone> zone) {
    final _ret = _objc_msgSend_20(
        _class_ASWebAuthenticationSession, _sel_allocWithZone_, zone);
    return ASWebAuthenticationSession.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// alloc
  static ASWebAuthenticationSession alloc() {
    final _ret = _objc_msgSend_2(_class_ASWebAuthenticationSession, _sel_alloc);
    return ASWebAuthenticationSession.castFromPointer(_ret,
        retain: false, release: true);
  }
}

late final _class_ASWebAuthenticationSession =
    objc.getClass("ASWebAuthenticationSession");
void _ObjCBlock_ffiVoid_NSURL_NSError_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlock> block,
        ffi.Pointer<objc.ObjCObject> arg0,
        ffi.Pointer<objc.ObjCObject> arg1) =>
    block.ref.target
        .cast<
            ffi.NativeFunction<
                ffi.Void Function(ffi.Pointer<objc.ObjCObject> arg0,
                    ffi.Pointer<objc.ObjCObject> arg1)>>()
        .asFunction<
            void Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>()(arg0, arg1);
void _ObjCBlock_ffiVoid_NSURL_NSError_closureTrampoline(
        ffi.Pointer<objc.ObjCBlock> block,
        ffi.Pointer<objc.ObjCObject> arg0,
        ffi.Pointer<objc.ObjCObject> arg1) =>
    (objc.getBlockClosure(block) as void Function(ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>))(arg0, arg1);

class ObjCBlock_ffiVoid_NSURL_NSError extends objc.ObjCBlockBase {
  ObjCBlock_ffiVoid_NSURL_NSError._(ffi.Pointer<objc.ObjCBlock> pointer,
      {bool retain = false, bool release = true})
      : super(pointer, retain: retain, release: release);

  /// Returns a block that wraps the given raw block pointer.
  static ObjCBlock_ffiVoid_NSURL_NSError castFromPointer(
      ffi.Pointer<objc.ObjCBlock> pointer,
      {bool retain = false,
      bool release = false}) {
    return ObjCBlock_ffiVoid_NSURL_NSError._(pointer,
        retain: retain, release: release);
  }

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ObjCBlock_ffiVoid_NSURL_NSError.fromFunctionPointer(
      ffi.Pointer<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<objc.ObjCObject> arg0,
                      ffi.Pointer<objc.ObjCObject> arg1)>>
          ptr)
      : this._(objc.newPointerBlock(
            _cFuncTrampoline ??= ffi.Pointer.fromFunction<
                        ffi.Void Function(
                            ffi.Pointer<objc.ObjCBlock>,
                            ffi.Pointer<objc.ObjCObject>,
                            ffi.Pointer<objc.ObjCObject>)>(
                    _ObjCBlock_ffiVoid_NSURL_NSError_fnPtrTrampoline)
                .cast(),
            ptr.cast()));
  static ffi.Pointer<ffi.Void>? _cFuncTrampoline;

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ObjCBlock_ffiVoid_NSURL_NSError.fromFunction(
      void Function(objc.NSURL?, objc.NSError?) fn)
      : this._(objc.newClosureBlock(
            _dartFuncTrampoline ??= ffi.Pointer.fromFunction<
                        ffi.Void Function(
                            ffi.Pointer<objc.ObjCBlock>,
                            ffi.Pointer<objc.ObjCObject>,
                            ffi.Pointer<objc.ObjCObject>)>(
                    _ObjCBlock_ffiVoid_NSURL_NSError_closureTrampoline)
                .cast(),
            (ffi.Pointer<objc.ObjCObject> arg0, ffi.Pointer<objc.ObjCObject> arg1) => fn(
                arg0.address == 0
                    ? null
                    : objc.NSURL.castFromPointer(arg0, retain: true, release: true),
                arg1.address == 0 ? null : objc.NSError.castFromPointer(arg1, retain: true, release: true))));
  static ffi.Pointer<ffi.Void>? _dartFuncTrampoline;

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// Note that unlike the default behavior of NativeCallable.listener, listener
  /// blocks do not keep the isolate alive.
  ObjCBlock_ffiVoid_NSURL_NSError.listener(
      void Function(objc.NSURL?, objc.NSError?) fn)
      : this._(wrapListenerBlock_ObjCBlock_ffiVoid_NSURL_NSError(objc.newClosureBlock(
            (_dartFuncListenerTrampoline ??=
                    ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlock>, ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCObject>)>.listener(
                        _ObjCBlock_ffiVoid_NSURL_NSError_closureTrampoline)
                      ..keepIsolateAlive = false)
                .nativeFunction
                .cast(),
            (ffi.Pointer<objc.ObjCObject> arg0, ffi.Pointer<objc.ObjCObject> arg1) => fn(
                arg0.address == 0
                    ? null
                    : objc.NSURL
                        .castFromPointer(arg0, retain: false, release: true),
                arg1.address == 0
                    ? null
                    : objc.NSError.castFromPointer(arg1, retain: false, release: true)))));
  static ffi.NativeCallable<
      ffi.Void Function(
          ffi.Pointer<objc.ObjCBlock>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCObject>)>? _dartFuncListenerTrampoline;

  void call(objc.NSURL? arg0, objc.NSError? arg1) => pointer.ref.invoke
          .cast<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<objc.ObjCBlock> block,
                      ffi.Pointer<objc.ObjCObject> arg0,
                      ffi.Pointer<objc.ObjCObject> arg1)>>()
          .asFunction<
              void Function(
                  ffi.Pointer<objc.ObjCBlock>,
                  ffi.Pointer<objc.ObjCObject>,
                  ffi.Pointer<objc.ObjCObject>)>()(
      pointer, arg0?.pointer ?? ffi.nullptr, arg1?.pointer ?? ffi.nullptr);
}

late final _sel_initWithURL_callbackURLScheme_completionHandler_ =
    objc.registerName("initWithURL:callbackURLScheme:completionHandler:");
final _objc_msgSend_411 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            instancetype Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCBlock>)>>()
    .asFunction<
        instancetype Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCBlock>)>();

/// ASWebAuthenticationSessionCallback
class ASWebAuthenticationSessionCallback extends objc.NSObject {
  ASWebAuthenticationSessionCallback._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release);

  /// Constructs a [ASWebAuthenticationSessionCallback] that points to the same underlying object as [other].
  ASWebAuthenticationSessionCallback.castFrom(objc.ObjCObjectBase other)
      : this._(other.pointer, retain: true, release: true);

  /// Constructs a [ASWebAuthenticationSessionCallback] that wraps the given raw object pointer.
  ASWebAuthenticationSessionCallback.castFromPointer(
      ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false,
      bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [ASWebAuthenticationSessionCallback].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_0(obj.pointer, _sel_isKindOfClass_,
        _class_ASWebAuthenticationSessionCallback);
  }

  /// Creates a callback object that matches against URLs with the given custom scheme.
  /// @param customScheme The custom scheme that the app expects in the callback URL.
  static ASWebAuthenticationSessionCallback callbackWithCustomScheme_(
      objc.NSString customScheme) {
    final _ret = _objc_msgSend_128(_class_ASWebAuthenticationSessionCallback,
        _sel_callbackWithCustomScheme_, customScheme.pointer);
    return ASWebAuthenticationSessionCallback.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// Creates a callback object that matches against HTTPS URLs with the given host and path.
  /// @param host The host that the app expects in the callback URL. The host must be associated with the
  /// app using associated web credentials domains.
  /// @param path The path that the app expects in the callback URL.
  static ASWebAuthenticationSessionCallback callbackWithHTTPSHost_path_(
      objc.NSString host, objc.NSString path) {
    final _ret = _objc_msgSend_412(_class_ASWebAuthenticationSessionCallback,
        _sel_callbackWithHTTPSHost_path_, host.pointer, path.pointer);
    return ASWebAuthenticationSessionCallback.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// init
  ASWebAuthenticationSessionCallback init() {
    final _ret = _objc_msgSend_2(this.pointer, _sel_init);
    return ASWebAuthenticationSessionCallback.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// new
  static ASWebAuthenticationSessionCallback new1() {
    final _ret =
        _objc_msgSend_2(_class_ASWebAuthenticationSessionCallback, _sel_new);
    return ASWebAuthenticationSessionCallback.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// Check whether a given main-frame navigation URL matches the callback expected by the client app. Handles all URL-based callback strategies, including custom schemes and HTTPS navigations.
  /// This is mainly meant for web browsers adopting the ASWebAuthenticationWebBrowser API, but may also be useful for other apps for debugging purposes.
  /// @param url The URL to check.
  bool matchesURL_(objc.NSURL url) {
    return _objc_msgSend_413(this.pointer, _sel_matchesURL_, url.pointer);
  }

  /// allocWithZone:
  static ASWebAuthenticationSessionCallback allocWithZone_(
      ffi.Pointer<_NSZone> zone) {
    final _ret = _objc_msgSend_20(
        _class_ASWebAuthenticationSessionCallback, _sel_allocWithZone_, zone);
    return ASWebAuthenticationSessionCallback.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// alloc
  static ASWebAuthenticationSessionCallback alloc() {
    final _ret =
        _objc_msgSend_2(_class_ASWebAuthenticationSessionCallback, _sel_alloc);
    return ASWebAuthenticationSessionCallback.castFromPointer(_ret,
        retain: false, release: true);
  }
}

late final _class_ASWebAuthenticationSessionCallback =
    objc.getClass("ASWebAuthenticationSessionCallback");
late final _sel_callbackWithCustomScheme_ =
    objc.registerName("callbackWithCustomScheme:");
late final _sel_callbackWithHTTPSHost_path_ =
    objc.registerName("callbackWithHTTPSHost:path:");
final _objc_msgSend_412 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            instancetype Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        instancetype Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>();
late final _sel_matchesURL_ = objc.registerName("matchesURL:");
final _objc_msgSend_413 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Bool Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        bool Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<objc.ObjCObject>)>();
late final _sel_initWithURL_callback_completionHandler_ =
    objc.registerName("initWithURL:callback:completionHandler:");
final _objc_msgSend_414 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            instancetype Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCBlock>)>>()
    .asFunction<
        instancetype Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCBlock>)>();
late final _sel_presentationContextProvider =
    objc.registerName("presentationContextProvider");
late final _sel_setPresentationContextProvider_ =
    objc.registerName("setPresentationContextProvider:");
late final _sel_prefersEphemeralWebBrowserSession =
    objc.registerName("prefersEphemeralWebBrowserSession");
late final _sel_setPrefersEphemeralWebBrowserSession_ =
    objc.registerName("setPrefersEphemeralWebBrowserSession:");
late final _sel_additionalHeaderFields =
    objc.registerName("additionalHeaderFields");
late final _sel_setAdditionalHeaderFields_ =
    objc.registerName("setAdditionalHeaderFields:");
late final _sel_canStart = objc.registerName("canStart");
late final _sel_start = objc.registerName("start");
late final _sel_cancel = objc.registerName("cancel");

/// ! @abstract Provides context to target where in an application's UI the authorization view should be shown.
abstract final class ASWebAuthenticationPresentationContextProviding {
  /// Builds an object that implements the ASWebAuthenticationPresentationContextProviding protocol. To implement
  /// multiple protocols, use [addToBuilder] or [objc.ObjCProtocolBuilder] directly.
  static objc.ObjCObjectBase implement(
      {required NSWindow Function(ASWebAuthenticationSession)
          presentationAnchorForWebAuthenticationSession_}) {
    final builder = objc.ObjCProtocolBuilder();
    ASWebAuthenticationPresentationContextProviding
        .presentationAnchorForWebAuthenticationSession_
        .implement(builder, presentationAnchorForWebAuthenticationSession_);
    return builder.build();
  }

  /// Adds the implementation of the ASWebAuthenticationPresentationContextProviding protocol to an existing
  /// [objc.ObjCProtocolBuilder].
  static void addToBuilder(objc.ObjCProtocolBuilder builder,
      {required NSWindow Function(ASWebAuthenticationSession)
          presentationAnchorForWebAuthenticationSession_}) {
    ASWebAuthenticationPresentationContextProviding
        .presentationAnchorForWebAuthenticationSession_
        .implement(builder, presentationAnchorForWebAuthenticationSession_);
  }

  /// ! @abstract Return the ASPresentationAnchor in the closest proximity to where a user interacted with your app to trigger
  /// authentication. If starting an ASWebAuthenticationSession on first launch, use the application's main window.
  /// @param session The session requesting a presentation anchor.
  /// @result The ASPresentationAnchor most closely associated with the UI used to trigger authentication.
  static final presentationAnchorForWebAuthenticationSession_ =
      objc.ObjCProtocolMethod<NSWindow Function(ASWebAuthenticationSession)>(
    _sel_presentationAnchorForWebAuthenticationSession_,
    objc.getProtocolMethodSignature(
      _protocol_ASWebAuthenticationPresentationContextProviding,
      _sel_presentationAnchorForWebAuthenticationSession_,
      isRequired: true,
      isInstanceMethod: true,
    ),
    (NSWindow Function(ASWebAuthenticationSession) func) =>
        ObjCBlock_NSWindow_ffiVoid_ASWebAuthenticationSession.fromFunction(
            (ffi.Pointer<ffi.Void> _, ASWebAuthenticationSession arg1) =>
                func(arg1)),
  );
}

late final _protocol_ASWebAuthenticationPresentationContextProviding =
    objc.getProtocol("ASWebAuthenticationPresentationContextProviding");
late final _sel_presentationAnchorForWebAuthenticationSession_ =
    objc.registerName("presentationAnchorForWebAuthenticationSession:");
ffi.Pointer<objc.ObjCObject>
    _ObjCBlock_NSWindow_ffiVoid_ASWebAuthenticationSession_fnPtrTrampoline(
            ffi.Pointer<objc.ObjCBlock> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObject> arg1) =>
        block.ref.target
            .cast<
                ffi.NativeFunction<
                    ffi.Pointer<objc.ObjCObject> Function(
                        ffi.Pointer<ffi.Void> arg0,
                        ffi.Pointer<objc.ObjCObject> arg1)>>()
            .asFunction<
                ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>,
                    ffi.Pointer<objc.ObjCObject>)>()(arg0, arg1);
ffi.Pointer<objc.ObjCObject>
    _ObjCBlock_NSWindow_ffiVoid_ASWebAuthenticationSession_closureTrampoline(
            ffi.Pointer<objc.ObjCBlock> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObject> arg1) =>
        (objc.getBlockClosure(block) as ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>))(arg0, arg1);

class ObjCBlock_NSWindow_ffiVoid_ASWebAuthenticationSession
    extends objc.ObjCBlockBase {
  ObjCBlock_NSWindow_ffiVoid_ASWebAuthenticationSession._(
      ffi.Pointer<objc.ObjCBlock> pointer,
      {bool retain = false,
      bool release = true})
      : super(pointer, retain: retain, release: release);

  /// Returns a block that wraps the given raw block pointer.
  static ObjCBlock_NSWindow_ffiVoid_ASWebAuthenticationSession castFromPointer(
      ffi.Pointer<objc.ObjCBlock> pointer,
      {bool retain = false,
      bool release = false}) {
    return ObjCBlock_NSWindow_ffiVoid_ASWebAuthenticationSession._(pointer,
        retain: retain, release: release);
  }

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ObjCBlock_NSWindow_ffiVoid_ASWebAuthenticationSession.fromFunctionPointer(
      ffi.Pointer<
              ffi.NativeFunction<
                  ffi.Pointer<objc.ObjCObject> Function(
                      ffi.Pointer<ffi.Void> arg0,
                      ffi.Pointer<objc.ObjCObject> arg1)>>
          ptr)
      : this._(objc.newPointerBlock(
            _cFuncTrampoline ??= ffi.Pointer.fromFunction<
                        ffi.Pointer<objc.ObjCObject> Function(
                            ffi.Pointer<objc.ObjCBlock>,
                            ffi.Pointer<ffi.Void>,
                            ffi.Pointer<objc.ObjCObject>)>(
                    _ObjCBlock_NSWindow_ffiVoid_ASWebAuthenticationSession_fnPtrTrampoline)
                .cast(),
            ptr.cast()));
  static ffi.Pointer<ffi.Void>? _cFuncTrampoline;

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ObjCBlock_NSWindow_ffiVoid_ASWebAuthenticationSession.fromFunction(
      NSWindow Function(ffi.Pointer<ffi.Void>, ASWebAuthenticationSession) fn)
      : this._(objc.newClosureBlock(
            _dartFuncTrampoline ??= ffi.Pointer.fromFunction<
                        ffi.Pointer<objc.ObjCObject> Function(
                            ffi.Pointer<objc.ObjCBlock>,
                            ffi.Pointer<ffi.Void>,
                            ffi.Pointer<objc.ObjCObject>)>(
                    _ObjCBlock_NSWindow_ffiVoid_ASWebAuthenticationSession_closureTrampoline)
                .cast(),
            (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1) => fn(
                    arg0,
                    ASWebAuthenticationSession.castFromPointer(arg1, retain: true, release: true))
                .retainAndReturnPointer()));
  static ffi.Pointer<ffi.Void>? _dartFuncTrampoline;

  NSWindow call(ffi.Pointer<ffi.Void> arg0, ASWebAuthenticationSession arg1) =>
      NSWindow.castFromPointer(
          pointer.ref.invoke
                  .cast<
                      ffi.NativeFunction<
                          ffi.Pointer<objc.ObjCObject> Function(
                              ffi.Pointer<objc.ObjCBlock> block,
                              ffi.Pointer<ffi.Void> arg0,
                              ffi.Pointer<objc.ObjCObject> arg1)>>()
                  .asFunction<
                      ffi.Pointer<objc.ObjCObject> Function(
                          ffi.Pointer<objc.ObjCBlock>,
                          ffi.Pointer<ffi.Void>,
                          ffi.Pointer<objc.ObjCObject>)>()(
              pointer, arg0, arg1.pointer),
          retain: false,
          release: true);
}
